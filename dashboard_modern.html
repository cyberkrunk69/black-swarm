<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Modern Dashboard</title>
    <style>
        :root {
            --color-indigo: #6366f1;
            --color-purple: #8b5cf6;
            --color-cyan:   #06b6d4;
            --color-amber:  #f59e0b;
            --badge-claude: #3b82f6; /* blue */
            --badge-groq:   #f97316; /* orange */
        }
        body {
            margin:0;
            font-family:Arial,Helvetica,sans-serif;
            background:#f0f2f5;
            overflow:hidden;
        }
        #tree {
            position:absolute;
            top:10px;
            left:10px;
            right:10px;
            bottom:10px;
            overflow:auto;
            display:flex;
            flex-direction:column;
            align-items:flex-start;
            gap:8px;
        }
        .node {
            padding:8px 12px;
            border:2px solid transparent;
            border-radius:6px;
            cursor:grab;
            user-select:none;
            display:flex;
            align-items:center;
            gap:6px;
            background:#fff;
            transition:transform 0.2s;
        }
        .node[data-color="indigo"] { background:var(--color-indigo); color:#fff; }
        .node[data-color="purple"] { background:var(--color-purple); color:#fff; }
        .node[data-color="cyan"]   { background:var(--color-cyan);   color:#fff; }
        .node[data-color="amber"]  { background:var(--color-amber);  color:#fff; }

        .node.active {
            animation: rainbowBorder 2s linear infinite;
        }
        @keyframes rainbowBorder {
            0%   { border-color:#ff0000; }
            20%  { border-color:#ff7f00; }
            40%  { border-color:#ffff00; }
            60%  { border-color:#00ff00; }
            80%  { border-color:#0000ff; }
            100% { border-color:#8b00ff; }
        }

        .badge {
            padding:2px 6px;
            border-radius:3px;
            font-size:0.75rem;
            color:#fff;
            margin-left:auto;
        }
        .badge.claude { background:var(--badge-claude); }
        .badge.groq   { background:var(--badge-groq);   }

        /* Chat module */
        #chat {
            position:fixed;
            bottom:20px;
            right:20px;
            width:300px;
            max-height:400px;
            background:#fff;
            border:1px solid #ccc;
            border-radius:8px;
            box-shadow:0 4px 12px rgba(0,0,0,0.15);
            display:flex;
            flex-direction:column;
            overflow:hidden;
            cursor:grab;
        }
        #chat header {
            background:#f5f5f5;
            padding:6px 10px;
            font-weight:bold;
            cursor:grab;
        }
        #chat .messages {
            flex:1;
            padding:8px;
            overflow:auto;
            font-size:0.9rem;
        }
        #chat .input {
            display:flex;
            border-top:1px solid #ddd;
        }
        #chat .input textarea {
            flex:1;
            border:none;
            padding:6px;
            resize:none;
            font-family:inherit;
        }
        #chat .input button {
            border:none;
            background:#3b82f6;
            color:#fff;
            padding:0 12px;
            cursor:pointer;
        }
    </style>
</head>
<body>
    <div id="tree"></div>

    <div id="chat">
        <header>Chat</header>
        <div class="messages"></div>
        <div class="input">
            <textarea rows="1" placeholder="Type a message..."></textarea>
            <button>Send</button>
        </div>
    </div>

    <script>
        // ---------- Utility ----------
        const qs = s => document.querySelector(s);
        const qsa = s => document.querySelectorAll(s);
        const saveState = () => localStorage.setItem('dashboard_nodes', JSON.stringify(nodesData));
        const loadState = () => JSON.parse(localStorage.getItem('dashboard_nodes')||'null');

        // ---------- Data ----------
        // Example node data structure
        let nodesData = loadState() || [
            {id:1, label:"Root", color:"indigo", children:[
                {id:2, label:"Child A", color:"purple", children:[]},
                {id:3, label:"Child B", color:"cyan", children:[
                    {id:4, label:"Grandchild", color:"amber", children:[]}
                ]}
            ]}
        ];

        // ---------- Rendering ----------
        const treeEl = qs('#tree');

        function createNodeEl(node) {
            const el = document.createElement('div');
            el.className = 'node';
            el.dataset.id = node.id;
            el.dataset.color = node.color;
            el.textContent = node.label;

            // Engine badges (demo logic)
            const badge = document.createElement('span');
            badge.className = 'badge ' + (node.id % 2 === 0 ? 'groq' : 'claude');
            badge.textContent = node.id % 2 === 0 ? 'GROQ' : 'CLAUDE';
            el.appendChild(badge);

            // Click to toggle collapse/expand with LIFO stagger
            el.addEventListener('click', e => {
                e.stopPropagation();
                toggleChildren(node.id);
            });

            // Drag handling
            makeDraggable(el);
            return el;
        }

        function renderTree(parentEl, nodes) {
            nodes.forEach(node => {
                const nodeEl = createNodeEl(node);
                parentEl.appendChild(nodeEl);
                if (node.children && node.children.length) {
                    const container = document.createElement('div');
                    container.style.marginLeft = '20px';
                    container.style.display = 'none';
                    nodeEl._childrenContainer = container;
                    parentEl.appendChild(container);
                    renderTree(container, node.children);
                }
            });
        }

        function rebuild() {
            treeEl.innerHTML = '';
            renderTree(treeEl, nodesData);
        }

        // ---------- Collapse / LIFO ----------
        function toggleChildren(nodeId) {
            const node = findNode(nodesData, nodeId);
            if (!node || !node._el) return;
            const container = node._el._childrenContainer;
            if (!container) return;
            const showing = container.style.display === 'flex' || container.style.display === 'block';
            const action = showing ? 'hide' : 'show';
            const children = Array.from(container.children);
            // LIFO order
            const ordered = action==='show' ? children.reverse() : children;
            ordered.forEach((childEl,i) => {
                setTimeout(()=> {
                    childEl.style.display = action==='show' ? 'flex' : 'none';
                }, i*120);
            });
        }

        function findNode(arr, id) {
            for (let n of arr) {
                if (n.id===id) return n;
                if (n.children) {
                    const res = findNode(n.children, id);
                    if (res) return res;
                }
            }
            return null;
        }

        // ---------- Drag & Persistence ----------
        function makeDraggable(el) {
            let offsetX, offsetY;
            const onMouseDown = e => {
                e.preventDefault();
                offsetX = e.clientX - el.getBoundingClientRect().left;
                offsetY = e.clientY - el.getBoundingClientRect().top;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                el.style.cursor = 'grabbing';
                el.classList.add('active');
            };
            const onMouseMove = e => {
                el.style.position = 'absolute';
                el.style.left = (e.clientX - offsetX) + 'px';
                el.style.top  = (e.clientY - offsetY) + 'px';
            };
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                el.style.cursor = 'grab';
                el.classList.remove('active');
                // persist positions
                const positions = JSON.parse(localStorage.getItem('node_positions')||'{}');
                positions[el.dataset.id] = {left:el.style.left, top:el.style.top};
                localStorage.setItem('node_positions', JSON.stringify(positions));
            };
            el.addEventListener('mousedown', onMouseDown);
        }

        function restorePositions() {
            const positions = JSON.parse(localStorage.getItem('node_positions')||'{}');
            qsa('.node').forEach(el => {
                const pos = positions[el.dataset.id];
                if (pos) {
                    el.style.position='absolute';
                    el.style.left=pos.left;
                    el.style.top=pos.top;
                }
            });
        }

        // ---------- Auto‑scaling ----------
        function autoScale() {
            const container = treeEl.parentElement;
            const scale = Math.min(
                container.clientWidth / treeEl.scrollWidth,
                container.clientHeight / treeEl.scrollHeight,
                1
            );
            treeEl.style.transform = `scale(${scale})`;
            treeEl.style.transformOrigin = 'top left';
        }
        window.addEventListener('resize', autoScale);

        // ---------- Chat ----------
        const chat = qs('#chat');
        const chatHeader = chat.querySelector('header');
        const chatMessages = chat.querySelector('.messages');
        const chatInput = chat.querySelector('textarea');
        const chatBtn = chat.querySelector('button');

        // Drag chat
        (function() {
            let offsetX, offsetY;
            const onDown = e => {
                e.preventDefault();
                offsetX = e.clientX - chat.getBoundingClientRect().left;
                offsetY = e.clientY - chat.getBoundingClientRect().top;
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            };
            const onMove = e => {
                chat.style.left = (e.clientX - offsetX) + 'px';
                chat.style.top  = (e.clientY - offsetY) + 'px';
            };
            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            chatHeader.addEventListener('mousedown', onDown);
        })();

        chatBtn.addEventListener('click', () => {
            const txt = chatInput.value.trim();
            if (!txt) return;
            const div = document.createElement('div');
            div.textContent = txt;
            chatMessages.appendChild(div);
            chatInput.value = '';
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        // ---------- Server‑Sent Events ----------
        const evtSource = new EventSource('/events');
        evtSource.onmessage = e => {
            // Expect JSON payload {type:'update', payload:{...}}
            try {
                const data = JSON.parse(e.data);
                if (data.type === 'update') {
                    // For demo, just log
                    console.log('SSE update:', data.payload);
                }
            } catch (err) {
                console.error('Invalid SSE data', err);
            }
        };
        evtSource.onerror = err => {
            console.error('SSE error', err);
        };

        // ---------- Init ----------
        rebuild();
        restorePositions();
        autoScale();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Modern Dashboard</title>
    <style>
        /* Layout */
        body { margin:0; font-family:Arial,Helvetica,sans-serif; background:#111; color:#eee; overflow:hidden; }
        #tree-container { position:absolute; top:0; left:0; right:0; bottom:0; padding:20px; box-sizing:border-box; overflow:auto; }

        /* Node styling */
        .node {
            display:inline-block;
            padding:10px 15px;
            margin:10px;
            border:3px solid transparent;
            border-radius:8px;
            cursor:grab;
            user-select:none;
            transition:transform 0.2s ease, opacity 0.2s ease;
        }
        .node[data-color="indigo"]  { background:#6366f1; }
        .node[data-color="purple"]  { background:#8b5cf6; }
        .node[data-color="cyan"]    { background:#06b6d4; }
        .node[data-color="amber"]   { background:#f59e0b; }

        /* Rainbow border animation for active node */
        @keyframes rainbowBorder {
            0%   { border-color:#ff0000; }
            20%  { border-color:#ff7f00; }
            40%  { border-color:#ffff00; }
            60%  { border-color:#00ff00; }
            80%  { border-color:#0000ff; }
            100% { border-color:#8b00ff; }
        }
        .node.active { animation:rainbowBorder 2s linear infinite; }

        /* Collapse animation */
        .node.collapsing {
            opacity:0;
            transform:scaleY(0);
        }

        /* Chat module */
        #chat {
            position:fixed;
            bottom:20px;
            right:20px;
            width:300px;
            max-height:400px;
            background:#222;
            border:2px solid #555;
            border-radius:8px;
            padding:10px;
            box-sizing:border-box;
            overflow:auto;
            cursor:grab;
            z-index:1000;
        }
        #chat-header { font-weight:bold; margin-bottom:8px; cursor:grab; }

        /* Engine badges */
        .badge {
            display:inline-block;
            padding:2px 6px;
            margin-left:4px;
            border-radius:4px;
            font-size:0.8em;
            color:#fff;
        }
        .badge.claude { background:#3b82f6; }   /* blue */
        .badge.groq   { background:#f97316; }   /* orange */
    </style>
</head>
<body>

<div id="tree-container">
    <!-- Example static nodes; in practice they can be generated dynamically -->
    <div class="node" data-id="1" data-color="indigo">Node 1<span class="badge claude">CLAUDE</span></div>
    <div class="node" data-id="2" data-color="purple">Node 2<span class="badge groq">GROQ</span></div>
    <div class="node" data-id="3" data-color="cyan">Node 3<span class="badge claude">CLAUDE</span></div>
    <div class="node" data-id="4" data-color="amber">Node 4<span class="badge groq">GROQ</span></div>
</div>

<div id="chat">
    <div id="chat-header">Chat</div>
    <div id="chat-body">Welcome!<br/></div>
    <input type="text" id="chat-input" placeholder="Type a message..." style="width:100%;box-sizing:border-box;margin-top:5px;">
</div>

<script>
/* ---------- Drag & Drop for Nodes ---------- */
const container = document.getElementById('tree-container');
let dragNode = null;
let offsetX = 0, offsetY = 0;

function loadNodePositions() {
    const saved = localStorage.getItem('nodePositions');
    if (!saved) return;
    const positions = JSON.parse(saved);
    document.querySelectorAll('.node').forEach(node => {
        const id = node.dataset.id;
        if (positions[id]) {
            node.style.position = 'absolute';
            node.style.left = positions[id].x + 'px';
            node.style.top = positions[id].y + 'px';
        }
    });
}
function saveNodePositions() {
    const positions = {};
    document.querySelectorAll('.node').forEach(node => {
        const id = node.dataset.id;
        if (node.style.left && node.style.top) {
            positions[id] = { x: parseInt(node.style.left), y: parseInt(node.style.top) };
        }
    });
    localStorage.setItem('nodePositions', JSON.stringify(positions));
}
function makeDraggable(node) {
    node.addEventListener('mousedown', e => {
        dragNode = node;
        const rect = node.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        node.style.zIndex = 1000;
        node.style.cursor = 'grabbing';
    });
}
document.addEventListener('mousemove', e => {
    if (!dragNode) return;
    dragNode.style.position = 'absolute';
    dragNode.style.left = (e.clientX - offsetX) + 'px';
    dragNode.style.top  = (e.clientY - offsetY) + 'px';
});
document.addEventListener('mouseup', () => {
    if (dragNode) {
        dragNode.style.zIndex = '';
        dragNode.style.cursor = 'grab';
        saveNodePositions();
        dragNode = null;
    }
});
document.querySelectorAll('.node').forEach(makeDraggable);
loadNodePositions();

/* ---------- Auto‑Scaling Tree (simple zoom on wheel) ---------- */
let scale = 1;
container.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.05 : 0.05;
    scale = Math.min(Math.max(0.5, scale + delta), 2);
    container.style.transform = `scale(${scale})`;
});

/* ---------- Thunk‑thunk‑thunk LIFO Collapse ---------- */
function collapseNodes() {
    const nodes = Array.from(document.querySelectorAll('.node')).reverse(); // LIFO
    nodes.forEach((node, idx) => {
        setTimeout(() => {
            node.classList.add('collapsing');
            setTimeout(() => node.remove(), 200); // remove after animation
        }, idx * 120);
    });
}
document.addEventListener('keydown', e => {
    if (e.key === 'c' && e.ctrlKey) { // Ctrl+C to trigger collapse
        collapseNodes();
    }
});

/* ---------- Floating Draggable Chat ---------- */
const chat = document.getElementById('chat');
const chatHeader = document.getElementById('chat-header');
let chatDrag = false, chatOffsetX = 0, chatOffsetY = 0;
chatHeader.addEventListener('mousedown', e => {
    chatDrag = true;
    const rect = chat.getBoundingClientRect();
    chatOffsetX = e.clientX - rect.left;
    chatOffsetY = e.clientY - rect.top;
    chat.style.cursor = 'grabbing';
});
document.addEventListener('mousemove', e => {
    if (!chatDrag) return;
    chat.style.left = (e.clientX - chatOffsetX) + 'px';
    chat.style.top  = (e.clientY - chatOffsetY) + 'px';
});
document.addEventListener('mouseup', () => {
    chatDrag = false;
    chat.style.cursor = 'grab';
});

/* ---------- SSE Real‑time Updates ---------- */
const evtSource = new EventSource('/events');
evtSource.onmessage = function(event) {
    // Expect payload: {id:"1", content:"New text"}
    try {
        const data = JSON.parse(event.data);
        const node = document.querySelector(`.node[data-id="${data.id}"]`);
        if (node) {
            node.textContent = data.content;
            // re‑append badge if present
            if (data.engine) {
                const badge = document.createElement('span');
                badge.className = `badge ${data.engine.toLowerCase()}`;
                badge.textContent = data.engine.toUpperCase();
                node.appendChild(badge);
            }
        }
    } catch (e) {
        console.error('Invalid SSE payload', e);
    }
};

/* ---------- Highlight active node on click ---------- */
document.addEventListener('click', e => {
    if (e.target.classList.contains('node')) {
        document.querySelectorAll('.node.active').forEach(n => n.classList.remove('active'));
        e.target.classList.add('active');
    }
});

/* ---------- Simple Chat Interaction (placeholder) ---------- */
const chatInput = document.getElementById('chat-input');
const chatBody  = document.getElementById('chat-body');
chatInput.addEventListener('keydown', e => {
    if (e.key === 'Enter' && chatInput.value.trim()) {
        const msg = document.createElement('div');
        msg.textContent = 'You: ' + chatInput.value;
        chatBody.appendChild(msg);
        chatInput.value = '';
        chatBody.scrollTop = chatBody.scrollHeight;
    }
});
</script>
</body>
</html>