{
  "meta": {
    "name": "Swarm Architecture V2 Build",
    "blueprint": "SWARM_ARCHITECTURE_V2.md",
    "gap_analysis": "ARCHITECTURE_GAP_ANALYSIS.md",
    "safety": "Run through self_healing_wrapper.py",
    "created": "2026-02-04"
  },
  "tasks": [
    {
      "id": "arch-1.1",
      "phase": 1,
      "component": "Atomizer Node",
      "description": "Create atomizer.py - converts feature plans into minimal, parallelizable atomic tasks with dependency graphs. See SWARM_ARCHITECTURE_V2.md 'Atomizer Node' section. Must output task list + dependency graph JSON. Include parallelism_groups calculation.",
      "output_file": "atomizer.py",
      "budget": 0.15,
      "model": "groq/compound",
      "priority": "critical",
      "dependencies": []
    },
    {
      "id": "arch-1.2",
      "phase": 1,
      "component": "Worker Pool",
      "description": "Create worker_pool.py - parallel task execution with dependency-aware scheduling. Workers get MINIMAL context (task + ~50 LOC). Must respect dependency graph from Atomizer. Use Groq for fast inference. Include task queue and completion tracking.",
      "output_file": "worker_pool.py",
      "budget": 0.15,
      "model": "groq/compound",
      "priority": "critical",
      "dependencies": ["arch-1.1"]
    },
    {
      "id": "arch-1.3",
      "phase": 1,
      "component": "Intent Gatekeeper",
      "description": "Create intent_gatekeeper.py - conversational requirements gathering. Won't proceed until understanding is confirmed. Asks clarifying questions. Outputs clear requirements document. See SWARM_ARCHITECTURE_V2.md 'Intent Gatekeeper Node' section for conversation flow example.",
      "output_file": "intent_gatekeeper.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "critical",
      "dependencies": []
    },
    {
      "id": "arch-1.4",
      "phase": 1,
      "component": "Gut-Check Planner",
      "description": "Create gut_check_planner.py - quick initial analysis. Scans file tree, reads git history, identifies affected systems, estimates complexity, flags risks. Outputs context summary JSON that HYDRATES the Expert Node. See spec for output format.",
      "output_file": "gut_check_planner.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-1.3"]
    },
    {
      "id": "arch-1.5",
      "phase": 1,
      "component": "Critic Integration",
      "description": "Wire task_verifier.py into worker_pool.py. Every worker output passes through Critic before marking complete. APPROVE/MINOR_ISSUES/REJECT verdicts. Rejected tasks requeue with feedback. Use existing task_verifier.py logic.",
      "output_file": "worker_pool.py",
      "budget": 0.10,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-1.2"]
    },
    {
      "id": "arch-2.1",
      "phase": 2,
      "component": "Expert Node",
      "description": "Create expert_node.py - deep thinking for hard problems. Receives hydration from Gut-Check Planner. Implements batched query system (batch triggers: 5 queries OR 10 seconds). Uses expensive model (DeepSeek R1 or similar). See SWARM_ARCHITECTURE_V2.md 'Expert Node' section.",
      "output_file": "expert_node.py",
      "budget": 0.15,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-1.4"]
    },
    {
      "id": "arch-2.2",
      "phase": 2,
      "component": "Expert Cache",
      "description": "Create expert_cache/ system - project-level persistent cache + session-level ephemeral cache. Semantic search with embeddings for cache lookup. LRU pruning with access frequency weighting. See SWARM_ARCHITECTURE_V2.md 'Expert Knowledge Cache' section for structure.",
      "output_file": "expert_cache/__init__.py",
      "budget": 0.15,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-2.1"]
    },
    {
      "id": "arch-2.3",
      "phase": 2,
      "component": "RPM Tracker",
      "description": "Create rpm_tracker.py - tracks requests per minute per provider. Groq limit: 30 RPM, Together limit: 60 RPM. Includes utilization(), should_batch(), can_call(), wait_time() methods. Enables adaptive batching when approaching limits.",
      "output_file": "rpm_tracker.py",
      "budget": 0.08,
      "model": "groq/compound",
      "priority": "medium",
      "dependencies": []
    },
    {
      "id": "arch-3.1",
      "phase": 3,
      "component": "Feature Breakdown Node",
      "description": "Create feature_breakdown.py - splits work into independent features/components. Each feature goes to a Feature Planner. Suggests parallelism (which features can run together). Integrates User Proxy checkpoint.",
      "output_file": "feature_breakdown.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-1.4"]
    },
    {
      "id": "arch-3.2",
      "phase": 3,
      "component": "Feature Planner",
      "description": "Create feature_planner.py - fully plans out a single feature. Can consult Expert Node when stuck. One planner per feature, running in parallel. Outputs detailed implementation plan.",
      "output_file": "feature_planner.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-3.1", "arch-2.1"]
    },
    {
      "id": "arch-3.3",
      "phase": 3,
      "component": "Consensus Node",
      "description": "Create consensus_node.py - multi-model debate for critical decisions. 3-round protocol: GENERATION (3 models), BLIND JUDGING (rank anonymized solutions), DEBATE (if no consensus). Logs dissenting opinions. See SWARM_ARCHITECTURE_V2.md for full protocol.",
      "output_file": "consensus_node.py",
      "budget": 0.15,
      "model": "groq/compound",
      "priority": "medium",
      "dependencies": []
    },
    {
      "id": "arch-4.1",
      "phase": 4,
      "component": "Tool Store Structure",
      "description": "Create tools/ directory structure with registry. tools/filesystem/, tools/git/, tools/testing/, tools/user_contributed/. Each tool has: semantic description, input/output schema, usage count, success rate. Create tools/__init__.py with ToolRegistry class.",
      "output_file": "tools/__init__.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": []
    },
    {
      "id": "arch-4.2",
      "phase": 4,
      "component": "Tool-First Router",
      "description": "Create tool_router.py - routes requests through hierarchy: 1) Check tool store (free), 2) Check components to assemble (cheap), 3) Full LLM build + store (expensive). Uses semantic search to find matching tools.",
      "output_file": "tool_router.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-4.1"]
    },
    {
      "id": "arch-5.1",
      "phase": 5,
      "component": "User Proxy V2",
      "description": "Upgrade user_proxy.py to v2 - acts as user for validation checkpoints. Captures: stated preferences, confirmed requirements, corrections, style preferences. NOT personal info. Insertion at: after Feature Breakdown, after Feature Planning, after E2E Testing.",
      "output_file": "user_proxy_v2.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "medium",
      "dependencies": ["arch-3.1"]
    },
    {
      "id": "arch-6.1",
      "phase": 6,
      "component": "RLIF Rule Extractor",
      "description": "Create rlif_learner.py - extracts rules immediately from user interactions. Sentiment detection on responses. Positive = mild boost. Negative = frustration analysis + rule extraction. Inverts mistakes into rules ('NEVER do X', 'ALWAYS do Y').",
      "output_file": "rlif_learner.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": []
    },
    {
      "id": "arch-6.2",
      "phase": 6,
      "component": "Rule Verifier",
      "description": "Create rlif_rule_verifier.py - SAFETY CRITICAL. Constitutional filter for proposed rules. Checks: enables unauthorized actions? bypasses oversight? expands scope? exploitable via injection? conflicts with safety? Unbounded scope = REJECT. Extracts meta-rules from rejections.",
      "output_file": "rlif_rule_verifier.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "critical",
      "dependencies": ["arch-6.1"]
    },
    {
      "id": "arch-6.3",
      "phase": 6,
      "component": "Efficiency Observer",
      "description": "Create efficiency_observer.py - tracks: llm_calls_per_task, tokens_per_task, tool_hits/misses, component_assemblies, full_builds, failure_patterns, cost_per_task. Suggests tool creation when same LLM calls repeat. See SWARM_ARCHITECTURE_V2.md 'Efficiency Observer' section.",
      "output_file": "efficiency_observer.py",
      "budget": 0.10,
      "model": "groq/compound",
      "priority": "medium",
      "dependencies": ["arch-4.1"]
    },
    {
      "id": "arch-7.1",
      "phase": 7,
      "component": "Test Gates",
      "description": "Create test_gates.py with UnitTestGate, IntegrationTestGate, E2ETestGate classes. Each generates tests for code just written, runs them, and GATES (must pass to proceed). Failed gate = task not complete.",
      "output_file": "test_gates.py",
      "budget": 0.12,
      "model": "groq/compound",
      "priority": "high",
      "dependencies": ["arch-1.5"]
    },
    {
      "id": "arch-7.2",
      "phase": 7,
      "component": "Orchestrator Integration",
      "description": "Create swarm_orchestrator_v2.py - wires all nodes together in the full flow: Intent Gatekeeper -> Gut-Check -> Feature Breakdown -> Feature Planners -> Atomizer -> Worker Pool -> Critic -> Test Gates -> User Proxy. Uses self_healing_wrapper for safety.",
      "output_file": "swarm_orchestrator_v2.py",
      "budget": 0.20,
      "model": "groq/compound",
      "priority": "critical",
      "dependencies": ["arch-1.1", "arch-1.2", "arch-1.3", "arch-1.4", "arch-1.5", "arch-3.1", "arch-3.2", "arch-7.1"]
    }
  ]
}
