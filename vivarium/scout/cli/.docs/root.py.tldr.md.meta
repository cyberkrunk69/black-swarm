{
  "source_hash": "33379606edd2dff8a56b99685739e96eb43b201a66b5fabeda4d6a1ff148bcda",
  "generated_at": "2026-02-13T01:42:20.066191+00:00",
  "model": "llama-3.3-70b-versatile",
  "symbols": {
    "_DOC_EXTENSIONS": {
      "tldr": "The constant _DOC_EXTENSIONS is not used to call any functions or types, but it imports several modules from the vivarium/scout package. \n\nIt appears to be a constant that is imported for potential use in the system, but its specific role is not immediately clear based on the provided information.",
      "deep": "## Logic Overview\nThe code defines a constant `_DOC_EXTENSIONS` which is a set containing four string values representing file extensions: `.py`, `.js`, `.mjs`, and `.cjs`. This constant is likely used to identify or filter files based on their extensions.\n\n## Dependency Interactions\nThere are no direct interactions with the traced imports (`vivarium/scout/doc_generation.py`, `vivarium/scout/git_analyzer.py`, `vivarium/scout/git_drafts.py`, `vivarium/scout/cli/status.py`) in the provided code snippet. The constant is defined independently without referencing any of the imported modules.\n\n## Potential Considerations\nThe code does not include any error handling or conditional logic. It simply defines a constant set of file extensions. Potential considerations may include:\n- The set data structure implies that the order of file extensions does not matter, and duplicates are automatically removed (although there are no duplicates in this case).\n- The constant is prefixed with an underscore, which is a Python convention indicating that the variable is intended to be private.\n- The choice of file extensions may be relevant for a specific use case, such as identifying files that contain code or documentation.\n\n## Signature\nN/A",
      "eliv": "",
      "hash": "99c9c75022e20c9cea954b007300823743562e1ede506679728924d5cd4c4e57"
    },
    "_resolve_pr_files": {
      "tldr": "This function appears to resolve PR files by interacting with a Git repository. It uses the `vivarium.scout.git_analyzer` module to retrieve changed files and their references. The function likely constructs a list of resolved file paths.",
      "deep": "## Logic Overview\nThe `_resolve_pr_files` function is designed to resolve which files to include in a PR description based on a set of predefined priorities. The main steps in the function are:\n1. Check if explicit files are provided (`args.files`).\n2. If not, check if a base branch is specified (`args.base_branch`).\n3. If neither of the above is provided, it checks for an upstream reference.\n4. If no upstream reference is found, it attempts to find a default base reference (e.g., `origin/main` or `origin/master`).\n5. If all else fails, it falls back to using staged files.\n\n## Dependency Interactions\nThe function interacts with the following traced calls:\n- `p.exists`: Checks if a file exists.\n- `p.is_absolute`: Checks if a path is absolute.\n- `p.resolve`: Resolves a path to its absolute form.\n- `pathlib.Path`: Creates a new `Path` object.\n- `print`: Prints warning messages to the standard error stream.\n- `repo_root.resolve`: Resolves the repository root path.\n- `resolved.append`: Adds a resolved file path to the `resolved` list.\n- `vivarium.scout.git_analyzer.get_changed_files`: Retrieves a list of changed files based on the provided parameters.\n- `vivarium.scout.git_analyzer.get_default_base_ref`: Retrieves the default base reference.\n- `vivarium.scout.git_analyzer.get_upstream_ref`: Retrieves the upstream reference.\n\n## Potential Considerations\nThe function handles the following edge cases and considerations:\n- Non-existent files: If a file specified in `args.files` does not exist, it prints a warning message and skips the file.\n- Non-absolute paths: If a path in `args.files` is not absolute, it resolves the path relative to the repository root.\n- No upstream reference: If no upstream reference is found, it attempts to find a default base reference.\n- No default base reference: If no default base reference is found, it falls back to using staged files.\n- Performance: The function uses list comprehensions to filter files based on their suffix, which may impact performance for large lists of files.\n\n## Signature\nThe function signature is:\n```python\ndef _resolve_pr_files(args: argparse.Namespace, repo_root: Path) -> tuple[list[Path], str]\n```\nThis indicates that the function:\n- Takes two parameters: `args` of type `argparse.Namespace` and `repo_root` of type `Path`.\n- Returns a tuple containing a list of `Path` objects and a string. The list of `Path` objects represents the resolved file paths, and the string represents the mode used to resolve the files (e.g., \"explicit file list\", \"git diff --base-branch\", etc.).",
      "eliv": "",
      "hash": "9615574fb14ae417a3ab8fc00ed45b49ddc1dca15d1efa231295513bd9ffaa8d"
    },
    "_cmd_commit": {
      "tldr": "This function appears to be responsible for committing changes to a Git repository. It uses the `vivarium.scout.git_analyzer` module to get changed files and the `vivarium.scout.git_drafts` module to assemble a commit message. It then writes the commit message to a file and uses `subprocess.run` to execute a Git commit command.",
      "deep": "## Logic Overview\nThe `_cmd_commit` function handles the scout commit subcommand. It follows these main steps:\n1. **Determine the repository root**: It uses `pathlib.Path.cwd().resolve()` to get the current working directory.\n2. **Get staged files**: It calls `vivarium.scout.git_analyzer.get_changed_files` with `staged_only=True` to get the list of staged files.\n3. **Filter for Python files**: It filters the staged files to only include files with a `.py` suffix.\n4. **Handle no staged files**: If there are no staged Python files, it prints an error message and returns 1.\n5. **Handle commit without draft**: If `args.use_draft` is False, it runs `git commit` without a draft, which opens an editor for the user to input a commit message.\n6. **Assemble commit message**: If `args.use_draft` is True, it calls `vivarium.scout.git_drafts.assemble_commit_message` to assemble a commit message based on the staged Python files.\n7. **Preview or commit**: Depending on the value of `args.preview`, it either prints the commit message to stdout or writes it to a temporary file and runs `git commit -F <temp>`.\n\n## Dependency Interactions\nThe function interacts with the following dependencies:\n* `pathlib.Path`: Used to get the current working directory (`pathlib.Path.cwd().resolve()`).\n* `pathlib.Path.cwd`: Used to get the current working directory.\n* `vivarium.scout.git_analyzer.get_changed_files`: Called to get the list of staged files.\n* `vivarium.scout.git_drafts.assemble_commit_message`: Called to assemble a commit message based on the staged Python files.\n* `subprocess.run`: Used to run `git commit` commands.\n* `tempfile.NamedTemporaryFile`: Used to create a temporary file for the commit message.\n* `print`: Used to print error messages or the commit message for preview.\n* `f.write`: Used to write the commit message to the temporary file.\n\n## Potential Considerations\nThe function handles the following edge cases and errors:\n* **No staged files**: It prints an error message and returns 1 if there are no staged Python files.\n* **Commit without draft**: It runs `git commit` without a draft if `args.use_draft` is False.\n* **Error running git commit**: It catches `subprocess.CalledProcessError`, `FileNotFoundError`, and `OSError` exceptions when running `git commit` commands and prints an error message.\n* **Temporary file creation**: It uses `tempfile.NamedTemporaryFile` to create a temporary file for the commit message, which is deleted after use.\n* **Performance**: The function uses `subprocess.run` to run `git commit` commands, which may have performance implications if the repository is large.\n\n## Signature\nThe function signature is:\n```python\ndef _cmd_commit(args: argparse.Namespace) -> int\n```\nIt takes an `argparse.Namespace` object as input and returns an integer value. The `argparse.Namespace` object is expected to contain the command-line arguments, including `args.use_draft` and `args.preview`. The return value is 0 on success and 1 on error.",
      "eliv": "",
      "hash": "79878e5c84110c69937dbcc2a9258b69c823bc8340880fb231ad5d7bd65aa630"
    },
    "_cmd_pr_auto_draft": {
      "tldr": "This function appears to be part of a command-line interface (CLI) for managing pull requests (PRs) in a Git repository. It generates or updates a draft PR description based on stale files and their downstream impact. The function likely operates on a specific repository path and uses various modules from the vivarium/scout package for its functionality.",
      "deep": "## Logic Overview\nThe `_cmd_pr_auto_draft` function generates a PR description and writes it to a file named `.github/pr-draft.md`. The main steps are:\n1. Create the output directory if it does not exist.\n2. Build the PR description from drafts or raw summaries.\n3. Add a versioned docs link if available.\n4. Add an impact section from the call graph if the call graph file exists and there are Python files.\n5. Append the stale status.\n6. Write the description to the output file.\n\n## Dependency Interactions\nThe function uses the following traced calls:\n- `call_graph_path.exists()`: checks if the call graph file exists.\n- `content.splitlines()`: splits the content of the version file into lines.\n- `f.relative_to(repo_root)`: gets the relative path of a file to the repository root.\n- `len()`: gets the length of a list (e.g., the number of impact modules).\n- `line.split()`: splits a line into parts (e.g., to extract the version number).\n- `line.startswith()`: checks if a line starts with a certain string (e.g., \"version:\").\n- `out_path.parent.mkdir()`: creates the output directory if it does not exist.\n- `out_path.write_text()`: writes the description to the output file.\n- `print()`: prints a message to the standard error stream.\n- `str()`: converts an object to a string (e.g., a file path).\n- `version_file.exists()`: checks if the version file exists.\n- `version_file.read_text()`: reads the content of the version file.\n- `vivarium.scout.doc_generation.find_stale_files()`: finds stale files in the repository.\n- `vivarium.scout.doc_generation.get_downstream_impact()`: gets the downstream impact of the changed files.\n- `vivarium.scout.doc_generation.synthesize_pr_description()`: synthesizes the PR description from raw summaries.\n- `vivarium.scout.git_drafts.assemble_pr_description()`: assembles the PR description from drafts.\n\n## Potential Considerations\nThe function handles the following edge cases and errors:\n- If the version file does not exist, the function does not add a versioned docs link.\n- If the call graph file does not exist or there are no Python files, the function does not add an impact section.\n- If there are stale files, the function appends a stale status section to the description.\n- If there is an error reading the version file, the function catches the `OSError` exception and continues without adding a versioned docs link.\n- If there is an error getting the relative path of a file, the function catches the `ValueError` exception and uses the absolute path instead.\n\nThe function also considers performance by:\n- Only reading the version file if it exists.\n- Only finding stale files if the vivarium directory exists.\n- Only getting the downstream impact if the call graph file exists and there are Python files.\n\n## Signature\nThe function signature is:\n```python\ndef _cmd_pr_auto_draft(repo_root: Path, py_files: list[Path], mode: str) -> int\n```\nThe function takes three parameters:\n- `repo_root`: the root directory of the repository (type `Path`).\n- `py_files`: a list of Python files (type `list[Path]`).\n- `mode`: a string parameter (type `str`).\nThe function returns an integer value (type `int`). Note that the `mode` parameter is not used in the function.",
      "eliv": "",
      "hash": "64d0d02c320666b11bfe625c738bd2e51d10d488b1e6471eb1e8fd36dbfe9d00"
    },
    "_find_gh": {
      "tldr": "This function appears to execute a Git command and retrieve its output. It uses the `subprocess.run` function to run the command and the `result.stdout.strip` function to process the output. The output is likely a string.",
      "deep": "## Logic Overview\nThe `_find_gh` function attempts to find the path to the `gh` CLI. The main steps are:\n1. Run a subprocess with the command `which gh` to find the path to the `gh` CLI.\n2. Capture the output of the subprocess.\n3. If the subprocess runs successfully, return the path to the `gh` CLI after stripping any leading or trailing whitespace.\n4. If the subprocess fails or the `gh` CLI is not found, return `None`.\n\n## Dependency Interactions\nThe function interacts with the following dependencies:\n- `subprocess.run`: This function is used to run the `which gh` command in a subprocess. The qualified name of this call is `subprocess.run`.\n- `result.stdout.strip`: This method is used to remove any leading or trailing whitespace from the output of the subprocess. The qualified name of this call is `str.strip`.\n\n## Potential Considerations\nThe function handles the following edge cases and errors:\n- `subprocess.CalledProcessError`: This exception is raised if the subprocess returns a non-zero exit code, indicating that the `gh` CLI was not found or the `which` command failed.\n- `FileNotFoundError`: This exception is raised if the `which` command is not found.\n- The function returns `None` if the `gh` CLI is not found or if an error occurs while running the subprocess.\n- The function uses the `check=True` argument with `subprocess.run`, which means that if the subprocess returns a non-zero exit code, a `subprocess.CalledProcessError` exception is raised.\n\n## Signature\nThe function signature is `def _find_gh() -> str | None`, indicating that:\n- The function name is `_find_gh`.\n- The function takes no arguments.\n- The function returns either a string (`str`) representing the path to the `gh` CLI or `None` if the `gh` CLI is not found.",
      "eliv": "",
      "hash": "90f8ea4f72dce54fc217bad04752c0ac98e2d63f7554f033e40b9237743a479e"
    },
    "_cmd_pr": {
      "tldr": "This function appears to be a command-line interface (CLI) handler responsible for processing pull requests. It calls various functions from the vivarium.scout module to analyze the Git repository and generate a pull request description. The function likely interacts with the Git repository, retrieves information about the current branch and upstream ref, and assembles a pull request description.",
      "deep": "## Logic Overview\nThe `_cmd_pr` function handles the scout pr subcommand. It follows these main steps:\n1. Resolves Python files based on the provided arguments and repository root.\n2. Checks for the `--auto-draft` flag and calls `_cmd_pr_auto_draft` if set.\n3. If no Python files are found, it prints an error message and returns 1.\n4. If the `--no-use-draft` flag is set, it skips draft assembly and returns 0.\n5. Assembles a PR description using `assemble_pr_description` and synthesizes it using `synthesize_pr_description`.\n6. If the `--create` flag is set, it creates a PR using the GitHub CLI.\n7. If the `--create` flag is not set, it prints the PR description.\n\n## Dependency Interactions\nThe `_cmd_pr` function interacts with the following dependencies:\n* `_cmd_pr_auto_draft`: called when the `--auto-draft` flag is set.\n* `_find_gh`: checks if the GitHub CLI is installed.\n* `_resolve_pr_files`: resolves Python files based on the provided arguments and repository root.\n* `vivarium.scout.doc_generation.synthesize_pr_description`: synthesizes the PR description.\n* `vivarium.scout.git_analyzer.get_current_branch`: gets the current branch.\n* `vivarium.scout.git_analyzer.get_default_base_ref`: gets the default base reference.\n* `vivarium.scout.git_analyzer.get_upstream_ref`: gets the upstream reference.\n* `vivarium.scout.git_analyzer.has_remote_origin`: checks if the repository has a remote origin.\n* `vivarium.scout.git_analyzer.is_remote_empty`: checks if the remote repository is empty.\n* `vivarium.scout.git_drafts.assemble_pr_description`: assembles the PR description.\n* `pathlib.Path`: used to create a temporary file for the PR description.\n* `subprocess.run`: used to run GitHub CLI commands.\n* `tempfile.NamedTemporaryFile`: used to create a temporary file for the PR description.\n* `argparse.Namespace`: used to parse command-line arguments.\n\n## Potential Considerations\nThe code handles the following edge cases and potential considerations:\n* Checks for the existence of Python files before proceeding.\n* Handles the case where the repository has no remote origin or is empty.\n* Handles the case where the current branch is not set.\n* Handles errors when running GitHub CLI commands.\n* Uses a temporary file to store the PR description, which is deleted after use.\n* Uses the `subprocess.run` function with the `check=True` argument to raise an exception if the command fails.\n* Uses the `try-except` block to catch and handle exceptions when running GitHub CLI commands.\n\n## Signature\nThe `_cmd_pr` function has the following signature:\n```python\ndef _cmd_pr(args: argparse.Namespace) -> int\n```\nIt takes an `argparse.Namespace` object as an argument and returns an integer. The integer return value indicates the exit status of the function, where 0 indicates success and non-zero values indicate errors.",
      "eliv": "",
      "hash": "e29fee5dec42d471d93d6ed8bfa1a06d2e456456e415a37e6651d3a279bb3e4f"
    },
    "main": {
      "tldr": "This function appears to be a command-line interface (CLI) entry point for a Git-based system, handling commit and PR-related commands. It uses the `argparse` library to parse command-line arguments and calls functions from other modules to perform specific tasks.",
      "deep": "## Logic Overview\nThe `main` function is the entry point for the scout root CLI. It defines an `ArgumentParser` with subparsers for different commands: `commit`, `pr`, and `status`. The function then parses the arguments and executes the corresponding command. The main steps are:\n- Define the parser and subparsers\n- Parse the arguments\n- Execute the corresponding command based on the parsed arguments\n- If no command is specified, print the help message and return 0\n\n## Dependency Interactions\nThe `main` function interacts with the following traced calls:\n- `argparse.ArgumentParser`: creates a new argument parser\n- `parser.add_subparsers`: adds subparsers to the parser\n- `subparsers.add_parser`: adds a new parser for each command (`commit`, `pr`, `status`)\n- `commit_parser.add_argument` and `pr_parser.add_argument`: add arguments to the `commit` and `pr` parsers\n- `parser.parse_args`: parses the command-line arguments\n- `parser.print_help`: prints the help message if no command is specified\n- `_cmd_commit` and `_cmd_pr`: calls the corresponding command functions based on the parsed arguments\n- `run_status`: calls the `run_status` function from `vivarium.scout.cli.status` for the `status` command\n- `pathlib.Path.cwd`: gets the current working directory for the `status` command\n- `print`: prints the result of the `run_status` function for the `status` command\n\n## Potential Considerations\nThe code does not explicitly handle errors, but it does return an integer value, which could be used to indicate success or failure. The `argparse` library will raise an exception if there are any errors parsing the arguments. The code also does not handle any potential exceptions that may be raised by the `_cmd_commit`, `_cmd_pr`, or `run_status` functions. Additionally, the performance of the code may be affected by the complexity of the argument parsing and the execution of the corresponding commands.\n\n## Signature\nThe `main` function is defined as `def main() -> int`, indicating that it takes no arguments and returns an integer value. The return value is used to indicate the success or failure of the command execution. The function does not take any arguments, which is typical for a command-line interface entry point.",
      "eliv": "",
      "hash": "7b0f3c86c019b97b05d32e67de457dc65e734f6a38c95c8e66069bf424aa51a6"
    }
  }
}