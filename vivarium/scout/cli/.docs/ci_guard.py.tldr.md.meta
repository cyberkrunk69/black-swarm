{
  "source_hash": "5223214b43521f08bbc86f8e821d444502672236c3494f20a0eebe6212e7298c",
  "generated_at": "2026-02-13T01:42:16.547980+00:00",
  "model": "llama-3.3-70b-versatile",
  "symbols": {
    "DEFAULT_BASE_BRANCH": {
      "tldr": "The DEFAULT_BASE_BRANCH constant is not explicitly used in the system.",
      "deep": "## Logic Overview\nThe code defines a constant `DEFAULT_BASE_BRANCH` and assigns it the string value `\"origin/main\"`. This constant is not used within any conditional statements or loops in the provided code snippet. The main step is the assignment of the string value to the constant.\n\n## Dependency Interactions\nThere are no traced calls to analyze. The code does not reference any qualified names from the imported modules (`vivarium/scout/audit.py`, `vivarium/scout/git_analyzer.py`, `vivarium/scout/ignore.py`).\n\n## Potential Considerations\nThe constant `DEFAULT_BASE_BRANCH` is assigned a hardcoded string value. Potential considerations include:\n- The hardcoded value may need to be updated if the base branch changes.\n- There is no error handling for cases where the assigned branch does not exist.\n- The performance impact of this constant is negligible since it is a simple assignment.\n\n## Signature\nN/A",
      "eliv": "",
      "hash": "87e185dac58ac9784f17613d83648a7929b075e1ffe2d111e21d8408930eb87c"
    },
    "DEFAULT_HOURLY_SPEND_LIMIT": {
      "tldr": "TL;DR: The DEFAULT_HOURLY_SPEND_LIMIT constant is not directly involved in any system operations, as there are no traced calls or used types. It is imported from the vivarium/scout module, suggesting it may be a configuration or setting used elsewhere in the system.",
      "deep": "## Logic Overview\nThe code defines a constant `DEFAULT_HOURLY_SPEND_LIMIT` and assigns it a value of `5.0`. There are no conditional statements, loops, or functions in this code snippet, making it a simple declaration.\n\n## Dependency Interactions\nThere are no traced calls in this code snippet. The imports from `vivarium/scout/audit.py`, `vivarium/scout/git_analyzer.py`, and `vivarium/scout/ignore.py` do not interact with the `DEFAULT_HOURLY_SPEND_LIMIT` constant in this specific code snippet.\n\n## Potential Considerations\nThe code does not handle any potential errors or edge cases. Since it is a simple constant declaration, there is no performance consideration in this specific line of code. However, the value of `5.0` may have implications in the context of the larger program, but that cannot be determined from this snippet alone.\n\n## Signature\nN/A",
      "eliv": "",
      "hash": "8a09899427e87709baaf836a0cd654e3ac2810658756e545da6e289114e792c2"
    },
    "DEFAULT_MIN_CONFIDENCE": {
      "tldr": "The DEFAULT_MIN_CONFIDENCE constant is not used in any traced calls. It imports modules from vivarium/scout, but its purpose cannot be determined from the provided information.",
      "deep": "## Logic Overview\nThe code defines a constant `DEFAULT_MIN_CONFIDENCE` and assigns it a value of `0.7`. This constant is not used within the provided code snippet, but it is likely used elsewhere in the program to represent a minimum confidence threshold.\n\n## Dependency Interactions\nThere are no traced calls to analyze. The code does not reference any qualified names from the imported modules (`vivarium/scout/audit.py`, `vivarium/scout/git_analyzer.py`, `vivarium/scout/ignore.py`).\n\n## Potential Considerations\nThe code does not handle any potential errors or edge cases. The constant is defined with a fixed value, which may not be suitable for all scenarios. The performance of the code is not a concern, as it is a simple constant definition.\n\n## Signature\nN/A",
      "eliv": "",
      "hash": "8fedb348d2d2d397417c1c017947a4076bc0e2df7abc59c78fade9b010c73edc"
    },
    "_check_tldr_coverage": {
      "tldr": "This function checks the coverage of a TL;DR file by comparing its length to the length of the original file. It uses the `vivarium/scout/ignore.py` module to ignore certain patterns and the `vivarium/scout/git_analyzer.py` module to analyze the TL;DR file. It appends errors to a list if the TL;DR file is incomplete.",
      "deep": "## Logic Overview\nThe `_check_tldr_coverage` function iterates over a list of Python files (`changed_py`) and checks if each file has a corresponding `.tldr.md` file in a `.docs` directory. The function skips files that match the ignore patterns (`ignore`). If a `.tldr.md` file is missing, an error message is appended to the `errors` list. The function returns a tuple containing a boolean indicating whether any errors were found (`len(errors) == 0`) and the list of error messages.\n\n## Dependency Interactions\nThe function interacts with the following dependencies:\n- `ignore.matches(f, repo_root)`: checks if a file (`f`) matches the ignore patterns (`ignore`) relative to the repository root (`repo_root`).\n- `f.relative_to(repo_root)`: gets the relative path of a file (`f`) to the repository root (`repo_root`).\n- `tldr_path.exists()`: checks if a `.tldr.md` file exists at the specified path (`tldr_path`).\n- `errors.append(...)`: appends an error message to the `errors` list.\n- `len(errors)`: gets the number of error messages in the `errors` list.\n\n## Potential Considerations\n- The function handles the case where a file is not relative to the repository root by catching the `ValueError` exception and using the absolute path instead.\n- The function does not handle any other exceptions that may occur when checking file existence or relative paths.\n- The function assumes that the `.docs` directory exists for each file; if it does not, the `tldr_path.exists()` check will always return `False`.\n- The function returns a tuple containing a boolean and a list of error messages, which may be useful for further processing or logging.\n\n## Signature\nThe function signature is:\n```python\ndef _check_tldr_coverage(\n    repo_root: Path,\n    changed_py: List[Path],\n    ignore: IgnorePatterns,\n) -> Tuple[bool, List[str]]:\n```\nThis indicates that the function:\n- Takes three parameters: `repo_root` (a `Path` object), `changed_py` (a list of `Path` objects), and `ignore` (an `IgnorePatterns` object).\n- Returns a tuple containing two values: a boolean (`ok`) and a list of strings (`errors`). The boolean indicates whether any errors were found, and the list contains error messages for each missing `.tldr.md` file.",
      "eliv": "",
      "hash": "063cdb14434eefb56e00844358ec410e69fdc4fa685cb15ded303cfc5538792d"
    },
    "_check_draft_confidence": {
      "tldr": "This function checks the draft confidence by querying the audit log and appending errors if the draft confidence is not valid. It appears to be part of a system that analyzes Git repositories, possibly to validate or enforce certain configuration or consistency rules. The function likely returns or modifies the draft confidence value based on the audit log query results.",
      "deep": "## Logic Overview\nThe `_check_draft_confidence` function checks if there are any draft or navigation events in the audit log within a specified time frame that have a confidence level below a minimum threshold. The main steps are:\n1. Calculate the time frame by subtracting a specified number of hours from the current time.\n2. Query the audit log for events within this time frame.\n3. Iterate over the events and check if the event type is \"nav\", \"commit_draft\", or \"pr_snippet\".\n4. For each matching event, retrieve the confidence value and check if it's below the minimum threshold.\n5. If the confidence value is below the threshold, add an error message to the list of errors.\n6. Return a tuple containing a boolean indicating whether any errors were found and the list of error messages.\n\n## Dependency Interactions\nThe function interacts with the following dependencies:\n* `audit.query`: This is called to retrieve events from the audit log within the specified time frame.\n* `datetime.datetime.now`: This is called to get the current time.\n* `datetime.timedelta`: This is used to calculate the time frame by subtracting a specified number of hours from the current time.\n* `errors.append`: This is called to add error messages to the list of errors.\n* `isinstance`: This is used to check the type of the confidence value.\n* `len`: This is called to check if the list of errors is empty.\n* `obj.get`: This is called to retrieve the event type and confidence value from each event object.\n\n## Potential Considerations\nSome potential considerations based on the code are:\n* The function assumes that the confidence value is either an integer or a float, and that it's greater than 1 if it's an integer (in which case it's divided by 100). If the confidence value is in a different format, this could cause issues.\n* The function doesn't handle any exceptions that might be raised by the `audit.query` call or other dependencies.\n* The function uses a simple linear scan to iterate over the events, which could be inefficient if the number of events is very large.\n* The function returns a tuple containing a boolean and a list of error messages. If the list of error messages is very large, this could use a significant amount of memory.\n\n## Signature\nThe function signature is:\n```python\ndef _check_draft_confidence(audit: AuditLog, min_confidence: float, hours: int=24) -> Tuple[bool, List[str]]:\n```\nThis indicates that the function takes three parameters:\n* `audit`: an `AuditLog` object\n* `min_confidence`: a float representing the minimum confidence threshold\n* `hours`: an integer representing the number of hours to look back in the audit log (defaulting to 24 if not specified)\nThe function returns a tuple containing two values:\n* A boolean indicating whether any errors were found\n* A list of strings representing the error messages (if any)",
      "eliv": "",
      "hash": "c817a94257a8027caf45ead59ee74a8dd33276cdd7c1056f7fac98221ec2f76b"
    },
    "_check_hourly_spend": {
      "tldr": "TL;DR: The _check_hourly_spend function calls audit.hourly_spend and uses AuditLog and float types. It appears to be related to auditing hourly spend, possibly for logging or analysis purposes.",
      "deep": "## Logic Overview\nThe `_check_hourly_spend` function takes an `audit` object of type `AuditLog` and a `limit` of type `float` as input. It calculates the hourly spend by calling the `hourly_spend` method on the `audit` object with `hours=1`. The function then checks if the calculated spend is greater than or equal to the provided limit. If it is, the function returns a tuple containing `False` and a list with an error message. If the spend is less than the limit, the function returns a tuple containing `True` and an empty list.\n\n## Dependency Interactions\nThe function interacts with the `audit` object by calling its `hourly_spend` method, which is qualified as `audit.hourly_spend`. This method is used to calculate the hourly spend. The function does not directly interact with the imported modules (`vivarium/scout/audit.py`, `vivarium/scout/git_analyzer.py`, `vivarium/scout/ignore.py`), but it uses the `AuditLog` type from one of these modules.\n\n## Potential Considerations\nThe function does not handle any potential errors that might occur when calling the `hourly_spend` method. If this method raises an exception, it will not be caught or handled by the `_check_hourly_spend` function. Additionally, the function assumes that the `hourly_spend` method returns a value that can be compared to the `limit` using the `>=` operator. If this is not the case, the function may raise a `TypeError`. The function also does not check if the `limit` is a valid value (e.g., non-negative).\n\n## Signature\nThe function signature is `def _check_hourly_spend(audit: AuditLog, limit: float) -> Tuple[bool, List[str]]`. This indicates that the function:\n- Takes two parameters: `audit` of type `AuditLog` and `limit` of type `float`.\n- Returns a tuple containing two values: a boolean and a list of strings.\nThe use of the `AuditLog` type and the `float` type for the `limit` parameter suggests that the function is designed to work with a specific type of audit log data and a specific type of limit value. The return type of `Tuple[bool, List[str]]` indicates that the function will return a boolean value indicating whether the hourly spend is within the limit, along with a list of error messages if the spend exceeds the limit.",
      "eliv": "",
      "hash": "db52bc767b17563f07211af05551eaf584252dfd8f694d9b999ae245f2e86fbe"
    },
    "_check_draft_events_recent": {
      "tldr": "This function checks recent draft events by querying the audit log. It uses the current date and time to determine the time frame of recent events. It likely filters out events older than a certain threshold.",
      "deep": "## Logic Overview\nThe `_check_draft_events_recent` function checks if there are any \"commit_draft\" events in the audit log within a specified time frame (default is 24 hours). The main steps are:\n1. Calculate the time frame by subtracting the specified number of hours from the current time.\n2. Query the audit log for events that occurred within this time frame.\n3. Check if any of these events are \"commit_draft\" events.\n4. Return a boolean indicating whether any \"commit_draft\" events were found, along with a list of error messages (if any).\n\n## Dependency Interactions\nThe function interacts with the following dependencies:\n- `datetime.datetime.now`: used to get the current time.\n- `datetime.timedelta`: used to calculate the time frame by subtracting the specified number of hours from the current time.\n- `audit.query`: used to query the audit log for events within the specified time frame.\n- `any`: used to check if any of the events in the audit log are \"commit_draft\" events.\n- `e.get`: used to access the \"event\" field of each event in the audit log.\n\n## Potential Considerations\nBased on the code, some potential considerations are:\n- The function does not handle any exceptions that may occur when querying the audit log or accessing event fields.\n- The function assumes that the audit log is properly configured and available.\n- The function uses a default time frame of 24 hours, which may not be suitable for all use cases.\n- The function returns a list of error messages, but only includes a single error message if no \"commit_draft\" events are found.\n- The performance of the function may be affected by the size of the audit log and the number of events within the specified time frame.\n\n## Signature\nThe function signature is:\n```python\ndef _check_draft_events_recent(audit: AuditLog, hours: int = 24) -> Tuple[bool, List[str]]:\n```\nThis indicates that the function:\n- Takes two parameters: `audit` of type `AuditLog` and `hours` of type `int` (with a default value of 24).\n- Returns a tuple containing two values: a boolean and a list of strings. The boolean indicates whether any \"commit_draft\" events were found, and the list of strings contains error messages (if any).",
      "eliv": "",
      "hash": "3f7ec63d5b0c738606fb67e3fa14d36c22676374ebe83592ce5eaa6c8a695c42"
    },
    "run_ci_guard": {
      "tldr": "This function appears to be part of a Continuous Integration (CI) guard, responsible for auditing a repository's changes and spending. It calls various functions to check for draft confidence, recent events, hourly spend, and TLDR coverage, and logs any audit results.",
      "deep": "## Logic Overview\nThe `run_ci_guard` function is designed to run a series of checks on a repository. The main steps are:\n1. Resolve the repository root path.\n2. Get the list of changed files in the repository.\n3. Filter the changed files to only include Python files.\n4. Initialize an `IgnorePatterns` object to ignore certain files.\n5. Run the following checks:\n   - `_check_tldr_coverage` to check the coverage of TLDR files.\n   - `_check_draft_confidence` to check the confidence of draft events.\n   - `_check_hourly_spend` to check the hourly spend.\n   - `_check_draft_events_recent` to check for recent draft events (if `require_draft_events` is `True`).\n6. Close the audit log and return a tuple containing a boolean indicating whether all checks passed and a list of error messages.\n\n## Dependency Interactions\nThe `run_ci_guard` function interacts with the following dependencies:\n- `vivarium.scout.git_analyzer.get_changed_files`: to get the list of changed files in the repository.\n- `vivarium.scout.ignore.IgnorePatterns`: to ignore certain files.\n- `vivarium.scout.audit.AuditLog`: to log audit events.\n- `_check_tldr_coverage`, `_check_draft_confidence`, `_check_hourly_spend`, and `_check_draft_events_recent`: to run the various checks.\n- `pathlib.Path`: to work with file paths.\n- `len`: to get the length of the error list.\n- `errors.extend`: to add error messages to the list.\n\n## Potential Considerations\nThe code handles the following edge cases and considerations:\n- If an exception occurs while getting the changed files, it tries to get the changed files again without the `base_branch` parameter. If this also fails, it returns an error message.\n- If the `require_draft_events` parameter is `True`, it checks for recent draft events.\n- The function uses a try-except block to catch any exceptions that may occur while getting the changed files.\n- The function closes the audit log after all checks have been run.\n- The function returns a tuple containing a boolean indicating whether all checks passed and a list of error messages.\n\n## Signature\nThe `run_ci_guard` function has the following signature:\n```python\ndef run_ci_guard(\n    repo_root: Path,\n    base_branch: str = DEFAULT_BASE_BRANCH,\n    hourly_limit: float = DEFAULT_HOURLY_SPEND_LIMIT,\n    min_confidence: float = DEFAULT_MIN_CONFIDENCE,\n    require_draft_events: bool = False,\n    draft_events_hours: int = 24\n) -> Tuple[bool, List[str]]:\n```\nThis signature indicates that the function:\n- Takes six parameters: `repo_root`, `base_branch`, `hourly_limit`, `min_confidence`, `require_draft_events`, and `draft_events_hours`.\n- Returns a tuple containing two values: a boolean indicating whether all checks passed and a list of error messages.\n- Uses the following types: `Path`, `str`, `float`, `bool`, `int`, and `Tuple[bool, List[str]]`.",
      "eliv": "",
      "hash": "9291409589076f05f81a860fd8d8b03c4f8e15c247e9af23dbe7a590bfe61b0a"
    },
    "main": {
      "tldr": "This function appears to be a command-line interface (CLI) entry point, utilizing the `argparse` library to parse command-line arguments. It likely performs some form of analysis or validation, possibly related to a Git repository, given the imports from `vivarium/scout/git_analyzer.py`.",
      "deep": "## Logic Overview\nThe `main` function serves as the CLI entry point. It can be broken down into the following main steps:\n1. **Argument Parsing**: The function initializes an `ArgumentParser` and defines several command-line arguments, including `--base-branch`, `--hourly-limit`, `--min-confidence`, `--require-draft-events`, and `--draft-events-hours`.\n2. **Parsing Arguments**: It then parses the command-line arguments using `parser.parse_args()`.\n3. **Running CI Guard**: The function calls `run_ci_guard` with the parsed arguments and the current working directory as the repository root.\n4. **Error Handling and Return**: If `run_ci_guard` returns an error (i.e., `ok` is `False`), it prints the errors to the standard error stream and returns an exit code of 1. Otherwise, it returns 0.\n\n## Dependency Interactions\nThe `main` function interacts with the following traced calls:\n* `argparse.ArgumentParser`: Creates a new argument parser with a specified program name and description.\n* `parser.add_argument`: Adds command-line arguments to the parser, including their names, types, default values, and help messages.\n* `parser.parse_args`: Parses the command-line arguments and returns a namespace containing the parsed values.\n* `pathlib.Path.cwd`: Gets the current working directory, which is used as the repository root for `run_ci_guard`.\n* `print`: Prints error messages to the standard error stream if `run_ci_guard` returns an error.\n* `run_ci_guard`: Calls the `run_ci_guard` function with the parsed arguments and repository root.\n\n## Potential Considerations\nBased on the code, the following potential considerations can be identified:\n* **Error Handling**: The function handles errors returned by `run_ci_guard` by printing them to the standard error stream and returning a non-zero exit code.\n* **Performance**: The function's performance may depend on the performance of `run_ci_guard`, which is not shown in the provided code.\n* **Edge Cases**: The function does not appear to handle any specific edge cases, such as invalid command-line arguments or repository root issues. However, `argparse` may handle some of these cases automatically.\n\n## Signature\nThe `main` function has the following signature:\n```python\ndef main() -> int:\n```\nThis indicates that the function takes no arguments and returns an integer value, which is typically used as an exit code in CLI applications. The return type is explicitly specified as `int`.",
      "eliv": "",
      "hash": "53d8427f9386b3d1688392491ac6037ace55c7b468df55dacbe713941041f9b5"
    }
  }
}