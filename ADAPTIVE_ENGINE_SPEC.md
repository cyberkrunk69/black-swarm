```markdown
# Adaptive Engine Selection Criteria

The adaptive engine selection uses the following criteria to select between Claude and Groq:

1. **Complexity Analysis**:
   - Simple tasks (create file, fix typo) -> Groq (cheap, fast)
   - Complex tasks (design, refactor, security) -> Claude (smart)

2. **Budget Awareness**:
   - Low remaining budget -> Groq
   - Critical task + budget available -> Claude

3. **Explicit Override**:
   - Task contains 'use groq' -> Force Groq
   - Task contains 'use claude' -> Force Claude

4. **Quality Feedback**:
   - If Groq output fails verification -> Retry with Claude
   - Learn patterns of which tasks need Claude
```
# Adaptive Engine Selection Specification

## Overview
The **AdaptiveEngineSelector** decides whether a task should be processed by **Claude** (high‑quality, higher‑cost) or **Groq** (fast, low‑cost) automatically. The decision is based on four orthogonal signals:

| Signal | Description | Impact |
|--------|-------------|--------|
| **Explicit Override** | The task text contains `use groq` or `use claude`. | Forces the corresponding engine, bypassing all other logic. |
| **Quality Feedback** | If a previous Groq run failed verification, the selector retries with Claude. | Guarantees a fallback to the higher‑quality model when Groq proves insufficient. |
| **Budget Awareness** | The system tracks a remaining budget (USD). If it falls below a configurable threshold (`0.05` by default), Groq is chosen to conserve funds. | Prevents budget overruns. |
| **Complexity Analysis** | Simple‑task heuristics (keywords like *create file*, *fix typo*, length < 12 words) → Groq. Complex‑task heuristics (keywords like *design*, *refactor*, *security*) → Claude. | Routes tasks to the engine that matches their difficulty. |
| **Critical‑Task Boost** | Tasks containing words such as *security*, *critical*, or *important* are treated as critical. When budget permits, Claude is selected regardless of other signals. | Ensures high‑risk work receives the best model. |

## Decision Flow
1. **Check for explicit override** – immediate return.  
2. **If Groq previously failed verification** – switch to Claude.  
3. **Budget check** – low budget forces Groq.  
4. **Complexity analysis** – simple → Groq, complex → Claude.  
5. **Critical‑task consideration** – if flagged and budget is sufficient, choose Claude.  

## Extensibility
- **Keyword sets** (`_simple_keywords`, `_complex_keywords`) can be extended in `grind_spawner_unified.py`.  
- **Budget threshold** is a single constant (`low_budget_threshold`) and can be externalised to a config file.  
- **Verification feedback** (`last_groq_success`) should be populated by the verification subsystem after each Groq run.

## Usage
```python
engine = AdaptiveEngineSelector.select_engine(
    task=task_description,
    budget_remaining=current_budget,
    last_groq_success=groq_verification_passed,
    critical=is_critical_task,
)
```
The returned string (`"claude"` or `"groq"`) is then passed to the downstream execution pipeline.

--- 

*Generated by the adaptive‑engine‑selection implementation.*
# Adaptive Engine Selection Specification

## Overview
The system automatically chooses between the **Groq** and **Claude** language model
engines on a per‑task basis. The decision is driven by four factors:

1. **Explicit Override**
   * If the task description contains the phrase `use groq` → Groq is forced.
   * If the task description contains the phrase `use claude` → Claude is forced.

2. **Complexity Analysis**
   * **Simple tasks** – identified by keywords such as  
     `create file`, `fix typo`, `add comment`, `write test`, etc. – default to **Groq** (fast & cheap).
   * **Complex tasks** – identified by keywords such as  
     `design`, `refactor`, `security`, `optimize`, `architecture`, etc. – default to **Claude** (more capable).

3. **Budget Awareness**
   * When the remaining budget is **low** ( < 5 units ) the selector prefers **Groq**.
   * If the budget is moderate‑to‑high ( ≥ 10 units ) and the task is not explicitly simple,
     **Claude** may be chosen.

4. **Quality Feedback**
   * If a Groq‑generated output fails verification, the next attempt automatically
     switches to **Claude**.
   * The selector records the task description that caused a failure. Future tasks
     containing the same pattern will be routed to Claude pre‑emptively.

## Implementation Details
* The logic lives in `EngineSelector.select(task, budget_remaining=0.0,
  verification_failed=False)`.
* An internal set `_groq_failure_patterns` stores lower‑cased task strings that have
  previously required Claude.
* The method returns the string `"groq"` or `"claude"` which is consumed by the
  spawning/orchestration layer.
* Default behaviour (no explicit cues, no budget pressure, unknown complexity) falls
  back to Groq for cost‑efficiency, unless the budget is high enough to justify Claude.

## Extensibility
* Add new keywords to `simple_keywords` or `complex_keywords` to refine heuristics.
* Adjust budget thresholds (`5.0`, `10.0`) according to pricing models.
* Persist `_groq_failure_patterns` to disk if long‑term learning across runs is desired.

---  
This specification documents the adaptive engine selection mechanism introduced
in `grind_spawner_unified.py`.