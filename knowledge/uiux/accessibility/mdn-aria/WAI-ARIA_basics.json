{
  "id": "mdn-aria__en-US_docs_Learn_Accessibility_WAI-ARIA_basics",
  "source_id": "mdn-aria",
  "source_name": "MDN ARIA Documentation",
  "category": "accessibility",
  "url": "https://developer.mozilla.org/en-US/docs/Learn/Accessibility/WAI-ARIA_basics",
  "title": "WAI-ARIA basics",
  "content": "WAI-ARIA basics\nPrevious\nOverview: Accessibility on the web\nNext\nFollowing on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.\nPrerequisites:\nFamiliarity with\nHTML\n,\nCSS\n, and accessibility best practices as taught in previous lessons in the module.\nLearning outcomes:\nThe purpose of WAI-ARIA \u00e2\u0080\u0094 to provide semantics to otherwise non-semantic HTML, so that AT users can make sense of the interfaces being presented to them.\nThe basic syntax \u00e2\u0080\u0094 roles, properties, and states.\nLandmarks and signposting.\nEnhancing keyboard accessibility.\nAnnouncing dynamic content updates with live regions.\nWhat is WAI-ARIA?\nLet's start by looking at what WAI-ARIA is, and what it can do for us.\nA whole new set of problems\nAs web apps started to get more complex and dynamic, a new set of accessibility features and problems started to appear.\nFor example, HTML introduced a number of semantic elements to define common page features (\n<nav>\n,\n<footer>\n, etc.). Before these were available, developers would use\n<div>\ns with IDs or classes, e.g.,\n<div class=\"nav\">\n, but these were problematic, as there was no easy way to easily find a specific page feature such as the main navigation programmatically.\nThe initial solution was to add one or more hidden links at the top of the page to link to the navigation (or whatever else), for example:\nhtml\n<a href=\"#hidden\" class=\"hidden\">Skip to navigation</a>\nBut this is still not very precise, and can only be used when the screen reader is reading from the top of the page.\nAs another example, apps started to feature complex controls like date pickers for choosing dates, sliders for choosing values, etc. HTML provides special input types to render such controls:\nhtml\n<input type=\"date\" /> <input type=\"range\" />\nThese were originally not well-supported and it was, and still is to a lesser extent, difficult to style them, leading designers and developers to opt for custom solutions. Instead of using these native features, some developers rely on JavaScript libraries that generate such controls as a series of nested\n<div>\ns which are then styled using CSS and controlled using JavaScript.\nThe problem here is that visually they work, but screen readers can't make any sense of what they are at all, and their users just get told that they can see a jumble of elements with no semantics to describe what they mean.\nEnter WAI-ARIA\nWAI-ARIA\n(Web Accessibility Initiative - Accessible Rich Internet Applications) is a specification written by the W3C, defining a set of additional HTML attributes that can be applied to elements to provide additional semantics and improve accessibility wherever it is lacking. There are three main features defined in the spec:\nRoles\nThese define what an element is or does. Many of these are so-called landmark roles, which largely duplicate the semantic value of structural elements, such as\nrole=\"navigation\"\n(\n<nav>\n),\nrole=\"banner\"\n(document\n<header>\n),\nrole=\"complementary\"\n(\n<aside>\n) or ,\nrole=\"search\"\n(\n<search>\n). Some other roles describe different page structures that do not have elements with that match those roles, such as\nrole=\"tablist\"\n, and\nrole=\"tabpanel\"\n, which are commonly found in UIs.\nProperties\nThese define properties of elements, which can be used to give them extra meaning or semantics. As an example,\naria-required=\"true\"\nspecifies that a form input needs to be filled in order to be valid, whereas\naria-labelledby=\"label\"\nallows you to put an ID on an element, then reference it as being the label for anything else on the page, including multiple elements, which is not possible using\n<label for=\"input\">\n. As an example, you could use\naria-labelledby\nto specify that a key description contained in a\n<div>\nis the label for multiple table cells, or you could use it as an alternative to image alt text \u00e2\u0080\u0094 specify existing information on the page as an image's alt text, rather than having to repeat it inside the\nalt\nattribute. You can see an example of this at\nText alternatives\n.\nStates\nSpecial properties that define the current conditions of elements, such as\naria-disabled=\"true\"\n, which specifies to a screen reader that a form input is currently disabled. States differ from properties in that properties don't change throughout the lifecycle of an app, whereas states can change, generally programmatically via JavaScript.\nAn important point about WAI-ARIA attributes is that they don't affect anything about the web page, except for the information exposed by the browser's accessibility APIs (where screen readers get their information from). WAI-ARIA doesn't affect webpage structure, the DOM, etc., although the attributes can be useful for selecting elements by CSS.\nNote:\nYou can find a useful list of all the ARIA roles and their uses, with links to further information, in the WAI-ARIA spec \u00e2\u0080\u0094 see\nDefinition of Roles\n\u00e2\u0080\u0094 on this site \u00e2\u0080\u0094 see\nARIA roles\n.\nThe spec also contains a list of all the properties and states, with links to further information \u00e2\u0080\u0094 see\nDefinitions of States and Properties (all\naria-*\nattributes)\n.\nWhere is WAI-ARIA supported?\nThis is not an easy question to answer. It is difficult to find a conclusive resource that states what features of WAI-ARIA are supported, and where, because:\nThere are a lot of features in the WAI-ARIA spec.\nThere are many combinations of operating systems, browsers, and screen readers to consider.\nThis last point is key \u00e2\u0080\u0094 To use a screen reader in the first place, your operating system needs to run browsers that have the necessary accessibility APIs in place to expose the information screen readers need to do their job. Most popular OSes have one or two browsers in place that screen readers can work with. The Paciello Group has a fairly up-to-date post that provides data for this \u00e2\u0080\u0094 see\nRough Guide: browsers, operating systems and screen reader support updated\n.\nNext, you need to worry about whether the browsers in question support ARIA features and expose them via their APIs, but also whether screen readers recognize that information and present it to their users in a useful way.\nBrowser support is almost universal.\nScreen reader support for ARIA features isn't quite at this level, but the most popular screen readers are getting there. You can get an idea of support levels by looking at Powermapper's\nWAI-ARIA Screen reader compatibility\narticle.\nIn this article, we won't attempt to cover every WAI-ARIA feature, and its exact support details. Instead, we will cover the most critical WAI-ARIA features for you to know about; if we don't mention any support details, you can assume that the feature is well-supported. We will clearly mention any exceptions to this.\nNote:\nSome JavaScript libraries support WAI-ARIA, meaning that when they generate UI features like complex form controls, they add ARIA attributes to improve the accessibility of those features. If you are looking for a 3rd party JavaScript solution for rapid UI development, you should definitely consider the accessibility of its UI widgets as an important factor when making your choice. Good examples are jQuery UI (see\nAbout jQuery UI: Deep accessibility support\n),\nExtJS\n, and\nDojo/Dijit\n.\nWhen should you use WAI-ARIA?\nWe talked about some of the problems that prompted WAI-ARIA to be created earlier on, but essentially, there are four main areas that WAI-ARIA is useful in:\nSignposts/Landmarks\nARIA's\nrole\nattribute values can act as landmarks that either replicate the semantics of HTML elements (e.g.,\n<nav>\n), or go beyond HTML semantics to provide signposts to different functional areas, for example,\nsearch\n,\ntablist\n,\ntab\n,\nlistbox\n, etc.\nDynamic content updates\nScreen readers tend to have difficulty with reporting constantly changing content; with ARIA we can use\naria-live\nto inform screen reader users when an area of content is updated dynamically: for example, by JavaScript in the page\nfetching new content from the server and updating the DOM\n.\nEnhancing keyboard accessibility\nThere are built-in HTML elements that have native keyboard accessibility; when other elements are used along with JavaScript to simulate similar interactions, keyboard accessibility and screen reader reporting suffers as a result. Where this is unavoidable, WAI-ARIA provides a means to allow other elements to receive focus (using\ntabindex\n).\nAccessibility of non-semantic controls\nWhen a series of nested\n<div>\ns along with CSS/JavaScript is used to create a complex UI-feature, or a native control is greatly enhanced/changed via JavaScript, accessibility can suffer \u00e2\u0080\u0094 screen reader users will find it difficult to work out what the feature does if there are no semantics or other clues. In these situations, ARIA can help to provide what's missing with a combination of roles like\nbutton\n,\nlistbox\n, or\ntablist\n, and properties like\naria-required\nor\naria-posinset\nto provide further clues as to functionality.\nIn the next section, we'll look at the four main areas described earlier in more detail, along with examples. Before you continue, you should put a screen reader testing setup in place, so you can test some of the examples as you go through. See our section on\ntesting screen readers\nfor more information.\nYou should only use WAI-ARIA when you need to!\nUsing the correct HTML elements implicitly gives you the roles that are needed and you should\nalways\nuse\nnative HTML features\nto provide the semantics required by screen readers to tell their users what is going on. Sometimes this isn't possible, either because you have limited control over the code, or because you are creating something complex that doesn't have an easy HTML element to implement it. In such cases, WAI-ARIA can be a valuable accessibility enhancing tool.\nBut again, only use it when necessary!\nAlso, try to make sure you test your site with a variety of\nreal\nusers \u00e2\u0080\u0094 non-disabled people, people using screen readers, people using keyboard navigation, etc. They will have better insights than you about how well it works.\nSignposts/Landmarks\nWAI-ARIA adds the\nrole\nattribute\nto browsers, which allows you to add extra semantic value to elements on your site wherever they are needed. The first major area in which this is useful is providing information for screen readers so that their users can find common page elements. This example has the following structure:\nhtml\n<header>\n  <h1>Header</h1>\n\n  <!-- Even is it's not mandatory, it's common practice to put the main navigation menu within the main header -->\n\n  <nav>\n    <ul>\n      <li><a href=\"#\">Home</a></li>\n      <li><a href=\"#\">Team</a></li>\n      <li><a href=\"#\">Projects</a></li>\n      <li><a href=\"#\">Contact</a></li>\n    </ul>\n\n    <!-- A Search form is another common non-linear way to navigate through a website. -->\n\n    <form>\n      <input type=\"search\" name=\"q\" placeholder=\"Search query\" />\n      <input type=\"submit\" value=\"Go!\" />\n    </form>\n  </nav>\n</header>\n\n<!-- Here is our page's main content -->\n<main>\n  <!-- It contains an article -->\n  <article>\n    <h2>Article heading</h2>\n\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam\n      lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra\n      nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam\n      eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue\n      enim, ut porta lorem lacinia consectetur.\n    </p>\n\n    <h3>subsection</h3>\n\n    <p>\n      Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum\n      dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut\n      turpis felis, pulvinar a semper sed, adipiscing id dolor.\n    </p>\n  </article>\n\n  <!-- the aside content can also be nested within the main content -->\n  <aside>\n    <h2>Related</h2>\n\n    <ul>\n      <li><a href=\"#\">Oh I do like to be beside the seaside</a></li>\n      <li><a href=\"#\">Oh I do like to be beside the sea</a></li>\n      <li><a href=\"#\">Although in the North of England</a></li>\n      <li><a href=\"#\">It never stops raining</a></li>\n      <li><a href=\"#\">Oh well...</a></li>\n    </ul>\n  </aside>\n</main>\n\n<!-- And here is our main footer that is used across all the pages of our website -->\n\n<footer>\n  <p>\u00c2\u00a9Copyright 2050 by nobody. All rights reversed.</p>\n</footer>\n/* || General setup */\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 10px;\n  background-color: darkgrey;\n}\n\nbody {\n  width: max(70vw, 90%);\n  margin: 0 auto;\n  padding: 0 10px;\n  display: flex;\n  flex-direction: column;\n}\n\n/* || typography */\n\nh1,\nh2,\nh3 {\n  font-family: \"Sonsie One\", cursive;\n  color: #2a2a2a;\n}\n\np,\ninput,\nli {\n  font-family: \"Open Sans Condensed\", sans-serif;\n  color: #2a2a2a;\n}\n\nh1 {\n  font-size: 4rem;\n  text-align: center;\n  color: white;\n  text-shadow: 2px 2px 10px black;\n}\n\nh2 {\n  font-size: 3rem;\n  text-align: center;\n}\n\nh3 {\n  font-size: 2.2rem;\n}\n\np,\nli {\n  font-size: 1.6rem;\n  line-height: 1.5;\n}\n\n/* || header layout */\n\nheader {\n  margin-bottom: 10px;\n}\n\nnav,\narticle,\naside,\nfooter {\n  background-color: white;\n  padding: 1%;\n}\n\nnav {\n  background-color: #ff80ff;\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\nnav ul {\n  padding: 0;\n  list-style-type: none;\n  flex: 2;\n  display: flex;\n  gap: 2vw;\n}\n\nnav li {\n  display: inline;\n  text-align: center;\n}\n\nnav a {\n  display: inline-block;\n  font-size: 2rem;\n  text-transform: uppercase;\n  text-decoration: none;\n  color: black;\n}\n\nnav form {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\ninput {\n  font-size: 1.6rem;\n  height: 32px;\n}\n\ninput[type=\"search\"] {\n  flex: 3;\n}\n\ninput[type=\"submit\"] {\n  flex: 1;\n  margin-left: 1rem;\n  background: #333333;\n  border: 0;\n  color: white;\n}\n\n/* || main layout */\n\nmain {\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\narticle {\n  flex: 4;\n}\n\naside {\n  flex: 1;\n  background-color: #ff80ff;\n}\n\naside li {\n  padding-bottom: 10px;\n}\n\nfooter {\n  margin-top: 10px;\n}\nIf you try testing the example with a screen reader in a modern browser, you'll already get some useful information. For example, VoiceOver gives you the following:\nOn the\n<header>\nelement \u00e2\u0080\u0094 \"banner, 2 items\" (it contains a heading and the\n<nav>\n).\nOn the\n<nav>\nelement \u00e2\u0080\u0094 \"navigation 2 items\" (it contains a list and a form).\nOn the\n<main>\nelement \u00e2\u0080\u0094 \"main 2 items\" (it contains an article and an aside).\nOn the\n<aside>\nelement \u00e2\u0080\u0094 \"complementary 2 items\" (it contains a heading and a list).\nOn the search form input \u00e2\u0080\u0094 \"Search query, insertion at beginning of text\".\nOn the\n<footer>\nelement \u00e2\u0080\u0094 \"footer 1 item\".\nIf you go to VoiceOver's landmarks menu (accessed using VoiceOver key + U and then using the cursor keys to cycle through the menu choices), you'll see that most of the elements are nicely listed so they can be accessed quickly.\nHowever, we could do better here. The search form is a really important landmark that people will want to find, but it is not listed in the landmarks menu or treated like a notable landmark beyond the actual input being called out as a search input (\n<input type=\"search\">\n).\nTo mark the form as a landmark, you can either wrap it with the\n<search>\nelement or give it ARIA\nrole=\"search\"\n. As a general rule, use HTML semantics where possible and only use ARIA where there is no HTML equivalent.\nhtml\n<header>\n  <h1>Header</h1>\n\n  <!-- Even is it's not mandatory, it's common practice to put the main navigation menu within the main header -->\n\n  <nav>\n    <ul>\n      <li><a href=\"#\">Home</a></li>\n      <li><a href=\"#\">Our team</a></li>\n      <li><a href=\"#\">Projects</a></li>\n      <li><a href=\"#\">Contact</a></li>\n    </ul>\n\n    <!-- A Search form is another common non-linear way to navigate through a website. -->\n\n    <search>\n      <form>\n        <input\n          type=\"search\"\n          name=\"q\"\n          placeholder=\"Search query\"\n          aria-label=\"Search through site content\" />\n        <input type=\"submit\" value=\"Go!\" />\n      </form>\n    </search>\n  </nav>\n</header>\n\n<!-- Here is our page's main content -->\n<main>\n  <!-- It contains an article -->\n  <article>\n    <h2>Article heading</h2>\n\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam\n      lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra\n      nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam\n      eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue\n      enim, ut porta lorem lacinia consectetur.\n    </p>\n\n    <h3>subsection</h3>\n\n    <p>\n      Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum\n      dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut\n      turpis felis, pulvinar a semper sed, adipiscing id dolor.\n    </p>\n\n    <p>\n      Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus,\n      enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis\n      libero in urna ultrices accumsan. Donec sed odio eros.\n    </p>\n  </article>\n\n  <!-- the aside content can also be nested within the main content -->\n  <aside>\n    <h2>Related</h2>\n    <ul>\n      <li><a href=\"#\">Oh I do like to be beside the seaside</a></li>\n      <li><a href=\"#\">Oh I do like to be beside the sea</a></li>\n      <li><a href=\"#\">Although in the North of England</a></li>\n      <li><a href=\"#\">It never stops raining</a></li>\n      <li><a href=\"#\">Oh well...</a></li>\n    </ul>\n  </aside>\n</main>\n\n<!-- And here is our main footer that is used across all the pages of our website -->\n\n<footer>\n  <p>\u00c2\u00a9Copyright 2050 by nobody. All rights reversed.</p>\n</footer>\n/* || General setup */\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 10px;\n  background-color: darkgrey;\n}\n\nbody {\n  width: max(70vw, 90%);\n  margin: 0 auto;\n  padding: 0 10px;\n  display: flex;\n  flex-direction: column;\n}\n\n/* || typography */\n\nh1,\nh2,\nh3 {\n  font-family: \"Sonsie One\", cursive;\n  color: #2a2a2a;\n}\n\np,\ninput,\nli {\n  font-family: \"Open Sans Condensed\", sans-serif;\n  color: #2a2a2a;\n}\n\nh1 {\n  font-size: 4rem;\n  text-align: center;\n  color: white;\n  text-shadow: 2px 2px 10px black;\n}\n\nh2 {\n  font-size: 3rem;\n  text-align: center;\n}\n\nh3 {\n  font-size: 2.2rem;\n}\n\np,\nli {\n  font-size: 1.6rem;\n  line-height: 1.5;\n}\n\n/* || header layout */\n\nheader {\n  margin-bottom: 10px;\n}\n\nnav,\narticle,\naside,\nfooter {\n  background-color: white;\n  padding: 1%;\n}\n\nnav {\n  background-color: #ff80ff;\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\nnav ul {\n  padding: 0;\n  list-style-type: none;\n  flex: 2;\n  display: flex;\n  gap: 2vw;\n}\n\nnav li {\n  display: inline;\n  text-align: center;\n}\n\nnav a {\n  display: inline-block;\n  font-size: 2rem;\n  text-transform: uppercase;\n  text-decoration: none;\n  color: black;\n}\n\nnav form {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\ninput {\n  font-size: 1.6rem;\n  height: 32px;\n}\n\ninput[type=\"search\"] {\n  flex: 3;\n}\n\ninput[type=\"submit\"] {\n  flex: 1;\n  margin-left: 1rem;\n  background: #333333;\n  border: 0;\n  color: white;\n}\n\n/* || main layout */\n\nmain {\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\narticle {\n  flex: 4;\n}\n\naside {\n  flex: 1;\n  background-color: #ff80ff;\n}\n\naside li {\n  padding-bottom: 10px;\n}\n\nfooter {\n  margin-top: 10px;\n}\nMost importantly, we have used semantic HTML that gives meaning and roles to the structure of the page without adding unnecessary\nrole\nattributes to our HTML structure, which has a structure like this:\nhtml\n<header>\n  <h1>\u00e2\u0080\u00a6</h1>\n  <nav>\n    <ul>\n      \u00e2\u0080\u00a6\n    </ul>\n    <search>\n      <form>\n        <!-- search form -->\n      </form>\n    </search>\n  </nav>\n</header>\n\n<main>\n  <article>\u00e2\u0080\u00a6</article>\n  <aside>\u00e2\u0080\u00a6</aside>\n</main>\n\n<footer>\u00e2\u0080\u00a6</footer>\nWe've also given you a bonus feature in this example \u00e2\u0080\u0094 the\n<input>\nelement has been given the attribute\naria-label\n, which gives it a descriptive label to be read out by a screen reader, even though we haven't included a\n<label>\nelement. In cases like these, this is very useful \u00e2\u0080\u0094 a search form like this one is a very common, easily recognized feature, and adding a visual label would spoil the page design.\nhtml\n<input\n  type=\"search\"\n  name=\"q\"\n  placeholder=\"Search query\"\n  aria-label=\"Search through site content\" />\nNow if we use VoiceOver to look at this example, we get some improvements:\nThe search form is called out as a separate item, both when browsing through the page, and in the Landmarks menu.\nThe label text contained in the\naria-label\nattribute is read out when the form input is highlighted.\nIf you need to support older browsers such as IE8; it is worth including ARIA roles for that purpose. And if for some reason your site is built using just\n<div>\ns, you should definitely include the ARIA roles to provide these much needed semantics!\nYou'll see a lot more about these semantics and the power of ARIA properties/attributes below, especially in the\nAccessibility of non-semantic controls\nsection. For now though, let's look at how ARIA can help with dynamic content updates.\nDynamic content updates\nContent loaded into the DOM can be easily accessed using a screen reader, from textual content to alternative text attached to images. Traditional static websites with largely text content are therefore easy to make accessible for people with visual impairments.\nThe problem is that modern web apps are often not just static text \u00e2\u0080\u0094 they often update parts of the page by fetching new content from the server (in this example we are using a static array of quotes) and updating the DOM. These are sometimes referred to as\nlive regions\n.\nLet's look at an example \u00e2\u0080\u0094 a random quote generator:\nhtml\n<section>\n  <h1>Random quote generator</h1>\n  <button>Start giving me quotes</button>\n  <blockquote>\n    <p></p>\n  </blockquote>\n</section>\n* {\n  box-sizing: border-box;\n}\n\nhtml {\n  font-family: sans-serif;\n}\n\nhtml,\nbody {\n  height: 100%;\n}\n\nh1 {\n  letter-spacing: 2px;\n}\n\np {\n  line-height: 1.6;\n}\n\nsection {\n  height: 100%;\n  padding: 10px;\n  background: #666666;\n  text-shadow: 1px 1px 1px black;\n  color: white;\n}\njs\nlet quotes = [\n  {\n    quote:\n      \"Every child is an artist. The problem is how to remain an artist once he grows up.\",\n    author: \"Pablo Picasso\",\n  },\n  {\n    quote:\n      \"You can never cross the ocean until you have the courage to lose sight of the shore.\",\n    author: \"Christopher Columbus\",\n  },\n  {\n    quote:\n      \"I love deadlines. I love the whooshing noise they make as they go by.\",\n    author: \"Douglas Adams\",\n  },\n];\njs\nconst quotePara = document.querySelector(\"section p\");\nconst btn = document.querySelector(\"button\");\n\nbtn.addEventListener(\"click\", () => {\n  function showQuote() {\n    let random = Math.floor(Math.random() * quotes.length);\n    quotePara.textContent = `${quotes[random].quote} -- ${quotes[random].author}`;\n  }\n\n  showQuote();\n  btn.disabled = true;\n  window.setInterval(showQuote, 5000);\n});\nThis works OK, but it is not good for accessibility \u00e2\u0080\u0094 the content update is not detected by screen readers, so their users would not know what is going on. This is a fairly trivial example, but just imagine if you were creating a complex UI with lots of constantly updating content, like a chat room, or a strategy game UI, or a live updating shopping cart display \u00e2\u0080\u0094 it would be impossible to use the app in any effective way without some kind of way of alerting the user to the updates.\nWAI-ARIA, fortunately, provides a useful mechanism to provide these alerts \u00e2\u0080\u0094 the\naria-live\nproperty. Applying this to an element causes screen readers to read out the content that is updated. How urgently the content is read out depends on the attribute value:\noff\nThe default. Updates should not be announced.\npolite\nUpdates should be announced only if the user is idle.\nassertive\nUpdates should be announced to the user as soon as possible.\nHere we update the\n<blockquote>\nopening tag as follows:\nhtml\n<blockquote aria-live=\"assertive\">\u00e2\u0080\u00a6</blockquote>\nThis will cause a screen reader to read out the content as it is updated: try testing the updated the updated live version:\n<section>\n  <h1>Random quote generator</h1>\n  <button>Start giving me quotes</button>\n  <blockquote aria-live=\"assertive\">\n    <p></p>\n  </blockquote>\n</section>\nNote:\nThere are some other ARIA properties related to\naria-live\nthat are also worth knowing about:\nThe\naria-atomic\nproperty, when set to\ntrue\n, tells screen readers to read out the entire element contents as one atomic unit, not just the bits that were updated. This is useful when only a section's contents are being updated, but you also want the heading to be read out each time something changes, to remind the user of its content.\nThe\naria-relevant\nproperty is useful for controlling what gets read out when a live region is updated. You can for example only get content additions or removals read out.\nEnhancing keyboard accessibility\nAs discussed in a few other places in the module, one of the key strengths of HTML with respect to accessibility is the built-in keyboard accessibility of features such as buttons, form controls, and links. Generally, you can use the tab key to move between controls, the Enter/Return key to select or activate controls, and occasionally other controls as needed (for example the up and down cursor to move between options in a\n<select>\nbox).\nHowever, sometimes you will end up having to write code that either uses non-semantic elements as buttons (or other types of control), or uses focusable controls for not quite the right purpose. You might be trying to fix some bad code you've inherited, or you might be building some kind of complex widget that requires it.\nIn terms of making non-focusable code focusable, WAI-ARIA extends the\ntabindex\nattribute with some new values:\ntabindex=\"0\"\n\u00e2\u0080\u0094 as indicated above, this value allows elements that are not normally tabbable to become tabbable. This is the most useful value of\ntabindex\n.\ntabindex=\"-1\"\n\u00e2\u0080\u0094 this allows not normally tabbable elements to receive focus programmatically, e.g., via JavaScript, or as the target of links.\nWe discussed this in more detail and showed a typical implementation back in our HTML accessibility article \u00e2\u0080\u0094 see\nBuilding keyboard accessibility back in\n.\nAccessibility of non-semantic controls\nThis follows on from the previous section \u00e2\u0080\u0094 when a series of nested\n<div>\ns along with CSS/JavaScript is used to create a complex UI-feature, or a native control is greatly enhanced/changed via JavaScript, not only can keyboard accessibility suffer, but screen reader users will find it difficult to work out what the feature does if there are no semantics or other clues. In such situations, ARIA can help to provide those missing semantics.\nForm validation and error alerts\nFirst of all, let's revisit the form example we first looked at in our CSS and JavaScript accessibility article (read\nKeeping it unobtrusive\nfor a full recap). At the end of this section, we showed that we have included some ARIA attributes on the error message box that displays any validation errors when you try to submit the form:\nhtml\n<div class=\"errors\" role=\"alert\" aria-relevant=\"all\">\n  <ul></ul>\n</div>\nrole=\"alert\"\nautomatically turns the element it is applied to into a live region, so changes to it are read out; it also semantically identifies it as an alert message (important time/context-sensitive information), and represents a better, more accessible way of delivering an alert to a user (modal dialogs like\nalert()\ncalls have a number of accessibility problems; see\nPopup Windows\nby WebAIM).\nAn\naria-relevant\nvalue of\nall\ninstructs the screen reader to read out the contents of the error list when any changes are made to it \u00e2\u0080\u0094 i.e., when errors are added or removed. This is useful because the user will want to know what errors are left, not just what has been added or removed from the list.\nWe could go further with our ARIA usage, and provide some more validation help. How about indicating whether fields are required in the first place, and what range the age should be?\nAt this point, take a copy of our\nform-validation.html\nand\nvalidation.js\nfiles, and save them in a local directory.\nOpen them both in a text editor and have a look at how the code works.\nFirst of all, add a paragraph just above the opening\n<form>\ntag, like the one below, and mark both the form\n<label>\ns with an asterisk. This is normally how we mark required fields for sighted users.\nhtml\n<p>Fields marked with an asterisk (*) are required.</p>\nThis makes visual sense, but it isn't as easy to understand for screen reader users. Fortunately, WAI-ARIA provides the\naria-required\nattribute to give screen readers hints that they should tell users that form inputs need to be filled in. Update the\n<input>\nelements like so:\nhtml\n<input type=\"text\" name=\"name\" id=\"name\" aria-required=\"true\" />\n\n<input type=\"number\" name=\"age\" id=\"age\" aria-required=\"true\" />\nIf you save the example now and test it with a screen reader, you should hear something like \"Enter your name star, required, edit text\".\nIt might also be useful if we give screen reader users and sighted users an idea of what the age value should be. This is often presented as a tooltip or placeholder inside the form field. WAI-ARIA does include\naria-valuemin\nand\naria-valuemax\nproperties to specify min and max values, and screen readers support the native\nmin\nand\nmax\nattributes. Another well-supported feature is the HTML\nplaceholder\nattribute, which can contain a message that is shown in the input when no value is entered and is read out by a few screen readers. Update your number input like this:\nhtml\n<label for=\"age\">Your age:</label>\n<input\n  type=\"number\"\n  name=\"age\"\n  id=\"age\"\n  placeholder=\"Enter 1 to 150\"\n  required\n  aria-required=\"true\" />\nAlways include a\n<label>\nfor every input. While some screen readers announce the placeholder text, most do not. Acceptable substitutions for providing form controls with an accessible name include\naria-label\nand\naria-labelledby\n. But the\n<label>\nelement with a\nfor\nattribute is the preferred method as it provides usability for all users, including mouse users.\nNote:\nYou can see the finished example live at\nform-validation-updated.html\n.\nWAI-ARIA also enables some advanced form labelling techniques, beyond the classic\n<label>\nelement. We already talked about using the\naria-label\nproperty to provide a label where we don't want the label to be visible to sighted users (see the\nSignposts/Landmarks\nsection, above). Some other labeling techniques use other properties such as\naria-labelledby\nif you want to designate a non-\n<label>\nelement as a label or label multiple form inputs with the same label, and\naria-describedby\n, if you want to associate other information with a form input and have it read out as well. See\nWebAIM's Advanced Form Labeling article\nfor more details.\nThere are many other useful properties and states too, for indicating the status of form elements. For example,\naria-disabled=\"true\"\ncan be used to indicate that a form field is disabled. Many browsers will skip past disabled form fields which leads to them not being read out by screen readers. In some cases, a disabled element will be perceived, so it is a good idea to include this attribute to let the screen reader know that a disabled form control is in fact disabled.\nIf the disabled state of an input is likely to change, then it is also a good idea to indicate when it happens, and what the result is. For example, in our\nform-validation-checkbox-disabled.html\ndemo, there is a checkbox that when checked, enables another form input to allow further information to be entered. We've set up a hidden live region:\nhtml\n<p class=\"hidden-alert\" aria-live=\"assertive\"></p>\nwhich is hidden from view using absolute positioning. When this is checked/unchecked, we update the text inside the hidden live region to tell screen reader users what the result of checking this checkbox is, as well as updating the\naria-disabled\nstate, and some visual indicators too:\njs\nfunction toggleMusician(bool) {\n  const instrument = formItems[formItems.length - 1];\n  if (bool) {\n    instrument.input.disabled = false;\n    instrument.label.style.color = \"black\";\n    instrument.input.setAttribute(\"aria-disabled\", \"false\");\n    hiddenAlert.textContent =\n      \"Instruments played field now enabled; use it to tell us what you play.\";\n  } else {\n    instrument.input.disabled = true;\n    instrument.label.style.color = \"#999999\";\n    instrument.input.setAttribute(\"aria-disabled\", \"true\");\n    instrument.input.removeAttribute(\"aria-label\");\n    hiddenAlert.textContent = \"Instruments played field now disabled.\";\n  }\n}\nDescribing non-semantic buttons as buttons\nA few times in this course already, we've mentioned the native accessibility of (and the accessibility issues behind using other elements to fake) buttons, links, or form elements (see\nUse semantic UI controls where possible\nin the HTML accessibility article, and\nEnhancing keyboard accessibility\n, above). Basically, you can add keyboard accessibility back in without too much trouble in many cases, using\ntabindex\nand a bit of JavaScript.\nBut what about screen readers? They still won't see the elements as buttons. If we test our\nfake-div-buttons.html\nexample in a screen reader, our fake buttons will be reported using phrases like \"Click me!, group\", which is obviously confusing.\nWe can fix this using a WAI-ARIA role. Make a local copy of\nfake-div-buttons.html\n, and add\nrole=\"button\"\nto each button\n<div>\n, for example:\nhtml\n<div data-message=\"This is from the first button\" tabindex=\"0\" role=\"button\">\n  Click me!\n</div>\nNow when you try this using a screen reader, you'll have buttons be reported using phrases like \"Click me!, button\". While this is much better, you still have to add in all the native button features users expect, like handling\nenter\nand click events, as explained in the\nbutton\nrole documentation\n.\nNote:\nDon't forget however that using the correct semantic element where possible is always better. If you want to create a button, and can use a\n<button>\nelement, you should use a\n<button>\nelement!\nGuiding users through complex widgets\nThere are a whole host of other\nroles\nthat can identify non-semantic element structures as common UI features that go beyond what's available in standard HTML, for example\ncombobox\n,\nslider\n,\ntabpanel\n,\ntree\n. You can see several useful examples in the\nDeque university code library\nto give you an idea of how such controls can be made accessible.\nYou can also find several live examples in our\nWAI-ARIA roles\ndocumentation. See for example, our\nARIA: tab role example\n, which explains how to implement an accessible tabbed interface.\nSummary\nThis article has by no means covered all that's available in WAI-ARIA, but it should have given you enough information to understand how to use it, and know some of the most common patterns you will encounter that require it.\nIn the next article, we'll give you some tests that you can use to check how well you've understood and retained all this information.\nSee also\nAria states and properties\n: All\naria-*\nattributes\nWAI-ARIA roles\n: Categories of ARIA roles and the roles covered on MDN\nARIA in HTML\non W3C: A specification that defines, for each HTML feature, the accessibility (ARIA) semantics implicitly applied on it by the browser and the WAI-ARIA features you may set on it if extra semantics are required\nDeque university code library\n: A library of really useful and practical examples showing complex UI controls made accessible using WAI-ARIA features\nWAI-ARIA authoring practices\non W3C: A very detailed design pattern from the W3C, explaining how to implement different types of complex UI control whilst making them accessible using WAI-ARIA features\nPrevious\nOverview: Accessibility on the web\nNext\nHelp improve MDN\nLearn how to contribute\nThis page was last modified on\nOct 13, 2025\nby\nMDN contributors\n.\nView this page on GitHub\n\u00e2\u0080\u00a2\nReport a problem with this content",
  "content_markdown": "# WAI-ARIA basics\n\n- [Previous](/en-US/docs/Learn_web_development/Core/Accessibility/Test_your_skills/CSS_and_JavaScript)\n- [Overview: Accessibility on the web](/en-US/docs/Learn_web_development/Core/Accessibility)\n- [Next](/en-US/docs/Learn_web_development/Core/Accessibility/Test_your_skills/WAI-ARIA)\n\nFollowing on from the previous article, sometimes making complex UI controls that involve unsemantic HTML and dynamic JavaScript-updated content can be difficult. WAI-ARIA is a technology that can help with such problems by adding in further semantics that browsers and assistive technologies can recognize and use to let users know what is going on. Here we'll show how to use it at a basic level to improve accessibility.\n\n|  |  |\n| --- | --- |\n| Prerequisites: | Familiarity with [HTML](/en-US/docs/Learn_web_development/Core/Structuring_content), [CSS](/en-US/docs/Learn_web_development/Core/Styling_basics), and accessibility best practices as taught in previous lessons in the module. |\n| Learning outcomes: | - The purpose of WAI-ARIA \u00e2\u0080\u0094 to provide semantics to otherwise non-semantic HTML, so that AT users can make sense of the interfaces being presented to them. - The basic syntax \u00e2\u0080\u0094 roles, properties, and states. - Landmarks and signposting. - Enhancing keyboard accessibility. - Announcing dynamic content updates with live regions. |\n\n## [What is WAI-ARIA?](#what_is_wai-aria)\n\nLet's start by looking at what WAI-ARIA is, and what it can do for us.\n\n### [A whole new set of problems](#a_whole_new_set_of_problems)\n\nAs web apps started to get more complex and dynamic, a new set of accessibility features and problems started to appear.\n\nFor example, HTML introduced a number of semantic elements to define common page features ([`<nav>`](/en-US/docs/Web/HTML/Reference/Elements/nav), [`<footer>`](/en-US/docs/Web/HTML/Reference/Elements/footer), etc.). Before these were available, developers would use [`<div>`](/en-US/docs/Web/HTML/Reference/Elements/div)s with IDs or classes, e.g., `<div class=\"nav\">`, but these were problematic, as there was no easy way to easily find a specific page feature such as the main navigation programmatically.\n\nThe initial solution was to add one or more hidden links at the top of the page to link to the navigation (or whatever else), for example:\n\nhtml\n\n```\n<a href=\"#hidden\" class=\"hidden\">Skip to navigation</a>\n```\n\nBut this is still not very precise, and can only be used when the screen reader is reading from the top of the page.\n\nAs another example, apps started to feature complex controls like date pickers for choosing dates, sliders for choosing values, etc. HTML provides special input types to render such controls:\n\nhtml\n\n```\n<input type=\"date\" /> <input type=\"range\" />\n```\n\nThese were originally not well-supported and it was, and still is to a lesser extent, difficult to style them, leading designers and developers to opt for custom solutions. Instead of using these native features, some developers rely on JavaScript libraries that generate such controls as a series of nested [`<div>`](/en-US/docs/Web/HTML/Reference/Elements/div)s which are then styled using CSS and controlled using JavaScript.\n\nThe problem here is that visually they work, but screen readers can't make any sense of what they are at all, and their users just get told that they can see a jumble of elements with no semantics to describe what they mean.\n\n### [Enter WAI-ARIA](#enter_wai-aria)\n\n[WAI-ARIA](https://w3c.github.io/aria/) (Web Accessibility Initiative - Accessible Rich Internet Applications) is a specification written by the W3C, defining a set of additional HTML attributes that can be applied to elements to provide additional semantics and improve accessibility wherever it is lacking. There are three main features defined in the spec:\n\n[Roles](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles)\n:   These define what an element is or does. Many of these are so-called landmark roles, which largely duplicate the semantic value of structural elements, such as `role=\"navigation\"` ([`<nav>`](/en-US/docs/Web/HTML/Reference/Elements/nav)), `role=\"banner\"` (document [`<header>`](/en-US/docs/Web/HTML/Reference/Elements/header)), `role=\"complementary\"` ([`<aside>`](/en-US/docs/Web/HTML/Reference/Elements/aside)) or , `role=\"search\"` ([`<search>`](/en-US/docs/Web/HTML/Reference/Elements/search)). Some other roles describe different page structures that do not have elements with that match those roles, such as `role=\"tablist\"`, and `role=\"tabpanel\"`, which are commonly found in UIs.\n\n[Properties](#properties)\n:   These define properties of elements, which can be used to give them extra meaning or semantics. As an example, `aria-required=\"true\"` specifies that a form input needs to be filled in order to be valid, whereas `aria-labelledby=\"label\"` allows you to put an ID on an element, then reference it as being the label for anything else on the page, including multiple elements, which is not possible using `<label for=\"input\">`. As an example, you could use `aria-labelledby` to specify that a key description contained in a [`<div>`](/en-US/docs/Web/HTML/Reference/Elements/div) is the label for multiple table cells, or you could use it as an alternative to image alt text \u00e2\u0080\u0094 specify existing information on the page as an image's alt text, rather than having to repeat it inside the `alt` attribute. You can see an example of this at [Text alternatives](/en-US/docs/Learn_web_development/Core/Accessibility/HTML#text_alternatives).\n\n[States](#states)\n:   Special properties that define the current conditions of elements, such as `aria-disabled=\"true\"`, which specifies to a screen reader that a form input is currently disabled. States differ from properties in that properties don't change throughout the lifecycle of an app, whereas states can change, generally programmatically via JavaScript.\n\nAn important point about WAI-ARIA attributes is that they don't affect anything about the web page, except for the information exposed by the browser's accessibility APIs (where screen readers get their information from). WAI-ARIA doesn't affect webpage structure, the DOM, etc., although the attributes can be useful for selecting elements by CSS.\n\n**Note:**\nYou can find a useful list of all the ARIA roles and their uses, with links to further information, in the WAI-ARIA spec \u00e2\u0080\u0094 see [Definition of Roles](https://w3c.github.io/aria/#role_definitions) \u00e2\u0080\u0094 on this site \u00e2\u0080\u0094 see [ARIA roles](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles).\n\nThe spec also contains a list of all the properties and states, with links to further information \u00e2\u0080\u0094 see [Definitions of States and Properties (all `aria-*` attributes)](https://w3c.github.io/aria/#state_prop_def).\n\n## [Where is WAI-ARIA supported?](#where_is_wai-aria_supported)\n\nThis is not an easy question to answer. It is difficult to find a conclusive resource that states what features of WAI-ARIA are supported, and where, because:\n\n1. There are a lot of features in the WAI-ARIA spec.\n2. There are many combinations of operating systems, browsers, and screen readers to consider.\n\nThis last point is key \u00e2\u0080\u0094 To use a screen reader in the first place, your operating system needs to run browsers that have the necessary accessibility APIs in place to expose the information screen readers need to do their job. Most popular OSes have one or two browsers in place that screen readers can work with. The Paciello Group has a fairly up-to-date post that provides data for this \u00e2\u0080\u0094 see [Rough Guide: browsers, operating systems and screen reader support updated](https://www.tpgi.com/rough-guide-browsers-operating-systems-and-screen-reader-support-updated/).\n\nNext, you need to worry about whether the browsers in question support ARIA features and expose them via their APIs, but also whether screen readers recognize that information and present it to their users in a useful way.\n\n1. Browser support is almost universal.\n2. Screen reader support for ARIA features isn't quite at this level, but the most popular screen readers are getting there. You can get an idea of support levels by looking at Powermapper's [WAI-ARIA Screen reader compatibility](https://www.powermapper.com/tests/screen-readers/aria/) article.\n\nIn this article, we won't attempt to cover every WAI-ARIA feature, and its exact support details. Instead, we will cover the most critical WAI-ARIA features for you to know about; if we don't mention any support details, you can assume that the feature is well-supported. We will clearly mention any exceptions to this.\n\n**Note:**\nSome JavaScript libraries support WAI-ARIA, meaning that when they generate UI features like complex form controls, they add ARIA attributes to improve the accessibility of those features. If you are looking for a 3rd party JavaScript solution for rapid UI development, you should definitely consider the accessibility of its UI widgets as an important factor when making your choice. Good examples are jQuery UI (see [About jQuery UI: Deep accessibility support](https://jqueryui.com/about/#deep-accessibility-support)), [ExtJS](https://www.sencha.com/products/extjs/), and [Dojo/Dijit](https://dojotoolkit.org/reference-guide/1.10/dijit/a11y/statement.html).\n\n## [When should you use WAI-ARIA?](#when_should_you_use_wai-aria)\n\nWe talked about some of the problems that prompted WAI-ARIA to be created earlier on, but essentially, there are four main areas that WAI-ARIA is useful in:\n\n[Signposts/Landmarks](#signpostslandmarks_2)\n:   ARIA's [`role`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles) attribute values can act as landmarks that either replicate the semantics of HTML elements (e.g., [`<nav>`](/en-US/docs/Web/HTML/Reference/Elements/nav)), or go beyond HTML semantics to provide signposts to different functional areas, for example, `search`, `tablist`, `tab`, `listbox`, etc.\n\n[Dynamic content updates](#dynamic_content_updates_2)\n:   Screen readers tend to have difficulty with reporting constantly changing content; with ARIA we can use `aria-live` to inform screen reader users when an area of content is updated dynamically: for example, by JavaScript in the page [fetching new content from the server and updating the DOM](/en-US/docs/Learn_web_development/Core/Scripting/Network_requests).\n\n[Enhancing keyboard accessibility](#enhancing_keyboard_accessibility_2)\n:   There are built-in HTML elements that have native keyboard accessibility; when other elements are used along with JavaScript to simulate similar interactions, keyboard accessibility and screen reader reporting suffers as a result. Where this is unavoidable, WAI-ARIA provides a means to allow other elements to receive focus (using `tabindex`).\n\n[Accessibility of non-semantic controls](#accessibility_of_non-semantic_controls_2)\n:   When a series of nested `<div>`s along with CSS/JavaScript is used to create a complex UI-feature, or a native control is greatly enhanced/changed via JavaScript, accessibility can suffer \u00e2\u0080\u0094 screen reader users will find it difficult to work out what the feature does if there are no semantics or other clues. In these situations, ARIA can help to provide what's missing with a combination of roles like `button`, `listbox`, or `tablist`, and properties like `aria-required` or `aria-posinset` to provide further clues as to functionality.\n\nIn the next section, we'll look at the four main areas described earlier in more detail, along with examples. Before you continue, you should put a screen reader testing setup in place, so you can test some of the examples as you go through. See our section on [testing screen readers](/en-US/docs/Learn_web_development/Core/Accessibility/Tooling#screen_readers) for more information.\n\n**You should only use WAI-ARIA when you need to!**\n\nUsing the correct HTML elements implicitly gives you the roles that are needed and you should *always* use [native HTML features](/en-US/docs/Learn_web_development/Core/Accessibility/HTML) to provide the semantics required by screen readers to tell their users what is going on. Sometimes this isn't possible, either because you have limited control over the code, or because you are creating something complex that doesn't have an easy HTML element to implement it. In such cases, WAI-ARIA can be a valuable accessibility enhancing tool.\n\nBut again, only use it when necessary!\n\nAlso, try to make sure you test your site with a variety of *real* users \u00e2\u0080\u0094 non-disabled people, people using screen readers, people using keyboard navigation, etc. They will have better insights than you about how well it works.\n\n## [Signposts/Landmarks](#signpostslandmarks)\n\nWAI-ARIA adds the [`role` attribute](https://w3c.github.io/aria/#role_definitions) to browsers, which allows you to add extra semantic value to elements on your site wherever they are needed. The first major area in which this is useful is providing information for screen readers so that their users can find common page elements. This example has the following structure:\n\nhtml\n\n```\n<header>\n  <h1>Header</h1>\n\n  <!-- Even is it's not mandatory, it's common practice to put the main navigation menu within the main header -->\n\n  <nav>\n    <ul>\n      <li><a href=\"#\">Home</a></li>\n      <li><a href=\"#\">Team</a></li>\n      <li><a href=\"#\">Projects</a></li>\n      <li><a href=\"#\">Contact</a></li>\n    </ul>\n\n    <!-- A Search form is another common non-linear way to navigate through a website. -->\n\n    <form>\n      <input type=\"search\" name=\"q\" placeholder=\"Search query\" />\n      <input type=\"submit\" value=\"Go!\" />\n    </form>\n  </nav>\n</header>\n\n<!-- Here is our page's main content -->\n<main>\n  <!-- It contains an article -->\n  <article>\n    <h2>Article heading</h2>\n\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam\n      lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra\n      nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam\n      eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue\n      enim, ut porta lorem lacinia consectetur.\n    </p>\n\n    <h3>subsection</h3>\n\n    <p>\n      Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum\n      dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut\n      turpis felis, pulvinar a semper sed, adipiscing id dolor.\n    </p>\n  </article>\n\n  <!-- the aside content can also be nested within the main content -->\n  <aside>\n    <h2>Related</h2>\n\n    <ul>\n      <li><a href=\"#\">Oh I do like to be beside the seaside</a></li>\n      <li><a href=\"#\">Oh I do like to be beside the sea</a></li>\n      <li><a href=\"#\">Although in the North of England</a></li>\n      <li><a href=\"#\">It never stops raining</a></li>\n      <li><a href=\"#\">Oh well...</a></li>\n    </ul>\n  </aside>\n</main>\n\n<!-- And here is our main footer that is used across all the pages of our website -->\n\n<footer>\n  <p>\u00c2\u00a9Copyright 2050 by nobody. All rights reversed.</p>\n</footer>\n```\n\n```\n/* || General setup */\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 10px;\n  background-color: darkgrey;\n}\n\nbody {\n  width: max(70vw, 90%);\n  margin: 0 auto;\n  padding: 0 10px;\n  display: flex;\n  flex-direction: column;\n}\n\n/* || typography */\n\nh1,\nh2,\nh3 {\n  font-family: \"Sonsie One\", cursive;\n  color: #2a2a2a;\n}\n\np,\ninput,\nli {\n  font-family: \"Open Sans Condensed\", sans-serif;\n  color: #2a2a2a;\n}\n\nh1 {\n  font-size: 4rem;\n  text-align: center;\n  color: white;\n  text-shadow: 2px 2px 10px black;\n}\n\nh2 {\n  font-size: 3rem;\n  text-align: center;\n}\n\nh3 {\n  font-size: 2.2rem;\n}\n\np,\nli {\n  font-size: 1.6rem;\n  line-height: 1.5;\n}\n\n/* || header layout */\n\nheader {\n  margin-bottom: 10px;\n}\n\nnav,\narticle,\naside,\nfooter {\n  background-color: white;\n  padding: 1%;\n}\n\nnav {\n  background-color: #ff80ff;\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\nnav ul {\n  padding: 0;\n  list-style-type: none;\n  flex: 2;\n  display: flex;\n  gap: 2vw;\n}\n\nnav li {\n  display: inline;\n  text-align: center;\n}\n\nnav a {\n  display: inline-block;\n  font-size: 2rem;\n  text-transform: uppercase;\n  text-decoration: none;\n  color: black;\n}\n\nnav form {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\ninput {\n  font-size: 1.6rem;\n  height: 32px;\n}\n\ninput[type=\"search\"] {\n  flex: 3;\n}\n\ninput[type=\"submit\"] {\n  flex: 1;\n  margin-left: 1rem;\n  background: #333333;\n  border: 0;\n  color: white;\n}\n\n/* || main layout */\n\nmain {\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\narticle {\n  flex: 4;\n}\n\naside {\n  flex: 1;\n  background-color: #ff80ff;\n}\n\naside li {\n  padding-bottom: 10px;\n}\n\nfooter {\n  margin-top: 10px;\n}\n```\n\nIf you try testing the example with a screen reader in a modern browser, you'll already get some useful information. For example, VoiceOver gives you the following:\n\n- On the `<header>` element \u00e2\u0080\u0094 \"banner, 2 items\" (it contains a heading and the `<nav>`).\n- On the `<nav>` element \u00e2\u0080\u0094 \"navigation 2 items\" (it contains a list and a form).\n- On the `<main>` element \u00e2\u0080\u0094 \"main 2 items\" (it contains an article and an aside).\n- On the `<aside>` element \u00e2\u0080\u0094 \"complementary 2 items\" (it contains a heading and a list).\n- On the search form input \u00e2\u0080\u0094 \"Search query, insertion at beginning of text\".\n- On the `<footer>` element \u00e2\u0080\u0094 \"footer 1 item\".\n\nIf you go to VoiceOver's landmarks menu (accessed using VoiceOver key + U and then using the cursor keys to cycle through the menu choices), you'll see that most of the elements are nicely listed so they can be accessed quickly.\n\n![Mac's VoiceOver menu for quick accessibility. Landmarks header and landmarks list including banner, navigation, main, and complementary.](/en-US/docs/Learn_web_development/Core/Accessibility/WAI-ARIA_basics/landmarks-list.png)\n\nHowever, we could do better here. The search form is a really important landmark that people will want to find, but it is not listed in the landmarks menu or treated like a notable landmark beyond the actual input being called out as a search input (`<input type=\"search\">`).\n\nTo mark the form as a landmark, you can either wrap it with the [`<search>`](/en-US/docs/Web/HTML/Reference/Elements/search) element or give it ARIA `role=\"search\"`. As a general rule, use HTML semantics where possible and only use ARIA where there is no HTML equivalent.\n\nhtml\n\n```\n<header>\n  <h1>Header</h1>\n\n  <!-- Even is it's not mandatory, it's common practice to put the main navigation menu within the main header -->\n\n  <nav>\n    <ul>\n      <li><a href=\"#\">Home</a></li>\n      <li><a href=\"#\">Our team</a></li>\n      <li><a href=\"#\">Projects</a></li>\n      <li><a href=\"#\">Contact</a></li>\n    </ul>\n\n    <!-- A Search form is another common non-linear way to navigate through a website. -->\n\n    <search>\n      <form>\n        <input\n          type=\"search\"\n          name=\"q\"\n          placeholder=\"Search query\"\n          aria-label=\"Search through site content\" />\n        <input type=\"submit\" value=\"Go!\" />\n      </form>\n    </search>\n  </nav>\n</header>\n\n<!-- Here is our page's main content -->\n<main>\n  <!-- It contains an article -->\n  <article>\n    <h2>Article heading</h2>\n\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam\n      lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra\n      nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam\n      eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue\n      enim, ut porta lorem lacinia consectetur.\n    </p>\n\n    <h3>subsection</h3>\n\n    <p>\n      Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum\n      dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut\n      turpis felis, pulvinar a semper sed, adipiscing id dolor.\n    </p>\n\n    <p>\n      Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus,\n      enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis\n      libero in urna ultrices accumsan. Donec sed odio eros.\n    </p>\n  </article>\n\n  <!-- the aside content can also be nested within the main content -->\n  <aside>\n    <h2>Related</h2>\n    <ul>\n      <li><a href=\"#\">Oh I do like to be beside the seaside</a></li>\n      <li><a href=\"#\">Oh I do like to be beside the sea</a></li>\n      <li><a href=\"#\">Although in the North of England</a></li>\n      <li><a href=\"#\">It never stops raining</a></li>\n      <li><a href=\"#\">Oh well...</a></li>\n    </ul>\n  </aside>\n</main>\n\n<!-- And here is our main footer that is used across all the pages of our website -->\n\n<footer>\n  <p>\u00c2\u00a9Copyright 2050 by nobody. All rights reversed.</p>\n</footer>\n```\n\n```\n/* || General setup */\n\nhtml,\nbody {\n  margin: 0;\n  padding: 0;\n}\n\nhtml {\n  font-size: 10px;\n  background-color: darkgrey;\n}\n\nbody {\n  width: max(70vw, 90%);\n  margin: 0 auto;\n  padding: 0 10px;\n  display: flex;\n  flex-direction: column;\n}\n\n/* || typography */\n\nh1,\nh2,\nh3 {\n  font-family: \"Sonsie One\", cursive;\n  color: #2a2a2a;\n}\n\np,\ninput,\nli {\n  font-family: \"Open Sans Condensed\", sans-serif;\n  color: #2a2a2a;\n}\n\nh1 {\n  font-size: 4rem;\n  text-align: center;\n  color: white;\n  text-shadow: 2px 2px 10px black;\n}\n\nh2 {\n  font-size: 3rem;\n  text-align: center;\n}\n\nh3 {\n  font-size: 2.2rem;\n}\n\np,\nli {\n  font-size: 1.6rem;\n  line-height: 1.5;\n}\n\n/* || header layout */\n\nheader {\n  margin-bottom: 10px;\n}\n\nnav,\narticle,\naside,\nfooter {\n  background-color: white;\n  padding: 1%;\n}\n\nnav {\n  background-color: #ff80ff;\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\nnav ul {\n  padding: 0;\n  list-style-type: none;\n  flex: 2;\n  display: flex;\n  gap: 2vw;\n}\n\nnav li {\n  display: inline;\n  text-align: center;\n}\n\nnav a {\n  display: inline-block;\n  font-size: 2rem;\n  text-transform: uppercase;\n  text-decoration: none;\n  color: black;\n}\n\nnav form {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  height: 100%;\n}\n\ninput {\n  font-size: 1.6rem;\n  height: 32px;\n}\n\ninput[type=\"search\"] {\n  flex: 3;\n}\n\ninput[type=\"submit\"] {\n  flex: 1;\n  margin-left: 1rem;\n  background: #333333;\n  border: 0;\n  color: white;\n}\n\n/* || main layout */\n\nmain {\n  display: flex;\n  gap: 2vw;\n  @media (width <= 650px) {\n    flex-direction: column;\n  }\n}\n\narticle {\n  flex: 4;\n}\n\naside {\n  flex: 1;\n  background-color: #ff80ff;\n}\n\naside li {\n  padding-bottom: 10px;\n}\n\nfooter {\n  margin-top: 10px;\n}\n```\n\nMost importantly, we have used semantic HTML that gives meaning and roles to the structure of the page without adding unnecessary [`role`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles) attributes to our HTML structure, which has a structure like this:\n\nhtml\n\n```\n<header>\n  <h1>\u00e2\u0080\u00a6</h1>\n  <nav>\n    <ul>\n      \u00e2\u0080\u00a6\n    </ul>\n    <search>\n      <form>\n        <!-- search form -->\n      </form>\n    </search>\n  </nav>\n</header>\n\n<main>\n  <article>\u00e2\u0080\u00a6</article>\n  <aside>\u00e2\u0080\u00a6</aside>\n</main>\n\n<footer>\u00e2\u0080\u00a6</footer>\n```\n\nWe've also given you a bonus feature in this example \u00e2\u0080\u0094 the [`<input>`](/en-US/docs/Web/HTML/Reference/Elements/input) element has been given the attribute [`aria-label`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label), which gives it a descriptive label to be read out by a screen reader, even though we haven't included a [`<label>`](/en-US/docs/Web/HTML/Reference/Elements/label) element. In cases like these, this is very useful \u00e2\u0080\u0094 a search form like this one is a very common, easily recognized feature, and adding a visual label would spoil the page design.\n\nhtml\n\n```\n<input\n  type=\"search\"\n  name=\"q\"\n  placeholder=\"Search query\"\n  aria-label=\"Search through site content\" />\n```\n\nNow if we use VoiceOver to look at this example, we get some improvements:\n\n- The search form is called out as a separate item, both when browsing through the page, and in the Landmarks menu.\n- The label text contained in the `aria-label` attribute is read out when the form input is highlighted.\n\nIf you need to support older browsers such as IE8; it is worth including ARIA roles for that purpose. And if for some reason your site is built using just `<div>`s, you should definitely include the ARIA roles to provide these much needed semantics!\n\nYou'll see a lot more about these semantics and the power of ARIA properties/attributes below, especially in the [Accessibility of non-semantic controls](#accessibility_of_non-semantic_controls) section. For now though, let's look at how ARIA can help with dynamic content updates.\n\n## [Dynamic content updates](#dynamic_content_updates)\n\nContent loaded into the DOM can be easily accessed using a screen reader, from textual content to alternative text attached to images. Traditional static websites with largely text content are therefore easy to make accessible for people with visual impairments.\n\nThe problem is that modern web apps are often not just static text \u00e2\u0080\u0094 they often update parts of the page by fetching new content from the server (in this example we are using a static array of quotes) and updating the DOM. These are sometimes referred to as **live regions**.\n\nLet's look at an example \u00e2\u0080\u0094 a random quote generator:\n\nhtml\n\n```\n<section>\n  <h1>Random quote generator</h1>\n  <button>Start giving me quotes</button>\n  <blockquote>\n    <p></p>\n  </blockquote>\n</section>\n```\n\n```\n* {\n  box-sizing: border-box;\n}\n\nhtml {\n  font-family: sans-serif;\n}\n\nhtml,\nbody {\n  height: 100%;\n}\n\nh1 {\n  letter-spacing: 2px;\n}\n\np {\n  line-height: 1.6;\n}\n\nsection {\n  height: 100%;\n  padding: 10px;\n  background: #666666;\n  text-shadow: 1px 1px 1px black;\n  color: white;\n}\n```\n\njs\n\n```\nlet quotes = [\n  {\n    quote:\n      \"Every child is an artist. The problem is how to remain an artist once he grows up.\",\n    author: \"Pablo Picasso\",\n  },\n  {\n    quote:\n      \"You can never cross the ocean until you have the courage to lose sight of the shore.\",\n    author: \"Christopher Columbus\",\n  },\n  {\n    quote:\n      \"I love deadlines. I love the whooshing noise they make as they go by.\",\n    author: \"Douglas Adams\",\n  },\n];\n```\n\njs\n\n```\nconst quotePara = document.querySelector(\"section p\");\nconst btn = document.querySelector(\"button\");\n\nbtn.addEventListener(\"click\", () => {\n  function showQuote() {\n    let random = Math.floor(Math.random() * quotes.length);\n    quotePara.textContent = `${quotes[random].quote} -- ${quotes[random].author}`;\n  }\n\n  showQuote();\n  btn.disabled = true;\n  window.setInterval(showQuote, 5000);\n});\n```\n\nThis works OK, but it is not good for accessibility \u00e2\u0080\u0094 the content update is not detected by screen readers, so their users would not know what is going on. This is a fairly trivial example, but just imagine if you were creating a complex UI with lots of constantly updating content, like a chat room, or a strategy game UI, or a live updating shopping cart display \u00e2\u0080\u0094 it would be impossible to use the app in any effective way without some kind of way of alerting the user to the updates.\n\nWAI-ARIA, fortunately, provides a useful mechanism to provide these alerts \u00e2\u0080\u0094 the [`aria-live`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-live) property. Applying this to an element causes screen readers to read out the content that is updated. How urgently the content is read out depends on the attribute value:\n\n[`off`](#off)\n:   The default. Updates should not be announced.\n\n[`polite`](#polite)\n:   Updates should be announced only if the user is idle.\n\n[`assertive`](#assertive)\n:   Updates should be announced to the user as soon as possible.\n\nHere we update the `<blockquote>` opening tag as follows:\n\nhtml\n\n```\n<blockquote aria-live=\"assertive\">\u00e2\u0080\u00a6</blockquote>\n```\n\nThis will cause a screen reader to read out the content as it is updated: try testing the updated the updated live version:\n\n```\n<section>\n  <h1>Random quote generator</h1>\n  <button>Start giving me quotes</button>\n  <blockquote aria-live=\"assertive\">\n    <p></p>\n  </blockquote>\n</section>\n```\n\n**Note:**\nThere are some other ARIA properties related to `aria-live` that are also worth knowing about:\n\n- The [`aria-atomic`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-atomic) property, when set to `true`, tells screen readers to read out the entire element contents as one atomic unit, not just the bits that were updated. This is useful when only a section's contents are being updated, but you also want the heading to be read out each time something changes, to remind the user of its content.\n- The [`aria-relevant`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-relevant) property is useful for controlling what gets read out when a live region is updated. You can for example only get content additions or removals read out.\n\n## [Enhancing keyboard accessibility](#enhancing_keyboard_accessibility)\n\nAs discussed in a few other places in the module, one of the key strengths of HTML with respect to accessibility is the built-in keyboard accessibility of features such as buttons, form controls, and links. Generally, you can use the tab key to move between controls, the Enter/Return key to select or activate controls, and occasionally other controls as needed (for example the up and down cursor to move between options in a `<select>` box).\n\nHowever, sometimes you will end up having to write code that either uses non-semantic elements as buttons (or other types of control), or uses focusable controls for not quite the right purpose. You might be trying to fix some bad code you've inherited, or you might be building some kind of complex widget that requires it.\n\nIn terms of making non-focusable code focusable, WAI-ARIA extends the `tabindex` attribute with some new values:\n\n- `tabindex=\"0\"` \u00e2\u0080\u0094 as indicated above, this value allows elements that are not normally tabbable to become tabbable. This is the most useful value of `tabindex`.\n- `tabindex=\"-1\"` \u00e2\u0080\u0094 this allows not normally tabbable elements to receive focus programmatically, e.g., via JavaScript, or as the target of links.\n\nWe discussed this in more detail and showed a typical implementation back in our HTML accessibility article \u00e2\u0080\u0094 see [Building keyboard accessibility back in](/en-US/docs/Learn_web_development/Core/Accessibility/HTML#building_keyboard_accessibility_back_in).\n\n## [Accessibility of non-semantic controls](#accessibility_of_non-semantic_controls)\n\nThis follows on from the previous section \u00e2\u0080\u0094 when a series of nested `<div>`s along with CSS/JavaScript is used to create a complex UI-feature, or a native control is greatly enhanced/changed via JavaScript, not only can keyboard accessibility suffer, but screen reader users will find it difficult to work out what the feature does if there are no semantics or other clues. In such situations, ARIA can help to provide those missing semantics.\n\n### [Form validation and error alerts](#form_validation_and_error_alerts)\n\nFirst of all, let's revisit the form example we first looked at in our CSS and JavaScript accessibility article (read [Keeping it unobtrusive](/en-US/docs/Learn_web_development/Core/Accessibility/CSS_and_JavaScript#keeping_it_unobtrusive) for a full recap). At the end of this section, we showed that we have included some ARIA attributes on the error message box that displays any validation errors when you try to submit the form:\n\nhtml\n\n```\n<div class=\"errors\" role=\"alert\" aria-relevant=\"all\">\n  <ul></ul>\n</div>\n```\n\n- [`role=\"alert\"`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/alert_role) automatically turns the element it is applied to into a live region, so changes to it are read out; it also semantically identifies it as an alert message (important time/context-sensitive information), and represents a better, more accessible way of delivering an alert to a user (modal dialogs like [`alert()`](/en-US/docs/Web/API/Window/alert) calls have a number of accessibility problems; see [Popup Windows](https://webaim.org/techniques/javascript/other#popups) by WebAIM).\n- An [`aria-relevant`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-relevant) value of `all` instructs the screen reader to read out the contents of the error list when any changes are made to it \u00e2\u0080\u0094 i.e., when errors are added or removed. This is useful because the user will want to know what errors are left, not just what has been added or removed from the list.\n\nWe could go further with our ARIA usage, and provide some more validation help. How about indicating whether fields are required in the first place, and what range the age should be?\n\n1. At this point, take a copy of our [`form-validation.html`](https://github.com/mdn/learning-area/blob/main/accessibility/css/form-validation.html) and [`validation.js`](https://github.com/mdn/learning-area/blob/main/accessibility/css/validation.js) files, and save them in a local directory.\n2. Open them both in a text editor and have a look at how the code works.\n3. First of all, add a paragraph just above the opening `<form>` tag, like the one below, and mark both the form `<label>`s with an asterisk. This is normally how we mark required fields for sighted users.\n\n   html\n\n   ```\n   <p>Fields marked with an asterisk (*) are required.</p>\n   ```\n4. This makes visual sense, but it isn't as easy to understand for screen reader users. Fortunately, WAI-ARIA provides the [`aria-required`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-required) attribute to give screen readers hints that they should tell users that form inputs need to be filled in. Update the `<input>` elements like so:\n\n   html\n\n   ```\n   <input type=\"text\" name=\"name\" id=\"name\" aria-required=\"true\" />\n\n   <input type=\"number\" name=\"age\" id=\"age\" aria-required=\"true\" />\n   ```\n5. If you save the example now and test it with a screen reader, you should hear something like \"Enter your name star, required, edit text\".\n6. It might also be useful if we give screen reader users and sighted users an idea of what the age value should be. This is often presented as a tooltip or placeholder inside the form field. WAI-ARIA does include [`aria-valuemin`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-valuemin) and [`aria-valuemax`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-valuemax) properties to specify min and max values, and screen readers support the native `min` and `max` attributes. Another well-supported feature is the HTML `placeholder` attribute, which can contain a message that is shown in the input when no value is entered and is read out by a few screen readers. Update your number input like this:\n\n   html\n\n   ```\n   <label for=\"age\">Your age:</label>\n   <input\n     type=\"number\"\n     name=\"age\"\n     id=\"age\"\n     placeholder=\"Enter 1 to 150\"\n     required\n     aria-required=\"true\" />\n   ```\n\nAlways include a [`<label>`](/en-US/docs/Web/HTML/Reference/Elements/label) for every input. While some screen readers announce the placeholder text, most do not. Acceptable substitutions for providing form controls with an accessible name include [`aria-label`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) and [`aria-labelledby`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-labelledby). But the `<label>` element with a `for` attribute is the preferred method as it provides usability for all users, including mouse users.\n\n**Note:**\nYou can see the finished example live at [`form-validation-updated.html`](https://mdn.github.io/learning-area/accessibility/aria/form-validation-updated.html).\n\nWAI-ARIA also enables some advanced form labelling techniques, beyond the classic [`<label>`](/en-US/docs/Web/HTML/Reference/Elements/label) element. We already talked about using the [`aria-label`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) property to provide a label where we don't want the label to be visible to sighted users (see the [Signposts/Landmarks](#signpostslandmarks) section, above). Some other labeling techniques use other properties such as [`aria-labelledby`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-labelledby) if you want to designate a non-`<label>` element as a label or label multiple form inputs with the same label, and [`aria-describedby`](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-describedby), if you want to associate other information with a form input and have it read out as well. See [WebAIM's Advanced Form Labeling article](https://webaim.org/techniques/forms/advanced) for more details.\n\nThere are many other useful properties and states too, for indicating the status of form elements. For example, `aria-disabled=\"true\"` can be used to indicate that a form field is disabled. Many browsers will skip past disabled form fields which leads to them not being read out by screen readers. In some cases, a disabled element will be perceived, so it is a good idea to include this attribute to let the screen reader know that a disabled form control is in fact disabled.\n\nIf the disabled state of an input is likely to change, then it is also a good idea to indicate when it happens, and what the result is. For example, in our [`form-validation-checkbox-disabled.html`](https://mdn.github.io/learning-area/accessibility/aria/form-validation-checkbox-disabled.html) demo, there is a checkbox that when checked, enables another form input to allow further information to be entered. We've set up a hidden live region:\n\nhtml\n\n```\n<p class=\"hidden-alert\" aria-live=\"assertive\"></p>\n```\n\nwhich is hidden from view using absolute positioning. When this is checked/unchecked, we update the text inside the hidden live region to tell screen reader users what the result of checking this checkbox is, as well as updating the `aria-disabled` state, and some visual indicators too:\n\njs\n\n```\nfunction toggleMusician(bool) {\n  const instrument = formItems[formItems.length - 1];\n  if (bool) {\n    instrument.input.disabled = false;\n    instrument.label.style.color = \"black\";\n    instrument.input.setAttribute(\"aria-disabled\", \"false\");\n    hiddenAlert.textContent =\n      \"Instruments played field now enabled; use it to tell us what you play.\";\n  } else {\n    instrument.input.disabled = true;\n    instrument.label.style.color = \"#999999\";\n    instrument.input.setAttribute(\"aria-disabled\", \"true\");\n    instrument.input.removeAttribute(\"aria-label\");\n    hiddenAlert.textContent = \"Instruments played field now disabled.\";\n  }\n}\n```\n\n### [Describing non-semantic buttons as buttons](#describing_non-semantic_buttons_as_buttons)\n\nA few times in this course already, we've mentioned the native accessibility of (and the accessibility issues behind using other elements to fake) buttons, links, or form elements (see [Use semantic UI controls where possible](/en-US/docs/Learn_web_development/Core/Accessibility/HTML#use_semantic_ui_controls_where_possible) in the HTML accessibility article, and [Enhancing keyboard accessibility](#enhancing_keyboard_accessibility), above). Basically, you can add keyboard accessibility back in without too much trouble in many cases, using `tabindex` and a bit of JavaScript.\n\nBut what about screen readers? They still won't see the elements as buttons. If we test our [`fake-div-buttons.html`](https://mdn.github.io/learning-area/tools-testing/cross-browser-testing/accessibility/fake-div-buttons.html) example in a screen reader, our fake buttons will be reported using phrases like \"Click me!, group\", which is obviously confusing.\n\nWe can fix this using a WAI-ARIA role. Make a local copy of [`fake-div-buttons.html`](https://github.com/mdn/learning-area/blob/main/tools-testing/cross-browser-testing/accessibility/fake-div-buttons.html), and add [`role=\"button\"`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/button_role) to each button `<div>`, for example:\n\nhtml\n\n```\n<div data-message=\"This is from the first button\" tabindex=\"0\" role=\"button\">\n  Click me!\n</div>\n```\n\nNow when you try this using a screen reader, you'll have buttons be reported using phrases like \"Click me!, button\". While this is much better, you still have to add in all the native button features users expect, like handling `enter` and click events, as explained in the [`button` role documentation](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/button_role).\n\n**Note:**\nDon't forget however that using the correct semantic element where possible is always better. If you want to create a button, and can use a [`<button>`](/en-US/docs/Web/HTML/Reference/Elements/button) element, you should use a [`<button>`](/en-US/docs/Web/HTML/Reference/Elements/button) element!\n\n### [Guiding users through complex widgets](#guiding_users_through_complex_widgets)\n\nThere are a whole host of other [roles](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles) that can identify non-semantic element structures as common UI features that go beyond what's available in standard HTML, for example [`combobox`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/combobox_role), [`slider`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/slider_role), [`tabpanel`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/tabpanel_role), [`tree`](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/tree_role). You can see several useful examples in the [Deque university code library](https://dequeuniversity.com/library/) to give you an idea of how such controls can be made accessible.\n\nYou can also find several live examples in our [WAI-ARIA roles](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles) documentation. See for example, our [ARIA: tab role example](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles/tab_role#example), which explains how to implement an accessible tabbed interface.\n\n## [Summary](#summary)\n\nThis article has by no means covered all that's available in WAI-ARIA, but it should have given you enough information to understand how to use it, and know some of the most common patterns you will encounter that require it.\n\nIn the next article, we'll give you some tests that you can use to check how well you've understood and retained all this information.\n\n## [See also](#see_also)\n\n- [Aria states and properties](/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes): All `aria-*` attributes\n- [WAI-ARIA roles](/en-US/docs/Web/Accessibility/ARIA/Reference/Roles): Categories of ARIA roles and the roles covered on MDN\n- [ARIA in HTML](https://w3c.github.io/html-aria/) on W3C: A specification that defines, for each HTML feature, the accessibility (ARIA) semantics implicitly applied on it by the browser and the WAI-ARIA features you may set on it if extra semantics are required\n- [Deque university code library](https://dequeuniversity.com/library/): A library of really useful and practical examples showing complex UI controls made accessible using WAI-ARIA features\n- [WAI-ARIA authoring practices](https://www.w3.org/WAI/ARIA/apg/) on W3C: A very detailed design pattern from the W3C, explaining how to implement different types of complex UI control whilst making them accessible using WAI-ARIA features\n\n- [Previous](/en-US/docs/Learn_web_development/Core/Accessibility/Test_your_skills/CSS_and_JavaScript)\n- [Overview: Accessibility on the web](/en-US/docs/Learn_web_development/Core/Accessibility)\n- [Next](/en-US/docs/Learn_web_development/Core/Accessibility/Test_your_skills/WAI-ARIA)\n\n## Help improve MDN\n\nWas this page helpful to you?\n\nYes\n\nNo\n\n[Learn how to contribute](/en-US/docs/MDN/Community/Getting_started)\n\nThis page was last modified on Oct 13, 2025 by [MDN contributors](/en-US/docs/Learn_web_development/Core/Accessibility/WAI-ARIA_basics/contributors.txt).\n\n[View this page on GitHub](https://github.com/mdn/content/blob/main/files/en-us/learn_web_development/core/accessibility/wai-aria_basics/index.md?plain=1 \"Folder: en-us/learn_web_development/core/accessibility/wai-aria_basics (Opens in a new tab)\") \u00e2\u0080\u00a2 [Report a problem with this content](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn_web_development%2FCore%2FAccessibility%2FWAI-ARIA_basics&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Flearn_web_development%2Fcore%2Faccessibility%2Fwai-aria_basics%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn_web_development%2FCore%2FAccessibility%2FWAI-ARIA_basics%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Flearn_web_development%2Fcore%2Faccessibility%2Fwai-aria_basics%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F6193c69cb71e80e45e7dff97188253ed15d58321%0A*+Document+last+modified%3A+2025-10-13T22%3A38%3A35.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\")",
  "tags": [
    "mdn",
    "aria",
    "reference",
    "mozilla"
  ],
  "extracted_at": "2026-02-03T12:33:40.373894+00:00",
  "content_length": 36455,
  "content_hash": "edb91546593f5b07"
}