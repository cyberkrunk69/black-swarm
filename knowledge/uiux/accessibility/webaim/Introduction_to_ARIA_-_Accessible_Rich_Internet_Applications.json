{
  "id": "webaim__techniques_aria_",
  "source_id": "webaim",
  "source_name": "WebAIM Accessibility Resources",
  "category": "accessibility",
  "url": "https://webaim.org/techniques/aria/",
  "title": "Introduction to ARIA - Accessible Rich Internet Applications",
  "content": "Introduction to ARIA - Accessible Rich Internet Applications\nYou are here:\nHome\n>\nArticles\n> Introduction to ARIA\nIntroduction to ARIA\nWAI-ARIA (Accessible Rich Internet Applications or ARIA) is\na W3C specification\nfor enhancing accessibility in ways that plain HTML cannot. When used properly, ARIA can...\nenhance accessibility of interactive controls, such as tree menus, sliders, pop-ups, etc.\ndefine helpful landmarks for page structure\ndefine dynamically-updated \"live regions\"\nimprove keyboard accessibility and interactivity\nand much more\nHTML has a defined\u2014but evolving\u2014vocabulary. For example,\n<blink>\nhas been removed while\n<main>\nhas been added.\nARIA provides new code attributes and values that expand the vocabulary and semantics of HTML for enhanced screen reader accessibility.\nLike HTML, ARIA evolves over time, and is generally well supported in modern browsers and screen readers. Many scripting libraries also support ARIA.\nRules of ARIA Use\nThe ARIA specification defines\nfive rules of ARIA use\nto support optimal accessibility. Summaries of these rules are below.\nRule #1 - If you can use HTML a native HTML element or attribute, then do so.\nHTML is the foundation of web accessibility.\nARIA should not be used when HTML provides sufficient semantics for accessibility! When used incorrectly, ARIA can introduce significant accessibility barriers.\nRule #2 - Do not change native semantics, unless you really have to.\nMost HTML elements have default semantics or meaning that can be conveyed to screen reader users. When necessary, ARIA can override and change those semantics.\nA\n<ul>\nelement, for example, defines an unordered list. When encountered by a screen reader, it is identified as an unordered list. Screen readers also announce the number of list items, enable list item navigation, and much more. If an ARIA\nrole\nis added to the\n<ul>\n\u2014for example, \u2014\n<ul role=\"navigation\">\n\u2014then the list semantics are overridden and lost. The element now becomes a navigation landmark (see below) and the accessibility benefits of the unordered list are gone. Instead,\n<div role=\"navigation\"><ul>...</ul></div>\nprovides the benefits of the navigation landmark AND the benefits of the unordered list. (Better yet,\n<nav><ul>...</ul></nav>\nis semantically equivalent without relying on ARIA at all.)\nRule #3 - All interactive ARIA controls must be usable with the keyboard.\nThe\nARIA Design Patterns\ndefine standard keyboard interactions for ARIA widgets and controls. This allows everyone to use the widget using the keyboard, and ensures that instructions provided by screen readers align with the actual functionality in the page.\nRule #4 - Interactive controls must have proper semantics and cannot be hidden\nAny element that is keyboard focusable (primarily using the\nTab\nkey),\nmust\nhave proper semantics so that it will be identified as a link, button, form control, etc., or other element with an appropriate\nrole\nvalue. Since\nrole=\"presentation\"\nremoves semantics, it must never be applied to a focusable element.\nSimilarly, interactive elements must be visible. Do not hide focused elements with CSS or with\naria-hidden=\"true\"\n.\nRule #5 - All interactive elements must have an accessible name\nText that describes an interactive control must be presented to screen reader users when the control is encountered. A button must have descriptive text (such as \"Register\") and a text input must have a descriptive label (such as \"First Name\"). The content that screen readers announce to identify a control is called its\n\"accessible name\"\n. ARIA can also be used to define accessible names.\nCore Components\nThe three main components of ARIA are\nroles\n,\nproperties\n, and\nstates\n.\nRoles\nRoles define what an element is or does. Most HTML elements have a default role that is presented to assistive technology. For example,\n<button>\nhas a default role of \"button\" and\n<form>\nhas a default role of \"form\". ARIA can define roles that are not available in HTML, and can also override the default roles of HTML elements (see Rule #2 above).\nAn example of an ARIA role is\n<form role=\"search\">\n. In HTML, all forms have the same semantics. But with ARIA, you can define the semantics of a particular form as being a search form.\nDefault HTML roles should not be duplicated using ARIA\u2014avoid things like\n<button role=\"button\">\n.\nARIA does not change browser behavior or appearance.\nAdding\nrole=\"button\"\nto a\n<div>\n, for example, will not make the\n<div>\nfunction like or appear like a button. However, this will cause screen readers to announce it as a button even though it cannot be navigated to or activated using the keyboard. Authors must implement\nappropriate design and interaction patterns\n, typically via JavaScript and CSS, along with ARIA.\nProperties\nARIA properties define additional semantics not supported in standard HTML. An example is\n<button aria-haspopup=\"true\">\n. This property extends the standard button to cause a screen reader to announce that the button, if activated, will trigger a pop-up.\nStates\nARIA states are attributes that define the current condition of an element. They generally change based on user interaction or some dynamic variable. An example is\n<input aria-invalid=\"true\">\n. This property will cause a screen reader to read this input as currently being invalid (meaning it needs to be corrected), but this state value could easily be changed to\nfalse\ndynamically based on user input.\nARIA roles, states, and properties can be defined in markup or they can be defined and dynamically set and changed using scripting. ARIA states and property attributes always start with \"aria-\" (e.g.,\naria-required=\"true\"\n).\nLandmark Roles\nARIA can define roles for significant page areas or regions. These are identified by screen readers and help with orientation and navigation in the page. The available document landmark roles are:\nbanner\nSite-orientated content that typically contains the name of the web site, logo, search, and/or main navigation. Semantically equivalent to\n<header>\nnavigation\nThe area that contains the navigation links for the document or web site. Semantically equivalent to\n<nav>\nmain\nThe main or central content of the document. Semantically equivalent to\n<main>\ncomplementary\nSupporting content for the main content, often presented in a side bar. Semantically equivalent to\n<aside>\ncontentinfo\nInformational child content, such as footnotes, copyrights, links to privacy statement, links to preferences, and so on. Semantically equivalent to\n<footer>\nsearch\nA section that contains the search functionality for the site. There is no equivalent element in HTML.\nOn a typical web page, the logo and header content might be within an element with role of\nbanner\n. The navigation links across the top would be identified within\nnavigation\n, typically contained within the\nbanner\n. The site search form would be given\n<form role=\"search\">\n. The main body of an article would be\nmain\n. The related links in a side bar might be identified as\ncomplementary\n. The footer content and links at the bottom of a page would have a role of\ncontentinfo\n.\nNote\nAll ARIA landmark roles, except\nsearch\n, have equivalent HTML \"\nregions\n\". Whenever possible, it is best to use the HTML markup (see Rule #1 above). While using both the HTML element and the ARIA attribute is allowed (e.g.,\n<nav role=\"navigation\">\n), this introduces unnecessary markup and the possibility for error. The terms \"landmark\" and \"region\" are typically synonymous in screen readers.\nLearn more about regions.\nScreen readers provide a list of all landmarks/regions on a page and shortcut keys to navigate among them. Some assistive technologies allow the user to jump to specific landmarks/regions (for instance,\nM\nfor the main content).\nGeneric regions\nIf a significant page or web application area does not align with the landmark roles above, the\nrole=\"region\"\nattribute can be added to create a generic landmark/region. It must have a descriptive accessible name defined using\naria-label\nor\naria-labelledby\n(e.g.,\n<div role=\"region\" aria-label=\"Filters\">\n).\nARIA Labels and Descriptions\nHTML facilitates associations that support accessibility\u2014\n<label>\nfor form inputs,\n<caption>\nfor data table descriptions,\n<th>\nfor row and column headers in data tables, etc. When HTML cannot create the necessary associations, ARIA can be used.\nWith\naria-labelledby\n, an element references the\nid\nattribute value (or, in some cases, multiple\nid\nattribute values) of the element(s) containing the text that acts as its descriptive label. This region will be labeled by and identified by the text within the\n<h2>\n\u2014\"Filters\":\n<div role=\"region\"\naria-labelledby=\"filtersheading\"\n>\n<h2\nid=\"filtersheading\"\n>Filters</h2>\nWith\naria-label\nyou apply the label text directly in the attribute value. Even though the\n<h2>\ncontent is \"Search Filters\", this region will be labeled by the\naria-label\nvalue of \"Filters\":\n<div role=\"region\"\naria-label=\"Filters\"\n>\n<h2>Search Filters</h2>\nThe\naria-labelledby\napproach is better in this case\u2014it does not duplicate the content, and it ensures that if the heading text is changed, the label for the region will change as well. When text within another element is available to be referenced, then\naria-labelledby\nshould be used rather than\naria-label\n.\nEvery interactive element needs text describing its function. Additional visually-associated descriptive text can be associated with\naria-describedby\n. Like\naria-labelledby\n, the descriptive element's\nid\nattribute value is referenced.\n<label for=\"password\">Password:</label>\n<input id=\"password\"\naria-describedby=\"requirements\"\n>\n<p\nid=\"requirements\"\n>Your password must be at least 8 characters in length</p>\nDescriptions are typically read by screen readers after labels and sometimes as the very last information for an element. Descriptions are most useful for form inputs.\nNote that the previous example uses\n<label>\nrather than ARIA labeling because\n<label>\nis sufficient (see Rule #1 above).\nTip\nARIA labeling is most useful and powerful when used with form inputs. See our article on\nAdvanced Form Labeling\n.\nDefining labels with ARIA comes with some constraints and warnings. How labels and descriptions are calculated in web pages is\nextremely complex\n, but below are a few general guidelines.\nIn order to be assigned an ARIA label, an element must be labelable\u2014either a link, button, or form control, or having specific HTML or ARIA semantics. Many elements are not labelable\u2014\n<p>\n,\n<div>\n, and\n<span>\n, for example, unless assigned an appropriate ARIA\nrole\n.\nARIA labels override the default text and accessible names for HTML elements. If an input has a\n<label>\nand\nan\naria-label\nor\naria-labelledby\n, the\n<label>\nwill not be read. Similarly, link/button text and image\nalt\nattribute values are overridden by ARIA label text.\nAn element can only have one accessible name, though you can reference multiple element\nid\ns with\naria-labelledby\nor\naria-describedby\nto concatenate multiple texts:\n<table\naria-labelledby=\"tablecaption tabledisclaimer\"\n>\nWCAG requires that the visible text label for an element be included within its accessible name (which is read by a screen reader). When using ARIA labels, ensure consistency between what sighted users see and what screen reader users hear. Many screen reader users have some vision.\nScreen reader users can pause and explore page text content\u2014even reading content word-by-word or letter-by-letter. However, this is not possible with ARIA labels or descriptions which are instead read as a stream of text. Keep these succinct.\nWhen associated\naria-labelledby\nor\naria-describedby\ntext is read, all semantics are removed. Links, tables, lists, etc. within the referenced element are not identified when the label or description text is presented.\nThe best way to ensure that ARIA labels and descriptions have been implemented correctly is to listen in a screen reader. You can also inspect the accessible name and description of an element using browser\nDeveloper Tools\n.\nDynamic Content Updates\nDynamic content changes may create accessibility problems. What happens if a screen reader reads an element while it is updated? If the updated content is important, should the user be interrupted? Should focus be set immediately to the new content? Should the user simply be informed of the update so they can find it elsewhere? Should nothing happen at all?\nARIA can flag dynamically-changing page areas as\nlive regions\n. Live regions make content updates screen reader compatible, inform the user of updates, provide controls for the live region, determine the amount of new content that is read, and much more.\nTo create a live region, the developer adds the\naria-live\nproperty to the element that will update. This attribute must be set when the page first loads; injecting it later doesn't work reliably. The\naria-live\nattribute takes values of\noff\n,\npolite\n, or\nassertive\nwhich specifies what a screen reader should do when the element is updated.\nA value of off (\naria-live=\"off\"\n) tells the screen reader to not announce the update. If the screen reader user later encounters the updated content, it will be read at that time. This would be used for irrelevant or less important content updates. It is useful primarily for live regions that are dynamically change from\npolite\nor\nassertive\nto\noff\nusing scripting.\nA value of\npolite\nwill cause the updated content to be read by the screen reader at the next logical pause. This value is most common for status notification, weather or stock updates, chat messages, etc.\nAn\naria-live\nvalue of\nassertive\nwill announce the content change immediately\u2014quite possibly when the screen reader user is listening to other page content. Assertive is best reserved for critical updates, such as error messages.\nCare is necessary with all live regions to ensure that screen reader users are not needlessly interrupted or overwhelmed with notifications, especially if there are multiple live regions on a page. Testing the page in a screen reader will quickly reveal if this is the case.\nThere are additional ARIA\nrole\nattribute values that create live regions including\nalert\n,\nlog\n, and\ntimer\n. The high level of fidelity with ARIA live regions allows great flexibility both for developers and for end users.\nKeyboard Accessibility of ARIA Widgets\nExamples of widgets include sliders, drop-down and fly-out menus, tree systems, drag-and-drop controls, auto-completing text boxes, dialog windows, and tooltips, to name a few. They are interactive elements that are created and controlled through scripting. Widgets are usually either not native to HTML or are HTML controls that are greatly enhanced through scripting.\nWidgets are not natively accessible, and HTML has very limited markup for defining complex widgets. However, by establishing a standard set of roles, properties, and states, ARIA helps developers implement accessibility with relative ease.\nThe\nARIA Design Patterns and Widgets\nprovides specific requirements for creating a wide variety of widgets. It's vital that this guidance be followed! Below are a few high-level considerations.\nIn HTML, only links and form controls can receive keyboard focus. As the user presses\nTab\nto navigate through a page, the browser stops or sets focus only on these types of elements, allowing them to be activated and manipulated.\nWith scripting and CSS, other page elements (such as\n<p>\nor\n<span>\n) can be made to appear and behave like interactive controls to sighted mouse users. Without additional effort, though, these would be neither keyboard accessible nor identified as interactive controls to a screen reader user. To avoid this loss of functionality, use HTML markup whenever possible (e.g.,\n<button>\nfor elements that function like buttons,\n<a>\nfor links,\n<select>\nfor select menus, etc.). However, when custom widgets are necessary, ARIA can help fill this gap.\nImportant!\nTo be accessible, an interactive widget or control must:\nBe keyboard focusable and have appropriate keyboard interactions.\nHave a descriptive accessible name.\nHave appropriate ARIA markup that identifies its role, states, and properties\nStandard HTML controls should typically be used to provide keyboard interactivity. Alternatively, an element that is not natively focusable (such as a\n<div>\n) can be made focusable using\ntabindex\n(\nread more about tabindex\n):\ntabindex=\"0\"\nmakes any element focusable using the keyboard or scripting, as if it were a link or button.\ntabindex=\"-1\"\nmakes any element focusable with scripting, but not with the keyboard.\nPositive tabindex values (\ntabindex=\"1\"\nor higher) must always be avoided. They force an artificial navigation order on the page that destroys the natural order.\nBy applying\ntabindex=\"0\"\n, the browser will stop and set focus to the element in the navigation order of the document when the user Tabs to the element. This allows an element to be interactive, such as triggering functionality when the element receives keyboard focus or when the user presses a key while the element has focus. This is sometimes necessary with certain ARIA widgets, such as tab panels, menus, and tree controls. The keyboard functionality\nMUST\nalign with the ARIA Design Pattern requirements to ensure that the widget provides standard keyboard interaction patterns.\nImportant!\nIf an element is focusable by pressing\nTab\non the keyboard, it must also be functional\u2014meaning it can respond to keyboard activation. Apply\ntabindex=\"0\"\nonly to interactive elements.\ntabindex=\"-1\"\nallows an element to receive focus programmatically\u2014when the user follows a link to the element (\n<a href=\"#maincontent\"> ...\n) or when focus is set with scripting (e.g.,\ndocument.getElementById('errormessage').focus();\n). This is especially helpful for error messages, dialog boxes, etc. that are not natively-focusable HTML controls, but that you want to be focused for optimal accessibility.\nImportant!\ntabindex=\"-1\"\nremoves the element from the keyboard navigation order\u2014users can't Tab to it. As such, it is seldom appropriate on links, buttons, or other elements that the user may need to navigate to.\nOnce a widget is keyboard focusable, it must have a descriptive accessible name using HTML values (such as button text) or associations (such as\n<label>\n) or, if not possible using HTML, by using\naria-labelledby\nor\naria-label\n.\nAdditionally, the element must have an appropriate ARIA\nrole\nvalue, as defined in the Design Patterns. This ensures that a screen reader user is informed what the widget is and what it does. This can also cause the screen reader to announce widget-specific instructions on how to interact with it. Certain widgets also require ARIA states and properties to inform the screen reader and support keyboard accessibility.\nBy expanding the focus capabilities in the browser to elements that otherwise cannot receive focus, and by providing proper accessible names and ARIA markup, web authors have great flexibility and power to build complex widgets and interfaces that are highly accessible.\nBasic ARIA Examples\nForm enhancements\nARIA can enhance form accessibility in ways HTML cannot.\naria-labelledby\nand\naria-label\nallow complex associations of text to form inputs, in ways that\n<label>\ncannot.\naria-describedby\nassociates secondary descriptions to inputs, such as field requirements or error messages.\naria-required=\"true\"\nidentifies inputs that require user input.\naria-invalid=\"true\"\nidentifies inputs that are in an error state.\nrole=\"radiogroup\"\n, when given an ARIA label, provides the same functionality as\n<fieldset>\n/\n<legend>\nfor groups of inputs, but with more flexibility.\nThe\nCreating Accessible Forms\narticle provides details on using these ARIA attributes.\nButton enhancements\nThe semantics of buttons can be enhanced for buttons that have specialized functions.\n<button aria-haspopup=\"dialog\">\ncauses screen readers to announce that the button triggers a dialog window. Additional\naria-haspopup\nvalues of\nmenu\n,\nlistbox\n,\ntree\n,\ngrid\n, and\ntrue\nare also available. Be sure to follow the ARIA Design Patterns.\n<button aria-expanded=\"true | false\">\ncan be used on buttons that expand or collapse content\u2014often called disclosures, zippies, or accordions. Setting the appropriate values informs screen readers of the state of the button and whether the following content is available or not.\n<button aria-pressed=\"true|false\">\nindicates whether a toggle button is currently pressed/active or not.\nTip\nElements can be styled based on their ARIA attributes and attribute values. This can be helpful to provide visual indications of states\u2014and can allow visual changes to be more effectively controlled via CSS as opposed to scripting. For example, this CSS declaration applies a blue background to any element having\naria-pressed=\"true\"\n:\n[aria-pressed=true] {background-color:#00f;}\nDecorative and presentational elements\nThe\nrole=\"presentation\"\nattribute removes the native semantics of an HTML element, making it akin to a\n<div>\nor\n<span>\n. This can be useful if an HTML element is used to control presentation or layout, or if the element's native semantics are not appropriate. Common examples include layout tables, lists used for presentational structure, and\n<svg>\nelements that need no alternative text.\nHiding content from screen reader users\nThe\naria-hidden=\"true\"\nattribute hides certain types of content from screen readers. There are\nvery\nfew use cases for\naria-hidden\n\u2014if something is visible in the page, it should almost always be presented to screen reader users. However,\naria-hidden=\"true\"\ncan be used to avoid significant repetition of content or for elements that should not be presented to screen reader users.\nImportant!\naria-hidden=\"true\"\nmust never be assigned to something that is keyboard-navigable (or that contains something that is), because the element remains within the keyboard navigation flow even though screen readers may not announce its contents or surrounding content. This can easily confuse screen reader users. In very isolated cases\ntabindex=\"-1\"\nmight be used with\naria-hidden=\"true\"\nto remove the element from being read and navigated to.\nScalable Vector Graphics (SVG)\nAccessibility for\n<svg>\nelements is not yet robust. Fortunately, ARIA can be used to ensure the content in SVG elements is accessible.\nIn the following example, the\nrole=\"img\"\nattribute defines the element as being an image. The accessible name (alternative text) is defined using\naria-labelledby\nwhich references the\n<title>\nelement within the SVG:\n<svg role=\"img\" aria-labelledby=\"title\">\n<title id=\"title\">Sales increased 10% from 2010 to 2015</title>\n...\n</svg>\nThe next example also has\nrole=\"img\"\n, but instead uses\naria-label\nto define the alternative text:\n<svg role=\"img\" aria-label=\"Sales increased 10% from 2010 to 2015\">\n...\n</svg>\nIn a screen reader, both examples above sound the same as\n<img alt=\"Sales increased 10% from 2010 to 2015\">\nIf the SVG were purely decorative, or if adjacent accessible text provided the image alternative, then\n<svg role=\"presentation\">\nwould effectively hide the element\u2014similar to\n<img alt=\"\">\n.\nFor more complex and custom-built widgets, be sure to follow the standardized\nWAI-ARIA Authoring Practices\n. Screen reader testing is almost always necessary when ARIA is implemented.\nFurther Reading\nThis is only an overview. To ensure accessible ARIA implementation, please follow the\nWAI-ARIA Authoring Practices\n. The\nMDN Web Docs\nalso provides a useful ARIA reference. For more details on JavaScript and scripted interactions, see our\nJavaScript Accessibility article\n.",
  "content_markdown": "# Introduction to ARIA - Accessible Rich Internet Applications\n\nYou are here: [Home](/) > [Articles](/articles/) > Introduction to ARIA\n\n## Introduction to ARIA\n\nWAI-ARIA (Accessible Rich Internet Applications or ARIA) is [a W3C specification](https://www.w3.org/WAI/standards-guidelines/aria/) for enhancing accessibility in ways that plain HTML cannot. When used properly, ARIA can...\n\n- enhance accessibility of interactive controls, such as tree menus, sliders, pop-ups, etc.\n- define helpful landmarks for page structure\n- define dynamically-updated \"live regions\"\n- improve keyboard accessibility and interactivity\n- and much more\n\nHTML has a defined\u2014but evolving\u2014vocabulary. For example, `<blink>` has been removed while `<main>` has been added. **ARIA provides new code attributes and values that expand the vocabulary and semantics of HTML for enhanced screen reader accessibility.**\n\nLike HTML, ARIA evolves over time, and is generally well supported in modern browsers and screen readers. Many scripting libraries also support ARIA.\n\n## Rules of ARIA Use\n\nThe ARIA specification defines [five rules of ARIA use](https://www.w3.org/TR/using-aria/#notes2) to support optimal accessibility. Summaries of these rules are below.\n\n### Rule #1 - If you can use HTML a native HTML element or attribute, then do so.\n\nHTML is the foundation of web accessibility. **ARIA should not be used when HTML provides sufficient semantics for accessibility! When used incorrectly, ARIA can introduce significant accessibility barriers.**\n\n### Rule #2 - Do not change native semantics, unless you really have to.\n\nMost HTML elements have default semantics or meaning that can be conveyed to screen reader users. When necessary, ARIA can override and change those semantics.\n\nA `<ul>` element, for example, defines an unordered list. When encountered by a screen reader, it is identified as an unordered list. Screen readers also announce the number of list items, enable list item navigation, and much more. If an ARIA `role` is added to the `<ul>`\u2014for example, \u2014`<ul role=\"navigation\">`\u2014then the list semantics are overridden and lost. The element now becomes a navigation landmark (see below) and the accessibility benefits of the unordered list are gone. Instead, `<div role=\"navigation\"><ul>...</ul></div>` provides the benefits of the navigation landmark AND the benefits of the unordered list. (Better yet, `<nav><ul>...</ul></nav>` is semantically equivalent without relying on ARIA at all.)\n\n### Rule #3 - All interactive ARIA controls must be usable with the keyboard.\n\nThe [ARIA Design Patterns](https://www.w3.org/WAI/ARIA/apg/patterns/) define standard keyboard interactions for ARIA widgets and controls. This allows everyone to use the widget using the keyboard, and ensures that instructions provided by screen readers align with the actual functionality in the page.\n\n### Rule #4 - Interactive controls must have proper semantics and cannot be hidden\n\nAny element that is keyboard focusable (primarily using the Tab key), *must* have proper semantics so that it will be identified as a link, button, form control, etc., or other element with an appropriate `role` value. Since `role=\"presentation\"` removes semantics, it must never be applied to a focusable element.\n\nSimilarly, interactive elements must be visible. Do not hide focused elements with CSS or with `aria-hidden=\"true\"`.\n\n### Rule #5 - All interactive elements must have an accessible name\n\nText that describes an interactive control must be presented to screen reader users when the control is encountered. A button must have descriptive text (such as \"Register\") and a text input must have a descriptive label (such as \"First Name\"). The content that screen readers announce to identify a control is called its [\"accessible name\"](/articles/label-name/). ARIA can also be used to define accessible names.\n\n## Core Components\n\nThe three main components of ARIA are **roles**, **properties**, and **states**.\n\n### Roles\n\nRoles define what an element is or does. Most HTML elements have a default role that is presented to assistive technology. For example, `<button>` has a default role of \"button\" and `<form>` has a default role of \"form\". ARIA can define roles that are not available in HTML, and can also override the default roles of HTML elements (see Rule #2 above).\n\nAn example of an ARIA role is `<form role=\"search\">`. In HTML, all forms have the same semantics. But with ARIA, you can define the semantics of a particular form as being a search form.\n\nDefault HTML roles should not be duplicated using ARIA\u2014avoid things like `<button role=\"button\">`.\n\nARIA does not change browser behavior or appearance.\n\nAdding `role=\"button\"` to a `<div>`, for example, will not make the `<div>` function like or appear like a button. However, this will cause screen readers to announce it as a button even though it cannot be navigated to or activated using the keyboard. Authors must implement [appropriate design and interaction patterns](https://www.w3.org/WAI/ARIA/apg/), typically via JavaScript and CSS, along with ARIA.\n\n### Properties\n\nARIA properties define additional semantics not supported in standard HTML. An example is `<button aria-haspopup=\"true\">`. This property extends the standard button to cause a screen reader to announce that the button, if activated, will trigger a pop-up.\n\n### States\n\nARIA states are attributes that define the current condition of an element. They generally change based on user interaction or some dynamic variable. An example is `<input aria-invalid=\"true\">`. This property will cause a screen reader to read this input as currently being invalid (meaning it needs to be corrected), but this state value could easily be changed to `false` dynamically based on user input.\n\nARIA roles, states, and properties can be defined in markup or they can be defined and dynamically set and changed using scripting. ARIA states and property attributes always start with \"aria-\" (e.g., `aria-required=\"true\"`).\n\n## Landmark Roles\n\nARIA can define roles for significant page areas or regions. These are identified by screen readers and help with orientation and navigation in the page. The available document landmark roles are:\n\n`banner`\n:   Site-orientated content that typically contains the name of the web site, logo, search, and/or main navigation. Semantically equivalent to `<header>`\n\n`navigation`\n:   The area that contains the navigation links for the document or web site. Semantically equivalent to `<nav>`\n\n`main`\n:   The main or central content of the document. Semantically equivalent to `<main>`\n\n`complementary`\n:   Supporting content for the main content, often presented in a side bar. Semantically equivalent to `<aside>`\n\n`contentinfo`\n:   Informational child content, such as footnotes, copyrights, links to privacy statement, links to preferences, and so on. Semantically equivalent to `<footer>`\n\n`search`\n:   A section that contains the search functionality for the site. There is no equivalent element in HTML.\n\nOn a typical web page, the logo and header content might be within an element with role of `banner`. The navigation links across the top would be identified within `navigation`, typically contained within the `banner`. The site search form would be given `<form role=\"search\">`. The main body of an article would be `main`. The related links in a side bar might be identified as `complementary`. The footer content and links at the bottom of a page would have a role of `contentinfo`.\n\nNote\n\nAll ARIA landmark roles, except `search`, have equivalent HTML \"[regions](/techniques/semanticstructure/#regions)\". Whenever possible, it is best to use the HTML markup (see Rule #1 above). While using both the HTML element and the ARIA attribute is allowed (e.g., `<nav role=\"navigation\">`), this introduces unnecessary markup and the possibility for error. The terms \"landmark\" and \"region\" are typically synonymous in screen readers. [Learn more about regions.](/techniques/semanticstructure/#regions)\n\nScreen readers provide a list of all landmarks/regions on a page and shortcut keys to navigate among them. Some assistive technologies allow the user to jump to specific landmarks/regions (for instance, M for the main content).\n\n### Generic regions\n\nIf a significant page or web application area does not align with the landmark roles above, the `role=\"region\"` attribute can be added to create a generic landmark/region. It must have a descriptive accessible name defined using `aria-label` or `aria-labelledby` (e.g., `<div role=\"region\" aria-label=\"Filters\">`).\n\n## ARIA Labels and Descriptions\n\nHTML facilitates associations that support accessibility\u2014`<label>` for form inputs, `<caption>` for data table descriptions, `<th>` for row and column headers in data tables, etc. When HTML cannot create the necessary associations, ARIA can be used.\n\nWith `aria-labelledby`, an element references the `id` attribute value (or, in some cases, multiple `id` attribute values) of the element(s) containing the text that acts as its descriptive label. This region will be labeled by and identified by the text within the `<h2>`\u2014\"Filters\":\n\n<div role=\"region\" **aria-labelledby=\"filtersheading\"**>  \n<h2 **id=\"filtersheading\"**>Filters</h2>\n\nWith `aria-label` you apply the label text directly in the attribute value. Even though the `<h2>` content is \"Search Filters\", this region will be labeled by the `aria-label` value of \"Filters\":\n\n<div role=\"region\" **aria-label=\"Filters\"**>  \n<h2>Search Filters</h2>\n\nThe `aria-labelledby` approach is better in this case\u2014it does not duplicate the content, and it ensures that if the heading text is changed, the label for the region will change as well. When text within another element is available to be referenced, then `aria-labelledby` should be used rather than `aria-label`.\n\nEvery interactive element needs text describing its function. Additional visually-associated descriptive text can be associated with `aria-describedby`. Like `aria-labelledby`, the descriptive element's `id` attribute value is referenced.\n\n<label for=\"password\">Password:</label>  \n<input id=\"password\" **aria-describedby=\"requirements\"**>  \n<p **id=\"requirements\"**>Your password must be at least 8 characters in length</p>\n\nDescriptions are typically read by screen readers after labels and sometimes as the very last information for an element. Descriptions are most useful for form inputs. *Note that the previous example uses `<label>` rather than ARIA labeling because `<label>` is sufficient (see Rule #1 above).*\n\nTip\n\nARIA labeling is most useful and powerful when used with form inputs. See our article on [Advanced Form Labeling](/techniques/forms/advanced).\n\nDefining labels with ARIA comes with some constraints and warnings. How labels and descriptions are calculated in web pages is [extremely complex](https://www.w3.org/TR/html-aam-1.0/%23accessible-name-and-description-computation), but below are a few general guidelines.\n\n- In order to be assigned an ARIA label, an element must be labelable\u2014either a link, button, or form control, or having specific HTML or ARIA semantics. Many elements are not labelable\u2014`<p>`, `<div>`, and `<span>`, for example, unless assigned an appropriate ARIA `role`.\n- ARIA labels override the default text and accessible names for HTML elements. If an input has a `<label>` *and* an `aria-label` or `aria-labelledby`, the `<label>` will not be read. Similarly, link/button text and image `alt` attribute values are overridden by ARIA label text.\n- An element can only have one accessible name, though you can reference multiple element `id`s with `aria-labelledby` or `aria-describedby` to concatenate multiple texts:  \n  `<table aria-labelledby=\"tablecaption tabledisclaimer\">`\n- WCAG requires that the visible text label for an element be included within its accessible name (which is read by a screen reader). When using ARIA labels, ensure consistency between what sighted users see and what screen reader users hear. Many screen reader users have some vision.\n- Screen reader users can pause and explore page text content\u2014even reading content word-by-word or letter-by-letter. However, this is not possible with ARIA labels or descriptions which are instead read as a stream of text. Keep these succinct.\n- When associated `aria-labelledby` or `aria-describedby` text is read, all semantics are removed. Links, tables, lists, etc. within the referenced element are not identified when the label or description text is presented.\n- The best way to ensure that ARIA labels and descriptions have been implemented correctly is to listen in a screen reader. You can also inspect the accessible name and description of an element using browser [Developer Tools](https://developers.google.com/web/tools/chrome-devtools/accessibility/reference).\n\n## Dynamic Content Updates\n\nDynamic content changes may create accessibility problems. What happens if a screen reader reads an element while it is updated? If the updated content is important, should the user be interrupted? Should focus be set immediately to the new content? Should the user simply be informed of the update so they can find it elsewhere? Should nothing happen at all?\n\nARIA can flag dynamically-changing page areas as *live regions*. Live regions make content updates screen reader compatible, inform the user of updates, provide controls for the live region, determine the amount of new content that is read, and much more.\n\nTo create a live region, the developer adds the `aria-live` property to the element that will update. This attribute must be set when the page first loads; injecting it later doesn't work reliably. The `aria-live` attribute takes values of `off`, `polite`, or `assertive` which specifies what a screen reader should do when the element is updated.\n\nA value of off (`aria-live=\"off\"`) tells the screen reader to not announce the update. If the screen reader user later encounters the updated content, it will be read at that time. This would be used for irrelevant or less important content updates. It is useful primarily for live regions that are dynamically change from `polite` or `assertive` to `off` using scripting.\n\nA value of `polite` will cause the updated content to be read by the screen reader at the next logical pause. This value is most common for status notification, weather or stock updates, chat messages, etc.\n\nAn `aria-live` value of `assertive` will announce the content change immediately\u2014quite possibly when the screen reader user is listening to other page content. Assertive is best reserved for critical updates, such as error messages.\n\nCare is necessary with all live regions to ensure that screen reader users are not needlessly interrupted or overwhelmed with notifications, especially if there are multiple live regions on a page. Testing the page in a screen reader will quickly reveal if this is the case.\n\nThere are additional ARIA `role` attribute values that create live regions including `alert`, `log`, and `timer`. The high level of fidelity with ARIA live regions allows great flexibility both for developers and for end users.\n\n## Keyboard Accessibility of ARIA Widgets\n\nExamples of widgets include sliders, drop-down and fly-out menus, tree systems, drag-and-drop controls, auto-completing text boxes, dialog windows, and tooltips, to name a few. They are interactive elements that are created and controlled through scripting. Widgets are usually either not native to HTML or are HTML controls that are greatly enhanced through scripting.\n\nWidgets are not natively accessible, and HTML has very limited markup for defining complex widgets. However, by establishing a standard set of roles, properties, and states, ARIA helps developers implement accessibility with relative ease.\n\nThe [ARIA Design Patterns and Widgets](https://www.w3.org/WAI/ARIA/apg/patterns/) provides specific requirements for creating a wide variety of widgets. It's vital that this guidance be followed! Below are a few high-level considerations.\n\nIn HTML, only links and form controls can receive keyboard focus. As the user presses Tab to navigate through a page, the browser stops or sets focus only on these types of elements, allowing them to be activated and manipulated.\n\nWith scripting and CSS, other page elements (such as `<p>` or `<span>`) can be made to appear and behave like interactive controls to sighted mouse users. Without additional effort, though, these would be neither keyboard accessible nor identified as interactive controls to a screen reader user. To avoid this loss of functionality, use HTML markup whenever possible (e.g., `<button>` for elements that function like buttons, `<a>` for links, `<select>` for select menus, etc.). However, when custom widgets are necessary, ARIA can help fill this gap.\n\nImportant!\n\nTo be accessible, an interactive widget or control must:\n\n1. Be keyboard focusable and have appropriate keyboard interactions.\n2. Have a descriptive accessible name.\n3. Have appropriate ARIA markup that identifies its role, states, and properties\n\nStandard HTML controls should typically be used to provide keyboard interactivity. Alternatively, an element that is not natively focusable (such as a `<div>`) can be made focusable using `tabindex` ([read more about tabindex](/techniques/keyboard/tabindex)):\n\n- `tabindex=\"0\"` makes any element focusable using the keyboard or scripting, as if it were a link or button.\n- `tabindex=\"-1\"` makes any element focusable with scripting, but not with the keyboard.\n- Positive tabindex values (`tabindex=\"1\"` or higher) must always be avoided. They force an artificial navigation order on the page that destroys the natural order.\n\nBy applying `tabindex=\"0\"`, the browser will stop and set focus to the element in the navigation order of the document when the user Tabs to the element. This allows an element to be interactive, such as triggering functionality when the element receives keyboard focus or when the user presses a key while the element has focus. This is sometimes necessary with certain ARIA widgets, such as tab panels, menus, and tree controls. The keyboard functionality **MUST** align with the ARIA Design Pattern requirements to ensure that the widget provides standard keyboard interaction patterns.\n\nImportant!\n\nIf an element is focusable by pressing Tab on the keyboard, it must also be functional\u2014meaning it can respond to keyboard activation. Apply `tabindex=\"0\"` only to interactive elements.\n\n`tabindex=\"-1\"` allows an element to receive focus programmatically\u2014when the user follows a link to the element (`<a href=\"#maincontent\"> ...`) or when focus is set with scripting (e.g., `document.getElementById('errormessage').focus();`). This is especially helpful for error messages, dialog boxes, etc. that are not natively-focusable HTML controls, but that you want to be focused for optimal accessibility.\n\nImportant!\n\n`tabindex=\"-1\"` removes the element from the keyboard navigation order\u2014users can't Tab to it. As such, it is seldom appropriate on links, buttons, or other elements that the user may need to navigate to.\n\nOnce a widget is keyboard focusable, it must have a descriptive accessible name using HTML values (such as button text) or associations (such as `<label>`) or, if not possible using HTML, by using `aria-labelledby` or `aria-label`.\n\nAdditionally, the element must have an appropriate ARIA `role` value, as defined in the Design Patterns. This ensures that a screen reader user is informed what the widget is and what it does. This can also cause the screen reader to announce widget-specific instructions on how to interact with it. Certain widgets also require ARIA states and properties to inform the screen reader and support keyboard accessibility.\n\nBy expanding the focus capabilities in the browser to elements that otherwise cannot receive focus, and by providing proper accessible names and ARIA markup, web authors have great flexibility and power to build complex widgets and interfaces that are highly accessible.\n\n## Basic ARIA Examples\n\n### Form enhancements\n\nARIA can enhance form accessibility in ways HTML cannot.\n\n- `aria-labelledby` and `aria-label` allow complex associations of text to form inputs, in ways that `<label>` cannot.\n- `aria-describedby` associates secondary descriptions to inputs, such as field requirements or error messages.- `aria-required=\"true\"` identifies inputs that require user input.- `aria-invalid=\"true\"` identifies inputs that are in an error state.- `role=\"radiogroup\"`, when given an ARIA label, provides the same functionality as `<fieldset>`/`<legend>` for groups of inputs, but with more flexibility.\n\nThe [Creating Accessible Forms](/techniques/forms/) article provides details on using these ARIA attributes.\n\n### Button enhancements\n\nThe semantics of buttons can be enhanced for buttons that have specialized functions.\n\n- `<button aria-haspopup=\"dialog\">` causes screen readers to announce that the button triggers a dialog window. Additional `aria-haspopup` values of `menu`, `listbox`, `tree`, `grid`, and `true` are also available. Be sure to follow the ARIA Design Patterns.\n- `<button aria-expanded=\"true | false\">` can be used on buttons that expand or collapse content\u2014often called disclosures, zippies, or accordions. Setting the appropriate values informs screen readers of the state of the button and whether the following content is available or not.\n- `<button aria-pressed=\"true|false\">` indicates whether a toggle button is currently pressed/active or not.\n\nTip\n\nElements can be styled based on their ARIA attributes and attribute values. This can be helpful to provide visual indications of states\u2014and can allow visual changes to be more effectively controlled via CSS as opposed to scripting. For example, this CSS declaration applies a blue background to any element having `aria-pressed=\"true\"`:  \n`[aria-pressed=true] {background-color:#00f;}`\n\n### Decorative and presentational elements\n\nThe `role=\"presentation\"` attribute removes the native semantics of an HTML element, making it akin to a `<div>` or `<span>`. This can be useful if an HTML element is used to control presentation or layout, or if the element's native semantics are not appropriate. Common examples include layout tables, lists used for presentational structure, and `<svg>` elements that need no alternative text.\n\n### Hiding content from screen reader users\n\nThe `aria-hidden=\"true\"` attribute hides certain types of content from screen readers. There are *very* few use cases for `aria-hidden`\u2014if something is visible in the page, it should almost always be presented to screen reader users. However, `aria-hidden=\"true\"` can be used to avoid significant repetition of content or for elements that should not be presented to screen reader users.\n\nImportant!\n\n`aria-hidden=\"true\"` must never be assigned to something that is keyboard-navigable (or that contains something that is), because the element remains within the keyboard navigation flow even though screen readers may not announce its contents or surrounding content. This can easily confuse screen reader users. In very isolated cases `tabindex=\"-1\"` might be used with `aria-hidden=\"true\"` to remove the element from being read and navigated to.\n\n### Scalable Vector Graphics (SVG)\n\nAccessibility for `<svg>` elements is not yet robust. Fortunately, ARIA can be used to ensure the content in SVG elements is accessible.\n\nIn the following example, the `role=\"img\"` attribute defines the element as being an image. The accessible name (alternative text) is defined using `aria-labelledby` which references the `<title>` element within the SVG:\n\n<svg role=\"img\" aria-labelledby=\"title\">  \n<title id=\"title\">Sales increased 10% from 2010 to 2015</title>  \n...  \n</svg>\n\nThe next example also has `role=\"img\"`, but instead uses `aria-label` to define the alternative text:\n\n<svg role=\"img\" aria-label=\"Sales increased 10% from 2010 to 2015\">  \n...  \n</svg>\n\nIn a screen reader, both examples above sound the same as `<img alt=\"Sales increased 10% from 2010 to 2015\">`\n\nIf the SVG were purely decorative, or if adjacent accessible text provided the image alternative, then `<svg role=\"presentation\">` would effectively hide the element\u2014similar to `<img alt=\"\">`.\n\nFor more complex and custom-built widgets, be sure to follow the standardized [WAI-ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/). Screen reader testing is almost always necessary when ARIA is implemented.\n\n## Further Reading\n\nThis is only an overview. To ensure accessible ARIA implementation, please follow the [WAI-ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/). The [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) also provides a useful ARIA reference. For more details on JavaScript and scripted interactions, see our [JavaScript Accessibility article](https://webaim.org/techniques/javascript/).",
  "tags": [
    "webaim",
    "accessibility",
    "techniques",
    "testing"
  ],
  "extracted_at": "2026-02-03T14:30:44.144155+00:00",
  "content_length": 23613,
  "content_hash": "d5839c2e2a91ebca"
}