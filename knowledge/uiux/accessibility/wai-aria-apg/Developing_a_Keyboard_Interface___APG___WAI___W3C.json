{
  "id": "wai-aria-apg__WAI_ARIA_apg_practices_keyboard-interface_",
  "source_id": "wai-aria-apg",
  "source_name": "WAI-ARIA Authoring Practices Guide",
  "category": "accessibility",
  "url": "https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/",
  "title": "Developing a Keyboard Interface | APG | WAI | W3C",
  "content": "Developing a Keyboard Interface\nIntroduction\nUnlike native HTML form elements, browsers do not provide keyboard support for graphical user interface (GUI) components that are made accessible with ARIA; authors have to provide the keyboard support in their code.\n          This section describes the principles and methods for making the functionality of a web page that includes ARIA widgets, such as menus and grids, as well as interactive components, such as toolbars and dialogs, operable with a keyboard.\n          Along with the basics of focus management, this section offers guidance toward the objective of providing experiences to people who rely on a keyboard that are as efficient and enjoyable as the experiences available to others.\nThis section covers:\nUnderstanding fundamental principles of focus movement conventions used in ARIA design patterns.\nMaintaining visible focus, predictable focus movement, and distinguishing between keyboard focus and the selected state.\nManaging movement of keyboard focus between components, e.g., how the focus moves when the\nTab\nand\nShift\n+\nTab\nkeys are pressed.\nManaging movement of keyboard focus inside components that contain multiple focusable elements, e.g., two different methods for programmatically exposing focus inside widgets like radio groups, menus, listboxes, trees, and grids.\nDetermining when to make disabled interactive elements focusable.\nAssigning and revealing keyboard shortcuts, including guidance on how to avoid problematic conflicts with keyboard commands of assistive technologies, browsers, and operating systems.\nFundamental Keyboard Navigation Conventions\nARIA roles, states, and properties model accessibility behaviors and features shared among GUI components of popular desktop GUIs, including Microsoft Windows, macOS, and GNOME.\n          Similarly, ARIA design patterns borrow user expectations and keyboard conventions from those platforms, consistently incorporating common conventions with the aim of facilitating easy learning and efficient operation of keyboard interfaces across the web.\nFor a web page to be accessible, all interactive elements must be operable via the keyboard.\n          In addition, consistent application of the common GUI keyboard interface conventions described in the\nAPG patterns\nis important, especially for assistive technology users.\n          Consider, for example, a screen reader user operating a tree.\n          Just as familiar visual styling helps users discover how to expand a tree branch with a mouse, ARIA attributes give the tree the sound and feel of a tree in a desktop application.\n          So, screen reader users will commonly expect that pressing the right arrow key will expand a collapsed node.\n          Because the screen reader knows the element is a tree, it also has the ability to instruct a novice user how to operate it.\n          Similarly, voice recognition software can implement commands for expanding and collapsing branches because it recognizes the element as a tree and can execute appropriate keyboard commands.\n          All this is only possible if the tree implements the GUI keyboard conventions as described in the\nTree View Pattern\n.\nA primary keyboard navigation convention common across all platforms is that the\ntab\nand\nshift\n+\ntab\nkeys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements.\n          The path that the focus follows when pressing the\ntab\nkey is known as the tab sequence or tab ring.\nCommon examples of UI components that contain multiple focusable elements are radio groups, tablists, menus, and grids.\n          A radio group, for example, contains multiple radio buttons, each of which is focusable.\n          However, only one of the radio buttons is included in the tab sequence.\n          After pressing the\nTab\nkey moves focus to a radio button in the group, pressing arrow keys moves focus among the radio buttons in the group, and pressing the\nTab\nkey moves focus out of the radio group to the next element in the tab sequence.\nThe ARIA specification refers to a discrete UI component that contains multiple focusable elements as a\ncomposite\nwidget.\n          The process of controlling focus movement inside a composite is called managing focus.\n          Following are some ARIA design patterns with example implementations that demonstrate focus management:\nCombobox\nGrid\nListbox\nMenu and Menubar\nRadio Group\nTabs\nToolbar\nTreegrid\nTree View\nDiscernible and Predictable Keyboard Focus\nWork to complete this section is tracked by\nissue 217.\nWhen operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed.\n          The following factors affect to what extent a web page affords users these capabilities.\nVisibility of the focus indicator: Users need to be able to easily distinguish the keyboard focus indicator from other features of the visual design.\n            Just as a mouse user may move the mouse to help find the mouse pointer, a keyboard user may press a navigation key to watch for movement.\n            If visual changes in response to focus movement are subtle, many users will lose track of focus and be unable to operate.\n            Authors are advised to rely on the default focus indicators provided by browsers.\n            If overriding the default, consider:\nsomething about ... Colors and gradients can disappear in high contrast modes.\nUsers need to be able to easily distinguish between focus and selection as described in\nFocus VS Selection and the Perception of Dual Focus\n, especially when a component that contains selected elements does not contain the focus.\n... other considerations to be added ...\nPersistence of focus: It is essential that there is always a component within the user interface that is active (document.activeElement is not null or is not the body element) and that the active element has a visual focus indicator.\n            Authors need to manage events that effect the currently active element so focus remains visible and moves logically.\n            For example, if the user closes a dialog or performs a destructive operation like deleting an item from a list, the active element may be hidden or removed from the DOM.\n            If such events are not managed to set focus on the button that triggered the dialog or on the list item following the deleted item, browsers move focus to the body element, effectively causing a loss of focus within the user interface.\nPredictability of movement: Usability of a keyboard interface is heavily influenced by how readily users can guess where focus will land after a navigation key is pressed.\n            Some possible approaches to optimizing predictability include:\nMove focus in a pattern that matches the reading order of the page's language.\n                In left to right languages, for example, create a tab sequence that moves focus left to right and then top to bottom.\nIncorporate all elements of a section of the page in the tab sequence before moving focus to another section.\n                For instance, in a page with multiple columns that has content in a left side bar, center region, and right side bar, build a tab sequence that covers all elements in the left sidebar before focus moves to the first focusable element in the center column.\nWhen the distance between two consecutive elements in the tab sequence is significant, avoid movement that would be perceived as backward.\n                For example, on a page with a left to right language, a jump from the last element in the bottom right of the main content to the top element in a left-hand sidebar is likely to be less predictable and more difficult to follow, especially for users with a narrow field of view.\nFollow consistent patterns across a site.\n                The keyboard experience is more predictable when similar pages have similar focus movement patterns.\nDo not set initial focus when the page loads except in cases where:\nThe page offers a single, primary function that nearly all users employ immediately after page load.\nAny given user is likely to use the page often.\nFocus VS Selection and the Perception of Dual Focus\nOccasionally, it may appear as if two elements on the page have focus at the same time.\n          For example, in a multi-select list box, when an option is selected it may be greyed.\n          Yet, the focus indicator can still be moved to other options, which may also be selected.\n          Similarly, when a user activates a tab in a tablist, the selected state is set on the tab and its visual appearance changes.\n          However, the user can still navigate, moving the focus indicator elsewhere on the page while the tab retains its selected appearance and state.\nFocus and selection are quite different.\n          From the keyboard user's perspective, focus is a pointer, like a mouse pointer; it tracks the path of navigation.\n          There is only one point of focus at any time and all operations take place at the point of focus.\n          On the other hand, selection is an operation that can be performed in some widgets, such as list boxes, trees, and tablists.\n          If a widget supports only single selection, then only one item can be selected and very often the selected state will simply follow the focus when focus is moved inside of the widget.\n          That is, in some widgets, moving focus may also perform the select operation.\n          However, if the widget supports multiple selection, then more than one item can be in a selected state, and keys for moving focus do not perform selection.\n          Some multi-select widgets do support key commands that both move focus and change selection, but those keys are different from the normal navigation keys.\n          Finally, when focus leaves a widget that includes a selected element, the selected state persists.\nFrom the developer's perspective, the difference is simple -- the focused element is the active element (document.activeElement).\n          Selected elements are elements that have\naria-selected=\"true\"\n.\nWith respect to focus and the selected state, the most important considerations for designers and developers are:\nThe visual focus indicator must always be visible.\nThe selected state must be visually distinct from the focus indicator.\nDeciding When to Make Selection Automatically Follow Focus\nIn composite widgets where only one element may be selected, such as a tablist or single-select listbox, moving the focus may also cause the focused element to become the selected element.\n          This is called having selection follow focus.\n          Having selection follow focus is often beneficial to users, but in some circumstances, it is extremely detrimental to accessibility.\nFor example, in a tablist, the selected state is used to indicate which panel is displayed.\n          So, when selection follows focus in a tablist, moving focus from one tab to another automatically changes which panel is displayed.\n          If the content of panels is present in the DOM, then displaying a new panel is nearly instantaneous.\n          A keyboard user who wishes to display the fourth of six tabs can do so with 3 quick presses of the right arrow.\n          And, a screen reader user who perceives the labels on tabs by navigating through them may efficiently read through the complete list without any latency.\nHowever, if displaying a new panel causes a network request and possibly a page refresh, the effect of having selection automatically focus can be devastating to the experience for keyboard and screen reader users.\n          In this case, displaying the fourth tab or reading through the list becomes a tedious and time-consuming task as the user experiences significant latency with each movement of focus.\n          Further, if displaying a new tab refreshes the page, then the user not only has to wait for the new page to load but also return focus to the tab list.\nWhen selection does not follow focus, the user changes which element is selected by pressing the\nEnter\nor\nSpace\nkey.\nKeyboard Navigation Between Components (The Tab Sequence)\nAs explained in section\nFundamental Keyboard Navigation Conventions\n, all interactive UI components need to be reachable via the keyboard.\n          This is best achieved by either including them in the tab sequence or by making them accessible from a component that is in the tab sequence, e.g., as part of a composite component.\n          This section addresses building and managing the tab sequence, and subsequent sections cover making focusable elements that are contained within components keyboard accessible.\nThe\nHTML\ntabindex\nand\nSVG2\ntabindex\nattributes can be used to add and remove elements from the tab sequence.\n          The value of\ntabindex\ncan also influence the order of the tab sequence, although authors are strongly advised not to use\ntabindex\nfor that purpose.\nIn HTML, the default tab sequence of a web page includes only links and HTML form elements, except In macOS, where it includes only form elements.\n          macOS system preferences include a keyboard setting that enables the tab key to move focus to all focusable elements.\nThe default order of elements in the tab sequence is the order of elements in the DOM.\n          The DOM order also determines screen reader reading order.\n          It is important to keep the keyboard tab sequence and the screen reader reading order aligned, logical, and predictable as described in\nDiscernible and Predictable Keyboard Focus\n.\n          The most robust method of manipulating the order of the tab sequence while also maintaining alignment with the reading order that is currently available in all browsers is rearranging elements in the DOM.\nThe values of the\ntabindex\nattribute have the following effects.\ntabindex\nis not present or does not have a valid value\nThe element has its default focus behavior.\n            In HTML, only form controls and anchors with an HREF attribute are included in the tab sequence.\ntabindex=\"0\"\nThe element is included in the tab sequence based on its position in the DOM.\ntabindex=\"-1\"\nThe element is not included in the tab sequence but is focusable with element.focus().\ntabindex=\"X\"\nwhere\nX\nis an integer in the range\n1 <= X <= 32767\nAuthors are strongly advised NOT to use these values.\n            The element is placed in the tab sequence based on the value of\ntabindex\n.\n            Elements with a\ntabindex\nvalue of 0 and elements that are focusable by default will be in the sequence after elements with a\ntabindex\nvalue of\n1\nor greater.\nKeyboard Navigation Inside Components\nAs described in section\nFundamental Keyboard Navigation Conventions\n, the tab sequence should include only one focusable element of a composite UI component.\n          Once a composite contains focus, keys other than\nTab\nand\nShift\n+\nTab\nenable the user to move focus among its focusable elements.\n          Authors are free to choose which keys move focus inside of a composite, but they are strongly advised to use the same key bindings as similar components in common GUI operating systems as demonstrated in\nAPG Patterns\n.\nThe convention for where focus lands in a composite when it receives focus as a result of a\nTab\nkey event depends on the type of composite.\n          It is typically one of the following.\nThe element that had focus the last time the composite contained focus.\n            Or, if the composite has not yet contained the focus, the first element.\n            Widgets that usually employ this pattern include grid and tree grid.\nThe selected element.\n            Or, if there is no selected element, the first element.\n            Widgets where this pattern is commonly implemented include radio groups, tabs, list boxes, and trees.\n            Note: For radio groups, this pattern is referring to the checked radio button; the selected state is not supported for radio buttons.\nThe first element.\n            Components that typically follow this pattern include menubars and toolbars.\nThe following sections explain two strategies for managing focus inside composite elements: creating a roving\ntabindex\nand using the\naria-activedescendant\nproperty.\nManaging Focus Within Components Using a Roving\ntabindex\nWhen using roving\ntabindex\nto manage focus in a composite UI component, the element that is to be included in the tab sequence has\ntabindex=\"0\"\nand all other focusable elements contained in the composite have\ntabindex=\"-1\"\n.\n            The algorithm for the roving\ntabindex\nstrategy is as follows.\nWhen the component container is loaded or created, set\ntabindex=\"0\"\non the element that will initially be included in the tab sequence and set\ntabindex=\"-1\"\non all other focusable elements it contains.\nWhen the component contains focus and the user presses a navigation key that moves focus within the component, such as an arrow key:\nset\ntabindex=\"-1\"\non the element that has\ntabindex=\"0\"\n.\nSet\ntabindex=\"0\"\non the element that will become focused as a result of the key event.\nSet focus,\nelement.focus()\n, on the element that has\ntabindex=\"0\"\n.\nIf the design calls for a specific element to be focused the next time the user moves focus into the composite with\nTab\nor\nShift\n+\nTab\n, check if that target element has\ntabindex=\"0\"\nwhen the composite loses focus.\n              If it does not, set\ntabindex=\"0\"\non the target element and set\ntabindex=\"-1\"\non the element that previously had\ntabindex=\"0\"\n.\nOne benefit of using roving\ntabindex\nrather than\naria-activedescendant\nto manage focus is that the user agent will scroll the newly focused element into view.\nManaging Focus in Composites Using\naria-activedescendant\nIf a component container has an ARIA role that supports the\naria-activedescendant\nproperty, it is not necessary to manipulate the\ntabindex\nattribute and move DOM focus among focusable elements within the container.\n            Instead, only the container element needs to be included in the tab sequence.\n            When the container has DOM focus, the value of\naria-activedescendant\non the container tells assistive technologies which element is active within the widget.\n            Assistive technologies will consider the element referred to as active to be the focused element even though DOM focus is on the element that has the\naria-activedescendant\nproperty.\n            And, when the value of\naria-activedescendant\nis changed, assistive technologies will receive focus change events equivalent to those received when DOM focus actually moves.\nThe steps for using the\naria-activedescendant\nmethod of managing focus are as follows.\nWhen the container element that has a role that supports\naria-activedescendant\nis loaded or created, ensure that:\nThe container element is included in the tab sequence as described in\nKeyboard Navigation Between Components\nor is a focusable element of a composite that implements\na roving\ntabindex\n.\nIt has\naria-activedescendant=\"IDREF\"\nwhere\nIDREF\nis the\nid\nof the element within the container that should be identified as active when the widget receives focus.\n                  The referenced element needs to meet the DOM relationship requirements described below.\nWhen the container element receives DOM focus, draw a visual focus indicator on the active element and ensure the active element is scrolled into view.\nWhen the composite widget contains focus and the user presses a navigation key that moves focus within the widget, such as an arrow key:\nChange the value of\naria-activedescendant\non the container to refer to the element that should be reported to assistive technologies as active.\nMove the visual focus indicator and, if necessary, scrolled the active element into view.\nIf the design calls for a specific element to be focused the next time a user moves focus into the composite with\nTab\nor\nShift+Tab\n, check if\naria-activedescendant\nis referring to that target element when the container loses focus.\n              If it is not, set\naria-activedescendant\nto refer to the target element.\nThe\nspecification for\naria-activedescendant\nplaces important restrictions on the DOM relationship between the focused element that has the\naria-activedescendant\nattribute and the element referenced as active by the value of the attribute.\n            One of the following three conditions must be met.\nThe element referenced as active is a DOM descendant of the focused referencing element.\nThe focused referencing element has a value specified for the\naria-owns\nproperty that includes the ID of the element referenced as active.\nThe focused referencing element has role of\ncombobox\n,\ntextbox\n, or\nsearchbox\nand has\naria-controls\nproperty referring to an element with a role that supports\naria-activedescendant\nand either:\nThe element referenced as active is a descendant of the controlled element.\nThe controlled element has a value specified for the\naria-owns\nproperty that includes the ID of the element referenced as active.\nNote\nThis guidance focuses specifically on keyboard interaction. However, authors also need to consider pointer interactions, such as mouse clicks\n              and touchscreen taps. When a component is clicked/tapped,\n              authors should take the same steps to set the correct\ntabindex\nor\naria-activedescendant\nfor the element,\n              in the same way that they would for keyboard navigation. Otherwise, this could lead to a confusing experience for users that switch between pointer\n              and keyboard navigation, as it will lead to a mismatch.\nFocusability of disabled controls\nBy default, disabled HTML input elements are removed from the tab sequence.\n          In most contexts, the normal expectation is that disabled interactive elements are not focusable.\n          However, there are some contexts where it is common for disabled elements to be focusable, especially inside of composite widgets.\n          For example, as demonstrated in the\nmenu and menubar pattern\n,\n          disabled items are focusable when navigating through a menu with the arrow keys.\nRemoving focusability from disabled elements can offer users both advantages and disadvantages.\n          Allowing keyboard users to skip disabled elements usually reduces the number of key presses required to complete a task.\n          However, preventing focus from moving to disabled elements can hide their presence from screen reader users who \"see\" by moving the focus.\nAuthors are encouraged to adopt a consistent set of conventions for the focusability of disabled elements.\n          The examples in this guide adopt the following conventions, which both reflect common practice and attempt to balance competing concerns.\nFor elements that are in the tab sequence when enabled, remove them from the tab sequence when disabled.\nFor the following composite widget elements, keep them focusable when disabled:\nOptions in a\nListbox\nMenu items in a\nMenu or menu bar\nTab elements in a set of\nTabs\nTree items in a\nTree View\nFor elements contained in a toolbar, make them focusable if discoverability is a concern.\n            Here are two examples to aid with this judgment.\nA toolbar with buttons for moving, removing, and adding items in a list includes buttons for \"Up\", \"Down\", \"Add\", and \"Remove\".\n                The \"Up\" button is disabled and its focusability is removed when the first item in the list is selected.\n                Given the presence of the \"Down\" button, discoverability of the \"Up\" button is not a concern.\nA toolbar in an editor contains a set of special smart paste functions that are disabled when the clipboard is empty or when the function is not applicable to the current content of the clipboard.\n                It could be helpful to keep the disabled buttons focusable if the ability to discover their functionality is primarily via their presence on the toolbar.\nOne design technique for mitigating the impact of including disabled elements in the path of keyboard focus is employing appropriate keyboard shortcuts as described in\nKeyboard Shortcuts\n.\nKey Assignment Conventions for Common Functions\nThe following key assignments can be used in any context where their conventionally associated functions are appropriate.\n          While the assignments associated with Windows and Linux platforms can be implemented and used in browsers running in macOS, replacing them with macOS assignments in browsers running on a macOS device can make the keyboard interface more discoverable and intuitive for those users.\n          In some cases, it may also help avoid system or browser keyboard conflicts.\nFunction\nWindows/Linux Key\nmacOS Key\nopen context menu\nShift\n+\nF10\nCopy to clipboard\nControl\n+\nC\nCommand\n+\nC\nPaste from clipboard\nControl\n+\nV\nCommand\n+\nV\nCut to clipboard\nControl\n+\nX\nCommand\n+\nX\nundo last action\nControl\n+\nZ\nCommand\n+\nZ\nRedo action\nControl\n+\nY\nCommand\n+\nShift\n+\nZ\nKeyboard Shortcuts\nWhen effectively designed, keyboard shortcuts that focus an element, activate a widget, or both can dramatically enhance usability of frequently used features of a page or site.\n          This section addresses some of the keyboard shortcut design and implementation factors that most impact their effectiveness, including:\nUnderstanding how keyboard shortcuts augment a keyboard interface and whether to make a particular shortcut move focus, perform a function, or both.\nMaking key assignments and avoiding assignment conflicts with assistive technologies, browsers, and operating systems.\nExposing and documenting key assignments.\nDesigning the Scope and Behavior of Keyboard Shortcuts\nThis section explains the following factors when determining which elements and features to assign keyboard shortcuts and what behavior to give each shortcut:\nEnsuring discovery through navigation; keyboard shortcuts enhance, not replace, standard keyboard access.\nEffectively choosing from among the following behaviors:\nNavigation: Moving focus to an element.\nActivation: Performing an operation associated with an element that does not have focus and might not be visible.\nNavigation and activation: Both moving focus to an element and activating it.\nBalancing efficiency and cognitive load: lack of a shortcut can reduce efficiency while too many shortcuts can increase cognitive load and clutter the experience.\nEnsure Basic Access Via Navigation\nBefore assigning keyboard shortcuts, it is essential to ensure the features and functions to which shortcuts may be assigned are keyboard accessible without a keyboard shortcut.\n              In other words, all elements that could be targets for keyboard shortcuts need to be focusable via the keyboard using the methods described in:\nKeyboard Navigation Between Components\nKeyboard Navigation Inside Components\nDo not use keyboard shortcuts as a substitute for access via navigation.\n              This is essential to full keyboard access because:\nThe primary means of making functions and their shortcuts discoverable is by making the target elements focusable and revealing key assignments on the element itself.\nIf people who rely on the keyboard have to read documentation to learn which keys are required to use an interface, the interface may technically meet some accessibility standards but in practice is only accessible to the small subset of them who have the knowledge that such documentation exists, have the extra time available, and the ability to retain the necessary information.\nNot all devices that depend on keyboard interfaces can support keyboard shortcuts.\nChoose Appropriate Shortcut Behavior\nThe following conventions may help identify the most advantageous behavior for a keyboard shortcut.\nMove focus when the primary objective is to make navigation more efficient, e.g., reduce the number of times the user must press\nTab\nor the arrow keys.\n                This behavior is commonly expected when assigning a shortcut to a text box, toolbar, or composite, such as a listbox, tree, grid, or menubar.\n                This behavior is also useful for moving focus to a section of a page, such as the main content or a complementary landmark section.\nActivate an element without moving focus when the target context of the function is the context that contains the focus.\n                This behavior is most common for command buttons and for functions associated with elements that are not visible, such as a \"Save\" option that is accessible via a menu.\n                For example, if the focus is on an option in a listbox and a toolbar contains buttons for moving and removing options, it is most beneficial to keep focus in the listbox when the user presses a key shortcut for one of the buttons in the toolbar.\n                This behavior can be particularly important for screen reader users because it provides confirmation of the action performed and makes performing multiple commands more efficient.\n                For instance, when a screen reader user presses the shortcut for the \"Up\" button, the user will be able to hear the new position of the option in the list since it still has the focus.\n                Similarly, when the user presses the shortcut for deleting an option, the user can hear the next option in the list and immediately decide whether to press the delete shortcut again.\nMove focus and activate when the target of the shortcut has a single function and the context of that function is the same as the target.\n                This behavior is typical when a shortcut is assigned to a button that opens a menu or dialog, to a checkbox, or to a navigation link or button.\nChoose Where to Add Shortcuts\nWork to draft content for this section is tracked in\nissue 219.\nThe first goal when designing a keyboard interface is simple, efficient, and intuitive operation with only basic keyboard navigation support.\n              If basic operation of a keyboard interface is inefficient, attempting to compensate for fundamental design issues, such as suboptimal layout or command structure, by implementing keyboard shortcuts will not likely reduce user frustration.\n              The practical implication of this is that, in most well-designed user interfaces, the percentage of functionality that needs to be accessible via a keyboard shortcut in order to create optimal usability is not very high.\n              In many simple user interfaces, keyboard shortcuts can be entirely superfluous.\n              And, in user interfaces with too many keyboard shortcuts, the excess shortcuts create cognitive load that make the most useful ones more difficult to remember.\nConsider the following when deciding where to assign keyboard shortcuts:\nTo be written.\nAssigning Keyboard Shortcuts\nWhen choosing the keys to assign to a shortcut, there are many factors to consider.\nMaking the shortcut easy to learn and remember by using a mnemonic (e.g.,\nControl\n+\nS\nfor \"Save\") or following a logical or spacial pattern.\nLocalizing the interface, including for differences in which keys are available and how they behave and for language considerations that could impact mnemonics.\nAvoiding and managing conflicts with key assignments used by an assistive technology, the browser, or the operating system.\nMethods for designing a key shortcut scheme that supports learning and memory is beyond the scope of this guide.\n            Unless the key shortcut scheme is extensive, it is likely sufficient to mimic concepts that are familiar from common desktop software, such as browsers.\n            Similarly, while localization is important, describing how to address it is left to other resources that specialize in that topic.\nThe remainder of this section provides guidance balancing requirements and concerns related to key assignment conflicts.\n            It is typically ideal if key assignments do not conflict with keys that are assigned to functions in the user's operating system, browser, or assistive technology.\n            Conflicts can block efficient access to functions that are essential to the user, and a perfect storm of conflicts can trap a user.\n            At the same time, there are some circumstances where intentional conflicts are useful.\n            And, given the vast array of operating system, browser, and assistive technology keys, it is almost impossible to be certain conflicts do not exist.\n            So it is also important to employ strategies that mitigate the impact of conflicts whether they are intentional or unknown.\nNote\nIn the following sections,\nmeta\nkey refers to the\nWindows\nkey on Windows-compatible keyboards and the\nCommand\nkey on MacOS-compatible keyboards.\nOperating System Key Conflicts\nIt is essential to avoid conflicts with keys that perform system level functions, such as application and window management and display and sound control.\n              In general, this can be achieved by refraining from the following types of assignments.\nAny modifier keys + any of\nTab\n,\nEnter\n,\nSpace\n, or\nEscape\n.\nMeta\nkey + any other single key (there are exceptions, but they can be risky as these keys can change across versions of operating systems).\nAlt\n+ a function key.\nIn addition, there are some important application level features that most applications, including browsers, generally support.\n              These include:\nZoom\nCopy/Paste\n... to be continued ...\nAssistive Technology Key Conflicts\nEven though assistive technologies have collectively taken thousands of key assignments, avoiding conflicts is relatively easy.\n              This is because assistive technologies have had to develop key assignment schemes that avoid conflicts with both operating systems and applications.\n              They do this by hijacking specific keys as modifiers that uniquely define their key commands.\n              For example, many assistive technologies use the\nCaps Lock\nkey as a modifier.\nDeflect assistive technology key conflicts by steering clear of the following types of assignments.\nCaps Lock\n+ any other combination of keys.\nInsert\n+ any combination of other keys.\nScroll Lock\n+ any combination of other keys.\nmacOS only:\nControl\n+\nOption\n+ any combination of other keys.\nBrowser Key Conflicts\nWhile there is considerable similarity among browser keyboard schemes, the patterns within the schemes are less homogenous.\n              Consequently, it is more difficult to avoid conflicts with browser key assignments.\n              While the impact of conflicts is sometimes mitigated by the availability of two paths to nearly every function -- keyboard accessible menus and keyboard shortcuts, avoiding conflicts with shortcuts to heavily used functions is nonetheless important.\n              Pay special attention to avoiding conflicts with shortcuts to:\nAddress or location bar\nNotification bar\nPage refresh\nBookmark and history functions\nFind functions\nIntentional Key Conflicts\nWhile avoiding key conflicts is usually desirable, there are circumstances where intentionally conflicting with a browser function is acceptable or even desirable.\n              This can occur when the following combination of conditions arises:\nA web application has a frequently used function that is similar to a browser function.\nUsers will often want to execute the web application function.\nUsers will rarely execute the browser function.\nThere is an efficient, alternative path to the browser function.\nFor example, consider a save function that is available when the focus is in an editor.\n              Most browsers use ... to be continued ...",
  "content_markdown": "Developing a Keyboard Interface\n\n## Introduction\n\nUnlike native HTML form elements, browsers do not provide keyboard support for graphical user interface (GUI) components that are made accessible with ARIA; authors have to provide the keyboard support in their code.\nThis section describes the principles and methods for making the functionality of a web page that includes ARIA widgets, such as menus and grids, as well as interactive components, such as toolbars and dialogs, operable with a keyboard.\nAlong with the basics of focus management, this section offers guidance toward the objective of providing experiences to people who rely on a keyboard that are as efficient and enjoyable as the experiences available to others.\n\nThis section covers:\n\n1. Understanding fundamental principles of focus movement conventions used in ARIA design patterns.\n2. Maintaining visible focus, predictable focus movement, and distinguishing between keyboard focus and the selected state.\n3. Managing movement of keyboard focus between components, e.g., how the focus moves when the `Tab` and `Shift` + `Tab` keys are pressed.\n4. Managing movement of keyboard focus inside components that contain multiple focusable elements, e.g., two different methods for programmatically exposing focus inside widgets like radio groups, menus, listboxes, trees, and grids.\n5. Determining when to make disabled interactive elements focusable.\n6. Assigning and revealing keyboard shortcuts, including guidance on how to avoid problematic conflicts with keyboard commands of assistive technologies, browsers, and operating systems.\n\n## Fundamental Keyboard Navigation Conventions\n\nARIA roles, states, and properties model accessibility behaviors and features shared among GUI components of popular desktop GUIs, including Microsoft Windows, macOS, and GNOME.\nSimilarly, ARIA design patterns borrow user expectations and keyboard conventions from those platforms, consistently incorporating common conventions with the aim of facilitating easy learning and efficient operation of keyboard interfaces across the web.\n\nFor a web page to be accessible, all interactive elements must be operable via the keyboard.\nIn addition, consistent application of the common GUI keyboard interface conventions described in the [APG patterns](../../patterns/) is important, especially for assistive technology users.\nConsider, for example, a screen reader user operating a tree.\nJust as familiar visual styling helps users discover how to expand a tree branch with a mouse, ARIA attributes give the tree the sound and feel of a tree in a desktop application.\nSo, screen reader users will commonly expect that pressing the right arrow key will expand a collapsed node.\nBecause the screen reader knows the element is a tree, it also has the ability to instruct a novice user how to operate it.\nSimilarly, voice recognition software can implement commands for expanding and collapsing branches because it recognizes the element as a tree and can execute appropriate keyboard commands.\nAll this is only possible if the tree implements the GUI keyboard conventions as described in the [Tree View Pattern](../../patterns/treeview/).\n\nA primary keyboard navigation convention common across all platforms is that the `tab` and `shift` + `tab` keys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements.\nThe path that the focus follows when pressing the `tab` key is known as the tab sequence or tab ring.\n\nCommon examples of UI components that contain multiple focusable elements are radio groups, tablists, menus, and grids.\nA radio group, for example, contains multiple radio buttons, each of which is focusable.\nHowever, only one of the radio buttons is included in the tab sequence.\nAfter pressing the `Tab` key moves focus to a radio button in the group, pressing arrow keys moves focus among the radio buttons in the group, and pressing the `Tab` key moves focus out of the radio group to the next element in the tab sequence.\n\nThe ARIA specification refers to a discrete UI component that contains multiple focusable elements as a [composite](https://w3c.github.io/aria/#composite) widget.\nThe process of controlling focus movement inside a composite is called managing focus.\nFollowing are some ARIA design patterns with example implementations that demonstrate focus management:\n\n- [Combobox](../../patterns/combobox/)\n- [Grid](../../patterns/grid/)\n- [Listbox](../../patterns/listbox/)\n- [Menu and Menubar](../../patterns/menubar/)\n- [Radio Group](../../patterns/radio/)\n- [Tabs](../../patterns/tabs/)\n- [Toolbar](../../patterns/toolbar/)\n- [Treegrid](../../patterns/treegrid/)\n- [Tree View](../../patterns/treeview/)\n\n## Discernible and Predictable Keyboard Focus\n\nWork to complete this section is tracked by [issue 217.](https://github.com/w3c/aria-practices/issues/217)\n\nWhen operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed.\nThe following factors affect to what extent a web page affords users these capabilities.\n\n1. Visibility of the focus indicator: Users need to be able to easily distinguish the keyboard focus indicator from other features of the visual design.\n   Just as a mouse user may move the mouse to help find the mouse pointer, a keyboard user may press a navigation key to watch for movement.\n   If visual changes in response to focus movement are subtle, many users will lose track of focus and be unable to operate.\n   Authors are advised to rely on the default focus indicators provided by browsers.\n   If overriding the default, consider:\n   - something about ... Colors and gradients can disappear in high contrast modes.\n   - Users need to be able to easily distinguish between focus and selection as described in [Focus VS Selection and the Perception of Dual Focus](#kbd_focus_vs_selection), especially when a component that contains selected elements does not contain the focus.\n   - ... other considerations to be added ...\n2. Persistence of focus: It is essential that there is always a component within the user interface that is active (document.activeElement is not null or is not the body element) and that the active element has a visual focus indicator.\n   Authors need to manage events that effect the currently active element so focus remains visible and moves logically.\n   For example, if the user closes a dialog or performs a destructive operation like deleting an item from a list, the active element may be hidden or removed from the DOM.\n   If such events are not managed to set focus on the button that triggered the dialog or on the list item following the deleted item, browsers move focus to the body element, effectively causing a loss of focus within the user interface.\n3. Predictability of movement: Usability of a keyboard interface is heavily influenced by how readily users can guess where focus will land after a navigation key is pressed.\n   Some possible approaches to optimizing predictability include:\n   - Move focus in a pattern that matches the reading order of the page's language.\n     In left to right languages, for example, create a tab sequence that moves focus left to right and then top to bottom.\n   - Incorporate all elements of a section of the page in the tab sequence before moving focus to another section.\n     For instance, in a page with multiple columns that has content in a left side bar, center region, and right side bar, build a tab sequence that covers all elements in the left sidebar before focus moves to the first focusable element in the center column.\n   - When the distance between two consecutive elements in the tab sequence is significant, avoid movement that would be perceived as backward.\n     For example, on a page with a left to right language, a jump from the last element in the bottom right of the main content to the top element in a left-hand sidebar is likely to be less predictable and more difficult to follow, especially for users with a narrow field of view.\n   - Follow consistent patterns across a site.\n     The keyboard experience is more predictable when similar pages have similar focus movement patterns.\n   - Do not set initial focus when the page loads except in cases where:\n     - The page offers a single, primary function that nearly all users employ immediately after page load.\n     - Any given user is likely to use the page often.\n\n## Focus VS Selection and the Perception of Dual Focus\n\nOccasionally, it may appear as if two elements on the page have focus at the same time.\nFor example, in a multi-select list box, when an option is selected it may be greyed.\nYet, the focus indicator can still be moved to other options, which may also be selected.\nSimilarly, when a user activates a tab in a tablist, the selected state is set on the tab and its visual appearance changes.\nHowever, the user can still navigate, moving the focus indicator elsewhere on the page while the tab retains its selected appearance and state.\n\nFocus and selection are quite different.\nFrom the keyboard user's perspective, focus is a pointer, like a mouse pointer; it tracks the path of navigation.\nThere is only one point of focus at any time and all operations take place at the point of focus.\nOn the other hand, selection is an operation that can be performed in some widgets, such as list boxes, trees, and tablists.\nIf a widget supports only single selection, then only one item can be selected and very often the selected state will simply follow the focus when focus is moved inside of the widget.\nThat is, in some widgets, moving focus may also perform the select operation.\nHowever, if the widget supports multiple selection, then more than one item can be in a selected state, and keys for moving focus do not perform selection.\nSome multi-select widgets do support key commands that both move focus and change selection, but those keys are different from the normal navigation keys.\nFinally, when focus leaves a widget that includes a selected element, the selected state persists.\n\nFrom the developer's perspective, the difference is simple -- the focused element is the active element (document.activeElement).\nSelected elements are elements that have `aria-selected=\"true\"`.\n\nWith respect to focus and the selected state, the most important considerations for designers and developers are:\n\n- The visual focus indicator must always be visible.\n- The selected state must be visually distinct from the focus indicator.\n\n## Deciding When to Make Selection Automatically Follow Focus\n\nIn composite widgets where only one element may be selected, such as a tablist or single-select listbox, moving the focus may also cause the focused element to become the selected element.\nThis is called having selection follow focus.\nHaving selection follow focus is often beneficial to users, but in some circumstances, it is extremely detrimental to accessibility.\n\nFor example, in a tablist, the selected state is used to indicate which panel is displayed.\nSo, when selection follows focus in a tablist, moving focus from one tab to another automatically changes which panel is displayed.\nIf the content of panels is present in the DOM, then displaying a new panel is nearly instantaneous.\nA keyboard user who wishes to display the fourth of six tabs can do so with 3 quick presses of the right arrow.\nAnd, a screen reader user who perceives the labels on tabs by navigating through them may efficiently read through the complete list without any latency.\n\nHowever, if displaying a new panel causes a network request and possibly a page refresh, the effect of having selection automatically focus can be devastating to the experience for keyboard and screen reader users.\nIn this case, displaying the fourth tab or reading through the list becomes a tedious and time-consuming task as the user experiences significant latency with each movement of focus.\nFurther, if displaying a new tab refreshes the page, then the user not only has to wait for the new page to load but also return focus to the tab list.\n\nWhen selection does not follow focus, the user changes which element is selected by pressing the `Enter` or `Space` key.\n\n## Keyboard Navigation Between Components (The Tab Sequence)\n\nAs explained in section [Fundamental Keyboard Navigation Conventions](#kbd_generalnav), all interactive UI components need to be reachable via the keyboard.\nThis is best achieved by either including them in the tab sequence or by making them accessible from a component that is in the tab sequence, e.g., as part of a composite component.\nThis section addresses building and managing the tab sequence, and subsequent sections cover making focusable elements that are contained within components keyboard accessible.\n\nThe [HTML `tabindex`](https://html.spec.whatwg.org/multipage/interaction.html#the-tabindex-attribute)\nand [SVG2 `tabindex`](https://www.w3.org/TR/SVG2/struct.html#tabindexattribute)\nattributes can be used to add and remove elements from the tab sequence.\nThe value of `tabindex` can also influence the order of the tab sequence, although authors are strongly advised not to use `tabindex` for that purpose.\n\nIn HTML, the default tab sequence of a web page includes only links and HTML form elements, except In macOS, where it includes only form elements.\nmacOS system preferences include a keyboard setting that enables the tab key to move focus to all focusable elements.\n\nThe default order of elements in the tab sequence is the order of elements in the DOM.\nThe DOM order also determines screen reader reading order.\nIt is important to keep the keyboard tab sequence and the screen reader reading order aligned, logical, and predictable as described in [Discernible and Predictable Keyboard Focus](#kbd_focus_discernable_predictable).\nThe most robust method of manipulating the order of the tab sequence while also maintaining alignment with the reading order that is currently available in all browsers is rearranging elements in the DOM.\n\nThe values of the `tabindex` attribute have the following effects.\n\n`tabindex` is not present or does not have a valid value\n:   The element has its default focus behavior.\n    In HTML, only form controls and anchors with an HREF attribute are included in the tab sequence.\n\n`tabindex=\"0\"`\n:   The element is included in the tab sequence based on its position in the DOM.\n\n`tabindex=\"-1\"`\n:   The element is not included in the tab sequence but is focusable with element.focus().\n\n`tabindex=\"X\"` where `X` is an integer in the range `1 <= X <= 32767`\n:   Authors are strongly advised NOT to use these values.\n    The element is placed in the tab sequence based on the value of `tabindex`.\n    Elements with a `tabindex` value of 0 and elements that are focusable by default will be in the sequence after elements with a `tabindex` value of `1` or greater.\n\n## Keyboard Navigation Inside Components\n\nAs described in section [Fundamental Keyboard Navigation Conventions](#kbd_generalnav), the tab sequence should include only one focusable element of a composite UI component.\nOnce a composite contains focus, keys other than `Tab` and `Shift` + `Tab` enable the user to move focus among its focusable elements.\nAuthors are free to choose which keys move focus inside of a composite, but they are strongly advised to use the same key bindings as similar components in common GUI operating systems as demonstrated in [APG Patterns](../../patterns/).\n\nThe convention for where focus lands in a composite when it receives focus as a result of a `Tab` key event depends on the type of composite.\nIt is typically one of the following.\n\n- The element that had focus the last time the composite contained focus.\n  Or, if the composite has not yet contained the focus, the first element.\n  Widgets that usually employ this pattern include grid and tree grid.\n- The selected element.\n  Or, if there is no selected element, the first element.\n  Widgets where this pattern is commonly implemented include radio groups, tabs, list boxes, and trees.\n  Note: For radio groups, this pattern is referring to the checked radio button; the selected state is not supported for radio buttons.\n- The first element.\n  Components that typically follow this pattern include menubars and toolbars.\n\nThe following sections explain two strategies for managing focus inside composite elements: creating a roving `tabindex` and using the `aria-activedescendant` property.\n\n### Managing Focus Within Components Using a Roving `tabindex`\n\nWhen using roving `tabindex` to manage focus in a composite UI component, the element that is to be included in the tab sequence has `tabindex=\"0\"` and all other focusable elements contained in the composite have `tabindex=\"-1\"`.\nThe algorithm for the roving `tabindex` strategy is as follows.\n\n- When the component container is loaded or created, set `tabindex=\"0\"` on the element that will initially be included in the tab sequence and set `tabindex=\"-1\"` on all other focusable elements it contains.\n- When the component contains focus and the user presses a navigation key that moves focus within the component, such as an arrow key:\n  - set `tabindex=\"-1\"` on the element that has `tabindex=\"0\"`.\n  - Set `tabindex=\"0\"` on the element that will become focused as a result of the key event.\n  - Set focus, `element.focus()`, on the element that has `tabindex=\"0\"`.\n- If the design calls for a specific element to be focused the next time the user moves focus into the composite with `Tab` or `Shift` + `Tab`, check if that target element has `tabindex=\"0\"` when the composite loses focus.\n  If it does not, set `tabindex=\"0\"` on the target element and set `tabindex=\"-1\"` on the element that previously had `tabindex=\"0\"`.\n\nOne benefit of using roving `tabindex` rather than `aria-activedescendant` to manage focus is that the user agent will scroll the newly focused element into view.\n\n### Managing Focus in Composites Using `aria-activedescendant`\n\nIf a component container has an ARIA role that supports the [aria-activedescendant](https://w3c.github.io/aria/#aria-activedescendant) property, it is not necessary to manipulate the `tabindex` attribute and move DOM focus among focusable elements within the container.\nInstead, only the container element needs to be included in the tab sequence.\nWhen the container has DOM focus, the value of `aria-activedescendant` on the container tells assistive technologies which element is active within the widget.\nAssistive technologies will consider the element referred to as active to be the focused element even though DOM focus is on the element that has the `aria-activedescendant` property.\nAnd, when the value of `aria-activedescendant` is changed, assistive technologies will receive focus change events equivalent to those received when DOM focus actually moves.\n\nThe steps for using the `aria-activedescendant` method of managing focus are as follows.\n\n- When the container element that has a role that supports `aria-activedescendant` is loaded or created, ensure that:\n  - The container element is included in the tab sequence as described in [Keyboard Navigation Between Components](#kbd_general_between) or is a focusable element of a composite that implements [a roving `tabindex`](#kbd_roving_tabindex).\n  - It has `aria-activedescendant=\"IDREF\"` where `IDREF` is the `id` of the element within the container that should be identified as active when the widget receives focus.\n    The referenced element needs to meet the DOM relationship requirements described below.\n- When the container element receives DOM focus, draw a visual focus indicator on the active element and ensure the active element is scrolled into view.\n- When the composite widget contains focus and the user presses a navigation key that moves focus within the widget, such as an arrow key:\n  - Change the value of `aria-activedescendant` on the container to refer to the element that should be reported to assistive technologies as active.\n  - Move the visual focus indicator and, if necessary, scrolled the active element into view.\n- If the design calls for a specific element to be focused the next time a user moves focus into the composite with `Tab` or `Shift+Tab`, check if `aria-activedescendant` is referring to that target element when the container loses focus.\n  If it is not, set `aria-activedescendant` to refer to the target element.\n\nThe [specification for `aria-activedescendant`](https://w3c.github.io/aria/#aria-activedescendant) places important restrictions on the DOM relationship between the focused element that has the `aria-activedescendant` attribute and the element referenced as active by the value of the attribute.\nOne of the following three conditions must be met.\n\n1. The element referenced as active is a DOM descendant of the focused referencing element.\n2. The focused referencing element has a value specified for the [aria-owns](https://w3c.github.io/aria/#aria-owns) property that includes the ID of the element referenced as active.\n3. The focused referencing element has role of [combobox](https://w3c.github.io/aria/#combobox), [textbox](https://w3c.github.io/aria/#textbox), or [searchbox](https://w3c.github.io/aria/#searchbox) and has [aria-controls](https://w3c.github.io/aria/#aria-controls) property referring to an element with a role that supports `aria-activedescendant` and either:\n   1. The element referenced as active is a descendant of the controlled element.\n   2. The controlled element has a value specified for the [aria-owns](https://w3c.github.io/aria/#aria-owns) property that includes the ID of the element referenced as active.\n\n#### Note\n\nThis guidance focuses specifically on keyboard interaction. However, authors also need to consider pointer interactions, such as mouse clicks\nand touchscreen taps. When a component is clicked/tapped,\nauthors should take the same steps to set the correct `tabindex` or `aria-activedescendant` for the element,\nin the same way that they would for keyboard navigation. Otherwise, this could lead to a confusing experience for users that switch between pointer\nand keyboard navigation, as it will lead to a mismatch.\n\n## Focusability of disabled controls\n\nBy default, disabled HTML input elements are removed from the tab sequence.\nIn most contexts, the normal expectation is that disabled interactive elements are not focusable.\nHowever, there are some contexts where it is common for disabled elements to be focusable, especially inside of composite widgets.\nFor example, as demonstrated in the\n[menu and menubar pattern](../../patterns/menubar/),\ndisabled items are focusable when navigating through a menu with the arrow keys.\n\nRemoving focusability from disabled elements can offer users both advantages and disadvantages.\nAllowing keyboard users to skip disabled elements usually reduces the number of key presses required to complete a task.\nHowever, preventing focus from moving to disabled elements can hide their presence from screen reader users who \"see\" by moving the focus.\n\nAuthors are encouraged to adopt a consistent set of conventions for the focusability of disabled elements.\nThe examples in this guide adopt the following conventions, which both reflect common practice and attempt to balance competing concerns.\n\n1. For elements that are in the tab sequence when enabled, remove them from the tab sequence when disabled.\n2. For the following composite widget elements, keep them focusable when disabled:\n   - Options in a [Listbox](../../patterns/listbox/)\n   - Menu items in a [Menu or menu bar](../../patterns/menubar/)\n   - Tab elements in a set of [Tabs](../../patterns/tabs/)\n   - Tree items in a [Tree View](../../patterns/treeview/)\n3. For elements contained in a toolbar, make them focusable if discoverability is a concern.\n   Here are two examples to aid with this judgment.\n   1. A toolbar with buttons for moving, removing, and adding items in a list includes buttons for \"Up\", \"Down\", \"Add\", and \"Remove\".\n      The \"Up\" button is disabled and its focusability is removed when the first item in the list is selected.\n      Given the presence of the \"Down\" button, discoverability of the \"Up\" button is not a concern.\n   2. A toolbar in an editor contains a set of special smart paste functions that are disabled when the clipboard is empty or when the function is not applicable to the current content of the clipboard.\n      It could be helpful to keep the disabled buttons focusable if the ability to discover their functionality is primarily via their presence on the toolbar.\n\nOne design technique for mitigating the impact of including disabled elements in the path of keyboard focus is employing appropriate keyboard shortcuts as described in [Keyboard Shortcuts](#kbd_shortcuts).\n\n## Key Assignment Conventions for Common Functions\n\nThe following key assignments can be used in any context where their conventionally associated functions are appropriate.\nWhile the assignments associated with Windows and Linux platforms can be implemented and used in browsers running in macOS, replacing them with macOS assignments in browsers running on a macOS device can make the keyboard interface more discoverable and intuitive for those users.\nIn some cases, it may also help avoid system or browser keyboard conflicts.\n\n| Function | Windows/Linux Key | macOS Key |\n| --- | --- | --- |\n| open context menu | `Shift` + `F10` |  |\n| Copy to clipboard | `Control` + `C` | `Command` + `C` |\n| Paste from clipboard | `Control` + `V` | `Command` + `V` |\n| Cut to clipboard | `Control` + `X` | `Command` + `X` |\n| undo last action | `Control` + `Z` | `Command` + `Z` |\n| Redo action | `Control` + `Y` | `Command` + `Shift` + `Z` |\n\n## Keyboard Shortcuts\n\nWhen effectively designed, keyboard shortcuts that focus an element, activate a widget, or both can dramatically enhance usability of frequently used features of a page or site.\nThis section addresses some of the keyboard shortcut design and implementation factors that most impact their effectiveness, including:\n\n1. Understanding how keyboard shortcuts augment a keyboard interface and whether to make a particular shortcut move focus, perform a function, or both.\n2. Making key assignments and avoiding assignment conflicts with assistive technologies, browsers, and operating systems.\n3. Exposing and documenting key assignments.\n\n### Designing the Scope and Behavior of Keyboard Shortcuts\n\nThis section explains the following factors when determining which elements and features to assign keyboard shortcuts and what behavior to give each shortcut:\n\n1. Ensuring discovery through navigation; keyboard shortcuts enhance, not replace, standard keyboard access.\n2. Effectively choosing from among the following behaviors:\n   1. Navigation: Moving focus to an element.\n   2. Activation: Performing an operation associated with an element that does not have focus and might not be visible.\n   3. Navigation and activation: Both moving focus to an element and activating it.\n3. Balancing efficiency and cognitive load: lack of a shortcut can reduce efficiency while too many shortcuts can increase cognitive load and clutter the experience.\n\n#### Ensure Basic Access Via Navigation\n\nBefore assigning keyboard shortcuts, it is essential to ensure the features and functions to which shortcuts may be assigned are keyboard accessible without a keyboard shortcut.\nIn other words, all elements that could be targets for keyboard shortcuts need to be focusable via the keyboard using the methods described in:\n\n- [Keyboard Navigation Between Components](#kbd_general_between)\n- [Keyboard Navigation Inside Components](#kbd_general_within)\n\nDo not use keyboard shortcuts as a substitute for access via navigation.\nThis is essential to full keyboard access because:\n\n1. The primary means of making functions and their shortcuts discoverable is by making the target elements focusable and revealing key assignments on the element itself.\n2. If people who rely on the keyboard have to read documentation to learn which keys are required to use an interface, the interface may technically meet some accessibility standards but in practice is only accessible to the small subset of them who have the knowledge that such documentation exists, have the extra time available, and the ability to retain the necessary information.\n3. Not all devices that depend on keyboard interfaces can support keyboard shortcuts.\n\n#### Choose Appropriate Shortcut Behavior\n\nThe following conventions may help identify the most advantageous behavior for a keyboard shortcut.\n\n- Move focus when the primary objective is to make navigation more efficient, e.g., reduce the number of times the user must press `Tab` or the arrow keys.\n  This behavior is commonly expected when assigning a shortcut to a text box, toolbar, or composite, such as a listbox, tree, grid, or menubar.\n  This behavior is also useful for moving focus to a section of a page, such as the main content or a complementary landmark section.\n- Activate an element without moving focus when the target context of the function is the context that contains the focus.\n  This behavior is most common for command buttons and for functions associated with elements that are not visible, such as a \"Save\" option that is accessible via a menu.\n  For example, if the focus is on an option in a listbox and a toolbar contains buttons for moving and removing options, it is most beneficial to keep focus in the listbox when the user presses a key shortcut for one of the buttons in the toolbar.\n  This behavior can be particularly important for screen reader users because it provides confirmation of the action performed and makes performing multiple commands more efficient.\n  For instance, when a screen reader user presses the shortcut for the \"Up\" button, the user will be able to hear the new position of the option in the list since it still has the focus.\n  Similarly, when the user presses the shortcut for deleting an option, the user can hear the next option in the list and immediately decide whether to press the delete shortcut again.\n- Move focus and activate when the target of the shortcut has a single function and the context of that function is the same as the target.\n  This behavior is typical when a shortcut is assigned to a button that opens a menu or dialog, to a checkbox, or to a navigation link or button.\n\n#### Choose Where to Add Shortcuts\n\nWork to draft content for this section is tracked in [issue 219.](https://github.com/w3c/aria-practices/issues/219)\n\nThe first goal when designing a keyboard interface is simple, efficient, and intuitive operation with only basic keyboard navigation support.\nIf basic operation of a keyboard interface is inefficient, attempting to compensate for fundamental design issues, such as suboptimal layout or command structure, by implementing keyboard shortcuts will not likely reduce user frustration.\nThe practical implication of this is that, in most well-designed user interfaces, the percentage of functionality that needs to be accessible via a keyboard shortcut in order to create optimal usability is not very high.\nIn many simple user interfaces, keyboard shortcuts can be entirely superfluous.\nAnd, in user interfaces with too many keyboard shortcuts, the excess shortcuts create cognitive load that make the most useful ones more difficult to remember.\n\nConsider the following when deciding where to assign keyboard shortcuts:\n\n1. To be written.\n\n### Assigning Keyboard Shortcuts\n\nWhen choosing the keys to assign to a shortcut, there are many factors to consider.\n\n- Making the shortcut easy to learn and remember by using a mnemonic (e.g., `Control` + `S` for \"Save\") or following a logical or spacial pattern.\n- Localizing the interface, including for differences in which keys are available and how they behave and for language considerations that could impact mnemonics.\n- Avoiding and managing conflicts with key assignments used by an assistive technology, the browser, or the operating system.\n\nMethods for designing a key shortcut scheme that supports learning and memory is beyond the scope of this guide.\nUnless the key shortcut scheme is extensive, it is likely sufficient to mimic concepts that are familiar from common desktop software, such as browsers.\nSimilarly, while localization is important, describing how to address it is left to other resources that specialize in that topic.\n\nThe remainder of this section provides guidance balancing requirements and concerns related to key assignment conflicts.\nIt is typically ideal if key assignments do not conflict with keys that are assigned to functions in the user's operating system, browser, or assistive technology.\nConflicts can block efficient access to functions that are essential to the user, and a perfect storm of conflicts can trap a user.\nAt the same time, there are some circumstances where intentional conflicts are useful.\nAnd, given the vast array of operating system, browser, and assistive technology keys, it is almost impossible to be certain conflicts do not exist.\nSo it is also important to employ strategies that mitigate the impact of conflicts whether they are intentional or unknown.\n\n#### Note\n\nIn the following sections, `meta` key refers to the `Windows` key on Windows-compatible keyboards and the `Command` key on MacOS-compatible keyboards.\n\n#### Operating System Key Conflicts\n\nIt is essential to avoid conflicts with keys that perform system level functions, such as application and window management and display and sound control.\nIn general, this can be achieved by refraining from the following types of assignments.\n\n1. Any modifier keys + any of `Tab`, `Enter`, `Space`, or `Escape`.\n2. `Meta` key + any other single key (there are exceptions, but they can be risky as these keys can change across versions of operating systems).\n3. `Alt` + a function key.\n\nIn addition, there are some important application level features that most applications, including browsers, generally support.\nThese include:\n\n1. Zoom\n2. Copy/Paste\n3. ... to be continued ...\n\n#### Assistive Technology Key Conflicts\n\nEven though assistive technologies have collectively taken thousands of key assignments, avoiding conflicts is relatively easy.\nThis is because assistive technologies have had to develop key assignment schemes that avoid conflicts with both operating systems and applications.\nThey do this by hijacking specific keys as modifiers that uniquely define their key commands.\nFor example, many assistive technologies use the `Caps Lock` key as a modifier.\n\nDeflect assistive technology key conflicts by steering clear of the following types of assignments.\n\n1. `Caps Lock` + any other combination of keys.\n2. `Insert` + any combination of other keys.\n3. `Scroll Lock` + any combination of other keys.\n4. macOS only: `Control` + `Option` + any combination of other keys.\n\n#### Browser Key Conflicts\n\nWhile there is considerable similarity among browser keyboard schemes, the patterns within the schemes are less homogenous.\nConsequently, it is more difficult to avoid conflicts with browser key assignments.\nWhile the impact of conflicts is sometimes mitigated by the availability of two paths to nearly every function -- keyboard accessible menus and keyboard shortcuts, avoiding conflicts with shortcuts to heavily used functions is nonetheless important.\nPay special attention to avoiding conflicts with shortcuts to:\n\n1. Address or location bar\n2. Notification bar\n3. Page refresh\n4. Bookmark and history functions\n5. Find functions\n\n#### Intentional Key Conflicts\n\nWhile avoiding key conflicts is usually desirable, there are circumstances where intentionally conflicting with a browser function is acceptable or even desirable.\nThis can occur when the following combination of conditions arises:\n\n- A web application has a frequently used function that is similar to a browser function.\n- Users will often want to execute the web application function.\n- Users will rarely execute the browser function.\n- There is an efficient, alternative path to the browser function.\n\nFor example, consider a save function that is available when the focus is in an editor.\nMost browsers use ... to be continued ...",
  "tags": [
    "aria",
    "accessibility",
    "patterns",
    "w3c"
  ],
  "extracted_at": "2026-02-03T14:23:27.315572+00:00",
  "content_length": 35705,
  "content_hash": "e3b9d0b3c4ef19c2"
}