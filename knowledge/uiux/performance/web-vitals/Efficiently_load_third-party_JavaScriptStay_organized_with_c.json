{
  "id": "web-vitals__articles_efficiently-load-third-party-javascript",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/efficiently-load-third-party-javascript",
  "title": "Efficiently load third-party JavaScriptStay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nEfficiently load third-party JavaScript\nStay organized with collections\nSave and categorize content based on your preferences.\nMilica Mihajlija\nIf a third-party script is\nslowing down\nyour\npage load, you have two options to improve performance:\nRemove it if it doesn't add clear value to your site.\nOptimize the loading process.\nThis post explains how to optimize the loading process of third-party scripts\nwith the following techniques:\nUsing the\nasync\nor\ndefer\nattribute on\n<script>\ntags\nEstablishing early connections to required origins\nLazy loading\nOptimizing how you serve third-party scripts\nUse\nasync\nor\ndefer\nBecause\nsynchronous scripts\ndelay DOM\nconstruction and rendering, you should always load third-party scripts\nasynchronously unless the script has to run before the page can be rendered.\nThe\nasync\nand\ndefer\nattributes tell the browser that it can go on parsing\nthe HTML while loading the script in the background, then execute the script\nafter it loads. This way, script downloads don't block DOM construction or page\nrendering, letting the user see the page before all scripts have finished\nloading.\n<script async src=\"script.js\">\n\n<script defer src=\"script.js\">\nThe difference between\nasync\nand\ndefer\nattributes is when the browser\nexecutes the scripts.\nasync\nScripts with the\nasync\nattribute execute at the first opportunity after they\nfinish downloading and before the window's\nload\nevent. This means\nit's possible (and likely) that\nasync\nscripts won't run in the order in which\nthey appear in the HTML. It also means they can interrupt DOM building if they\nfinish downloading while the parser is still at work.\nScripts with\nasync\ncan still block\n  HTML parsing.\ndefer\nScripts with the\ndefer\nattribute execute after HTML parsing is completely\nfinished, but before the\nDOMContentLoaded\nevent.\ndefer\nensures that scripts run in the order they appear in the HTML and\ndon't block the parser.\nScripts with\ndefer\nwait to run until\n  the browser is done parsing the HTML.\nUse\nasync\nif it's important to have the script run earlier in the loading\nprocess.\nUse\ndefer\nfor less critical resources, such as a video player that's below\nthe fold.\nUsing these attributes can significantly speed up page load. For example,\nTelegraph deferred all their scripts\n,\nincluding ads and analytics, and improved the ad loading time by an average of\nfour seconds.\nEstablish early connections to required origins\nYou can save 100\u2013500 ms by\nestablishing early connections\nto\nimportant third-party origins.\nTwo\n<link>\ntypes,\npreconnect\nand\ndns-prefetch\n, can help here:\npreconnect\n<link rel=\"preconnect\">\ntells the browser that your page wants to establish a\nconnection to another origin, and that you'd like the process to start as soon\nas possible. When the browser requests a resource from the pre-connected origin,\nthe download starts immediately.\n<link rel=\"preconnect\" href=\"https://cdn.example.com\">\ndns-prefetch\n<link rel=\"dns-prefetch>\nhandles a small subset of what\n<link rel=\"preconnect\">\nhandles. Establishing a connection involves the DNS\nlookup and TCP handshake, and for secure origins, TLS negotiations.\ndns-prefetch\ntells the browser to only resolve the DNS of a specific domain before it has been explicitly called.\nThe\npreconnect\nhint is best used for only the most critical connections. For\nless important third-party domains, use\n<link rel=dns-prefetch>\n.\n<link rel=\"dns-prefetch\" href=\"http://example.com\">\nBrowser support for\ndns-prefetch\nis slightly different from\npreconnect\nsupport\n,\nso\ndns-prefetch\ncan serve as a fallback for browsers that don't support\npreconnect\n. Use separate link tags to implement this safely:\n<link rel=\"preconnect\" href=\"http://example.com\">\n<link rel=\"dns-prefetch\" href=\"http://example.com\">\nLazy-load third-party resources\nEmbedded third-party resources can significantly slow down page loading if\nthey're constructed poorly. If they aren't critical, or are below the fold\n(that is, if users have to scroll to view them), lazy loading is a good way to\nimprove page speed and paint metrics. This way, users get the main page content\nfaster and have a better experience.\nLazy load content below the fold.\nOne effective approach is to lazy-load third-party content after the main page\ncontent loads. Ads are a good candidate for this approach.\nAds are an important source of income for many sites, but users come for the\ncontent. By lazy loading ads and delivering the main content faster, you can\nincrease the overall viewability percentage of an ad. For example, MediaVine\nswitched to\nlazy-loading ads\nand saw a 200% improvement in page load speed. Google Ad Manager has documentation\non how to\nlazy load ads\n.\nYou can also set third-party content to load only when users first scroll to\nthat section of the page.\nIntersection Observer\nis a browser API that efficiently detects when an element enters or exits the\nbrowser's viewport, and you can use it to implement this technique.\nlazysizes\nis a popular JavaScript library\nfor lazy loading images and\niframes\n.\nIt supports YouTube embeds and\nwidgets\n.\nIt also has\noptional support\nfor Intersection Observer.\nUsing the\nloading\nattribute for lazy loading images and iframes\nis a great alternative to JavaScript techniques, and it has recently become\navailable in Chrome 76!\nOptimize how you serve third-party scripts\nThe following are some recommended strategies for optimizing your use of\nthird-party scripts.\nThird-party CDN hosting\nIt's common for third-party vendors to provide URLs for JavaScript files they\nhost, usually on a\ncontent delivery network (CDN)\n.\nThe benefits of this approach are that you can get started quickly\u2014just\ncopy and paste the URL\u2014and there's no maintenance overhead. The\nthird-party vendor handles server configuration and script updates.\nBut because they aren't on the same origin as the rest of your resources,\nloading files from a public CDN comes with a network cost. The browser needs to\nperform a DNS lookup, establish a new HTTP connection, and, on secure origins,\nperform an SSL handshake with the vendor's server.\nWhen you use files from third-party servers, you rarely have control over\ncaching. Relying on someone else's caching strategy might cause scripts to be\nunnecessarily re-fetched from the network too often.\nSelf-host third-party scripts\nSelf-hosting third-party scripts is an option that gives you more control over a\nscript's loading process. By self-hosting you can:\nReduce DNS lookup and round-trip times.\nImprove\nHTTP caching\nheaders.\nTake advantage of\nHTTP/2\n, or the newer HTTP/3.\nFor example, Casper managed to\nshave 1.7 seconds\noff load times by self-hosting an A/B testing script.\nSelf-hosting comes with one big downside though: scripts can go out of date and\nwon't get automatic updates when there's an API change or a security fix.\nUse service workers to cache scripts from third-party servers\nYou can use\nservice workers to cache scripts from third-party servers\nas an alternative to self-hosting. This gives you greater control over caching,\nwhile retaining the benefits of third-party CDNs.\nYou can control how often scripts are re-fetched from the network and\ncreate a loading strategy that throttles requests for non-essential,\nthird-party resources until a user arrives at a key interaction on the page.\nWith\npreconnect\n, you can establish early connections and also help\nmitigate the network costs.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2019-08-14 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Efficiently load third-party JavaScript Stay organized with collections Save and categorize content based on your preferences.\n\n![Milica Mihajlija](https://web.dev/images/authors/mihajlija.jpg)\n\nMilica Mihajlija\n\nIf a third-party script is [slowing down](/articles/third-party-javascript) your\npage load, you have two options to improve performance:\n\n- Remove it if it doesn't add clear value to your site.\n- Optimize the loading process.\n\nThis post explains how to optimize the loading process of third-party scripts\nwith the following techniques:\n\n- Using the `async` or `defer` attribute on `<script>` tags\n- Establishing early connections to required origins\n- Lazy loading\n- Optimizing how you serve third-party scripts\n\n## Use `async` or `defer`\n\nBecause [synchronous scripts](/articles/third-party-javascript) delay DOM\nconstruction and rendering, you should always load third-party scripts\nasynchronously unless the script has to run before the page can be rendered.\n\nThe `async` and `defer` attributes tell the browser that it can go on parsing\nthe HTML while loading the script in the background, then execute the script\nafter it loads. This way, script downloads don't block DOM construction or page\nrendering, letting the user see the page before all scripts have finished\nloading.\n\n```\n<script async src=\"script.js\">\n\n<script defer src=\"script.js\">\n```\n\nThe difference between `async` and `defer` attributes is when the browser\nexecutes the scripts.\n\n### `async`\n\nScripts with the `async` attribute execute at the first opportunity after they\nfinish downloading and before the window's\n[load](https://developer.mozilla.org/docs/Web/Events/load) event. This means\nit's possible (and likely) that `async` scripts won't run in the order in which\nthey appear in the HTML. It also means they can interrupt DOM building if they\nfinish downloading while the parser is still at work.\n\n![Diagram of parser blocking script with async attribute](/static/articles/efficiently-load-third-party-javascript/image/diagram-parser-blocking-020263bc7658c.png)\n\nScripts with `async` can still block\nHTML parsing.\n\n### `defer`\n\nScripts with the `defer` attribute execute after HTML parsing is completely\nfinished, but before the\n[`DOMContentLoaded`](https://developer.mozilla.org/docs/Web/Events/DOMContentLoaded)\nevent. `defer` ensures that scripts run in the order they appear in the HTML and\ndon't block the parser.\n\n![Diagram of parser flow with a script with defer attribute](/static/articles/efficiently-load-third-party-javascript/image/diagram-parser-flow-a-s-f9a9ef751f974.png)\n\nScripts with `defer` wait to run until\nthe browser is done parsing the HTML.\n\n- Use `async` if it's important to have the script run earlier in the loading\n  process.\n- Use `defer` for less critical resources, such as a video player that's below\n  the fold.\n\nUsing these attributes can significantly speed up page load. For example,\n[Telegraph deferred all their scripts](https://medium.com/p/a0a1000be5#4123),\nincluding ads and analytics, and improved the ad loading time by an average of\nfour seconds.\n\n## Establish early connections to required origins\n\nYou can save 100\u2013500 ms by\n[establishing early connections](/articles/preconnect-and-dns-prefetch) to\nimportant third-party origins.\n\nTwo [`<link>`](https://developer.mozilla.org/docs/Web/HTML/Element/link) types,\n`preconnect` and `dns-prefetch`, can help here:\n\n### `preconnect`\n\n`<link rel=\"preconnect\">` tells the browser that your page wants to establish a\nconnection to another origin, and that you'd like the process to start as soon\nas possible. When the browser requests a resource from the pre-connected origin,\nthe download starts immediately.\n\n```\n<link rel=\"preconnect\" href=\"https://cdn.example.com\">\n```\n\n### `dns-prefetch`\n\n`<link rel=\"dns-prefetch>` handles a small subset of what\n`<link rel=\"preconnect\">` handles. Establishing a connection involves the DNS\nlookup and TCP handshake, and for secure origins, TLS negotiations.\n`dns-prefetch` tells the browser to only resolve the DNS of a specific domain before it has been explicitly called.\n\nThe `preconnect` hint is best used for only the most critical connections. For\nless important third-party domains, use `<link rel=dns-prefetch>`.\n\n```\n<link rel=\"dns-prefetch\" href=\"http://example.com\">\n```\n\n[Browser support for `dns-prefetch`](https://caniuse.com/#search=dns-prefetch)\nis slightly different from [`preconnect` support](https://caniuse.com/#search=preconnect),\nso `dns-prefetch` can serve as a fallback for browsers that don't support\n`preconnect`. Use separate link tags to implement this safely:\n\n```\n<link rel=\"preconnect\" href=\"http://example.com\">\n<link rel=\"dns-prefetch\" href=\"http://example.com\">\n```\n\n## Lazy-load third-party resources\n\nEmbedded third-party resources can significantly slow down page loading if\nthey're constructed poorly. If they aren't critical, or are below the fold\n(that is, if users have to scroll to view them), lazy loading is a good way to\nimprove page speed and paint metrics. This way, users get the main page content\nfaster and have a better experience.\n\n![A diagram of a webpage shown on a mobile device with scrollable content extending beyond the screen. The content that's below-the-fold is desaturated because it's not loaded yet.](/static/articles/efficiently-load-third-party-javascript/image/a-diagram-a-webpage-show-0c848a2212482.png)\n\nLazy load content below the fold.\n\nOne effective approach is to lazy-load third-party content after the main page\ncontent loads. Ads are a good candidate for this approach.\n\nAds are an important source of income for many sites, but users come for the\ncontent. By lazy loading ads and delivering the main content faster, you can\nincrease the overall viewability percentage of an ad. For example, MediaVine\nswitched to [lazy-loading ads](https://www.mediavine.com/lazy-loading-ads-mediavine-ads-load-200-faster/)\nand saw a 200% improvement in page load speed. Google Ad Manager has documentation\non how to [lazy load ads](https://developers.google.com/publisher-tag/reference#googletag.PubAdsService_enableLazyLoad).\n\nYou can also set third-party content to load only when users first scroll to\nthat section of the page.\n\n[Intersection Observer](https://developer.chrome.com/blog/intersectionobserver)\nis a browser API that efficiently detects when an element enters or exits the\nbrowser's viewport, and you can use it to implement this technique.\n[lazysizes](/use-lazysizes-to-lazyload-images) is a popular JavaScript library\nfor lazy loading images and [`iframes`](http://afarkas.github.io/lazysizes/#examples).\nIt supports YouTube embeds and\n[widgets](https://github.com/aFarkas/lazysizes/tree/gh-pages/plugins/unveilhooks).\nIt also has [optional support](https://github.com/aFarkas/lazysizes/blob/097a9878817dd17be3366633e555f3929a7eaaf1/src/lazysizes-intersection.js)\nfor Intersection Observer.\n\nUsing the [`loading` attribute for lazy loading images and iframes](/articles/browser-level-image-lazy-loading)\nis a great alternative to JavaScript techniques, and it has recently become\navailable in Chrome 76!\n\n## Optimize how you serve third-party scripts\n\nThe following are some recommended strategies for optimizing your use of\nthird-party scripts.\n\n### Third-party CDN hosting\n\nIt's common for third-party vendors to provide URLs for JavaScript files they\nhost, usually on a [content delivery network (CDN)](https://en.wikipedia.org/wiki/Content_delivery_network).\nThe benefits of this approach are that you can get started quickly\u2014just\ncopy and paste the URL\u2014and there's no maintenance overhead. The\nthird-party vendor handles server configuration and script updates.\n\nBut because they aren't on the same origin as the rest of your resources,\nloading files from a public CDN comes with a network cost. The browser needs to\nperform a DNS lookup, establish a new HTTP connection, and, on secure origins,\nperform an SSL handshake with the vendor's server.\n\nWhen you use files from third-party servers, you rarely have control over\ncaching. Relying on someone else's caching strategy might cause scripts to be\nunnecessarily re-fetched from the network too often.\n\n### Self-host third-party scripts\n\nSelf-hosting third-party scripts is an option that gives you more control over a\nscript's loading process. By self-hosting you can:\n\n- Reduce DNS lookup and round-trip times.\n- Improve [HTTP caching](/articles/http-cache) headers.\n- Take advantage of [HTTP/2](/articles/performance-http2), or the newer HTTP/3.\n\nFor example, Casper managed to [shave 1.7 seconds](https://medium.com/caspertechteam/we-shaved-1-7-seconds-off-casper-com-by-self-hosting-optimizely-2704bcbff8ec)\noff load times by self-hosting an A/B testing script.\n\nSelf-hosting comes with one big downside though: scripts can go out of date and\nwon't get automatic updates when there's an API change or a security fix.\n\n### Use service workers to cache scripts from third-party servers\n\nYou can use [service workers to cache scripts from third-party servers](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime#cross-origin-considerations)\nas an alternative to self-hosting. This gives you greater control over caching,\nwhile retaining the benefits of third-party CDNs.\n\nYou can control how often scripts are re-fetched from the network and\ncreate a loading strategy that throttles requests for non-essential,\nthird-party resources until a user arrives at a key interaction on the page.\nWith `preconnect`, you can establish early connections and also help\nmitigate the network costs.\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2019-08-14 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2019-08-14 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:46.491457+00:00",
  "content_length": 7704,
  "content_hash": "5e0e417aac5e8f49"
}