{
  "id": "web-vitals__articles_reduce-javascript-payloads-with-code-spl",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/reduce-javascript-payloads-with-code-splitting",
  "title": "Reduce JavaScript payloads with code splittingStay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nReduce JavaScript payloads with code splitting\nStay organized with collections\nSave and categorize content based on your preferences.\nHoussein Djirdeh\nJeremy Wagner\nNobody likes waiting.\nOver 50% of users abandon a website if it takes longer than 3 seconds to load\n.\nSending large JavaScript payloads impacts the speed of your site\nsignificantly. Instead of shipping all the JavaScript to your user as soon as\nthe first page of your application is loaded, split your bundle into\nmultiple pieces and only send what's necessary at the very beginning.\nWhy is code splitting beneficial?\nCode splitting is a technique that seeks to minimize startup time. When we ship less JavaScript at startup, we can get applications to be\ninteractive faster\nby minimizing main thread work during this critical period.\nWhen it comes to\nCore Web Vitals\n, reducing JavaScript payloads downloaded at startup will contribute to better\nInteraction to Next Paint (INP)\ntimes. The reasoning behind this is that, by freeing up the main thread, the application is able to respond to user inputs more quickly by reducing JavaScript parse, compile, and execution-related startup costs.\nDepending on your website's architecture\u2014particularly if your website relies heavily on client-side rendering\u2014reducing the size of JavaScript payloads responsible for rendering markup may lead to improved\nLargest Contentful Paint (LCP)\ntimes. This can occur when the LCP resource is\ndelayed in being discovered by the browser\nuntil after client-side markup is completed, or when the main thread is too busy to\nrender that LCP element\n. Both scenarios can delay the LCP time for the page.\nMeasure\nLighthouse displays a failed audit when a significant amount of time is taken to\nexecute all the JavaScript on a page.\nSplit the JavaScript bundle to only send the code needed for the initial route when the\nuser loads an application. This minimizes the amount of script that needs to be\nparsed and compiled, which results in faster page load times.\nPopular module bundlers like\nwebpack\n,\nParcel\n, and\nRollup\nallow you to split your\nbundles using\ndynamic imports\n.\nFor example, consider the following code snippet that shows an example of a\nsomeFunction\nmethod that gets fired when a form is submitted.\nimport\nmoduleA\nfrom\n\"library\"\n;\nform\n.\naddEventListener\n(\n\"submit\"\n,\ne\n=\n>\n{\ne\n.\npreventDefault\n();\nsomeFunction\n();\n});\nconst\nsomeFunction\n=\n()\n=\n>\n{\n// uses moduleA\n}\nIn here,\nsomeFunction\nuses a module imported from a particular library. If\nthis module is not being used elsewhere, the code block can be modified to use a\ndynamic import to fetch it only when the form is submitted by the user.\nform\n.\naddEventListener\n(\n\"submit\"\n,\ne\n=\n>\n{\ne\n.\npreventDefault\n();\nimport\n(\n'library.moduleA'\n)\n.\nthen\n(\nmodule\n=\n>\nmodule\n.\ndefault\n)\n//\nusing\nthe\ndefault\nexport\n.\nthen\n(()\n=\n>\nsomeFunction\n())\n.\ncatch\n(\nhandleError\n());\n});\nconst\nsomeFunction\n=\n()\n=\n>\n{\n//\nuses\nmoduleA\n}\nThe code that makes up the module does not get included into the initial bundle\nand is now\nlazy loaded\n, or provided to the user only when it is needed after\nthe form submission. To further improve page performance,\npreload critical chunks to prioritize and fetch them sooner\n.\nAlthough the previous code snippet is a simple example, lazy loading third party\ndependencies is not a common pattern in larger applications. Usually, third\nparty dependencies are split into a separate vendor bundle that can be cached\nsince they don't update as often. You can read more about how the\nSplitChunksPlugin\ncan\nhelp you do this.\nSplitting on the route or component level when using a client-side framework is\na simpler approach to lazy loading different parts of your application. Many\npopular frameworks that use webpack provide abstractions to make lazy loading\neasier than diving into the configurations yourself.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2018-11-05 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Reduce JavaScript payloads with code splitting Stay organized with collections Save and categorize content based on your preferences.\n\n![Houssein Djirdeh](https://web.dev/images/authors/houssein.jpg)\n\nHoussein Djirdeh\n\n![Jeremy Wagner](https://web.dev/images/authors/jlwagner-v6.jpg)\n\nJeremy Wagner\n\nNobody likes waiting.\n**[Over 50% of users abandon a website if it takes longer than 3 seconds to load](https://www.thinkwithgoogle.com/intl/en-154/insights-inspiration/research-data/need-mobile-speed-how-mobile-latency-impacts-publisher-revenue/)**.\n\nSending large JavaScript payloads impacts the speed of your site\nsignificantly. Instead of shipping all the JavaScript to your user as soon as\nthe first page of your application is loaded, split your bundle into\nmultiple pieces and only send what's necessary at the very beginning.\n\n## Why is code splitting beneficial?\n\nCode splitting is a technique that seeks to minimize startup time. When we ship less JavaScript at startup, we can get applications to be [interactive faster](/articles/tti) by minimizing main thread work during this critical period.\n\nWhen it comes to [Core Web Vitals](/articles/vitals), reducing JavaScript payloads downloaded at startup will contribute to better [Interaction to Next Paint (INP)](/articles/inp) times. The reasoning behind this is that, by freeing up the main thread, the application is able to respond to user inputs more quickly by reducing JavaScript parse, compile, and execution-related startup costs.\n\nDepending on your website's architecture\u2014particularly if your website relies heavily on client-side rendering\u2014reducing the size of JavaScript payloads responsible for rendering markup may lead to improved [Largest Contentful Paint (LCP)](/articles/lcp) times. This can occur when the LCP resource is [delayed in being discovered by the browser](/articles/optimize-lcp#optimize_when_the_resource_is_discovered) until after client-side markup is completed, or when the main thread is too busy to [render that LCP element](/articles/optimize-lcp#2_eliminate_element_render_delay). Both scenarios can delay the LCP time for the page.\n\n## Measure\n\nLighthouse displays a failed audit when a significant amount of time is taken to\nexecute all the JavaScript on a page.\n\n![A failing Lighthouse audit showing scripts taking too long to execute.](/static/articles/reduce-javascript-payloads-with-code-splitting/image/a-failing-lighthouse-audi-3489471baf6d4.png)\n\nSplit the JavaScript bundle to only send the code needed for the initial route when the\nuser loads an application. This minimizes the amount of script that needs to be\nparsed and compiled, which results in faster page load times.\n\nPopular module bundlers like [webpack](https://webpack.js.org/guides/code-splitting/),\n[Parcel](https://parceljs.org/code_splitting.html), and\n[Rollup](https://rollupjs.org/guide/en#dynamic-import) allow you to split your\nbundles using [dynamic imports](https://v8.dev/features/dynamic-import).\nFor example, consider the following code snippet that shows an example of a\n`someFunction` method that gets fired when a form is submitted.\n\n```\nimport moduleA from \"library\";\n\nform.addEventListener(\"submit\", e => {\n  e.preventDefault();\n  someFunction();\n});\n\nconst someFunction = () => {\n  // uses moduleA\n}\n```\n\nIn here, `someFunction` uses a module imported from a particular library. If\nthis module is not being used elsewhere, the code block can be modified to use a\ndynamic import to fetch it only when the form is submitted by the user.\n\n```\nform.addEventListener(\"submit\", e => {\n  e.preventDefault();\n  import('library.moduleA')\n    .then(module => module.default) // using the default export\n    .then(() => someFunction())\n    .catch(handleError());\n});\n\nconst someFunction = () => {\n    // uses moduleA\n}\n```\n\nThe code that makes up the module does not get included into the initial bundle\nand is now **lazy loaded**, or provided to the user only when it is needed after\nthe form submission. To further improve page performance, [preload critical chunks to prioritize and fetch them sooner](/articles/preload-critical-assets).\n\nAlthough the previous code snippet is a simple example, lazy loading third party\ndependencies is not a common pattern in larger applications. Usually, third\nparty dependencies are split into a separate vendor bundle that can be cached\nsince they don't update as often. You can read more about how the\n[**SplitChunksPlugin**](https://webpack.js.org/plugins/split-chunks-plugin/) can\nhelp you do this.\n\nSplitting on the route or component level when using a client-side framework is\na simpler approach to lazy loading different parts of your application. Many\npopular frameworks that use webpack provide abstractions to make lazy loading\neasier than diving into the configurations yourself.\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2018-11-05 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2018-11-05 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:29.103621+00:00",
  "content_length": 4172,
  "content_hash": "ebd8660b2fad748c"
}