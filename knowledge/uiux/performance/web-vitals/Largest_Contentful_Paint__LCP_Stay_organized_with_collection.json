{
  "id": "web-vitals__articles_lcp",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/lcp",
  "title": "Largest Contentful Paint (LCP)Stay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nLargest Contentful Paint (LCP)\nStay organized with collections\nSave and categorize content based on your preferences.\nPhilip Walton\nBarry Pollard\nPublished: August 8, 2019, Last updated: September 4, 2025\nLargest Contentful Paint (LCP) is an important,\nstable\nCore Web Vital metric for measuring\nperceived load speed\nbecause it marks the point in the page load timeline when the page's main content has likely loaded\u2014a fast LCP helps reassure the user that the page is\nuseful\n.\nHistorically, it's been a challenge for web developers to measure how quickly the main content of a web page loads and is visible to users. Older metrics like\nload\nor\nDOMContentLoaded\ndon't work well because they don't necessarily correspond to what the user sees on their screen. And newer, user-centric performance metrics like\nFirst Contentful Paint (FCP)\nonly capture the very beginning of the loading experience. If a page shows a splash screen or displays a loading indicator, this moment isn't very relevant to the user.\nIn the past, we've recommended performance metrics like\nFirst Meaningful Paint (FMP)\nand\nSpeed Index (SI)\n(both available in Lighthouse) to help capture more of the loading experience after the initial paint, but these metrics are complex, hard to explain, and often wrong\u2014meaning they still don't identify when the main content of the page has loaded.\nBased on discussions in the\nW3C Web Performance Working Group\nand research done at Google, we've found that a more accurate way to measure when the main content of a page is loaded is to look at when the largest element is rendered.\nWhat is LCP?\nLCP reports the render time of the largest\nimage, text block, or video\nvisible in the viewport, relative to when the user first navigated to the page.\nWhat is a good LCP score?\nTo provide a good user experience, sites should strive to have Largest Contentful Paint of\n2.5 seconds\nor less. To ensure you're hitting this target for most of your users, a good threshold to measure is the\n75th percentile\nof page loads, segmented across mobile and desktop devices.\nA good LCP value is 2.5 seconds or less.\nTo learn more about the research and methodology behind this recommendation, see:\nDefining the Core Web Vitals metrics thresholds\n.\nWhat elements are considered?\nAs specified in the\nLargest Contentful Paint\nAPI\n, the types of elements\nconsidered for Largest Contentful Paint are:\n<img>\nelements (the\nfirst frame presentation time\nis used for animated content such as GIFs or animated PNGs)\n<image>\nelements inside an\n<svg>\nelement\n<video>\nelements (the poster image load time or\nfirst frame presentation time\nfor videos is used\u2014whichever is earlier)\nAn element with a background image loaded using the\nurl()\nfunction, (as opposed to a\nCSS gradient\n)\nBlock-level\nelements containing text nodes or other inline-level text element children.\nNote that restricting the elements to this limited set was intentional in order to reduce complexity. Additional elements (like the full\n<svg>\nsupport) may be added in the future as more research is conducted.\nAs well as only considering some elements, LCP measurements use heuristics to exclude certain elements that users are likely to see as \"non-contentful\". For Chromium-based browsers, these include:\nElements with an opacity of 0, that are invisible to the user\nElements that cover the full viewport, that are likely considered as background rather than content\nPlaceholder images or other images with a low entropy, that likely don't reflect the true content of the page\nBrowsers are likely to continue to improve these heuristics to ensure we match user expectations of what the largest\ncontentful\nelement is.\nThese \"contentful\" heuristics may differ from those used by\nFirst Contentful Paint (FCP)\n, which may consider some of these elements, such as placeholder images or full viewport images, even if they are ineligible to be LCP candidates. Despite both using \"contentful\" in their name, the aim of these metrics is different. FCP measures when\nany content\nis painted to screen and LCP when the\nmain content\nis painted so LCP is intented to be more selective.\nHow is an element's size determined?\nThe size of the element reported for LCP is typically the size that's visible to the user within the viewport. If the element extends outside of the viewport, or if any of the element is clipped or has non-visible\noverflow\n, those portions don't count toward the element's size.\nFor image elements that have been resized from their\nintrinsic size\n, the size that gets reported is either the visible size or the intrinsic size, whichever is smaller.\nFor text elements, LCP considers only the smallest rectangle that can contain all text nodes.\nFor all elements, LCP doesn't consider margins, paddings, or borders applied using CSS.\nWhen is LCP reported?\nWeb pages often load in stages, and as a result, it's possible that the largest element on the page might change.\nTo handle this potential for change, the browser dispatches a\nPerformanceEntry\nof type\nlargest-contentful-paint\nidentifying the largest contentful element as soon as the browser has painted the first frame. But then, after rendering subsequent frames, it will dispatch another\nPerformanceEntry\nany time the largest contentful element changes.\nFor example, on a page with text and a hero image the browser may initially just render the text\u2014at which point the browser would dispatch a\nlargest-contentful-paint\nentry whose\nelement\nproperty would likely reference a\n<p>\nor\n<h1>\n. Later, once the hero image finishes loading, a second\nlargest-contentful-paint\nentry would be dispatched and its\nelement\nproperty would reference the\n<img>\n.\nAn element can only be considered the largest contentful element after it has rendered and is visible to the user. Images that haven't yet loaded aren't considered \"rendered\". Neither are text nodes using web fonts during the\nfont block period\n. In such cases, a smaller element might be reported as the largest contentful element, but as soon as the larger element finishes rendering, another\nPerformanceEntry\nis created.\nIn addition to late-loading images and fonts, a page may add new elements to the DOM as new content becomes available. If any of these new elements is larger than the previous largest contentful element, a new\nPerformanceEntry\nwill also be reported.\nIf the largest contentful element is removed from the viewport, or even from the DOM, it remains the largest contentful element unless a larger element is rendered.\nFor analysis purposes, you should only report the most recently dispatched\nPerformanceEntry\nto your analytics service.\nLoad time versus render time\nFor security reasons, the render timestamp of images was not originally exposed for cross-origin images that lack the\nTiming-Allow-Origin\nheader. Instead, only their load time was exposed (since this is already exposed through many other web APIs).\nThe\nload time\nwill usually be slightly after the resource download ends (\nresponseEnd\nin Resource Timing\n) as it takes time for the browser to process the resource after the download completes, even before it starts to render it. However, where the LCP resource is preloaded, or the rendering is delayed, there can be a larger gap between the load time and the render time.\nThis can lead to the seemingly impossible situation where LCP is reported by web APIs as earlier than FCP. This is not the case but only appears so due to this security restriction.\nThis was\nresolved in late 2024\nand a slightly coarsened render time\nis available from Chrome 133\neven when\nTiming-Allow-Origin\nis not provided.\nWhen possible, it's still recommended to set the\nTiming-Allow-Origin\nheader, so your metrics will be more accurate, particular for browsers that don't include this recent change.\nHow are element layout and size changes handled?\nTo keep the performance overhead of calculating and dispatching new performance entries low, changes to an element's size or position don't generate new LCP candidates. Only the element's initial size and position in the viewport is considered.\nThis means images that are initially rendered off-screen and then transition on-screen may not be reported. It also means elements initially rendered in the viewport that then get pushed down, out of view will still report their initial, in-viewport size.\nExamples\nHere are some examples of when the Largest Contentful Paint occurs on a few popular websites:\nAn LCP timeline from cnn.com.\nAn LCP timeline from techcrunch.com.\nIn both of the timelines, the largest element changes as content loads. In the first example, new content is added to the DOM and that changes what element is the largest. In the second example, the layout changes and content that was previously the largest is removed from the viewport.\nWhile it's often the case that late-loading content is larger than content already on the page, that's not necessarily the case. The next two examples show the LCP occurring before the page fully loads.\nAn LCP timeline from instagram.com.\nIn this example, the Instagram logo is loaded relatively early and it remains the largest element even as other content is progressively shown.\nAn LCP timeline from google.com.\nIn this Google Search results page example, the largest element is a paragraph of text that is displayed before any of the images or logo finish loading. Since all the individual images are smaller than this paragraph, it remains the largest element throughout the load process.\nHow to measure LCP\nLCP can be measured\nin the lab\nor\nin the field\n, and it's available in the following tools:\nField tools\nChrome User Experience Report\nPageSpeed Insights\nSearch Console (Core Web Vitals report)\nweb-vitals\nJavaScript library\nLab tools\nChrome DevTools\nLighthouse\nPageSpeed Insights\nWebPageTest\nMeasure LCP in JavaScript\nTo measure LCP in JavaScript, you can use the\nLargest Contentful Paint API\n. The following example shows how to create a\nPerformanceObserver\nthat listens for\nlargest-contentful-paint\nentries and logs them to the console.\nnew\nPerformanceObserver\n((\nentryList\n)\n=\n>\n{\nfor\n(\nconst\nentry\nof\nentryList\n.\ngetEntries\n())\n{\nconsole\n.\nlog\n(\n'LCP candidate:'\n,\nentry\n.\nstartTime\n,\nentry\n);\n}\n}).\nobserve\n({\ntype\n:\n'largest-contentful-paint'\n,\nbuffered\n:\ntrue\n});\nIn the previous example, each logged\nlargest-contentful-paint\nentry represents the current LCP candidate. In general, the\nstartTime\nvalue of the last entry emitted is the LCP value\u2014however, that is not always the case. Not all\nlargest-contentful-paint\nentries are valid for measuring LCP.\nThe following section lists the differences between what the API reports and how the metric is calculated.\nDifferences between the metric and the API\nThe API will dispatch\nlargest-contentful-paint\nentries for pages loaded in a background tab, but those pages should be ignored when calculating LCP.\nThe API will continue to dispatch\nlargest-contentful-paint\nentries after a page has been backgrounded, but those entries should be ignored when calculating LCP (elements may only be considered if the page was in the foreground the entire time).\nThe API does not report\nlargest-contentful-paint\nentries when the page is restored from the\nback/forward cache\n, but LCP should be measured in these cases since users experience them as distinct page visits.\nThe API does not consider elements within iframes but the metric does as they are part of the user experience of the page. In pages with an LCP within an iframe\u2014for example a poster image on an embedded video\u2014this will\nshow as a difference between CrUX and RUM\n. To properly measure LCP you should consider them. Sub-frames can use the API to report their\nlargest-contentful-paint\nentries to the parent frame for aggregation.\nThe API measures LCP from navigation start, but for\nprerendered pages\nLCP should be measured from\nactivationStart\nsince that corresponds to the LCP time as experienced by the user.\nRather than memorizing all these subtle differences, developers can use the\nweb-vitals\nJavaScript library\nto measure LCP, which handles these differences for you (where possible\u2014note the iframe issue is not covered):\nimport\n{\nonLCP\n}\nfrom\n'web-vitals'\n;\n// Measure and log LCP as soon as it's available.\nonLCP\n(\nconsole\n.\nlog\n);\nRefer to\nthe source code for\nonLCP()\nfor a complete example of how to measure LCP in JavaScript.\nWhat if the largest element isn't the most important?\nIn some cases the most important element (or elements) on the page is not the same as the largest element, and developers may be more interested in measuring the render times of these other elements instead. This is possible using the\nElement Timing API\n, as described in the article on\ncustom metrics\n.\nHow to improve LCP\nA full guide on\noptimizing LCP\nis available to guide you through the process of identifying LCP timings in the field and using lab data to drill down and optimize them.\nAdditional resources\nLessons learned from performance monitoring in Chrome\nby\nAnnie Sullivan\nat\nperformance.now()\n(2019)\nChangelog\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this\nChangelog\n.\nIf you have feedback for these metrics, you can provide it in the\nweb-vitals-feedback Google group\n.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2025-09-04 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Largest Contentful Paint (LCP) Stay organized with collections Save and categorize content based on your preferences.\n\n![Philip Walton](https://web.dev/images/authors/philipwalton.jpg)\n\nPhilip Walton\n\n![Barry Pollard](https://web.dev/images/authors/tunetheweb.jpg)\n\nBarry Pollard\n\nPublished: August 8, 2019, Last updated: September 4, 2025\n\nLargest Contentful Paint (LCP) is an important, [stable](/articles/vitals#lifecycle) Core Web Vital metric for measuring [perceived load speed](/articles/user-centric-performance-metrics#types_of_metrics) because it marks the point in the page load timeline when the page's main content has likely loaded\u2014a fast LCP helps reassure the user that the page is [useful](/articles/user-centric-performance-metrics#defining_metrics%22).\n\nHistorically, it's been a challenge for web developers to measure how quickly the main content of a web page loads and is visible to users. Older metrics like [load](https://developer.mozilla.org/docs/Web/Events/load) or [DOMContentLoaded](https://developer.mozilla.org/docs/Web/Events/DOMContentLoaded) don't work well because they don't necessarily correspond to what the user sees on their screen. And newer, user-centric performance metrics like [First Contentful Paint (FCP)](/articles/fcp) only capture the very beginning of the loading experience. If a page shows a splash screen or displays a loading indicator, this moment isn't very relevant to the user.\n\nIn the past, we've recommended performance metrics like [First Meaningful Paint (FMP)](https://developer.chrome.com/docs/lighthouse/performance/first-meaningful-paint) and [Speed Index (SI)](https://developer.chrome.com/docs/lighthouse/performance/speed-index) (both available in Lighthouse) to help capture more of the loading experience after the initial paint, but these metrics are complex, hard to explain, and often wrong\u2014meaning they still don't identify when the main content of the page has loaded.\n\nBased on discussions in the [W3C Web Performance Working Group](https://www.w3.org/webperf/) and research done at Google, we've found that a more accurate way to measure when the main content of a page is loaded is to look at when the largest element is rendered.\n\n## What is LCP?\n\nLCP reports the render time of the largest [image, text block, or video](#what-elements-are-considered) visible in the viewport, relative to when the user first navigated to the page.\n\n### What is a good LCP score?\n\nTo provide a good user experience, sites should strive to have Largest Contentful Paint of **2.5 seconds** or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the **75th percentile** of page loads, segmented across mobile and desktop devices.\n\n![Good LCP values are 2.5 seconds or less, poor values are greater than 4.0 seconds, and anything in between needs improvement](/static/articles/lcp/image/good-lcp-values-are-25-s-28836be83d1aa.svg)\n\nA good LCP value is 2.5 seconds or less.\n\nTo learn more about the research and methodology behind this recommendation, see: [Defining the Core Web Vitals metrics thresholds](/articles/defining-core-web-vitals-thresholds).\n\n### What elements are considered?\n\nAs specified in the [Largest Contentful Paint\nAPI](https://wicg.github.io/largest-contentful-paint/), the types of elements\nconsidered for Largest Contentful Paint are:\n\n- `<img>` elements (the [first frame presentation time](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/2023_08_lcp.md) is used for animated content such as GIFs or animated PNGs)\n- `<image>` elements inside an `<svg>` element\n- `<video>` elements (the poster image load time or [first frame presentation time](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/2023_08_lcp.md) for videos is used\u2014whichever is earlier)\n- An element with a background image loaded using the [`url()`](https://developer.mozilla.org/docs/Web/CSS/url()) function, (as opposed to a [CSS gradient](https://developer.mozilla.org/docs/Web/CSS/CSS_Images/Using_CSS_gradients))\n- [Block-level](https://developer.mozilla.org/docs/Web/HTML/Block-level_elements) elements containing text nodes or other inline-level text element children.\n\nNote that restricting the elements to this limited set was intentional in order to reduce complexity. Additional elements (like the full `<svg>` support) may be added in the future as more research is conducted.\n\nAs well as only considering some elements, LCP measurements use heuristics to exclude certain elements that users are likely to see as \"non-contentful\". For Chromium-based browsers, these include:\n\n- Elements with an opacity of 0, that are invisible to the user\n- Elements that cover the full viewport, that are likely considered as background rather than content\n- Placeholder images or other images with a low entropy, that likely don't reflect the true content of the page\n\nBrowsers are likely to continue to improve these heuristics to ensure we match user expectations of what the largest *contentful* element is.\n\nThese \"contentful\" heuristics may differ from those used by [First Contentful Paint (FCP)](/articles/fcp), which may consider some of these elements, such as placeholder images or full viewport images, even if they are ineligible to be LCP candidates. Despite both using \"contentful\" in their name, the aim of these metrics is different. FCP measures when *any content* is painted to screen and LCP when the *main content* is painted so LCP is intented to be more selective.\n\n### How is an element's size determined?\n\nThe size of the element reported for LCP is typically the size that's visible to the user within the viewport. If the element extends outside of the viewport, or if any of the element is clipped or has non-visible [overflow](https://developer.mozilla.org/docs/Web/CSS/overflow), those portions don't count toward the element's size.\n\nFor image elements that have been resized from their [intrinsic size](https://developer.mozilla.org/docs/Glossary/Intrinsic_Size), the size that gets reported is either the visible size or the intrinsic size, whichever is smaller.\n\nFor text elements, LCP considers only the smallest rectangle that can contain all text nodes.\n\nFor all elements, LCP doesn't consider margins, paddings, or borders applied using CSS.\n\n### When is LCP reported?\n\nWeb pages often load in stages, and as a result, it's possible that the largest element on the page might change.\n\nTo handle this potential for change, the browser dispatches a [`PerformanceEntry`](https://developer.mozilla.org/docs/Web/API/PerformanceEntry) of type `largest-contentful-paint` identifying the largest contentful element as soon as the browser has painted the first frame. But then, after rendering subsequent frames, it will dispatch another [`PerformanceEntry`](https://developer.mozilla.org/docs/Web/API/PerformanceEntry) any time the largest contentful element changes.\n\nFor example, on a page with text and a hero image the browser may initially just render the text\u2014at which point the browser would dispatch a `largest-contentful-paint` entry whose `element` property would likely reference a `<p>` or `<h1>`. Later, once the hero image finishes loading, a second `largest-contentful-paint` entry would be dispatched and its `element` property would reference the `<img>`.\n\nAn element can only be considered the largest contentful element after it has rendered and is visible to the user. Images that haven't yet loaded aren't considered \"rendered\". Neither are text nodes using web fonts during the [font block period](https://developer.mozilla.org/docs/Web/CSS/@font-face/font-display#The_font_display_timeline). In such cases, a smaller element might be reported as the largest contentful element, but as soon as the larger element finishes rendering, another `PerformanceEntry` is created.\n\nIn addition to late-loading images and fonts, a page may add new elements to the DOM as new content becomes available. If any of these new elements is larger than the previous largest contentful element, a new `PerformanceEntry` will also be reported.\n\nIf the largest contentful element is removed from the viewport, or even from the DOM, it remains the largest contentful element unless a larger element is rendered.\n\nFor analysis purposes, you should only report the most recently dispatched `PerformanceEntry` to your analytics service.\n\n#### Load time versus render time\n\nFor security reasons, the render timestamp of images was not originally exposed for cross-origin images that lack the [`Timing-Allow-Origin`](https://developer.mozilla.org/docs/Web/HTTP/Headers/Timing-Allow-Origin) header. Instead, only their load time was exposed (since this is already exposed through many other web APIs).\n\nThe *load time* will usually be slightly after the resource download ends ([`responseEnd` in Resource Timing](https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming/responseEnd)) as it takes time for the browser to process the resource after the download completes, even before it starts to render it. However, where the LCP resource is preloaded, or the rendering is delayed, there can be a larger gap between the load time and the render time.\n\nThis can lead to the seemingly impossible situation where LCP is reported by web APIs as earlier than FCP. This is not the case but only appears so due to this security restriction.\n\nThis was [resolved in late 2024](https://github.com/w3c/paint-timing/issues/104) and a slightly coarsened render time [is available from Chrome 133](https://chromestatus.com/feature/5128261284397056) even when `Timing-Allow-Origin` is not provided.\n\nWhen possible, it's still recommended to set the `Timing-Allow-Origin` header, so your metrics will be more accurate, particular for browsers that don't include this recent change.\n\n### How are element layout and size changes handled?\n\nTo keep the performance overhead of calculating and dispatching new performance entries low, changes to an element's size or position don't generate new LCP candidates. Only the element's initial size and position in the viewport is considered.\n\nThis means images that are initially rendered off-screen and then transition on-screen may not be reported. It also means elements initially rendered in the viewport that then get pushed down, out of view will still report their initial, in-viewport size.\n\n### Examples\n\nHere are some examples of when the Largest Contentful Paint occurs on a few popular websites:\n\n![Largest Contentful Paint timeline from cnn.com](/static/articles/lcp/image/largest-contentful-paint-fc43128e011aa.png)\n\nAn LCP timeline from cnn.com.\n\n![Largest Contentful Paint timeline from techcrunch.com](/static/articles/lcp/image/largest-contentful-paint-3713e2f14970a.png)\n\nAn LCP timeline from techcrunch.com.\n\nIn both of the timelines, the largest element changes as content loads. In the first example, new content is added to the DOM and that changes what element is the largest. In the second example, the layout changes and content that was previously the largest is removed from the viewport.\n\nWhile it's often the case that late-loading content is larger than content already on the page, that's not necessarily the case. The next two examples show the LCP occurring before the page fully loads.\n\n![Largest Contentful Paint timeline from instagram.com](/static/articles/lcp/image/largest-contentful-paint-9bc403e812154.png)\n\nAn LCP timeline from instagram.com.\n\nIn this example, the Instagram logo is loaded relatively early and it remains the largest element even as other content is progressively shown.\n\n![Largest Contentful Paint timeline from google.com](/static/articles/lcp/image/largest-contentful-paint-6c5554de0eac7.png)\n\nAn LCP timeline from google.com.\n\nIn this Google Search results page example, the largest element is a paragraph of text that is displayed before any of the images or logo finish loading. Since all the individual images are smaller than this paragraph, it remains the largest element throughout the load process.\n\n## How to measure LCP\n\nLCP can be measured [in the lab](/articles/user-centric-performance-metrics#in_the_lab) or [in the field](/articles/user-centric-performance-metrics#in_the_field), and it's available in the following tools:\n\n### Field tools\n\n- [Chrome User Experience Report](https://developer.chrome.com/docs/crux)\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n- [Search Console (Core Web Vitals report)](https://support.google.com/webmasters/answer/9205520)\n- [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals)\n\n### Lab tools\n\n- [Chrome DevTools](https://developer.chrome.com/docs/devtools)\n- [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview)\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n- [WebPageTest](https://webpagetest.org/)\n\n### Measure LCP in JavaScript\n\nTo measure LCP in JavaScript, you can use the [Largest Contentful Paint API](https://wicg.github.io/largest-contentful-paint/). The following example shows how to create a [`PerformanceObserver`](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) that listens for `largest-contentful-paint` entries and logs them to the console.\n\n```\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    console.log('LCP candidate:', entry.startTime, entry);\n  }\n}).observe({type: 'largest-contentful-paint', buffered: true});\n```\n\nIn the previous example, each logged `largest-contentful-paint` entry represents the current LCP candidate. In general, the `startTime` value of the last entry emitted is the LCP value\u2014however, that is not always the case. Not all `largest-contentful-paint` entries are valid for measuring LCP.\n\nThe following section lists the differences between what the API reports and how the metric is calculated.\n\n#### Differences between the metric and the API\n\n- The API will dispatch `largest-contentful-paint` entries for pages loaded in a background tab, but those pages should be ignored when calculating LCP.\n- The API will continue to dispatch `largest-contentful-paint` entries after a page has been backgrounded, but those entries should be ignored when calculating LCP (elements may only be considered if the page was in the foreground the entire time).\n- The API does not report `largest-contentful-paint` entries when the page is restored from the [back/forward cache](/articles/bfcache#impact_on_core_web_vitals), but LCP should be measured in these cases since users experience them as distinct page visits.\n- The API does not consider elements within iframes but the metric does as they are part of the user experience of the page. In pages with an LCP within an iframe\u2014for example a poster image on an embedded video\u2014this will [show as a difference between CrUX and RUM](/articles/crux-and-rum-differences#iframes). To properly measure LCP you should consider them. Sub-frames can use the API to report their `largest-contentful-paint` entries to the parent frame for aggregation.\n- The API measures LCP from navigation start, but for [prerendered pages](https://developer.chrome.com/docs/web-platform/prerender-pages) LCP should be measured from [`activationStart`](https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming/activationStart) since that corresponds to the LCP time as experienced by the user.\n\nRather than memorizing all these subtle differences, developers can use the [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals) to measure LCP, which handles these differences for you (where possible\u2014note the iframe issue is not covered):\n\n```\nimport {onLCP} from 'web-vitals';\n\n// Measure and log LCP as soon as it's available.\nonLCP(console.log);\n```\n\nRefer to [the source code for `onLCP()`](https://github.com/GoogleChrome/web-vitals/blob/main/src/onLCP.ts) for a complete example of how to measure LCP in JavaScript.\n\n### What if the largest element isn't the most important?\n\nIn some cases the most important element (or elements) on the page is not the same as the largest element, and developers may be more interested in measuring the render times of these other elements instead. This is possible using the [Element Timing API](https://wicg.github.io/element-timing/), as described in the article on [custom metrics](/articles/custom-metrics#element_timing_api).\n\n## How to improve LCP\n\nA full guide on [optimizing LCP](/articles/optimize-lcp) is available to guide you through the process of identifying LCP timings in the field and using lab data to drill down and optimize them.\n\n## Additional resources\n\n- [Lessons learned from performance monitoring in Chrome](https://youtu.be/ctavZT87syI) by [Annie Sullivan](https://anniesullie.com/) at [performance.now()](https://perfnow.nl/) (2019)\n\n## Changelog\n\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\n\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this [Changelog](https://chromium.googlesource.com/chromium/src/+/main/docs/speed/metrics_changelog/lcp.md).\n\nIf you have feedback for these metrics, you can provide it in the [web-vitals-feedback Google group](https://groups.google.com/g/web-vitals-feedback).\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2025-09-04 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-09-04 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:11.577052+00:00",
  "content_length": 13867,
  "content_hash": "8cdc1bc06fcbffce"
}