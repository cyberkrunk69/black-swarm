{
  "id": "web-vitals__articles_cls",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/cls",
  "title": "Cumulative Layout Shift (CLS)Stay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nCumulative Layout Shift (CLS)\nStay organized with collections\nSave and categorize content based on your preferences.\nMilica Mihajlija\nPhilip Walton\nUnexpected layout shifts can disrupt the user experience in many ways, from causing them to lose their place while reading if the text moves suddenly, to making them click the wrong link or button. In some cases, this can do serious damage.\nA sudden shift in layout makes the user confirm a large order they intended\n    to cancel.\nUnexpected movement of page content usually happens when resources load asynchronously or DOM elements are dynamically added to the page before existing content. The cause of layout shifts might be images or videos with unknown dimensions, fonts that render larger or smaller than its initial fallback, or third-party ads or widgets that dynamically resize themselves.\nDifferences between how a site function in development and how its users experience it make this problem worse. For example:\nPersonalized or third-party content often behaves differently in development and in production.\nTest images are often already in the developer's browser cache, but take longer to load for the end user.\nAPI calls that run locally are often so fast that unnoticeable delays in development can become substantial in production.\nThe Cumulative Layout Shift (CLS) metric helps you address this problem by measuring how often it's occurring for real users.\nWhat is CLS?\nCLS is a measure of the largest burst of\nlayout shift scores\nfor every\nunexpected\nlayout shift that occurs during the entire lifecycle of a page.\nA\nlayout shift\noccurs any time a visible element changes its position from one rendered frame to the next. (Details on how individual\nlayout shift scores\nare calculated are covered later in this guide.)\nA burst of layout shifts, known as a\nsession window\n, is when one or more individual layout shifts occur in rapid succession with less than 1-second in between each shift and a maximum of 5 seconds for the total window duration.\nThe largest burst is the session window with the maximum cumulative score of all layout shifts within that window.\nExample of session windows. Blue bars represent the scores of each individual layout shift.\nWhat is a good CLS score?\nTo provide a good user experience, sites should strive to have a CLS score of\n0.1\nor less. To ensure you're hitting this target for most of your users, a good threshold to measure is the\n75th percentile\nof page loads, segmented across mobile and desktop devices.\nGood CLS values are 0.1 or less. Poor values are greater than 0.25.\nTo learn more about the research and methodology behind this recommendation, see\nDefining the Core Web Vitals metrics thresholds\n.\nLayout shifts in detail\nLayout shifts are defined by the\nLayout Instability API\n, which reports\nlayout-shift\nentries any time an element that is visible within the viewport changes its start position (for example, its top and left position in the default\nwriting mode\n) between two frames. Such elements are considered\nunstable elements\n.\nNote that layout shifts only occur when existing elements change their start position. If a new element is added to the DOM or an existing element changes size, it doesn't count as a layout shift\u2014as long as the change doesn't cause other visible elements to change their start position.\nLayout shift score\nTo calculate the\nlayout shift score\n, the browser looks at the viewport size and the movement of\nunstable elements\nin the viewport between two rendered frames. The layout shift score is a product of two measures of that movement: the\nimpact fraction\nand the\ndistance fraction\n(both defined below).\nlayout shift score = impact fraction * distance fraction\nImpact fraction\nThe\nimpact fraction\nmeasures how\nunstable elements\nimpact the viewport area between two frames.\nThe impact fraction for a given frame is a combination of the visible areas of all unstable elements for that frame and the previous frame, as a fraction of the total area of the viewport.\nIf an element changes position, both its previous and its current position contribute to its impact fraction.\nIn the preceding image, there's an element that takes up half of the viewport in one frame. Then, in the next frame, the element shifts down by 25% of the viewport height. The red, dotted rectangle indicates the union of the element's visible area in both frames, which, in this case, is 75% of the total viewport, so its\nimpact fraction\nis\n0.75\n.\nDistance fraction\nThe other part of the layout shift score equation measures the distance that unstable elements have moved relative to the viewport. The\ndistance fraction\nis the greatest horizontal or vertical distance any\nunstable element\nhas moved in the frame divided by the viewport's largest dimension (width or height, whichever is greater).\nThe distance fraction measures how far across the viewport an element has moved.\nIn the prior example, the largest viewport dimension is the height, and the unstable element has moved by 25% of the viewport height, which makes the\ndistance fraction\n0.25.\nSo, in this example the\nimpact fraction\nis\n0.75\nand the\ndistance fraction\nis\n0.25\n, so the\nlayout shift score\nis\n0.75 * 0.25 = 0.1875\n.\nExamples\nThe next example illustrates how adding content to an existing element affects the layout shift score:\nAdding a button to the bottom of the gray box pushes the green box down and partly out of the viewport.\nIn this example, the gray box changes size, but its start position does not change so it's not an\nunstable element\n.\nThe \"Click Me!\" button was not previously in the DOM, so its start position doesn't change either.\nThe start position of the green box, however, does change, but since it's been moved partially out of the viewport, the invisible area is not considered when calculating the\nimpact fraction\n. The union of the visible areas for the green box in both frames (illustrated by the red, dotted rectangle) is the same as the area of the green box in the first frame\u201450% of the viewport. The\nimpact fraction\nis\n0.5\n.\nThe\ndistance fraction\nis illustrated with the purple arrow. The green box has moved down by about 14% of the viewport so the\ndistance fraction\nis\n0.14\n.\nThe layout shift score is\n0.5 x 0.14 = 0.07\n.\nThe following example shows how multiple unstable elements affect a page's layout shift score:\nAs more names appear on this sorted list, existing names move to preserve alphabetical order.\nIn the first frame in the preceding image, there are four results of an API request for animals, sorted in alphabetical order. In the second frame, more results are added to the sorted list.\nThe first item in the list (\"Cat\") does not change its start position between frames, so it's stable. Similarly, the new items added to the list were not previously in the DOM, so their start positions don't change either. But the items labelled \"Dog\", \"Horse\", and \"Zebra\" all shift their start positions, making them\nunstable elements\n.\nAgain, the red, dotted rectangles represent the union of these three\nunstable elements\n' before and after areas, which in this case is around 60% of the viewport's area (\nimpact fraction\nof\n0.60\n).\nThe arrows represent the distances that\nunstable elements\nhave moved from their starting positions. The \"Zebra\" element, represented by the blue arrow, has moved the most, by about 30% of the viewport height. That makes the\ndistance fraction\nin this example\n0.3\n.\nThe layout shift score is\n0.60 x 0.3 = 0.18\n.\nExpected versus unexpected layout shifts\nNot all layout shifts are bad. In fact, many dynamic web applications frequently change the start position of elements on the page. A layout shift is only bad if the user isn't expecting it.\nUser-initiated layout shifts\nLayout shifts that occur in response to user interactions (such as clicking or tapping a link, pressing a button, or typing in a search box) are generally fine, as long as the shift occurs close enough to the interaction that the relationship is clear to the user.\nFor example, if a user interaction triggers a network request that may take a while to complete, it's best to create some space right away and show a loading indicator to avoid an unpleasant layout shift when the request completes. If the user doesn't realize something is loading, or doesn't have a sense of when the resource will be ready, they may try to click something else while waiting\u2014something that could move out from under them.\nLayout shifts that occur within 500 milliseconds of user input will have the\nhadRecentInput\nflag set, so they can be excluded from calculations.\nAnimations and transitions\nAnimations and transitions, when done well, are a great way to update content on the page without surprising the user. Content that shifts abruptly and unexpectedly on the page almost always creates a bad user experience. But content that moves gradually and naturally from one position to the next can often help the user better understand what's going on, and guide them between state changes.\nBe sure to respect\nprefers-reduced-motion\nbrowser settings, as some site visitors can experience ill effects or attention\nissues from animation.\nCSS\ntransform\nproperty\nlets you animate elements without triggering layout shifts:\nInstead of changing the\nheight\nand\nwidth\nproperties, use\ntransform: scale()\n.\nTo move elements around, avoid changing the\ntop\n,\nright\n,\nbottom\n, or\nleft\nproperties and use\ntransform: translate()\ninstead.\nHow to measure CLS\nCLS can be measured\nin the lab\nor\nin the field\n, and\nit's available in the following tools:\nField tools\nChrome User Experience\nReport\nPageSpeed Insights\nSearch Console (Core Web Vitals\nreport)\nweb-vitals\nJavaScript library\nLab tools\nChrome DevTools\nLighthouse\nPageSpeed Insights\nWebPageTest\nMeasure layout shifts in JavaScript\nTo measure layout shifts in JavaScript, you use the\nLayout Instability API\n.\nThe following example shows how to create a\nPerformanceObserver\nto log\nlayout-shift\nentries to the console:\nnew\nPerformanceObserver\n((\nentryList\n)\n=\n>\n{\nfor\n(\nconst\nentry\nof\nentryList\n.\ngetEntries\n())\n{\nconsole\n.\nlog\n(\n'Layout shift:'\n,\nentry\n);\n}\n}).\nobserve\n({\ntype\n:\n'layout-shift'\n,\nbuffered\n:\ntrue\n});\nMeasure CLS in JavaScript\nTo measure CLS in JavaScript, you need to group these unexpected\nlayout-shift\nentries into sessions, and calculate the maximum session value. You can refer to the\nweb vitals\nJavaScript library source code\nwhich contains a reference implementation on how CLS is calculated.\nIn most cases, the current CLS value at the time the page is being unloaded is the final CLS value for that page, but there are a few important exceptions as noted in the next section. The\nweb vitals\nJavaScript library accounts for these as much as possible, within the limitations of the Web APIs.\nDifferences between the metric and the API\nIf a page is loaded in the background, or if it's backgrounded prior to the browser painting any content, then it shouldn't report any CLS value.\nIf a page is restored from the\nback/forward cache\n, its CLS value should be reset to zero since users experience this as a distinct page visit.\nThe API does not report\nlayout-shift\nentries for shifts that occur within iframes but the metric does as they are part of the user experience of the page. This can\nshow as a difference between CrUX and RUM\n. To properly measure CLS you should consider them. Sub-frames can use the API to report their\nlayout-shift\nentries to the parent frame for\naggregation\n.\nIn addition to these exceptions, CLS has some added complexity due to the fact that it measures the entire lifespan of a page:\nUsers might keep a tab open for a\nvery\nlong time\u2014days, weeks, months. In fact, a user might never close a tab.\nOn mobile operating systems, browsers typically don't run page unload callbacks for background tabs, making it difficult to report the \"final\" value.\nTo handle such cases, CLS should be reported any time a page is background\u2014in addition to any time it's unloaded (the\nvisibilitychange\nevent\ncovers both of these scenarios). And analytics systems receiving this data will then need to calculate the final CLS value on the backend.\nRather than memorizing and grappling with all of these cases yourself, developers can use the\nweb-vitals\nJavaScript library\nto measure CLS, which accounts for everything mentioned previously, except the iframe case:\nimport\n{\nonCLS\n}\nfrom\n'web-vitals'\n;\n// Measure and log CLS in all situations\n// where it needs to be reported.\nonCLS\n(\nconsole\n.\nlog\n);\nHow to improve CLS\nFor more guidance on identifying layout shifts in the field and using lab data to optimize them, see our guide to\noptimizing CLS\n.\nAdditional resources\nGoogle Publisher Tag's guidance on\nminimizing layout shift\nUnderstanding Cumulative Layout Shift\nby\nAnnie Sullivan\nand\nSteve Kobes\nat\n#PerfMatters\n(2020)\nChangelog\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this\nChangelog\n.\nIf you have feedback for these metrics, you can provide it in the\nweb-vitals-feedback Google group\n.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2023-04-12 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Cumulative Layout Shift (CLS) Stay organized with collections Save and categorize content based on your preferences.\n\n![Milica Mihajlija](https://web.dev/images/authors/mihajlija.jpg)\n\nMilica Mihajlija\n\n![Philip Walton](https://web.dev/images/authors/philipwalton.jpg)\n\nPhilip Walton\n\nUnexpected layout shifts can disrupt the user experience in many ways, from causing them to lose their place while reading if the text moves suddenly, to making them click the wrong link or button. In some cases, this can do serious damage.\n\n[![\n\n](https://web.dev/articles/cls/web-dev-assets/layout-instability-api/layout-instability-poster.png)](/static/articles/cls/video/web-dev-assets/layout-instability-api/layout-instability2.webm)\n\nA sudden shift in layout makes the user confirm a large order they intended\nto cancel.\n\nUnexpected movement of page content usually happens when resources load asynchronously or DOM elements are dynamically added to the page before existing content. The cause of layout shifts might be images or videos with unknown dimensions, fonts that render larger or smaller than its initial fallback, or third-party ads or widgets that dynamically resize themselves.\n\nDifferences between how a site function in development and how its users experience it make this problem worse. For example:\n\n- Personalized or third-party content often behaves differently in development and in production.\n- Test images are often already in the developer's browser cache, but take longer to load for the end user.\n- API calls that run locally are often so fast that unnoticeable delays in development can become substantial in production.\n\nThe Cumulative Layout Shift (CLS) metric helps you address this problem by measuring how often it's occurring for real users.\n\n## What is CLS?\n\nCLS is a measure of the largest burst of *layout shift scores* for every [unexpected](/articles/cls#expected_vs_unexpected_layout_shifts) layout shift that occurs during the entire lifecycle of a page.\n\nA *layout shift* occurs any time a visible element changes its position from one rendered frame to the next. (Details on how individual [layout shift scores](#layout_shift_score) are calculated are covered later in this guide.)\n\nA burst of layout shifts, known as a [*session window*](/blog/evolving-cls#why_a_session_window), is when one or more individual layout shifts occur in rapid succession with less than 1-second in between each shift and a maximum of 5 seconds for the total window duration.\n\nThe largest burst is the session window with the maximum cumulative score of all layout shifts within that window.\n\n[![\n\n](https://web.dev/articles/cls/web-dev-assets/layout-instability-api/session-window-poster.png)](/static/articles/cls/video/web-dev-assets/better-layout-shift-metric/session-window.webm)\n\nExample of session windows. Blue bars represent the scores of each individual layout shift.\n\n### What is a good CLS score?\n\nTo provide a good user experience, sites should strive to have a CLS score of **0.1** or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the **75th percentile** of page loads, segmented across mobile and desktop devices.\n\n![Good CLS values are 0.1 or less, poor values are greater than 0.25, and anything in between needs improvement](/static/articles/cls/image/good-cls-values-are-01-a42d66f2d0f42.svg)\n\nGood CLS values are 0.1 or less. Poor values are greater than 0.25.\n\nTo learn more about the research and methodology behind this recommendation, see [Defining the Core Web Vitals metrics thresholds](/articles/defining-core-web-vitals-thresholds).\n\n## Layout shifts in detail\n\nLayout shifts are defined by the [Layout Instability API](https://github.com/WICG/layout-instability), which reports `layout-shift` entries any time an element that is visible within the viewport changes its start position (for example, its top and left position in the default [writing mode](https://developer.mozilla.org/docs/Web/CSS/writing-mode)) between two frames. Such elements are considered *unstable elements*.\n\nNote that layout shifts only occur when existing elements change their start position. If a new element is added to the DOM or an existing element changes size, it doesn't count as a layout shift\u2014as long as the change doesn't cause other visible elements to change their start position.\n\n### Layout shift score\n\nTo calculate the *layout shift score*, the browser looks at the viewport size and the movement of *unstable elements* in the viewport between two rendered frames. The layout shift score is a product of two measures of that movement: the *impact fraction* and the *distance fraction* (both defined below).\n\n```\nlayout shift score = impact fraction * distance fraction\n```\n\n### Impact fraction\n\nThe [impact fraction](https://github.com/WICG/layout-instability#Impact-Fraction) measures how *unstable elements* impact the viewport area between two frames.\n\nThe impact fraction for a given frame is a combination of the visible areas of all unstable elements for that frame and the previous frame, as a fraction of the total area of the viewport.\n\n![Impact fraction example with one unstable element](/static/articles/cls/image/impact-fraction-example-164341c82ee76.png)\n\nIf an element changes position, both its previous and its current position contribute to its impact fraction.\n\nIn the preceding image, there's an element that takes up half of the viewport in one frame. Then, in the next frame, the element shifts down by 25% of the viewport height. The red, dotted rectangle indicates the union of the element's visible area in both frames, which, in this case, is 75% of the total viewport, so its *impact fraction* is `0.75`.\n\n### Distance fraction\n\nThe other part of the layout shift score equation measures the distance that unstable elements have moved relative to the viewport. The *distance fraction* is the greatest horizontal or vertical distance any *unstable element* has moved in the frame divided by the viewport's largest dimension (width or height, whichever is greater).\n\n![Distance fraction example with one unstable element](/static/articles/cls/image/distance-fraction-example-9146d2a862482.png)\n\nThe distance fraction measures how far across the viewport an element has moved.\n\nIn the prior example, the largest viewport dimension is the height, and the unstable element has moved by 25% of the viewport height, which makes the *distance fraction* 0.25.\n\nSo, in this example the *impact fraction* is `0.75` and the *distance fraction* is `0.25`, so the *layout shift score* is `0.75 * 0.25 = 0.1875`.\n\n### Examples\n\nThe next example illustrates how adding content to an existing element affects the layout shift score:\n\n![Layout shift example with multiple stable and _unstable elements_](/static/articles/cls/image/layout-shift-example-mul-10d90b67b5d6a.png)\n\nAdding a button to the bottom of the gray box pushes the green box down and partly out of the viewport.\n\nIn this example, the gray box changes size, but its start position does not change so it's not an *unstable element*.\n\nThe \"Click Me!\" button was not previously in the DOM, so its start position doesn't change either.\n\nThe start position of the green box, however, does change, but since it's been moved partially out of the viewport, the invisible area is not considered when calculating the *impact fraction*. The union of the visible areas for the green box in both frames (illustrated by the red, dotted rectangle) is the same as the area of the green box in the first frame\u201450% of the viewport. The *impact fraction* is `0.5`.\n\nThe *distance fraction* is illustrated with the purple arrow. The green box has moved down by about 14% of the viewport so the *distance fraction* is `0.14`.\n\nThe layout shift score is `0.5 x 0.14 = 0.07`.\n\nThe following example shows how multiple unstable elements affect a page's layout shift score:\n\n![Layout shift example with stable and _unstable elements_ and viewport clipping](/static/articles/cls/image/layout-shift-example-sta-05cf93597fcee.png)\n\nAs more names appear on this sorted list, existing names move to preserve alphabetical order.\n\nIn the first frame in the preceding image, there are four results of an API request for animals, sorted in alphabetical order. In the second frame, more results are added to the sorted list.\n\nThe first item in the list (\"Cat\") does not change its start position between frames, so it's stable. Similarly, the new items added to the list were not previously in the DOM, so their start positions don't change either. But the items labelled \"Dog\", \"Horse\", and \"Zebra\" all shift their start positions, making them *unstable elements*.\n\nAgain, the red, dotted rectangles represent the union of these three *unstable elements*' before and after areas, which in this case is around 60% of the viewport's area (*impact fraction* of `0.60`).\n\nThe arrows represent the distances that *unstable elements* have moved from their starting positions. The \"Zebra\" element, represented by the blue arrow, has moved the most, by about 30% of the viewport height. That makes the *distance fraction* in this example `0.3`.\n\nThe layout shift score is `0.60 x 0.3 = 0.18`.\n\n### Expected versus unexpected layout shifts\n\nNot all layout shifts are bad. In fact, many dynamic web applications frequently change the start position of elements on the page. A layout shift is only bad if the user isn't expecting it.\n\n#### User-initiated layout shifts\n\nLayout shifts that occur in response to user interactions (such as clicking or tapping a link, pressing a button, or typing in a search box) are generally fine, as long as the shift occurs close enough to the interaction that the relationship is clear to the user.\n\nFor example, if a user interaction triggers a network request that may take a while to complete, it's best to create some space right away and show a loading indicator to avoid an unpleasant layout shift when the request completes. If the user doesn't realize something is loading, or doesn't have a sense of when the resource will be ready, they may try to click something else while waiting\u2014something that could move out from under them.\n\nLayout shifts that occur within 500 milliseconds of user input will have the [`hadRecentInput`](https://wicg.github.io/layout-instability/#dom-layoutshift-hadrecentinput) flag set, so they can be excluded from calculations.\n\n#### Animations and transitions\n\nAnimations and transitions, when done well, are a great way to update content on the page without surprising the user. Content that shifts abruptly and unexpectedly on the page almost always creates a bad user experience. But content that moves gradually and naturally from one position to the next can often help the user better understand what's going on, and guide them between state changes.\n\nBe sure to respect [`prefers-reduced-motion`](/articles/prefers-reduced-motion)\nbrowser settings, as some site visitors can experience ill effects or attention\nissues from animation.\n\nCSS [`transform`](https://developer.mozilla.org/docs/Web/CSS/transform) property\nlets you animate elements without triggering layout shifts:\n\n- Instead of changing the `height` and `width` properties, use `transform: scale()`.\n- To move elements around, avoid changing the `top`, `right`, `bottom`, or `left` properties and use `transform: translate()` instead.\n\n## How to measure CLS\n\nCLS can be measured [in the lab](/articles/user-centric-performance-metrics#lab)\nor [in the field](/articles/user-centric-performance-metrics#in_the_field), and\nit's available in the following tools:\n\n### Field tools\n\n- [Chrome User Experience\n  Report](https://developer.chrome.com/docs/crux)\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n- [Search Console (Core Web Vitals\n  report)](https://support.google.com/webmasters/answer/9205520)\n- [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals)\n\n### Lab tools\n\n- [Chrome DevTools](https://developer.chrome.com/docs/devtools)\n- [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview)\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n- [WebPageTest](https://webpagetest.org/)\n\n### Measure layout shifts in JavaScript\n\nTo measure layout shifts in JavaScript, you use the [Layout Instability API](https://github.com/WICG/layout-instability).\n\nThe following example shows how to create a [`PerformanceObserver`](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) to log `layout-shift` entries to the console:\n\n```\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    console.log('Layout shift:', entry);\n  }\n}).observe({type: 'layout-shift', buffered: true});\n```\n\n### Measure CLS in JavaScript\n\nTo measure CLS in JavaScript, you need to group these unexpected `layout-shift` entries into sessions, and calculate the maximum session value. You can refer to the [`web vitals` JavaScript library source code](https://github.com/GoogleChrome/web-vitals/blob/main/src/onCLS.ts) which contains a reference implementation on how CLS is calculated.\n\nIn most cases, the current CLS value at the time the page is being unloaded is the final CLS value for that page, but there are a few important exceptions as noted in the next section. The `web vitals` JavaScript library accounts for these as much as possible, within the limitations of the Web APIs.\n\n#### Differences between the metric and the API\n\n- If a page is loaded in the background, or if it's backgrounded prior to the browser painting any content, then it shouldn't report any CLS value.\n- If a page is restored from the [back/forward cache](/articles/bfcache#impact_on_core_web_vitals), its CLS value should be reset to zero since users experience this as a distinct page visit.\n- The API does not report `layout-shift` entries for shifts that occur within iframes but the metric does as they are part of the user experience of the page. This can [show as a difference between CrUX and RUM](/articles/crux-and-rum-differences#iframes). To properly measure CLS you should consider them. Sub-frames can use the API to report their `layout-shift` entries to the parent frame for [aggregation](https://github.com/WICG/layout-instability#cumulative-scores).\n\nIn addition to these exceptions, CLS has some added complexity due to the fact that it measures the entire lifespan of a page:\n\n- Users might keep a tab open for a *very* long time\u2014days, weeks, months. In fact, a user might never close a tab.\n- On mobile operating systems, browsers typically don't run page unload callbacks for background tabs, making it difficult to report the \"final\" value.\n\nTo handle such cases, CLS should be reported any time a page is background\u2014in addition to any time it's unloaded (the [`visibilitychange` event](https://developer.chrome.com/blog/page-lifecycle-api#event-visibilitychange) covers both of these scenarios). And analytics systems receiving this data will then need to calculate the final CLS value on the backend.\n\nRather than memorizing and grappling with all of these cases yourself, developers can use the [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals) to measure CLS, which accounts for everything mentioned previously, except the iframe case:\n\n```\nimport {onCLS} from 'web-vitals';\n\n// Measure and log CLS in all situations\n// where it needs to be reported.\nonCLS(console.log);\n```\n\n## How to improve CLS\n\nFor more guidance on identifying layout shifts in the field and using lab data to optimize them, see our guide to [optimizing CLS](/articles/optimize-cls).\n\n## Additional resources\n\n- Google Publisher Tag's guidance on [minimizing layout shift](https://developers.google.com/doubleclick-gpt/guides/minimize-layout-shift)\n- [Understanding Cumulative Layout Shift](https://youtu.be/zIJuY-JCjqw) by [Annie Sullivan](https://anniesullie.com/) and [Steve Kobes](https://kobes.ca/) at [#PerfMatters](https://perfmattersconf.com/) (2020)\n\n## Changelog\n\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\n\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this [Changelog](https://chromium.googlesource.com/chromium/src/+/main/docs/speed/metrics_changelog/cls.md).\n\nIf you have feedback for these metrics, you can provide it in the [web-vitals-feedback Google group](https://groups.google.com/g/web-vitals-feedback).\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2023-04-12 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2023-04-12 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:15.536507+00:00",
  "content_length": 13672,
  "content_hash": "57f3aba47e30210a"
}