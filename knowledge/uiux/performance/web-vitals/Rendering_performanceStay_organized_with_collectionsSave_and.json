{
  "id": "web-vitals__articles_rendering-performance",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/rendering-performance",
  "title": "Rendering performanceStay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nRendering performance\nStay organized with collections\nSave and categorize content based on your preferences.\nUsers notice if sites and apps don't run well, so optimizing rendering performance is crucial!\nPaul Lewis\nUsers of today's web expect that the pages they visit will be interactive and\nsmooth, and that's where you need to increasingly focus your time and effort.\nPages shouldn't just load quickly, but also respond quickly to user input\nthroughout their entire lifecycle. In fact, this aspect of the user experience\nis precisely what the\nInteraction to Next Paint (INP)\nmetric measures. A good\nINP means that a page was consistently and reliably responsive to the user's\nneeds.\nWhile a major component of what makes a page feel snappy involves the amount of\nJavaScript you execute in response to user interactions, what users are\nanticipating are visual changes to the user interface. Visual changes to a user\ninterface are the result of several types of work, often collectively referred\nto as\nrendering\n, and this work needs to happen as quickly as possible so that\nthe user experience feels fast and reliable.\nTo write pages that respond quickly to user interactions, you need to understand\nhow HTML, JavaScript, and CSS are handled by the browser, and ensure that the\ncode you write\u2014as well as any other third-party code you include\u2014runs as\nefficiently as possible.\nA note on device refresh rates\nThe refresh rate of a display is an important consideration when it comes to\n    building websites that feel responsive to user input.\nMost devices today refresh their screens\n60 times a second\n. Each refresh\nproduces the visual output you see, and is commonly known as a\nframe\n. In the\nfollowing video, the concept of frames is demonstrated:\nFrames as shown in the performance panel of Chrome DevTools. As the cursor\n    scrubs over the filmstrip near the top, an enlarged representation of each\n    frame is shown within a tooltip as a mobile navigation menu animates to its\n    \"open\" state.\nWhile a device's screen always refreshes at a consistent rate, applications that\nrun on a device may not necessarily always be able to produce enough frames to\nmatch that refresh rate. For example, if there's an animation or transition\nrunning, the browser needs to match the device's refresh rate to produce one\nframe for each time the screen refreshes.\nGiven that a typical display refreshes 60 times per second, some quick math\nwould reveal that the browser has 16.66 milliseconds to produce each frame.\nIn reality, though, the browser has its own overhead for each frame, so all of\nyour work needs to be completed inside\n10 milliseconds\n. When you fail to\nmeet this budget, the frame rate drops, and page contents judder on-screen. This\nphenomenon is often called\njank\n.\nHowever, your targets change based on the type of work you're trying to do.\nMeeting the 10 millisecond threshold is crucial for\nanimations\n, where the\nof objects on the screen are interpolated across a series of frames between two\npoints. When it comes to discrete changes in the user interface\u2014that is,\nproceeding from one state to another without any motion in between\u2014it's\nrecommended that you achieve such changes in a timeframe that\nfeels\ninstant to\nthe user. In cases such as these, 100 milliseconds is an oft-cited figure, but\nthe INP metric's \"good\" threshold is 200 milliseconds or lower in order to\naccommodate a wider array of devices with varying capabilities.\nWhatever your goals are\u2014be they producing the many frames that animations\nrequire in order to avoid jank, or merely producing a discrete visual change in\nthe user interface as quickly as possible\u2014understanding how the browser's pixel\npipeline works is essential to your work.\nThe pixel pipeline\nThere are five major areas that you need to know about and be mindful of in your\nwork as a web developer. These five areas are those that you have the most\ncontrol over, and each represents a key point in the pixels-to-screen pipeline:\nThe full pixel pipeline, illustrated.\nJavaScript:\nJavaScript is typically used to handle work that will result\nin visual changes to the user interface. For example, this could be jQuery's\nanimate\nfunction, sorting a dataset, or adding DOM elements to the page.\nJavaScript isn't strictly necessary to trigger visual changes, though:\nCSS\nanimations\n,\nCSS transitions\n, and\nthe Web Animations API\nare capable of\nanimating page contents.\nStyle calculations:\nThis is the process of figuring out which CSS rules\napply to which HTML elements based on matching selectors. For example,\n.headline\nis an example of a CSS selector that applies to any HTML element\nwith a\nclass\nattribute value that contains a class of\nheadline\n. From\nthere, once rules are known, they are applied, and the final styles for each\nelement are calculated.\nLayout:\nOnce the browser knows which rules apply to an element it can\nbegin to calculate the geometry of the page, such as how much space elements\ntake up, and where they appear on the screen. The web's layout model means\nthat one element can affect others. For example, the width of the\n<body>\nelement typically affects the dimensions of its child elements all the way up\nand down the tree, so the process can be quite involved for the browser.\nPaint:\nPainting is the process of filling in pixels. It involves drawing\nout text, colors, images, borders, shadows, and essentially every visual\naspect of the elements after their layout on the page has been calculated.\nThe drawing is typically done onto multiple surfaces, often called layers.\nComposite:\nSince the parts of the page were potentially drawn onto\nmultiple layers, they need to be applied to the screen in the correct order so\nthat the page renders as expected. This is especially important for elements\nthat overlap another, since a mistake could result in one element appearing\nover the top of another incorrectly.\nEach of these parts of the pixel pipeline represents an opportunity to introduce\njank in animations, or delay the painting of frames even for discrete visual\nchanges to the user interface. It's therefore important to understand exactly\nwhich parts of the pipeline your code triggers, and to investigate if you can\nlimit your changes to only the parts of the pixel pipeline that are necessary to\nrender them.\nYou may have heard the term \"rasterize\" used in conjunction with \"paint\". This\nis because painting is actually two tasks:\nCreating a list of draw calls.\nFilling in the pixels.\nThe latter is called \"rasterization\", so whenever you see paint records in\nDevTools, you should think of it as including rasterization. In some\narchitectures, creating the list of draw calls and rasterization are done on\ndifferent threads, but that isn't under your control as a developer.\nYou won't always necessarily touch every part of the pipeline on every frame.\nIn fact, there are three ways the pipeline\nnormally\nplays out for a given\nframe when you make a visual change, either with JavaScript, CSS, or the Web\nAnimations API.\n1. JS / CSS > Style > Layout > Paint > Composite\nIf you change a \"layout\" property, such as one that changes an element's\ngeometry like width, height, or its position (such as the\nleft\nor\ntop\nCSS\nproperties), the browser needs to check all other elements and \"reflow\" the\npage. Any affected areas will need to be repainted, and the final painted\nelements will need to be composited back together.\n2. JS / CSS > Style > Paint > Composite\nIf you changed a \"paint-only\" property for an element in CSS\u2014for example,\nproperties such as\nbackground-image\n,\ncolor\n, or\nbox-shadow\n\u2014the layout step\nis not necessary to commit a visual update to the page. By omitting the layout\nstep\u2014where possible\u2014you avoid potentially costly layout work that could have\notherwise contributed significant latency in producing the next frame.\n3. JS / CSS > Style > Composite\nIf you change a property that requires\nneither\nlayout or paint, the browser\ncan jump straight to the compositing step. This is the cheapest and most\ndesirable pathway through the pixel pipeline for high pressure points in a\npage's lifecycle, such as animations or scrolling. Fun fact: Chromium optimizes\nscrolling of the page so that it occurs solely on the compositor thread where\npossible, meaning that even if a page is not responding, you're still able to\nscroll the page and see parts of it that were previously drawn to the screen.\nWeb performance is the art of\navoiding\nwork, while increasing the efficiency\nof any necessary work as much as possible. In many cases, it's about working\nwith the browser, not against it. It's worth bearing in mind that the work\npreviously shown in the pipeline differs in terms of computational cost; some\ntasks are inherently more expensive than others!\nLet\u2019s take a dive into the different parts of the pipeline. We\u2019ll take a look\nat the common issues, as well how to diagnose and fix them.\nBrowser Rendering Optimizations\nPerformance matters to users, and to build good user experiences, web developers\nneed to build websites that react quickly to user interactions and render\nsmoothly. Performance expert Paul Lewis is here to help you destroy jank and\ncreate web apps that maintain 60 frames per second performance. You'll leave\nthis course with the tools you need to profile apps, and identify the causes of\nsuboptimal rendering performance. You'll also explore the browser's rendering\npipeline and uncover patterns that make it easier to build fast websites that\nusers will find delightful to use.\nThis is a free course offered through\nUdacity\n, and you can\ntake it any time\n.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2023-12-13 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Rendering performance Stay organized with collections Save and categorize content based on your preferences.\n\nUsers notice if sites and apps don't run well, so optimizing rendering performance is crucial!\n\nPaul Lewis\n\nUsers of today's web expect that the pages they visit will be interactive and\nsmooth, and that's where you need to increasingly focus your time and effort.\nPages shouldn't just load quickly, but also respond quickly to user input\nthroughout their entire lifecycle. In fact, this aspect of the user experience\nis precisely what the [Interaction to Next Paint (INP)](/articles/inp) metric measures. A good\nINP means that a page was consistently and reliably responsive to the user's\nneeds.\n\nWhile a major component of what makes a page feel snappy involves the amount of\nJavaScript you execute in response to user interactions, what users are\nanticipating are visual changes to the user interface. Visual changes to a user\ninterface are the result of several types of work, often collectively referred\nto as *rendering*, and this work needs to happen as quickly as possible so that\nthe user experience feels fast and reliable.\n\nTo write pages that respond quickly to user interactions, you need to understand\nhow HTML, JavaScript, and CSS are handled by the browser, and ensure that the\ncode you write\u2014as well as any other third-party code you include\u2014runs as\nefficiently as possible.\n\n## A note on device refresh rates\n\n![A user interacting with a website on a mobile phone.](/static/articles/rendering-performance/image/user-interacting-a-websi-f32989a67c995.jpg)\n\nThe refresh rate of a display is an important consideration when it comes to\nbuilding websites that feel responsive to user input.\n\nMost devices today refresh their screens **60 times a second**. Each refresh\nproduces the visual output you see, and is commonly known as a *frame*. In the\nfollowing video, the concept of frames is demonstrated:\n\n[\n\n](/static/articles/rendering-performance/video/frames.webm)\n\nFrames as shown in the performance panel of Chrome DevTools. As the cursor\nscrubs over the filmstrip near the top, an enlarged representation of each\nframe is shown within a tooltip as a mobile navigation menu animates to its\n\"open\" state.\n\nWhile a device's screen always refreshes at a consistent rate, applications that\nrun on a device may not necessarily always be able to produce enough frames to\nmatch that refresh rate. For example, if there's an animation or transition\nrunning, the browser needs to match the device's refresh rate to produce one\nframe for each time the screen refreshes.\n\nGiven that a typical display refreshes 60 times per second, some quick math\nwould reveal that the browser has 16.66 milliseconds to produce each frame.\nIn reality, though, the browser has its own overhead for each frame, so all of\nyour work needs to be completed inside **10 milliseconds**. When you fail to\nmeet this budget, the frame rate drops, and page contents judder on-screen. This\nphenomenon is often called *jank*.\n\nHowever, your targets change based on the type of work you're trying to do.\nMeeting the 10 millisecond threshold is crucial for *animations*, where the\nof objects on the screen are interpolated across a series of frames between two\npoints. When it comes to discrete changes in the user interface\u2014that is,\nproceeding from one state to another without any motion in between\u2014it's\nrecommended that you achieve such changes in a timeframe that *feels* instant to\nthe user. In cases such as these, 100 milliseconds is an oft-cited figure, but\nthe INP metric's \"good\" threshold is 200 milliseconds or lower in order to\naccommodate a wider array of devices with varying capabilities.\n\nWhatever your goals are\u2014be they producing the many frames that animations\nrequire in order to avoid jank, or merely producing a discrete visual change in\nthe user interface as quickly as possible\u2014understanding how the browser's pixel\npipeline works is essential to your work.\n\n## The pixel pipeline\n\nThere are five major areas that you need to know about and be mindful of in your\nwork as a web developer. These five areas are those that you have the most\ncontrol over, and each represents a key point in the pixels-to-screen pipeline:\n\n![The full pixel pipeline, containing five steps: JavaScript, Style, Layout, Paint, and Composite.](/static/articles/rendering-performance/image/the-full-pixel-pipeline-45b24543207ea.jpg)\n\nThe full pixel pipeline, illustrated.\n\n- **JavaScript:** JavaScript is typically used to handle work that will result\n  in visual changes to the user interface. For example, this could be jQuery's\n  `animate` function, sorting a dataset, or adding DOM elements to the page.\n  JavaScript isn't strictly necessary to trigger visual changes, though: [CSS\n  animations](/learn/css/animations), [CSS transitions](/learn/css/transitions), and [the Web Animations API](https://developer.mozilla.org/docs/Web/API/Web_Animations_API) are capable of\n  animating page contents.\n- **Style calculations:** This is the process of figuring out which CSS rules\n  apply to which HTML elements based on matching selectors. For example,\n  `.headline` is an example of a CSS selector that applies to any HTML element\n  with a `class` attribute value that contains a class of `headline`. From\n  there, once rules are known, they are applied, and the final styles for each\n  element are calculated.\n- **Layout:** Once the browser knows which rules apply to an element it can\n  begin to calculate the geometry of the page, such as how much space elements\n  take up, and where they appear on the screen. The web's layout model means\n  that one element can affect others. For example, the width of the `<body>`\n  element typically affects the dimensions of its child elements all the way up\n  and down the tree, so the process can be quite involved for the browser.\n- **Paint:** Painting is the process of filling in pixels. It involves drawing\n  out text, colors, images, borders, shadows, and essentially every visual\n  aspect of the elements after their layout on the page has been calculated.\n  The drawing is typically done onto multiple surfaces, often called layers.\n- **Composite:** Since the parts of the page were potentially drawn onto\n  multiple layers, they need to be applied to the screen in the correct order so\n  that the page renders as expected. This is especially important for elements\n  that overlap another, since a mistake could result in one element appearing\n  over the top of another incorrectly.\n\nEach of these parts of the pixel pipeline represents an opportunity to introduce\njank in animations, or delay the painting of frames even for discrete visual\nchanges to the user interface. It's therefore important to understand exactly\nwhich parts of the pipeline your code triggers, and to investigate if you can\nlimit your changes to only the parts of the pixel pipeline that are necessary to\nrender them.\n\nYou may have heard the term \"rasterize\" used in conjunction with \"paint\". This\nis because painting is actually two tasks:\n\n1. Creating a list of draw calls.\n2. Filling in the pixels.\n\nThe latter is called \"rasterization\", so whenever you see paint records in\nDevTools, you should think of it as including rasterization. In some\narchitectures, creating the list of draw calls and rasterization are done on\ndifferent threads, but that isn't under your control as a developer.\n\nYou won't always necessarily touch every part of the pipeline on every frame.\nIn fact, there are three ways the pipeline *normally* plays out for a given\nframe when you make a visual change, either with JavaScript, CSS, or the Web\nAnimations API.\n\n### 1. JS / CSS > Style > Layout > Paint > Composite\n\n![The full pixel pipeline, with none of the steps omitted.](/static/articles/rendering-performance/image/the-full-pixel-pipeline-8f8a7297e4f77.jpg)\n\nIf you change a \"layout\" property, such as one that changes an element's\ngeometry like width, height, or its position (such as the `left` or `top` CSS\nproperties), the browser needs to check all other elements and \"reflow\" the\npage. Any affected areas will need to be repainted, and the final painted\nelements will need to be composited back together.\n\n### 2. JS / CSS > Style > Paint > Composite\n\n![The pixel pipeline with the layout step omitted.](/static/articles/rendering-performance/image/the-pixel-pipeline-witho-346f1f6fd4ada.jpg)\n\nIf you changed a \"paint-only\" property for an element in CSS\u2014for example,\nproperties such as `background-image`, `color`, or `box-shadow`\u2014the layout step\nis not necessary to commit a visual update to the page. By omitting the layout\nstep\u2014where possible\u2014you avoid potentially costly layout work that could have\notherwise contributed significant latency in producing the next frame.\n\n### 3. JS / CSS > Style > Composite\n\n![The pixel pipeline with the layout and paint steps omitted.](/static/articles/rendering-performance/image/the-pixel-pipeline-withou-c9b3dd7e7ab5f.jpg)\n\nIf you change a property that requires *neither* layout or paint, the browser\ncan jump straight to the compositing step. This is the cheapest and most\ndesirable pathway through the pixel pipeline for high pressure points in a\npage's lifecycle, such as animations or scrolling. Fun fact: Chromium optimizes\nscrolling of the page so that it occurs solely on the compositor thread where\npossible, meaning that even if a page is not responding, you're still able to\nscroll the page and see parts of it that were previously drawn to the screen.\n\nWeb performance is the art of *avoiding* work, while increasing the efficiency\nof any necessary work as much as possible. In many cases, it's about working\nwith the browser, not against it. It's worth bearing in mind that the work\npreviously shown in the pipeline differs in terms of computational cost; some\ntasks are inherently more expensive than others!\n\nLet\u2019s take a dive into the different parts of the pipeline. We\u2019ll take a look\nat the common issues, as well how to diagnose and fix them.\n\n## Browser Rendering Optimizations\n\n[![Udacity course screenshot](/static/articles/rendering-performance/image/udacity-course-screenshot-4c7c3a821e1fa.jpg)](https://www.udacity.com/course/browser-rendering-optimization--ud860)\n\nPerformance matters to users, and to build good user experiences, web developers\nneed to build websites that react quickly to user interactions and render\nsmoothly. Performance expert Paul Lewis is here to help you destroy jank and\ncreate web apps that maintain 60 frames per second performance. You'll leave\nthis course with the tools you need to profile apps, and identify the causes of\nsuboptimal rendering performance. You'll also explore the browser's rendering\npipeline and uncover patterns that make it easier to build fast websites that\nusers will find delightful to use.\n\nThis is a free course offered through [Udacity](https://www.udacity.com), and you can [take it any time](https://www.udacity.com/course/browser-rendering-optimization--ud860).\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2023-12-13 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2023-12-13 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:27.325898+00:00",
  "content_length": 9912,
  "content_hash": "19960b022870238a"
}