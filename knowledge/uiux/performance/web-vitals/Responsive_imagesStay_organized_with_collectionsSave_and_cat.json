{
  "id": "web-vitals__articles_responsive-images",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/responsive-images",
  "title": "Responsive imagesStay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nResponsive images\nStay organized with collections\nSave and categorize content based on your preferences.\nA picture is worth 1000 words, and images play an integral part of every page. But they also often account for most of the downloaded bytes.  With responsive web design not only can our layouts change based on device characteristics, but images as well.\nPete LePage\nResponsive web design means that not only can our layouts change based on device\ncharacteristics, but content can change as well.  For example, on high\nresolution (2x) displays, high resolution graphics ensure sharpness. An image\nthat  is 50% width may work just fine when the browser is 800px wide, but uses\ntoo much real estate on a narrow phone, and requires the same bandwidth overhead\nwhen scaled down to fit a smaller screen.\nArt direction\nOther times the image may need to be changed more drastically: changing the\nproportions, cropping, and even replacing the entire image.  In this case,\nchanging the image is usually referred to as art direction.  See\nresponsiveimages.org/demos/\nfor more\nexamples.\nResponsive Images\nDid you know that images account for more than 60% of the bytes on average needed to load a web page?\nIn this course you will learn how to work with images on the modern web, so\nthat your images look great and load quickly on any device.\nAlong the way, you will pick up a range of skills and techniques to smoothly\nintegrate responsive images into your development workflow. By the end of\nthe course, you will be developing with images that adapt and respond to\ndifferent viewport sizes and usage scenarios.\nThis is a free course offered through\nUdacity\nTake Course\nImages in markup\nThe\nimg\nelement is powerful\u2014it downloads, decodes, and renders\ncontent\u2014and modern browsers support a range of image  formats.  Including\nimages that work across devices is no different than for desktop, and only\nrequires a few minor tweaks to create a good experience.\nSummary\nUse relative sizes for images to prevent them from accidentally overflowing\nthe container.\nUse the\npicture\nelement when you want to specify different images depending\non device characteristics (a.k.a. art direction).\nUse\nsrcset\nand the\nx\ndescriptor in the\nimg\nelement to give hints to\nthe browser about the best  image to use when choosing from different densities.\nIf your page only has one or two images and these are not used elsewhere on\nyour site, consider using inline images to reduce file requests.\nUse relative sizes for images\nRemember to use relative units when specifying widths for images to prevent them\nfrom accidentally overflowing the viewport.  For example,\nwidth: 50%;\ncauses\nthe image width to be 50% of the containing element (not 50% of the viewport or\n50% of actual pixel size).\nBecause CSS allows content to overflow its container, you may need to use max-\nwidth: 100% to prevent images and other content from overflowing.  For example:\nimg\n,\nembed\n,\nobject\n,\nvideo\n{\nmax-width\n:\n100\n%\n;\n}\nBe sure to provide meaningful descriptions via the\nalt\nattribute on\nimg\nelements; these help make your site more accessible by giving context to screen\nreaders and other assistive technologies.\nEnhance\nimg\ns with\nsrcset\nfor high DPI devices\nThe\nsrcset\nattribute enhances the behavior of the\nimg\nelement, making it easy to provide multiple image files\nfor different device characteristics. Similar to the\nimage-set\nCSS function\nnative to CSS,\nsrcset\nallows the browser to choose the best\nimage depending on the characteristics of the device, for example using\na 2x image on a 2x display, and potentially in the future, a 1x image on\na 2x device when on a limited bandwidth network.\n<img src=\"photo.png\" srcset=\"photo@2x.png 2x\" ...>\nOn browsers that don't support\nsrcset\n, the browser simply uses the default\nimage file specified by the\nsrc\nattribute.  This is why it is important to\nalways include a 1x image that can be displayed on any device, regardless of\ncapabilities.  When\nsrcset\nis supported, the  comma-separated list of\nimage/conditions is parsed prior to making any requests, and only the most\nappropriate image is downloaded and displayed.\nWhile the conditions can include everything from pixel density to width and\nheight, only pixel density is well-supported today.  To balance current\nbehavior with future features, stick with simply providing the 2x image in\nthe attribute.\nArt direction in responsive images with\npicture\nTo change images based on device characteristics, also known as art\ndirection, use the\npicture\nelement.  The\npicture\nelement defines a declarative solution for\nproviding multiple versions of an image based on different\ncharacteristics, like device size, device resolution, orientation,\nand more.\nUse the\npicture\nelement when an image source\nexists in multiple densities, or when a responsive design dictates a\nsomewhat different image on some types of screens.  Similar to the\nvideo\nelement, multiple\nsource\nelements can\nbe included, making it possible to specify different image files\ndepending on media queries or image format.\n<picture>\n  <source media=\"(min-width: 800px)\" srcset=\"head.jpg, head-2x.jpg 2x\">\n  <source media=\"(min-width: 450px)\" srcset=\"head-small.jpg, head-small-2x.jpg 2x\">\n  <img src=\"head-fb.jpg\" srcset=\"head-fb-2x.jpg 2x\" alt=\"a head carved out of wood\">\n</picture>\nTry it\nIn the above example, if the browser width is at least 800px then either\nhead.jpg\nor\nhead-2x.jpg\nis used, depending on the device resolution. If the\nbrowser is between 450px and 800px, then either\nhead-small.jpg\nor\nhead-small-\n2x.jpg\nis used, again, depending on the device resolution. For screen widths\nless than 450px and backward compatibility where the\npicture\nelement isn\u2019t\nsupported, the browser renders the\nimg\nelement instead, and should always be\nincluded.\nRelative sized images\nWhen the final size of the image isn\u2019t known, it can be difficult to specify a\ndensity descriptor for the image sources.  This is especially true for images\nthat span a proportional width of the browser and are fluid, depending on the\nsize of the browser.\nInstead of supplying fixed image sizes and densities, you can specify the size\nof each supplied image by adding a width descriptor along with the size of the\nimage element, allowing the browser to automatically calculate the effective\npixel density and choose the best image to download.\n<img src=\"lighthouse-200.jpg\" sizes=\"50vw\"\n     srcset=\"lighthouse-100.jpg 100w, lighthouse-200.jpg 200w,\n             lighthouse-400.jpg 400w, lighthouse-800.jpg 800w,\n             lighthouse-1000.jpg 1000w, lighthouse-1400.jpg 1400w,\n             lighthouse-1800.jpg 1800w\" alt=\"a lighthouse\">\nTry it\nThe above example renders an image that is half the viewport width\n(\nsizes=\"50vw\"\n), and depending on the width of the browser and its device pixel\nratio, allows the browser to choose the correct image regardless of how large\nthe browser window is. For example, the table below shows which image the\nbrowser would choose:\nBrowser width\nDevice pixel ratio\nImage used\nEffective resolution\n400px\n1\n200.jpg\n1x\n400px\n2\n400.jpg\n2x\n320px\n2\n400.jpg\n2.5x\n600px\n2\n800.jpg\n2.67x\n640px\n3\n1000.jpg\n3.125x\n1100px\n1\n800.png\n1.45x\nAccount for breakpoints in responsive images\nIn many cases, the image size may change depending on the site\u2019s layout\nbreakpoints.  For example, on a small screen, you might want the image to\nspan the full width of the viewport, while on larger screens, it should only\ntake a small proportion.\n<img src=\"400.png\"\n     sizes=\"(min-width: 600px) 25vw, (min-width: 500px) 50vw, 100vw\"\n     srcset=\"100.png 100w, 200.png 200w, 400.png 400w,\n             800.png 800w, 1600.png 1600w, 2000.png 2000w\" alt=\"an example image\">\nTry it\nThe\nsizes\nattribute, in the above example, uses several media queries to\nspecify the size of the image. When the browser width is greater than\n600px, the image is 25% of the viewport width; when it is between 500px\nand 600px, the image is 50% of the viewport width; and below 500px, it\nis full width.\nMake product images expandable\nJ. Crew's website with expandable product image.\nCustomers want to see what they're buying.  On retail sites, users expect to be\nable to view high resolution closeups of products to get a better look at\ndetails, and\nstudy participants\ngot frustrated if they weren't able to.\nA good example of tappable, expandable images is provided by the J. Crew site.\nA disappearing overlay indicates that an image is tappable, providing a zoomed\nin image with fine detail visible.\nOther image techniques\nCompressive images\nThe\ncompressive image technique\nserves a highly compressed 2x image to all devices, no matter the actual\ncapabilities of the device.  Depending on the type of image and level of\ncompression, image quality may not appear to change, but the file size drops\nsignificantly.\nTry it\nJavaScript image replacement\nJavaScript image replacement checks the capabilities of the device and \"does the\nright thing.\" You can determine device pixel ratio via\nwindow.devicePixelRatio\n, get screen width and height, and even potentially do\nsome network connection sniffing via\nnavigator.connection\nor issuing a fake\nrequest. When you've collected all of this information, you can decide which\nimage to load.\nOne big drawback to this approach is that using JavaScript means that you will\ndelay image loading until at least the look-ahead parser has finished. This\nmeans that images won't even start downloading until after the\npageload\nevent\nfires. In addition, the browser will most likely download both the 1x and 2x\nimages, resulting in increased page weight.\nInlining images: raster and vector\nThere are two fundamentally different ways to create and store images\u2014and\nthis affects how you deploy images responsively.\nRaster images\n\u2014 such as photographs and other images, are\nrepresented as a grid of individual dots of color. Raster images might come\nfrom a camera or scanner, or be created with the HTML canvas element. Formats\nlike PNG, JPEG, and WebP are used to store raster images.\nVector images\nsuch as logos and line art are defined as a set of\ncurves, lines, shapes, fill colors and gradients. Vector images can be created\nwith programs like Adobe Illustrator or Inkscape, or handwritten in code using\na vector format such as SVG.\nSVG\nSVG makes it possible to include responsive vector graphics in a web page. The\nadvantage of vector file formats over raster file formats is that the browser\ncan render a vector image at any size. Vector formats describe the geometry of\nthe image\u2014how it's constructed from lines, curves, and colors and so on.\nRaster formats, on the other hand, only have information about individual dots\nof color, so the browser has to guess how to fill in the blanks when scaling.\nBelow are two versions of the same image: a PNG image on the left and an SVG on\nthe right. The SVG looks great at any size, whereas the PNG next to it starts to\nlook blurry at larger display sizes.\nIf you want to reduce the number of file requests your page makes, you can code\nimages inline using SVG or Data URI format. If you view the source of this page,\nyou'll see that both logos below are declared inline: a Data URI and an SVG.\nSVG has\ngreat support\non mobile and desktop,\nand\noptimization tools\ncan\nsignificantly reduce SVG size. The following two inline SVG logos look\nidentical, but one is around 3KB and the other only 2KB:\nData URI\nData URIs provide a way to include a file, such as an image, inline by setting\nthe src of an\nimg\nelement as a Base64 encoded string using the\nfollowing format:\n<img src=\"data:image/svg+xml;base64,[data]\">\nThe start of the code for the HTML5 logo above looks like this:\n<img src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiB\nBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW ...\">\n(The full version is over 5000 characters in length!)\nDrag 'n' drop tool such as\njpillora.com/base64-encoder\nare\navailable to convert binary files such as images to Data URIs. Just like SVGs,\nData URIs are\nwell supported\non mobile and\ndesktop browsers.\nInlining in CSS\nData URIs and SVGs can also be inlined in CSS\u2014and this is supported on\nboth mobile and desktop. Here are two identical-looking images implemented as\nbackground images in CSS; one Data URI, one SVG:\nInlining pros & cons\nInline code for images can be verbose\u2014especially Data URIs\u2014so why\nwould you want to use it? To reduce HTTP requests! SVGs and Data URIs can enable\nan entire web page, including images, CSS and JavaScript, to be retrieved with\none single request.\nOn the downside:\nOn mobile, Data URIs can be significantly slower\nto display on mobile than images from an external\nsrc\n.\nData URIs can considerably increase the size of an HTML request.\nThey add complexity to your markup and your workflow.\nThe Data URI format is considerably bigger than binary (up to 30%) and\ntherefore doesn't reduce total download size.\nData URIs cannot be cached, so must be downloaded for every page they're used on.\nThey're not supported in IE 6 and 7, incomplete support in IE8.\nWith HTTP/2, reducing the number of asset requests will become less of a priority.\nAs with all things responsive, you need to test what works best. Use developer\ntools to measure download file size, the number of requests, and the total\nlatency. Data URIs can sometimes be useful for raster images\u2014for example,\non a homepage that only has one or two photos that aren't used elsewhere. If you\nneed to inline vector images, SVG is a much better option.\nImages in CSS\nThe CSS\nbackground\nproperty is a powerful tool for adding complex images\nto elements, making it easy to add multiple images, and causing them to repeat,\nand more.  When combined with media queries, the background property becomes\neven more powerful, enabling conditional image loading based on screen\nresolution, viewport size, and more.\nSummary\nUse the best image for the characteristics of the display, consider screen\nsize, device resolution, and page layout.\nChange the\nbackground-image\nproperty in CSS for high DPI displays using\nmedia queries with\nmin-resolution\nand\n-webkit-min-device-pixel-ratio\n.\nUse srcset to provide high resolution images in addition to the 1x image in\nmarkup.\nConsider the performance costs when using JavaScript image replacement\ntechniques or when serving highly compressed high resolution images to\nlower resolution devices.\nUse media queries for conditional image loading or art direction\nMedia queries not only affect the page layout; you can also use them to\nconditionally load images or to provide art direction depending on the viewport\nwidth.\nFor example, in the sample below, on smaller screens only\nsmall.png\nis\ndownloaded and applied to the content\ndiv\n, while on larger screens\nbackground-image: url(body.png)\nis applied to the body and\nbackground-image:\nurl(large.png)\nis applied to the content\ndiv\n.\n.\nexample\n{\nheight\n:\n400\npx\n;\nbackground-image\n:\nurl\n(\nsmall.png\n);\nbackground-repeat\n:\nno-repeat\n;\nbackground-size\n:\ncontain\n;\nbackground-position-x\n:\ncenter\n;\n}\n@\nmedia\n(\nmin-width\n:\n500px\n)\n{\nbody\n{\nbackground-image\n:\nurl\n(\nbody.png\n);\n}\n.\nexample\n{\nbackground-image\n:\nurl\n(\nlarge.png\n);\n}\n}\nTry it\nUse image-set to provide high res images\nThe\nimage-set()\nfunction in CSS enhances the behavior\nbackground\nproperty,\nmaking it easy to provide multiple image files for different device\ncharacteristics.  This allows the browser to choose the best image depending on\nthe characteristics of the device, for example using a 2x image on a 2x display,\nor a 1x image on a 2x device when on a limited bandwidth network.\nbackground-image\n:\nimage-set\n(\nurl\n(\nicon1x\n.\njpg\n)\n1x\n,\nurl\n(\nicon2x\n.\njpg\n)\n2x\n);\nIn addition to loading the correct image, the browser also scales it\naccordingly. In other words, the browser assumes that 2x images are twice as\nlarge as 1x images, and so scales the 2x image down by a factor of 2, so\nthat the image appears to be the same size on the page.\nSupport for\nimage-set()\nis still new and is only supported in Chrome and\nSafari with the\n-webkit\nvendor prefix.  Take care to include a\nfallback image for when\nimage-set()\nis not supported; for example:\n.\nsample\n{\nwidth\n:\n128\npx\n;\nheight\n:\n128\npx\n;\nbackground-image\n:\nurl\n(\nicon1x.png\n);\nbackground-image\n:\n-webkit-\nimage-set\n(\nurl\n(\nicon1x.png\n)\n1\nx\n,\nurl\n(\nicon2x.png\n)\n2\nx\n);\nbackground-image\n:\nimage-set\n(\nurl\n(\nicon1x.png\n)\n1\nx\n,\nurl\n(\nicon2x.png\n)\n2\nx\n);\n}\nTry it\nThe above loads the appropriate asset in browsers that support image-set;\notherwise it falls back to the 1x asset. The obvious caveat is that while\nimage-set()\nbrowser support is low, most browsers get the 1x asset.\nUse media queries to provide high res images or art direction\nMedia queries can create rules based on the\ndevice pixel ratio\n,\nmaking it possible to specify different images for 2x versus 1x displays.\n@\nmedia\n(\nmin-resolution\n:\n2dppx\n),\n(\n-webkit-min-device-pixel-ratio\n:\n2\n)\n{\n/* High dpi styles & resources here */\n}\nChrome, Firefox, and Opera all support the standard\n(min-resolution: 2dppx)\n,\nwhile the Safari and Android browsers both require the older vendor prefixed\nsyntax without the\ndppx\nunit.  Remember, these styles are only loaded if the\ndevice matches the media query, and you must specify styles for the base case.\nThis also provides the benefit of ensuring something is rendered if the browser\ndoesn't support resolution-specific media queries.\n.\nsample\n{\nwidth\n:\n128\npx\n;\nheight\n:\n128\npx\n;\nbackground-image\n:\nurl\n(\nicon1x.png\n);\n}\n@\nmedia\n(\nmin-resolution\n:\n2dppx\n),\n/* Standard syntax */\n(\n-webkit-min-device-pixel-ratio\n:\n2\n)\n/* Safari & Android Browser */\n{\n.\nsample\n{\nbackground-size\n:\ncontain\n;\nbackground-image\n:\nurl\n(\nicon2x.png\n);\n}\n}\nTry it\nYou can also use the min-width syntax to display alternative images depending on\nthe viewport size.  This technique has the advantage that the image is not\ndownloaded if the media query doesn't match.  For example,\nbg.png\nis only\ndownloaded and applied to the\nbody\nif the browser width is 500px or greater:\n@\nmedia\n(\nmin-width\n:\n500px\n)\n{\nbody\n{\nbackground-image\n:\nurl\n(\nbg.png\n);\n}\n}\nUse SVG for icons\nWhen adding icons to your page, use SVG icons where possible or in some\ncases, unicode characters.\nSummary\nUse SVG or unicode for icons instead of raster images.\nReplace simple icons with unicode\nMany fonts include support for the myriad of unicode glyphs, which can be used\ninstead of images. Unlike images, unicode fonts scale well and look good no\nmatter how small or large they appear on screen.\nBeyond the normal character set, unicode may include symbols for\narrows (\u2190), math operators (\u221a), geometric shapes\n(\u2605), control pictures (\u25b6), music notation (\u266c),\nGreek letters (\u03a9), even chess pieces (\u265e).\nIncluding a unicode character is done in the same way named entities are:\n&#XXXX\n, where\nXXXX\nrepresents the unicode character number. For example:\nYou're a super &#9733;\nYou're a super \u2605\nReplace complex icons with SVG\nFor more complex icon requirements, SVG icons are generally lightweight,\neasy to use, and can be styled with CSS. SVG have a number of advantages over\nraster images:\nThey're vector graphics that can be infinitely scaled.\nCSS effects such as color, shadowing, transparency, and animations are\nstraightforward.\nSVG images can be inlined right in the document.\nThey are semantic.\nThey provide better accessibility with the appropriate attributes.\nWith SVG icons, you can either add icons using inline SVG, like\nthis checkmark:\n  <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\n       xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n       width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n    <path d=\"M27 4l-15 15-7-7-5 5 12 12 20-20z\" fill=\"#000000\"></path>\n  </svg>\nor by using an image tag, like this credit card icon:\n<img src=\"credit.svg\">.\nTry it\nUse icon fonts with caution\nExample of a page that uses FontAwesome for its font icons.\nIcon fonts are popular, and can be easy to use, but have some drawbacks\ncompared to SVG icons:\nThey're vector graphics that can be infinitely scaled, but may be\nanti-aliased resulting in icons that aren\u2019t as sharp as expected.\nLimited styling with CSS.\nPixel perfect positioning can be difficult, depending on line-height,\nletter spacing, etc.\nThey aren't semantic, and can be difficult to use with screen readers or\nother assistive technology.\nUnless properly scoped, they can result in a large file size for only using a\nsmall subset of the icons available.\nWith Font Awesome, you can either add icons by using a unicode\nentity, like this HTML5 logo (<span class=\"awesome\">&#xf13b;</span>)\nor by adding special classes to an &lt;i&gt; element like the CSS3\nlogo (<i class=\"fa fa-css3\"></i>).\nTry it\nThere are hundreds of free and paid icon fonts available including\nFont\nAwesome\n,\nPictos\n, and\nGlyphicons\n.\nBe sure to balance the weight of the additional HTTP request and file size with\nthe need for the icons. For example, if you only need a handful of icons, it\nmay be better to use an image or an image sprite.\nOptimize images for performance\nImages often account for most of the downloaded bytes and also often occupy\na significant amount of the visual space on the page. As a result, optimizing\nimages can often yield some of the largest byte savings and performance\nimprovements for your website: the fewer bytes the browser has to download,\nthe less competition there is for client's bandwidth and the faster the\nbrowser can download and display all the assets.\nSummary\nDon't just randomly choose an image format\u2014understand the different\nformats available and use the format best suited.\nInclude image optimization and compression tools into your workflow to reduce\nfile sizes.\nReduce the number of http requests by placing frequently used images into\nimage sprites.\nTo improve the initial page load time and reduce the initial page weight,\nconsider loading images only after they\u2019ve scrolled into view.\nChoose the right format\nThere are two types of images to consider:\nvector images\nand\nraster images\n.\nFor raster images, you also need to choose the right compression format,\nfor example:\nGIF\n,\nPNG\n,\nJPG\n.\nRaster images\n, like photographs and other images, are represented as a grid\nof individual dots or pixels. Raster images typically come from a camera or\nscanner, or can be created in the browser with the\ncanvas\nelement.  As the\nimage size gets larger, so does the file size.  When scaled larger than their\noriginal size, raster images become blurry because the browser needs to guess\nhow to fill in the missing pixels.\nVector images\n, such as logos and line art, are defined by a set of curves,\nlines, shapes, and fill colors. Vector images are created with programs like\nAdobe Illustrator or Inkscape and saved to a vector format like\nSVG\n.  Because vector images are built on\nsimple primitives, they can be scaled without any loss in quality or\nchange in file size.\nWhen choosing the appropriate format, it is important to consider both the\norigin of the image (raster or vector), and the content (colors, animation,\ntext, etc). No one format fits all image types, and each has its own strengths\nand weaknesses.\nStart with these guidelines when choosing the appropriate format:\nUse\nJPG\nfor photographic images.\nUse\nSVG\nfor vector art and solid color graphics such as logos and line art.\nIf vector art is unavailable, try\nWebP\nor\nPNG\n.\nUse\nPNG\nrather than\nGIF\nas it allows for more colors and offers better\ncompression ratios.\nFor longer animations consider using\n<video>\n, which provides better image\nquality and gives the user control over playback.\nReduce the file size\nYou can reduce image file size considerably by \"post-processing\" the images\nafter saving. There are a number of tools for image compression\u2014lossy and\nlossless, online, GUI, command line.  Where possible, it's best to try\nautomating image optimization so that it's a built-in to your\nworkflow.\nSeveral tools are available that perform further, lossless compression on\nJPG\nand\nPNG\nfiles with no effect on image quality. For\nJPG\n, try\njpegtran\nor\njpegoptim\n(available on Linux only;\nrun with the --strip-all option). For\nPNG\n, try\nOptiPNG\nor\nPNGOUT\n.\nUse image sprites\nCSS spriting is a technique whereby a number of images are combined into a single\n\"sprite sheet\" image. You can then use individual images by specifying the\nbackground image for an element (the sprite sheet) plus an offset to display the\ncorrect part.\n.\nsprite-sheet\n{\nbackground-image\n:\nurl\n(\nsprite-sheet.png\n);\nwidth\n:\n40\npx\n;\nheight\n:\n25\npx\n;\n}\n.\ngoogle-logo\n{\nwidth\n:\n125\npx\n;\nheight\n:\n45\npx\n;\nbackground-position\n:\n-190\npx\n-170\npx\n;\n}\n.\ngmail\n{\nbackground-position\n:\n-150\npx\n-210\npx\n;\n}\n.\nmaps\n{\nheight\n:\n40\npx\n;\nbackground-position\n:\n-120\npx\n-165\npx\n;\n}\nTry it\nSpriting has the advantage of reducing the number of downloads required to get\nmultiple images, while still enabling caching.\nConsider lazy loading\nLazy loading can significantly speed up loading on long pages that include many\nimages below the fold by loading them either as needed or when the primary\ncontent has finished loading and rendering.  In addition to performance\nimprovements, using lazy loading can create infinite scrolling experiences.\nBe careful when creating infinite scrolling pages\u2014because content is loaded as\nit becomes visible, search engines may never see that content.  In addition,\nusers who are looking for information they expect to see in the footer,\nnever see the footer because new content is always loaded.\nAvoid images completely\nSometimes the best image isn't actually an image at all. Whenever possible, use\nthe native capabilities of the browser to provide the same or similar\nfunctionality.  Browsers generate visuals that would have previously required\nimages.   This means that browsers no longer need to download separate image\nfiles thus preventing awkwardly scaled images.  You can use unicode or special\nicon fonts to render icons.\nPlace text in markup instead of embedded in images\nWherever possible, text should be text and not embedded into images. For\nexample, using images for headlines or placing contact information\u2014like\nphone numbers or addresses\u2014directly into images prevents users from\ncopying and pasting the information; it makes the information inaccessible for\nscreen readers, and it isn't responsive.  Instead, place the text in your markup\nand if necessary use webfonts to achieve the style you need.\nUse CSS to replace images\nModern browsers can use CSS features to create styles that would previously have\nrequired images.  For example: complex gradients can be created using the\nbackground\nproperty, shadows can be created using\nbox-shadow\n, and rounded\ncorners can be added with the\nborder-radius\nproperty.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque sit\namet augue eu magna scelerisque porta ut ut dolor. Nullam placerat egestas\nnisl sed sollicitudin. Fusce placerat, ipsum ac vestibulum porta, purus\ndolor mollis nunc, pharetra vehicula nulla nunc quis elit. Duis ornare\nfringilla dui non vehicula. In hac habitasse platea dictumst. Donec\nipsum lectus, hendrerit malesuada sapien eget, venenatis tempus purus.\n<\nstyle\n>\ndiv\n#\nnoImage\n{\ncolor\n:\nwhite\n;\nborder-radius\n:\n5\npx\n;\nbox-shadow\n:\n5\npx\n5\npx\n4\npx\n0\nrgba\n(\n9\n,\n130\n,\n154\n,\n0.2\n);\nbackground\n:\nlinear-gradient\n(\nrgba\n(\n9\n,\n130\n,\n154\n,\n1\n),\nrgba\n(\n9\n,\n130\n,\n154\n,\n0.5\n));\n}\n<\n/\nstyle\n>\nKeep in mind that using these techniques does require rendering cycles, which\ncan be significant on mobile.  If over-used, you'll lose any benefit you may\nhave gained and it may hinder performance.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2014-04-29 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Responsive images Stay organized with collections Save and categorize content based on your preferences.\n\nA picture is worth 1000 words, and images play an integral part of every page. But they also often account for most of the downloaded bytes. With responsive web design not only can our layouts change based on device characteristics, but images as well.\n\n![Pete LePage](https://web.dev/images/authors/petelepage.jpg)\n\nPete LePage\n\nResponsive web design means that not only can our layouts change based on device\ncharacteristics, but content can change as well. For example, on high\nresolution (2x) displays, high resolution graphics ensure sharpness. An image\nthat is 50% width may work just fine when the browser is 800px wide, but uses\ntoo much real estate on a narrow phone, and requires the same bandwidth overhead\nwhen scaled down to fit a smaller screen.\n\n## Art direction\n\n![Art direction example](/static/articles/responsive-images/image/art-direction-example-2a99df174349c.png)\n\nOther times the image may need to be changed more drastically: changing the\nproportions, cropping, and even replacing the entire image. In this case,\nchanging the image is usually referred to as art direction. See\n[responsiveimages.org/demos/](https://responsiveimages.org/demos/) for more\nexamples.\n\n## Responsive Images\n\n[![Udacity Course Screenshot](/static/articles/responsive-images/image/udacity-course-screenshot-434dec66b55e5.png)](https://www.udacity.com/course/responsive-images--ud882)\n\nDid you know that images account for more than 60% of the bytes on average needed to load a web page?\n\nIn this course you will learn how to work with images on the modern web, so\nthat your images look great and load quickly on any device.\n\nAlong the way, you will pick up a range of skills and techniques to smoothly\nintegrate responsive images into your development workflow. By the end of\nthe course, you will be developing with images that adapt and respond to\ndifferent viewport sizes and usage scenarios.\n\nThis is a free course offered through [Udacity](https://www.udacity.com)\n\n[Take Course](https://www.udacity.com/course/responsive-images--ud882)\n\n## Images in markup\n\nThe `img` element is powerful\u2014it downloads, decodes, and renders\ncontent\u2014and modern browsers support a range of image formats. Including\nimages that work across devices is no different than for desktop, and only\nrequires a few minor tweaks to create a good experience.\n\n### Summary\n\n- Use relative sizes for images to prevent them from accidentally overflowing\n  the container.\n- Use the `picture` element when you want to specify different images depending\n  on device characteristics (a.k.a. art direction).\n- Use `srcset` and the `x` descriptor in the `img` element to give hints to\n  the browser about the best image to use when choosing from different densities.\n- If your page only has one or two images and these are not used elsewhere on\n  your site, consider using inline images to reduce file requests.\n\n### Use relative sizes for images\n\nRemember to use relative units when specifying widths for images to prevent them\nfrom accidentally overflowing the viewport. For example, `width: 50%;` causes\nthe image width to be 50% of the containing element (not 50% of the viewport or\n50% of actual pixel size).\n\nBecause CSS allows content to overflow its container, you may need to use max-\nwidth: 100% to prevent images and other content from overflowing. For example:\n\n```\nimg, embed, object, video {\n    max-width: 100%;\n}\n```\n\nBe sure to provide meaningful descriptions via the `alt` attribute on `img`\nelements; these help make your site more accessible by giving context to screen\nreaders and other assistive technologies.\n\n### Enhance `img`s with `srcset` for high DPI devices\n\nThe `srcset` attribute enhances the behavior of the\n`img` element, making it easy to provide multiple image files\nfor different device characteristics. Similar to the `image-set`\n[CSS function](#use_image-set_to_provide_high_res_images)\nnative to CSS, `srcset` allows the browser to choose the best\nimage depending on the characteristics of the device, for example using\na 2x image on a 2x display, and potentially in the future, a 1x image on\na 2x device when on a limited bandwidth network.\n\n```\n<img src=\"photo.png\" srcset=\"photo@2x.png 2x\" ...>\n```\n\nOn browsers that don't support `srcset`, the browser simply uses the default\nimage file specified by the `src` attribute. This is why it is important to\nalways include a 1x image that can be displayed on any device, regardless of\ncapabilities. When `srcset` is supported, the comma-separated list of\nimage/conditions is parsed prior to making any requests, and only the most\nappropriate image is downloaded and displayed.\n\nWhile the conditions can include everything from pixel density to width and\nheight, only pixel density is well-supported today. To balance current\nbehavior with future features, stick with simply providing the 2x image in\nthe attribute.\n\n### Art direction in responsive images with `picture`\n\n![Art direction example](/static/articles/responsive-images/image/art-direction-example-a02acbd7a6646.png)\n\nTo change images based on device characteristics, also known as art\ndirection, use the `picture` element. The\n`picture` element defines a declarative solution for\nproviding multiple versions of an image based on different\ncharacteristics, like device size, device resolution, orientation,\nand more.\n\nUse the `picture` element when an image source\nexists in multiple densities, or when a responsive design dictates a\nsomewhat different image on some types of screens. Similar to the\n`video` element, multiple `source` elements can\nbe included, making it possible to specify different image files\ndepending on media queries or image format.\n\n```\n<picture>\n  <source media=\"(min-width: 800px)\" srcset=\"head.jpg, head-2x.jpg 2x\">\n  <source media=\"(min-width: 450px)\" srcset=\"head-small.jpg, head-small-2x.jpg 2x\">\n  <img src=\"head-fb.jpg\" srcset=\"head-fb-2x.jpg 2x\" alt=\"a head carved out of wood\">\n</picture>\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/media.html)\n\nIn the above example, if the browser width is at least 800px then either\n`head.jpg` or `head-2x.jpg` is used, depending on the device resolution. If the\nbrowser is between 450px and 800px, then either `head-small.jpg` or `head-small-\n2x.jpg` is used, again, depending on the device resolution. For screen widths\nless than 450px and backward compatibility where the `picture` element isn\u2019t\nsupported, the browser renders the `img` element instead, and should always be\nincluded.\n\n#### Relative sized images\n\nWhen the final size of the image isn\u2019t known, it can be difficult to specify a\ndensity descriptor for the image sources. This is especially true for images\nthat span a proportional width of the browser and are fluid, depending on the\nsize of the browser.\n\nInstead of supplying fixed image sizes and densities, you can specify the size\nof each supplied image by adding a width descriptor along with the size of the\nimage element, allowing the browser to automatically calculate the effective\npixel density and choose the best image to download.\n\n```\n<img src=\"lighthouse-200.jpg\" sizes=\"50vw\"\n     srcset=\"lighthouse-100.jpg 100w, lighthouse-200.jpg 200w,\n             lighthouse-400.jpg 400w, lighthouse-800.jpg 800w,\n             lighthouse-1000.jpg 1000w, lighthouse-1400.jpg 1400w,\n             lighthouse-1800.jpg 1800w\" alt=\"a lighthouse\">\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/sizes.html)\n\nThe above example renders an image that is half the viewport width\n(`sizes=\"50vw\"`), and depending on the width of the browser and its device pixel\nratio, allows the browser to choose the correct image regardless of how large\nthe browser window is. For example, the table below shows which image the\nbrowser would choose:\n\n| Browser width | Device pixel ratio | Image used | Effective resolution |\n| --- | --- | --- | --- |\n| 400px | 1 | `200.jpg` | 1x |\n| 400px | 2 | `400.jpg` | 2x |\n| 320px | 2 | `400.jpg` | 2.5x |\n| 600px | 2 | `800.jpg` | 2.67x |\n| 640px | 3 | `1000.jpg` | 3.125x |\n| 1100px | 1 | `800.png` | 1.45x |\n\n#### Account for breakpoints in responsive images\n\nIn many cases, the image size may change depending on the site\u2019s layout\nbreakpoints. For example, on a small screen, you might want the image to\nspan the full width of the viewport, while on larger screens, it should only\ntake a small proportion.\n\n```\n<img src=\"400.png\"\n     sizes=\"(min-width: 600px) 25vw, (min-width: 500px) 50vw, 100vw\"\n     srcset=\"100.png 100w, 200.png 200w, 400.png 400w,\n             800.png 800w, 1600.png 1600w, 2000.png 2000w\" alt=\"an example image\">\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/breakpoints.html)\n\nThe `sizes` attribute, in the above example, uses several media queries to\nspecify the size of the image. When the browser width is greater than\n600px, the image is 25% of the viewport width; when it is between 500px\nand 600px, the image is 50% of the viewport width; and below 500px, it\nis full width.\n\n### Make product images expandable\n\n![J. Crews website with expandable product image](/static/articles/responsive-images/image/j-crews-website-expanda-68db8abcb92ed.png)\n\nJ. Crew's website with expandable product image.\n\nCustomers want to see what they're buying. On retail sites, users expect to be\nable to view high resolution closeups of products to get a better look at\ndetails, and\n[study participants](https://developers.google.com/web/fundamentals/getting-started/principles/#make-product-images-expandable)\ngot frustrated if they weren't able to.\n\nA good example of tappable, expandable images is provided by the J. Crew site.\nA disappearing overlay indicates that an image is tappable, providing a zoomed\nin image with fine detail visible.\n\n### Other image techniques\n\n#### Compressive images\n\nThe\n[compressive image technique](http://www.html5rocks.com/en/mobile/high-dpi/#toc-tech-overview)\nserves a highly compressed 2x image to all devices, no matter the actual\ncapabilities of the device. Depending on the type of image and level of\ncompression, image quality may not appear to change, but the file size drops\nsignificantly.\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/compressive.html)\n\n#### JavaScript image replacement\n\nJavaScript image replacement checks the capabilities of the device and \"does the\nright thing.\" You can determine device pixel ratio via\n`window.devicePixelRatio`, get screen width and height, and even potentially do\nsome network connection sniffing via `navigator.connection` or issuing a fake\nrequest. When you've collected all of this information, you can decide which\nimage to load.\n\nOne big drawback to this approach is that using JavaScript means that you will\ndelay image loading until at least the look-ahead parser has finished. This\nmeans that images won't even start downloading until after the `pageload` event\nfires. In addition, the browser will most likely download both the 1x and 2x\nimages, resulting in increased page weight.\n\n#### Inlining images: raster and vector\n\nThere are two fundamentally different ways to create and store images\u2014and\nthis affects how you deploy images responsively.\n\n**Raster images** \u2014 such as photographs and other images, are\nrepresented as a grid of individual dots of color. Raster images might come\nfrom a camera or scanner, or be created with the HTML canvas element. Formats\nlike PNG, JPEG, and WebP are used to store raster images.\n\n**Vector images** such as logos and line art are defined as a set of\ncurves, lines, shapes, fill colors and gradients. Vector images can be created\nwith programs like Adobe Illustrator or Inkscape, or handwritten in code using\na vector format such as SVG.\n\n##### SVG\n\nSVG makes it possible to include responsive vector graphics in a web page. The\nadvantage of vector file formats over raster file formats is that the browser\ncan render a vector image at any size. Vector formats describe the geometry of\nthe image\u2014how it's constructed from lines, curves, and colors and so on.\nRaster formats, on the other hand, only have information about individual dots\nof color, so the browser has to guess how to fill in the blanks when scaling.\n\nBelow are two versions of the same image: a PNG image on the left and an SVG on\nthe right. The SVG looks great at any size, whereas the PNG next to it starts to\nlook blurry at larger display sizes.\n\n![HTML5 logo, PNG format](/static/articles/responsive-images/image/html5-logo-png-format-d92f93e643a47.png)\n\n![HTML5 logo, SVG format](/static/articles/responsive-images/image/html5-logo-svg-format-550784ff36e4b.svg)\n\nIf you want to reduce the number of file requests your page makes, you can code\nimages inline using SVG or Data URI format. If you view the source of this page,\nyou'll see that both logos below are declared inline: a Data URI and an SVG.\n\n![](data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiB\n      BZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW\n      9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RUR\n      CBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2\n      ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8\n      vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OT\n      kveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMzk2Ljc0cHgiIGhlaWdodD0iNTYwc\n      HgiIHZpZXdCb3g9IjI4MS42MyAwIDM5Ni43NCA1NjAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcg\n      MjgxLjYzIDAgMzk2Ljc0IDU2MCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSINCgk+DQo8Zz4NCgk8Zz4\n      NCgkJPGc+DQoJCQk8cG9seWdvbiBmaWxsPSIjRTQ0RDI2IiBwb2ludHM9IjQwOS43MzcsMjQyLj\n      UwMiA0MTQuMjc2LDI5My4zNjIgNDc5LjgyOCwyOTMuMzYyIDQ4MCwyOTMuMzYyIDQ4MCwyNDIuN\n      TAyIDQ3OS44MjgsMjQyLjUwMiAJCQkNCgkJCQkiLz4NCgkJCTxwYXRoIGZpbGw9IiNFNDREMjYi\n      IGQ9Ik0yODEuNjMsMTEwLjA1M2wzNi4xMDYsNDA0Ljk2OEw0NzkuNzU3LDU2MGwxNjIuNDctNDU\n    uMDQybDM2LjE0NC00MDQuOTA1SDI4MS42M3ogTTYxMS4yODMsNDg5LjE3Ng0KCQkJCUw0ODAsNT\n    I1LjU3MlY0NzQuMDNsLTAuMjI5LDAuMDYzTDM3OC4wMzEsNDQ1Ljg1bC02Ljk1OC03Ny45ODVoM\n    jIuOThoMjYuODc5bDMuNTM2LDM5LjYxMmw1NS4zMTUsMTQuOTM3bDAuMDQ2LTAuMDEzdi0wLjAw\n    NA0KCQkJCUw0ODAsNDIyLjM1di03OS4zMmgtMC4xNzJIMzY4Ljg1M2wtMTIuMjA3LTEzNi44NzF\n    sLTEuMTg5LTEzLjMyNWgxMjQuMzcxSDQ4MHYtNDkuNjY4aDE2Mi4xN0w2MTEuMjgzLDQ4OS4xNz\n    Z6Ii8+DQoJCQk8cG9seWdvbiBmaWxsPSIjRjE2NTI5IiBwb2ludHM9IjQ4MCwxOTIuODMzIDYwN\n    C4yNDcsMTkyLjgzMyA2MDMuMDU5LDIwNi4xNTkgNjAwLjc5NiwyMzEuMzM4IDU5OS44LDI0Mi41\n    MDIgNTk5LjY0LDI0Mi41MDIgDQoJCQkJNDgwLDI0Mi41MDIgNDgwLDI5My4zNjIgNTgxLjg5Niw\n    yOTMuMzYyIDU5NS4yOCwyOTMuMzYyIDU5NC4wNjgsMzA2LjY5OSA1ODIuMzk2LDQzNy40NTggNT\n    gxLjY0OSw0NDUuODUgNDgwLDQ3NC4wMjEgDQoJCQkJNDgwLDQ3NC4wMyA0ODAsNTI1LjU3MiA2M\n    TEuMjgzLDQ4OS4xNzYgNjQyLjE3LDE0My4xNjYgNDgwLDE0My4xNjYgCQkJIi8+DQoJCQk8cG9s\n    eWdvbiBmaWxsPSIjRjE2NTI5IiBwb2ludHM9IjU0MC45ODgsMzQzLjAyOSA0ODAsMzQzLjAyOSA\n    0ODAsNDIyLjM1IDUzNS4yMjQsNDA3LjQ0NSAJCQkiLz4NCgkJCTxwb2x5Z29uIGZpbGw9IiNFQk\n    VCRUIiIHBvaW50cz0iNDE0LjI3NiwyOTMuMzYyIDQwOS43MzcsMjQyLjUwMiA0NzkuODI4LDI0M\n    i41MDIgNDc5LjgyOCwyNDIuMzggNDc5LjgyOCwyMjMuNjgyIA0KCQkJCTQ3OS44MjgsMTkyLjgz\n    MyAzNTUuNDU3LDE5Mi44MzMgMzU2LjY0NiwyMDYuMTU5IDM2OC44NTMsMzQzLjAyOSA0NzkuODI\n    4LDM0My4wMjkgNDc5LjgyOCwyOTMuMzYyIAkJCSIvPg0KCQkJPHBvbHlnb24gZmlsbD0iI0VCRU\n    JFQiIgcG9pbnRzPSI0NzkuODI4LDQ3NC4wNjkgNDc5LjgyOCw0MjIuNCA0NzkuNzgyLDQyMi40M\n    TMgNDI0LjQ2Nyw0MDcuNDc3IDQyMC45MzEsMzY3Ljg2NCANCgkJCQkzOTQuMDUyLDM2Ny44NjQg\n    MzcxLjA3MiwzNjcuODY0IDM3OC4wMzEsNDQ1Ljg1IDQ3OS43NzEsNDc0LjA5NCA0ODAsNDc0LjA\n    zIDQ4MCw0NzQuMDIxIAkJCSIvPg0KCQkJPHBvbHlnb24gcG9pbnRzPSIzNDMuNzg0LDUwLjIyOS\n    AzNjYuODc0LDUwLjIyOSAzNjYuODc0LDc1LjUxNyAzOTIuMTE0LDc1LjUxNyAzOTIuMTE0LDAgM\n    zY2Ljg3MywwIDM2Ni44NzMsMjQuOTM4IA0KCQkJCTM0My43ODMsMjQuOTM4IDM0My43ODMsMCAz\n    MTguNTQ0LDAgMzE4LjU0NCw3NS41MTcgMzQzLjc4NCw3NS41MTcgCQkJIi8+DQoJCQk8cG9seWd\n    vbiBwb2ludHM9IjQyNS4zMDcsMjUuMDQyIDQyNS4zMDcsNzUuNTE3IDQ1MC41NDksNzUuNTE3ID\n    Q1MC41NDksMjUuMDQyIDQ3Mi43NzksMjUuMDQyIDQ3Mi43NzksMCA0MDMuMDg1LDAgDQoJCQkJN\n    DAzLjA4NSwyNS4wNDIgNDI1LjMwNiwyNS4wNDIgCQkJIi8+DQoJCQk8cG9seWdvbiBwb2ludHM9\n    IjUwOC41MzcsMzguMDg2IDUyNS45MTQsNjQuOTM3IDUyNi4zNDksNjQuOTM3IDU0My43MTQsMzg\n    uMDg2IDU0My43MTQsNzUuNTE3IDU2OC44NTEsNzUuNTE3IDU2OC44NTEsMCANCgkJCQk1NDIuNT\n    IyLDAgNTI2LjM0OSwyNi41MzQgNTEwLjE1OSwwIDQ4My44NCwwIDQ4My44NCw3NS41MTcgNTA4L\n    jUzNyw3NS41MTcgCQkJIi8+DQoJCQk8cG9seWdvbiBwb2ludHM9IjY0Mi4xNTYsNTAuNTU1IDYw\n    Ni42Niw1MC41NTUgNjA2LjY2LDAgNTgxLjQxMiwwIDU4MS40MTIsNzUuNTE3IDY0Mi4xNTYsNzU\n    uNTE3IAkJCSIvPg0KCQkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSI0ODAsNDc0Lj\n    AyMSA1ODEuNjQ5LDQ0NS44NSA1ODIuMzk2LDQzNy40NTggNTk0LjA2OCwzMDYuNjk5IDU5NS4yO\n    CwyOTMuMzYyIDU4MS44OTYsMjkzLjM2MiANCgkJCQk0ODAsMjkzLjM2MiA0NzkuODI4LDI5My4z\n    NjIgNDc5LjgyOCwzNDMuMDI5IDQ4MCwzNDMuMDI5IDU0MC45ODgsMzQzLjAyOSA1MzUuMjI0LDQ\n    wNy40NDUgNDgwLDQyMi4zNSA0NzkuODI4LDQyMi4zOTYgDQoJCQkJNDc5LjgyOCw0MjIuNCA0Nz\n    kuODI4LDQ3NC4wNjkgCQkJIi8+DQoJCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9I\n    jQ3OS44MjgsMjQyLjM4IDQ3OS44MjgsMjQyLjUwMiA0ODAsMjQyLjUwMiA1OTkuNjQsMjQyLjUw\n    MiA1OTkuOCwyNDIuNTAyIDYwMC43OTYsMjMxLjMzOCANCgkJCQk2MDMuMDU5LDIwNi4xNTkgNjA\n    0LjI0NywxOTIuODMzIDQ4MCwxOTIuODMzIDQ3OS44MjgsMTkyLjgzMyA0NzkuODI4LDIyMy42OD\n    IgCQkJIi8+DQoJCTwvZz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==)\n\nSVG has [great support](http://caniuse.com/svg-html5) on mobile and desktop,\nand [optimization tools](https://sarasoueidan.com/blog/svgo-tools/) can\nsignificantly reduce SVG size. The following two inline SVG logos look\nidentical, but one is around 3KB and the other only 2KB:\n\n##### Data URI\n\nData URIs provide a way to include a file, such as an image, inline by setting\nthe src of an `img` element as a Base64 encoded string using the\nfollowing format:\n\n```\n<img src=\"data:image/svg+xml;base64,[data]\">\n```\n\nThe start of the code for the HTML5 logo above looks like this:\n\n```\n<img src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiB\nBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW ...\">\n```\n\n(The full version is over 5000 characters in length!)\n\nDrag 'n' drop tool such as\n[jpillora.com/base64-encoder](https://jpillora.com/base64-encoder) are\navailable to convert binary files such as images to Data URIs. Just like SVGs,\nData URIs are [well supported](http://caniuse.com/datauri) on mobile and\ndesktop browsers.\n\n##### Inlining in CSS\n\nData URIs and SVGs can also be inlined in CSS\u2014and this is supported on\nboth mobile and desktop. Here are two identical-looking images implemented as\nbackground images in CSS; one Data URI, one SVG:\n\n##### Inlining pros & cons\n\nInline code for images can be verbose\u2014especially Data URIs\u2014so why\nwould you want to use it? To reduce HTTP requests! SVGs and Data URIs can enable\nan entire web page, including images, CSS and JavaScript, to be retrieved with\none single request.\n\nOn the downside:\n\n- On mobile, Data URIs can be significantly slower\n  to display on mobile than images from an external `src`.\n- Data URIs can considerably increase the size of an HTML request.\n- They add complexity to your markup and your workflow.\n- The Data URI format is considerably bigger than binary (up to 30%) and\n  therefore doesn't reduce total download size.\n- Data URIs cannot be cached, so must be downloaded for every page they're used on.\n- They're not supported in IE 6 and 7, incomplete support in IE8.\n- With HTTP/2, reducing the number of asset requests will become less of a priority.\n\nAs with all things responsive, you need to test what works best. Use developer\ntools to measure download file size, the number of requests, and the total\nlatency. Data URIs can sometimes be useful for raster images\u2014for example,\non a homepage that only has one or two photos that aren't used elsewhere. If you\nneed to inline vector images, SVG is a much better option.\n\n## Images in CSS\n\nThe CSS `background` property is a powerful tool for adding complex images\nto elements, making it easy to add multiple images, and causing them to repeat,\nand more. When combined with media queries, the background property becomes\neven more powerful, enabling conditional image loading based on screen\nresolution, viewport size, and more.\n\n### Summary\n\n- Use the best image for the characteristics of the display, consider screen\n  size, device resolution, and page layout.\n- Change the `background-image` property in CSS for high DPI displays using\n  media queries with `min-resolution` and `-webkit-min-device-pixel-ratio`.\n- Use srcset to provide high resolution images in addition to the 1x image in\n  markup.\n- Consider the performance costs when using JavaScript image replacement\n  techniques or when serving highly compressed high resolution images to\n  lower resolution devices.\n\n### Use media queries for conditional image loading or art direction\n\nMedia queries not only affect the page layout; you can also use them to\nconditionally load images or to provide art direction depending on the viewport\nwidth.\n\nFor example, in the sample below, on smaller screens only `small.png` is\ndownloaded and applied to the content `div`, while on larger screens\n`background-image: url(body.png)` is applied to the body and `background-image:\nurl(large.png)` is applied to the content `div`.\n\n```\n.example {\n  height: 400px;\n  background-image: url(small.png);\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position-x: center;\n}\n\n@media (min-width: 500px) {\n  body {\n    background-image: url(body.png);\n  }\n  .example {\n    background-image: url(large.png);\n  }\n}\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/conditional-mq.html)\n\n### Use image-set to provide high res images\n\nThe `image-set()` function in CSS enhances the behavior `background` property,\nmaking it easy to provide multiple image files for different device\ncharacteristics. This allows the browser to choose the best image depending on\nthe characteristics of the device, for example using a 2x image on a 2x display,\nor a 1x image on a 2x device when on a limited bandwidth network.\n\n```\nbackground-image: image-set(\n    url(icon1x.jpg) 1x,\n    url(icon2x.jpg) 2x\n);\n```\n\nIn addition to loading the correct image, the browser also scales it\naccordingly. In other words, the browser assumes that 2x images are twice as\nlarge as 1x images, and so scales the 2x image down by a factor of 2, so\nthat the image appears to be the same size on the page.\n\nSupport for `image-set()` is still new and is only supported in Chrome and\nSafari with the `-webkit` vendor prefix. Take care to include a\nfallback image for when `image-set()` is not supported; for example:\n\n```\n.sample {\n  width: 128px;\n  height: 128px;\n  background-image: url(icon1x.png);\n  background-image: -webkit-image-set(\n    url(icon1x.png) 1x,\n    url(icon2x.png) 2x\n  );\n  background-image: image-set(\n    url(icon1x.png) 1x,\n    url(icon2x.png) 2x\n  );\n}\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/image-set.html)\n\nThe above loads the appropriate asset in browsers that support image-set;\notherwise it falls back to the 1x asset. The obvious caveat is that while\n`image-set()` browser support is low, most browsers get the 1x asset.\n\n### Use media queries to provide high res images or art direction\n\nMedia queries can create rules based on the\n[device pixel ratio](http://www.html5rocks.com/en/mobile/high-dpi/#toc-bg),\nmaking it possible to specify different images for 2x versus 1x displays.\n\n```\n@media (min-resolution: 2dppx),\n(-webkit-min-device-pixel-ratio: 2)\n{\n    /* High dpi styles & resources here */\n}\n```\n\nChrome, Firefox, and Opera all support the standard `(min-resolution: 2dppx)`,\nwhile the Safari and Android browsers both require the older vendor prefixed\nsyntax without the `dppx` unit. Remember, these styles are only loaded if the\ndevice matches the media query, and you must specify styles for the base case.\nThis also provides the benefit of ensuring something is rendered if the browser\ndoesn't support resolution-specific media queries.\n\n```\n.sample {\n  width: 128px;\n  height: 128px;\n  background-image: url(icon1x.png);\n}\n\n@media (min-resolution: 2dppx), /* Standard syntax */\n(-webkit-min-device-pixel-ratio: 2)  /* Safari & Android Browser */\n{\n  .sample {\n    background-size: contain;\n    background-image: url(icon2x.png);\n  }\n}\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/media-query-dppx.html)\n\nYou can also use the min-width syntax to display alternative images depending on\nthe viewport size. This technique has the advantage that the image is not\ndownloaded if the media query doesn't match. For example, `bg.png` is only\ndownloaded and applied to the `body` if the browser width is 500px or greater:\n\n```\n@media (min-width: 500px) {\n    body {\n    background-image: url(bg.png);\n    }\n}\n```\n\n## Use SVG for icons\n\nWhen adding icons to your page, use SVG icons where possible or in some\ncases, unicode characters.\n\n### Summary\n\n- Use SVG or unicode for icons instead of raster images.\n\n### Replace simple icons with unicode\n\nMany fonts include support for the myriad of unicode glyphs, which can be used\ninstead of images. Unlike images, unicode fonts scale well and look good no\nmatter how small or large they appear on screen.\n\nBeyond the normal character set, unicode may include symbols for\narrows (\u2190), math operators (\u221a), geometric shapes\n(\u2605), control pictures (\u25b6), music notation (\u266c),\nGreek letters (\u03a9), even chess pieces (\u265e).\n\nIncluding a unicode character is done in the same way named entities are:\n`&#XXXX`, where `XXXX` represents the unicode character number. For example:\n\n```\nYou're a super &#9733;\n```\n\nYou're a super \u2605\n\n### Replace complex icons with SVG\n\nFor more complex icon requirements, SVG icons are generally lightweight,\neasy to use, and can be styled with CSS. SVG have a number of advantages over\nraster images:\n\n- They're vector graphics that can be infinitely scaled.\n- CSS effects such as color, shadowing, transparency, and animations are\n  straightforward.\n- SVG images can be inlined right in the document.\n- They are semantic.\n- They provide better accessibility with the appropriate attributes.\n\n```\nWith SVG icons, you can either add icons using inline SVG, like\nthis checkmark:\n  <svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\n       xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n       width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n    <path d=\"M27 4l-15 15-7-7-5 5 12 12 20-20z\" fill=\"#000000\"></path>\n  </svg>\nor by using an image tag, like this credit card icon:\n<img src=\"credit.svg\">.\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/icon-svg.html)\n\n### Use icon fonts with caution\n\n![Example of a page that uses FontAwesome for its font icons.](/static/articles/responsive-images/image/example-a-page-uses-fon-dbf8a265a1b2e.png)\n\n[Example of a page that uses FontAwesome for its font icons.](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/icon-font.html)\n\nIcon fonts are popular, and can be easy to use, but have some drawbacks\ncompared to SVG icons:\n\n- They're vector graphics that can be infinitely scaled, but may be\n  anti-aliased resulting in icons that aren\u2019t as sharp as expected.\n- Limited styling with CSS.\n- Pixel perfect positioning can be difficult, depending on line-height,\n  letter spacing, etc.\n- They aren't semantic, and can be difficult to use with screen readers or\n  other assistive technology.\n- Unless properly scoped, they can result in a large file size for only using a\n  small subset of the icons available.\n\n```\nWith Font Awesome, you can either add icons by using a unicode\nentity, like this HTML5 logo (<span class=\"awesome\">&#xf13b;</span>)\nor by adding special classes to an &lt;i&gt; element like the CSS3\nlogo (<i class=\"fa fa-css3\"></i>).\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/icon-font.html)\n\nThere are hundreds of free and paid icon fonts available including [Font\nAwesome](https://fortawesome.github.io/Font-Awesome/),\n[Pictos](http://pictos.cc/), and [Glyphicons](https://glyphicons.com/).\n\nBe sure to balance the weight of the additional HTTP request and file size with\nthe need for the icons. For example, if you only need a handful of icons, it\nmay be better to use an image or an image sprite.\n\n## Optimize images for performance\n\nImages often account for most of the downloaded bytes and also often occupy\na significant amount of the visual space on the page. As a result, optimizing\nimages can often yield some of the largest byte savings and performance\nimprovements for your website: the fewer bytes the browser has to download,\nthe less competition there is for client's bandwidth and the faster the\nbrowser can download and display all the assets.\n\n### Summary\n\n- Don't just randomly choose an image format\u2014understand the different\n  formats available and use the format best suited.\n- Include image optimization and compression tools into your workflow to reduce\n  file sizes.\n- Reduce the number of http requests by placing frequently used images into\n  image sprites.\n- To improve the initial page load time and reduce the initial page weight,\n  consider loading images only after they\u2019ve scrolled into view.\n\n### Choose the right format\n\nThere are two types of images to consider:\n[vector images](https://en.wikipedia.org/wiki/Vector_graphics)\nand [raster images](https://en.wikipedia.org/wiki/Raster_graphics).\nFor raster images, you also need to choose the right compression format,\nfor example: `GIF`, `PNG`, `JPG`.\n\n**Raster images**, like photographs and other images, are represented as a grid\nof individual dots or pixels. Raster images typically come from a camera or\nscanner, or can be created in the browser with the `canvas` element. As the\nimage size gets larger, so does the file size. When scaled larger than their\noriginal size, raster images become blurry because the browser needs to guess\nhow to fill in the missing pixels.\n\n**Vector images**, such as logos and line art, are defined by a set of curves,\nlines, shapes, and fill colors. Vector images are created with programs like\nAdobe Illustrator or Inkscape and saved to a vector format like\n[`SVG`](https://css-tricks.com/using-svg/). Because vector images are built on\nsimple primitives, they can be scaled without any loss in quality or\nchange in file size.\n\nWhen choosing the appropriate format, it is important to consider both the\norigin of the image (raster or vector), and the content (colors, animation,\ntext, etc). No one format fits all image types, and each has its own strengths\nand weaknesses.\n\nStart with these guidelines when choosing the appropriate format:\n\n- Use `JPG` for photographic images.\n- Use `SVG` for vector art and solid color graphics such as logos and line art.\n  If vector art is unavailable, try `WebP` or `PNG`.\n- Use `PNG` rather than `GIF` as it allows for more colors and offers better\n  compression ratios.\n- For longer animations consider using `<video>`, which provides better image\n  quality and gives the user control over playback.\n\n### Reduce the file size\n\nYou can reduce image file size considerably by \"post-processing\" the images\nafter saving. There are a number of tools for image compression\u2014lossy and\nlossless, online, GUI, command line. Where possible, it's best to try\nautomating image optimization so that it's a built-in to your\nworkflow.\n\nSeveral tools are available that perform further, lossless compression on `JPG`\nand `PNG` files with no effect on image quality. For `JPG`, try\n[jpegtran](http://jpegclub.org/) or\n[jpegoptim](http://freshmeat.net/projects/jpegoptim/) (available on Linux only;\nrun with the --strip-all option). For `PNG`, try\n[OptiPNG](http://optipng.sourceforge.net/) or\n[PNGOUT](http://www.advsys.net/ken/util/pngout.htm).\n\n### Use image sprites\n\n![Image sprite sheet used in example](/static/articles/responsive-images/image/image-sprite-sheet-used-5dca0dfa226c5.png)\n\nCSS spriting is a technique whereby a number of images are combined into a single\n\"sprite sheet\" image. You can then use individual images by specifying the\nbackground image for an element (the sprite sheet) plus an offset to display the\ncorrect part.\n\n```\n.sprite-sheet {\n  background-image: url(sprite-sheet.png);\n  width: 40px;\n  height: 25px;\n}\n\n.google-logo {\n  width: 125px;\n  height: 45px;\n  background-position: -190px -170px;\n}\n\n.gmail {\n  background-position: -150px -210px;\n}\n\n.maps {\n  height: 40px;\n  background-position: -120px -165px;\n}\n```\n\n[Try it](https://googlesamples.github.io/web-fundamentals/fundamentals/design-and-ux/responsive/image-sprite.html)\n\nSpriting has the advantage of reducing the number of downloads required to get\nmultiple images, while still enabling caching.\n\n### Consider lazy loading\n\nLazy loading can significantly speed up loading on long pages that include many\nimages below the fold by loading them either as needed or when the primary\ncontent has finished loading and rendering. In addition to performance\nimprovements, using lazy loading can create infinite scrolling experiences.\n\nBe careful when creating infinite scrolling pages\u2014because content is loaded as\nit becomes visible, search engines may never see that content. In addition,\nusers who are looking for information they expect to see in the footer,\nnever see the footer because new content is always loaded.\n\n## Avoid images completely\n\nSometimes the best image isn't actually an image at all. Whenever possible, use\nthe native capabilities of the browser to provide the same or similar\nfunctionality. Browsers generate visuals that would have previously required\nimages. This means that browsers no longer need to download separate image\nfiles thus preventing awkwardly scaled images. You can use unicode or special\nicon fonts to render icons.\n\n### Place text in markup instead of embedded in images\n\nWherever possible, text should be text and not embedded into images. For\nexample, using images for headlines or placing contact information\u2014like\nphone numbers or addresses\u2014directly into images prevents users from\ncopying and pasting the information; it makes the information inaccessible for\nscreen readers, and it isn't responsive. Instead, place the text in your markup\nand if necessary use webfonts to achieve the style you need.\n\n### Use CSS to replace images\n\nModern browsers can use CSS features to create styles that would previously have\nrequired images. For example: complex gradients can be created using the\n`background` property, shadows can be created using `box-shadow`, and rounded\ncorners can be added with the `border-radius` property.\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque sit\namet augue eu magna scelerisque porta ut ut dolor. Nullam placerat egestas\nnisl sed sollicitudin. Fusce placerat, ipsum ac vestibulum porta, purus\ndolor mollis nunc, pharetra vehicula nulla nunc quis elit. Duis ornare\nfringilla dui non vehicula. In hac habitasse platea dictumst. Donec\nipsum lectus, hendrerit malesuada sapien eget, venenatis tempus purus.\n\n```\n<style>\n    div#noImage {\n    color: white;\n    border-radius: 5px;\n    box-shadow: 5px 5px 4px 0 rgba(9,130,154,0.2);\n    background: linear-gradient(rgba(9, 130, 154, 1), rgba(9, 130, 154, 0.5));\n    }\n</style>\n```\n\nKeep in mind that using these techniques does require rendering cycles, which\ncan be significant on mobile. If over-used, you'll lose any benefit you may\nhave gained and it may hinder performance.\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2014-04-29 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2014-04-29 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:40.797773+00:00",
  "content_length": 27852,
  "content_hash": "7012a994cc0372c8"
}