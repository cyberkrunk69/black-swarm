{
  "id": "web-vitals__articles_fcp",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/fcp",
  "title": "First Contentful Paint (FCP)Stay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nFirst Contentful Paint (FCP)\nStay organized with collections\nSave and categorize content based on your preferences.\nPhilip Walton\nWhat is FCP?\nFirst Contentful Paint (FCP) measures the time from when the user first navigated to the page to when any part of the page's content is rendered on the screen. For this metric, \"content\" refers to text, images (including background images),\n<svg>\nelements, or non-white\n<canvas>\nelements.\nIn this load timeline, FCP happens in the second frame, because that's when the first text and image elements are rendered to the screen.\nIn the loading timeline depicted in the preceding image, FCP happens in the second frame, as that's when the first text and image elements are rendered to the screen.\nYou'll notice that though some of the content has rendered, not all of it has rendered. This is an important distinction to make between\nFirst\nContentful Paint and\nLargest\nContentful Paint (LCP)\n\u2014which aims to measure when the page's main contents have finished loading.\nWhat is a good FCP score?\nTo provide a good user experience, sites should strive to have a First Contentful Paint of\n1.8 seconds\nor less. To ensure you're hitting this target for most of your users, a good threshold to measure is the\n75th percentile\nof page loads, segmented across mobile and desktop devices.\nGood FCP values are 1.8 seconds or less. Poor values are greater than 3.0 seconds\nHow to measure FCP\nFCP can be measured\nin the lab\nor\nin the field\n, and it's available in the following tools:\nField tools\nPageSpeed Insights\nChrome User Experience\nReport\nSearch Console (Speed\nReport)\nweb-vitals\nJavaScript library\nLab tools\nLighthouse\nChrome DevTools\nPageSpeed Insights\nMeasure FCP in JavaScript\nTo measure FCP in JavaScript, you can use the\nPaint Timing API\n. The following example shows how to create a\nPerformanceObserver\nthat listens for a\npaint\nentry with the name\nfirst-contentful-paint\nand logs it to the console.\nnew\nPerformanceObserver\n((\nentryList\n)\n=\n>\n{\nfor\n(\nconst\nentry\nof\nentryList\n.\ngetEntriesByName\n(\n'first-contentful-paint'\n))\n{\nconsole\n.\nlog\n(\n'FCP candidate:'\n,\nentry\n.\nstartTime\n,\nentry\n);\n}\n}).\nobserve\n({\ntype\n:\n'paint'\n,\nbuffered\n:\ntrue\n});\nIn the previous code snippet, the logged\nfirst-contentful-paint\nentry will tell you when the first contentful element was painted. However, in some cases this entry is not valid for measuring FCP.\nThe following section lists the differences between what the API reports and how the metric is calculated.\nDifferences between the metric and the API\nThe API will dispatch a\nfirst-contentful-paint\nentry for pages loaded in a background tab, but those pages should be ignored when calculating FCP (first paint timings should only be considered if the page was in the foreground the entire time).\nThe API does not report\nfirst-contentful-paint\nentries when the page is restored from the\nback/forward cache\n, but FCP should be measured in these cases since users experience them as distinct page visits.\nThe API\nmay not report paint timings from cross-origin iframes\n, but to properly measure FCP you should consider all frames. Sub-frames can use the API to report their paint timings to the parent frame for aggregation.\nThe API measures FCP from navigation start, but for\nprerendered pages\nFCP should be measured from\nactivationStart\nsince that corresponds to the FCP time as experienced by the user.\nRather than memorizing all these subtle differences, developers can use the\nweb-vitals\nJavaScript library\nto measure FCP, which handles these differences for you (where possible\u2014note the iframe issue is not covered):\nimport\n{\nonFCP\n}\nfrom\n'web-vitals'\n;\n// Measure and log FCP as soon as it's available.\nonFCP\n(\nconsole\n.\nlog\n);\nYou can refer to\nthe source code for\nonFCP()\nfor a complete example of how to measure FCP in JavaScript.\nHow to improve FCP\nTo learn how to improve FCP for a specific site, you can run a Lighthouse performance audit and pay attention to any specific\nopportunities\nor\ndiagnostics\nthe audit suggests.\nTo learn how to improve FCP in general (for any site), refer to the following performance guides:\nEliminate render-blocking resources\nMinify CSS\nRemove unused CSS\nRemove unused JavaScript\nPreconnect to required origins\nReduce server response times (TTFB)\nAvoid multiple page redirects\nPreload key requests\nAvoid enormous network payloads\nServe static assets with an efficient cache policy\nAvoid an excessive DOM size\nMinimize critical request depth\nEnsure text remains visible during webfont load\nKeep request counts low and transfer sizes small\nChangelog\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this\nChangelog\n.\nIf you have feedback for these metrics, you can provide it in the\nweb-vitals-feedback Google group\n.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2023-12-06 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# First Contentful Paint (FCP) Stay organized with collections Save and categorize content based on your preferences.\n\n![Philip Walton](https://web.dev/images/authors/philipwalton.jpg)\n\nPhilip Walton\n\n## What is FCP?\n\nFirst Contentful Paint (FCP) measures the time from when the user first navigated to the page to when any part of the page's content is rendered on the screen. For this metric, \"content\" refers to text, images (including background images), `<svg>` elements, or non-white `<canvas>` elements.\n\n![FCP timeline from google.com](/static/articles/fcp/image/fcp-timeline-googlecom.png)\n\nIn this load timeline, FCP happens in the second frame, because that's when the first text and image elements are rendered to the screen.\n\nIn the loading timeline depicted in the preceding image, FCP happens in the second frame, as that's when the first text and image elements are rendered to the screen.\n\nYou'll notice that though some of the content has rendered, not all of it has rendered. This is an important distinction to make between *First* Contentful Paint and [*Largest* Contentful Paint (LCP)](/articles/lcp)\u2014which aims to measure when the page's main contents have finished loading.\n\n### What is a good FCP score?\n\nTo provide a good user experience, sites should strive to have a First Contentful Paint of **1.8 seconds** or less. To ensure you're hitting this target for most of your users, a good threshold to measure is the **75th percentile** of page loads, segmented across mobile and desktop devices.\n\n![Good FCP values are 1.8 seconds or less, poor values are greater than 3.0 seconds, and anything in between needs improvement](/static/articles/fcp/image/good-fcp-values-are-18-s-421f9e1a2cc56.svg)\n\nGood FCP values are 1.8 seconds or less. Poor values are greater than 3.0 seconds\n\n## How to measure FCP\n\nFCP can be measured [in the lab](/articles/user-centric-performance-metrics#lab) or [in the field](/articles/user-centric-performance-metrics#field), and it's available in the following tools:\n\n### Field tools\n\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n- [Chrome User Experience\n  Report](https://developer.chrome.com/docs/crux)\n- [Search Console (Speed\n  Report)](https://webmasters.googleblog.com/2019/11/search-console-speed-report.html)\n- [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals)\n\n### Lab tools\n\n- [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview)\n- [Chrome DevTools](https://developer.chrome.com/docs/devtools)\n- [PageSpeed Insights](https://pagespeed.web.dev/)\n\n### Measure FCP in JavaScript\n\nTo measure FCP in JavaScript, you can use the [Paint Timing API](https://w3c.github.io/paint-timing/). The following example shows how to create a [`PerformanceObserver`](https://developer.mozilla.org/docs/Web/API/PerformanceObserver) that listens for a `paint` entry with the name `first-contentful-paint` and logs it to the console.\n\n```\nnew PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntriesByName('first-contentful-paint')) {\n    console.log('FCP candidate:', entry.startTime, entry);\n  }\n}).observe({type: 'paint', buffered: true});\n```\n\nIn the previous code snippet, the logged `first-contentful-paint` entry will tell you when the first contentful element was painted. However, in some cases this entry is not valid for measuring FCP.\n\nThe following section lists the differences between what the API reports and how the metric is calculated.\n\n#### Differences between the metric and the API\n\n- The API will dispatch a `first-contentful-paint` entry for pages loaded in a background tab, but those pages should be ignored when calculating FCP (first paint timings should only be considered if the page was in the foreground the entire time).\n- The API does not report `first-contentful-paint` entries when the page is restored from the [back/forward cache](/articles/bfcache#impact_on_core_web_vitals), but FCP should be measured in these cases since users experience them as distinct page visits.\n- The API [may not report paint timings from cross-origin iframes](https://w3c.github.io/paint-timing/#:%7E:text=cross-origin%20iframes), but to properly measure FCP you should consider all frames. Sub-frames can use the API to report their paint timings to the parent frame for aggregation.\n- The API measures FCP from navigation start, but for [prerendered pages](https://developer.chrome.com/docs/web-platform/prerender-pages) FCP should be measured from [`activationStart`](https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming/activationStart) since that corresponds to the FCP time as experienced by the user.\n\nRather than memorizing all these subtle differences, developers can use the [`web-vitals` JavaScript library](https://github.com/GoogleChrome/web-vitals) to measure FCP, which handles these differences for you (where possible\u2014note the iframe issue is not covered):\n\n```\nimport {onFCP} from 'web-vitals';\n\n// Measure and log FCP as soon as it's available.\nonFCP(console.log);\n```\n\nYou can refer to [the source code for `onFCP()`](https://github.com/GoogleChrome/web-vitals/blob/main/src/onFCP.ts) for a complete example of how to measure FCP in JavaScript.\n\n## How to improve FCP\n\nTo learn how to improve FCP for a specific site, you can run a Lighthouse performance audit and pay attention to any specific [opportunities](https://developer.chrome.com/docs/lighthouse/performance/#opportunities) or [diagnostics](https://developer.chrome.com/docs/lighthouse/performance/#diagnostics) the audit suggests.\n\nTo learn how to improve FCP in general (for any site), refer to the following performance guides:\n\n- [Eliminate render-blocking resources](https://developer.chrome.com/docs/lighthouse/performance/render-blocking-resources)\n- [Minify CSS](https://developer.chrome.com/docs/lighthouse/performance/unminified-css)\n- [Remove unused CSS](https://developer.chrome.com/docs/lighthouse/performance/unused-css-rules)\n- [Remove unused JavaScript](https://developer.chrome.com/docs/lighthouse/performance/unused-javascript)\n- [Preconnect to required origins](https://developer.chrome.com/docs/lighthouse/performance/uses-rel-preconnect)\n- [Reduce server response times (TTFB)](/articles/ttfb)\n- [Avoid multiple page redirects](https://developer.chrome.com/docs/lighthouse/performance/redirects)\n- [Preload key requests](https://developer.chrome.com/docs/lighthouse/performance/uses-rel-preload)\n- [Avoid enormous network payloads](https://developer.chrome.com/docs/lighthouse/performance/total-byte-weight)\n- [Serve static assets with an efficient cache policy](https://developer.chrome.com/docs/lighthouse/performance/uses-long-cache-ttl)\n- [Avoid an excessive DOM size](https://developer.chrome.com/docs/lighthouse/performance/dom-size)\n- [Minimize critical request depth](https://developer.chrome.com/docs/lighthouse/performance/critical-request-chains)\n- [Ensure text remains visible during webfont load](https://developer.chrome.com/docs/lighthouse/performance/font-display)\n- [Keep request counts low and transfer sizes small](https://developer.chrome.com/docs/lighthouse/performance/resource-summary)\n\n## Changelog\n\nOccasionally, bugs are discovered in the APIs used to measure metrics, and sometimes in the definitions of the metrics themselves. As a result, changes must sometimes be made, and these changes can show up as improvements or regressions in your internal reports and dashboards.\n\nTo help you manage this, all changes to either the implementation or definition of these metrics will be surfaced in this [Changelog](https://chromium.googlesource.com/chromium/src/+/main/docs/speed/metrics_changelog/fcp.md).\n\nIf you have feedback for these metrics, you can provide it in the [web-vitals-feedback Google group](https://groups.google.com/g/web-vitals-feedback).\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2023-12-06 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2023-12-06 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:17.447559+00:00",
  "content_length": 5418,
  "content_hash": "896c11cd2564e705"
}