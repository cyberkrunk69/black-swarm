{
  "id": "web-vitals__articles_preload-critical-assets",
  "source_id": "web-vitals",
  "source_name": "Web Vitals",
  "category": "performance",
  "url": "https://web.dev/articles/preload-critical-assets",
  "title": "Preload critical assets to improve loading speedStay organized with collectionsSave and categorize content based on your preferences.",
  "content": "Home\nArticles\nPreload critical assets to improve loading speed\nStay organized with collections\nSave and categorize content based on your preferences.\nHoussein Djirdeh\nJeremy Wagner\nMilica Mihajlija\nWhen you open a web page, the browser requests the HTML document from a server, parses its contents, and submits separate requests for any referenced resources. As a developer, you already know about all the resources your page needs and which of them are the most important. You can use that knowledge to request the critical resources ahead of time and speed up the loading process. This post explains how to achieve that with\n<link rel=\"preload\">\n.\nHow preloading works\nPreloading is best suited for resources typically discovered late by the browser.\nIn this example, Pacifico font is defined in the stylesheet with a\n@font-face\nrule. The browser loads the font file only after it has finished downloading and parsing the stylesheet.\nBy preloading a certain resource, you are telling the browser that you would like to fetch it sooner than the browser would otherwise discover it because you are certain that it is important for the current page.\nIn this example, Pacifico font is preloaded, so the download happens in parallel with the stylesheet.\nThe critical request chain represents the order of resources that are prioritized and fetched by the browser. Lighthouse identifies assets that are on the third level of this chain as late-discovered. You can use the\nPreload key requests\naudit to identify which resources to preload.\nYou can preload resources by adding a\n<link>\ntag with\nrel=\"preload\"\nto the head of your HTML document:\n<link rel=\"preload\" as=\"script\" href=\"critical.js\">\nThe browser caches preloaded resources so they are available immediately when needed. (It doesn't execute the scripts or apply the stylesheets.)\nResource hints, for example,\npreconnect\nand\nprefetch\n, are executed as the browser sees fit. The\npreload\n, on the other hand, is mandatory for the browser. Modern browsers are already pretty good at prioritizing resources, that's why it's important to use\npreload\nsparingly and only preload the most critical resources.\nUnused preloads trigger a Console warning in Chrome, approximately 3 seconds after the\nload\nevent.\nUse cases\nPreloading resources defined in CSS\nFonts defined with\n@font-face\nrules or background images defined in CSS files aren't discovered until the browser downloads and parses those CSS files. Preloading these resources ensures they are fetched before the CSS files have downloaded.\nPreloading CSS files\nIf you are using the\ncritical CSS approach\n, you split your CSS into two parts. The critical CSS required for rendering the above-the-fold content is inlined in the\n<head>\nof the document and non-critical CSS is usually lazy-loaded with JavaScript. Waiting for JavaScript to execute before loading non-critical CSS can cause delays in rendering when users scroll, so it's a good idea to use\n<link rel=\"preload\">\nto initiate the download sooner.\nPreloading JavaScript files\nBecause browsers don't execute preloaded files, preloading is useful to separate fetching from\nexecution\nwhich can improve metrics such as Time to Interactive. Preloading works best if you\nsplit\nyour JavaScript bundles and only preload critical chunks.\nHow to implement rel=preload\nThe simplest way to implement\npreload\nis to add a\n<link>\ntag to the\n<head>\nof the document:\n<head>\n  <link rel=\"preload\" as=\"script\" href=\"critical.js\">\n</head>\nSupplying the\nas\nattribute helps the browser set the priority of the prefetched resource according to its type, set the right headers, and determine whether the resource already exists in the cache. Accepted values for this attribute include:\nscript\n,\nstyle\n,\nfont\n,\nimage\n, and\nothers\n.\nSome types of resources, such as fonts, are loaded in\nanonymous mode\n. For those you must set the\ncrossorigin\nattribute with\npreload\n:\n<link rel=\"preload\" href=\"ComicSans.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n<link>\nelements also accept a\ntype\nattribute\n, which contains the\nMIME type\nof the linked resource. The browsers use the value of the\ntype\nattribute to make sure that resources get preloaded only if their file type is supported. If a browser doesn't support the specified resource type, it will ignore the\n<link rel=\"preload\">\n.\nYou can also preload any type of resource via the\nLink\nHTTP header\n:\nLink: </css/style.css>; rel=\"preload\"; as=\"style\"\nA benefit of specifying\npreload\nin the HTTP Header is that the browser doesn't need to parse the document to discover it, which can offer small improvements in some cases.\nPreloading JavaScript modules with webpack\nIf you are using a module bundler that creates build files of your application, you need to check if it supports the injection of preload tags. With\nwebpack\nversion 4.6.0 or later, preloading is supported through the use of\nmagic comments\ninside\nimport()\n:\nimport\n(\n_\n/* webpackPreload: true */\n_\n\"CriticalChunk\"\n)\nIf you are using an older version of webpack, use a third-party plugin such as\npreload-webpack-plugin\n.\nEffects of preloading on Core Web Vitals\nPreloading is a powerful performance optimization that has an effect on loading speed. Such optimizations can lead to changes in your site's\nCore Web Vitals\n, and it's important to be aware them.\nLargest Contentful Paint (LCP)\nPreloading has a powerful effect on\nLargest Contentful Paint (LCP)\nwhen it comes to fonts and images, as both images and text nodes can be\nLCP candidates\n. Hero images and large runs of text that are rendered using web fonts can benefit significantly from a well-placed preload hint, and should be used when there are opportunities to deliver these important bits of content to the user faster.\nHowever, you want to be careful when it comes to preloading\u2014and other optimizations! In particular, avoid preloading too many resources. If too many resources are prioritized, effectively none of them are. The effects of excessive preload hints will be especially detrimental to those on slower networks where bandwidth contention will be more evident.\nInstead, focus on a few high-value resources that you know will benefit from a well-placed preload. When preloading fonts, ensure that you're serving fonts in WOFF 2.0 format to reduce resource load time as much as possible. Since WOFF 2.0 has\nexcellent browser support\n, using older formats such as WOFF 1.0 or TrueType (TTF) will delay your LCP if the LCP candidate is a text node.\nWhen it comes to LCP and JavaScript, you'll want to ensure that you're sending complete markup from the server in order for the\nbrowser's preload scanner\nto work properly. If you're serving up an experience that relies entirely on JavaScript to render markup and can't send server-rendered HTML, it would be advantageous to step in where the browser preload scanner can't and preload resources that would only otherwise be discoverable when the JavaScript finishes loading and executing.\nCumulative Layout Shift (CLS)\nCumulative Layout Shift (CLS)\nis an especially important metric where web fonts are concerned, and CLS has significant interplay with web fonts that use the\nfont-display\nCSS property\nto manage how fonts are loaded. To minimize web font-related layout shifts, consider the following strategies:\nPreload fonts while using the default\nblock\nvalue for\nfont-display\n.\nThis is a delicate balance. Blocking the display of fonts without a fallback can be considered a user experience problem. On one hand, loading fonts with\nfont-display: block;\neliminates web font-related layout shifts. On the other hand, you still want to get those web fonts loaded as soon as possible if they're crucial to the user experience. Combining a preload with\nfont-display: block;\nmay be an acceptable compromise.\nPreload fonts while using the\nfallback\nvalue for\nfont-display\n.\nfallback\nis a compromise between\nswap\nand\nblock\n, in that it has an extremely short blocking period.\nUse the\noptional\nvalue for\nfont-display\nwithout a preload.\nIf a web font isn't crucial to the user experience, but it is still used to render a significant amount of page text, consider using the\noptional\nvalue. In adverse conditions,\noptional\nwill display page text in a fallback font while it loads the font in the background for the next navigation. The net result in these conditions is improved CLS, as system fonts will render immediately, while subsequent page loads will load the font immediately without layout shifts.\nCLS is a difficult metric to optimize for when it comes to web fonts. As always, experiment in the\nlab\n, but trust your\nfield data\nto determine if your font loading strategies are improving CLS or making it worse.\nInteraction to Next Paint (INP)\nInteraction to Next Paint\nis a metric that gauges responsiveness to user input. Since the lion's share of interactivity on the web is driven by JavaScript, preloading JavaScript that powers important interactions may help to keep a page's INP lower. However, be aware that preloading too much JavaScript during startup can carry unintended negative consequences if too many resources are contending for bandwidth.\nYou'll also want to be careful about how you go about\ncode splitting\n. Code splitting is an excellent optimization for reducing the amount of JavaScript loaded during startup, but interactions can be delayed if they rely on JavaScript loaded right at the start of the interaction. To compensate for this, you'll need to examine the user's intent, and inject a preload for the necessary chunk(s) of JavaScript before the interaction takes place. One example could be preloading JavaScript required for validating a form's contents when any of the fields in the form are focused.\nConclusion\nTo improve page speed, preload important resources that are discovered late by the browser. Preloading everything would be counterproductive so use\npreload\nsparingly and\nmeasure the impact in the real-world\n.\nExcept as otherwise noted, the content of this page is licensed under the\nCreative Commons Attribution 4.0 License\n, and code samples are licensed under the\nApache 2.0 License\n. For details, see the\nGoogle Developers Site Policies\n. Java is a registered trademark of Oracle and/or its affiliates.\nLast updated 2018-11-05 UTC.",
  "content_markdown": "- [Home](https://web.dev/)\n- [Articles](https://web.dev/articles)\n\n# Preload critical assets to improve loading speed Stay organized with collections Save and categorize content based on your preferences.\n\n![Houssein Djirdeh](https://web.dev/images/authors/houssein.jpg)\n\nHoussein Djirdeh\n\n![Jeremy Wagner](https://web.dev/images/authors/jlwagner-v6.jpg)\n\nJeremy Wagner\n\n![Milica Mihajlija](https://web.dev/images/authors/mihajlija.jpg)\n\nMilica Mihajlija\n\nWhen you open a web page, the browser requests the HTML document from a server, parses its contents, and submits separate requests for any referenced resources. As a developer, you already know about all the resources your page needs and which of them are the most important. You can use that knowledge to request the critical resources ahead of time and speed up the loading process. This post explains how to achieve that with `<link rel=\"preload\">`.\n\n## How preloading works\n\nPreloading is best suited for resources typically discovered late by the browser.\n\n![Screenshot of Chrome DevTools Network panel.](/static/articles/preload-critical-assets/image/screenshot-devtools-1.png)\n\nIn this example, Pacifico font is defined in the stylesheet with a [`@font-face`](/articles/reduce-webfont-size#define_a_font_family_with_font-face)) rule. The browser loads the font file only after it has finished downloading and parsing the stylesheet.\n\nBy preloading a certain resource, you are telling the browser that you would like to fetch it sooner than the browser would otherwise discover it because you are certain that it is important for the current page.\n\n![Screenshot of Chrome DevTools Network panel after applying preloading.](/static/articles/preload-critical-assets/image/screenshot-chrome-devtoo-debf067f48e5c.png)\n\nIn this example, Pacifico font is preloaded, so the download happens in parallel with the stylesheet.\n\nThe critical request chain represents the order of resources that are prioritized and fetched by the browser. Lighthouse identifies assets that are on the third level of this chain as late-discovered. You can use the [**Preload key requests**](https://developer.chrome.com/docs/lighthouse/performance/uses-rel-preload) audit to identify which resources to preload.\n\n![Lighthouse's preload key requests audit.](/static/articles/preload-critical-assets/image/lighthouses-preload-key-10ff8ed0fe6e4.png)\n\nYou can preload resources by adding a `<link>` tag with `rel=\"preload\"` to the head of your HTML document:\n\n```\n<link rel=\"preload\" as=\"script\" href=\"critical.js\">\n```\n\nThe browser caches preloaded resources so they are available immediately when needed. (It doesn't execute the scripts or apply the stylesheets.)\n\nResource hints, for example, [`preconnect`](/articles/preconnect-and-dns-prefetch)and [`prefetch`](/articles/link-prefetch), are executed as the browser sees fit. The `preload`, on the other hand, is mandatory for the browser. Modern browsers are already pretty good at prioritizing resources, that's why it's important to use `preload` sparingly and only preload the most critical resources.\n\nUnused preloads trigger a Console warning in Chrome, approximately 3 seconds after the `load` event.\n\n![Chrome DevTools Console warning about unused preloaded resources.](/static/articles/preload-critical-assets/image/chrome-devtools-console-w-f76d517c80d4b.png)\n\n## Use cases\n\n### Preloading resources defined in CSS\n\nFonts defined with [`@font-face`](/articles/reduce-webfont-size#define_a_font_family_with_font-face) rules or background images defined in CSS files aren't discovered until the browser downloads and parses those CSS files. Preloading these resources ensures they are fetched before the CSS files have downloaded.\n\n### Preloading CSS files\n\nIf you are using the [critical CSS approach](/articles/extract-critical-css), you split your CSS into two parts. The critical CSS required for rendering the above-the-fold content is inlined in the `<head>` of the document and non-critical CSS is usually lazy-loaded with JavaScript. Waiting for JavaScript to execute before loading non-critical CSS can cause delays in rendering when users scroll, so it's a good idea to use `<link rel=\"preload\">` to initiate the download sooner.\n\n### Preloading JavaScript files\n\nBecause browsers don't execute preloaded files, preloading is useful to separate fetching from [execution](https://developer.chrome.com/docs/lighthouse/performance/bootup-time) which can improve metrics such as Time to Interactive. Preloading works best if you [split](/articles/reduce-javascript-payloads-with-code-splitting) your JavaScript bundles and only preload critical chunks.\n\n## How to implement rel=preload\n\nThe simplest way to implement `preload` is to add a `<link>` tag to the `<head>` of the document:\n\n```\n<head>\n  <link rel=\"preload\" as=\"script\" href=\"critical.js\">\n</head>\n```\n\nSupplying the `as` attribute helps the browser set the priority of the prefetched resource according to its type, set the right headers, and determine whether the resource already exists in the cache. Accepted values for this attribute include: `script`, `style`, `font`, `image`, and [others](https://developer.mozilla.org/docs/Web/HTML/Element/link#Attributes).\n\nSome types of resources, such as fonts, are loaded in [anonymous mode](https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements). For those you must set the `crossorigin` attribute with `preload`:\n\n```\n<link rel=\"preload\" href=\"ComicSans.woff2\" as=\"font\" type=\"font/woff2\" crossorigin>\n```\n\n`<link>` elements also accept a [`type` attribute](https://developer.mozilla.org/docs/Web/HTML/Element/link#attr-type), which contains the [MIME type](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types) of the linked resource. The browsers use the value of the `type` attribute to make sure that resources get preloaded only if their file type is supported. If a browser doesn't support the specified resource type, it will ignore the `<link rel=\"preload\">`.\n\nYou can also preload any type of resource via the [`Link` HTTP header](https://developer.mozilla.org/docs/Web/HTTP/Headers/Link):\n\n`Link: </css/style.css>; rel=\"preload\"; as=\"style\"`\n\nA benefit of specifying `preload` in the HTTP Header is that the browser doesn't need to parse the document to discover it, which can offer small improvements in some cases.\n\n### Preloading JavaScript modules with webpack\n\nIf you are using a module bundler that creates build files of your application, you need to check if it supports the injection of preload tags. With [webpack](https://webpack.js.org/) version 4.6.0 or later, preloading is supported through the use of [magic comments](https://webpack.js.org/api/module-methods/#magic-comments) inside `import()`:\n\n```\nimport(_/* webpackPreload: true */_ \"CriticalChunk\")\n```\n\nIf you are using an older version of webpack, use a third-party plugin such as [preload-webpack-plugin](https://github.com/GoogleChromeLabs/preload-webpack-plugin).\n\n## Effects of preloading on Core Web Vitals\n\nPreloading is a powerful performance optimization that has an effect on loading speed. Such optimizations can lead to changes in your site's [Core Web Vitals](/articles/vitals), and it's important to be aware them.\n\n### Largest Contentful Paint (LCP)\n\nPreloading has a powerful effect on [Largest Contentful Paint (LCP)](/articles/lcp) when it comes to fonts and images, as both images and text nodes can be [LCP candidates](/articles/lcp#what-elements-are-considered). Hero images and large runs of text that are rendered using web fonts can benefit significantly from a well-placed preload hint, and should be used when there are opportunities to deliver these important bits of content to the user faster.\n\nHowever, you want to be careful when it comes to preloading\u2014and other optimizations! In particular, avoid preloading too many resources. If too many resources are prioritized, effectively none of them are. The effects of excessive preload hints will be especially detrimental to those on slower networks where bandwidth contention will be more evident.\n\nInstead, focus on a few high-value resources that you know will benefit from a well-placed preload. When preloading fonts, ensure that you're serving fonts in WOFF 2.0 format to reduce resource load time as much as possible. Since WOFF 2.0 has [excellent browser support](https://caniuse.com/woff2), using older formats such as WOFF 1.0 or TrueType (TTF) will delay your LCP if the LCP candidate is a text node.\n\nWhen it comes to LCP and JavaScript, you'll want to ensure that you're sending complete markup from the server in order for the [browser's preload scanner](/articles/preload-scanner) to work properly. If you're serving up an experience that relies entirely on JavaScript to render markup and can't send server-rendered HTML, it would be advantageous to step in where the browser preload scanner can't and preload resources that would only otherwise be discoverable when the JavaScript finishes loading and executing.\n\n### Cumulative Layout Shift (CLS)\n\n[Cumulative Layout Shift (CLS)](/articles/cls) is an especially important metric where web fonts are concerned, and CLS has significant interplay with web fonts that use the [`font-display` CSS property](https://developer.mozilla.org/docs/Web/CSS/@font-face/font-display) to manage how fonts are loaded. To minimize web font-related layout shifts, consider the following strategies:\n\n1. **Preload fonts while using the default `block` value for `font-display`.** This is a delicate balance. Blocking the display of fonts without a fallback can be considered a user experience problem. On one hand, loading fonts with `font-display: block;` eliminates web font-related layout shifts. On the other hand, you still want to get those web fonts loaded as soon as possible if they're crucial to the user experience. Combining a preload with `font-display: block;` may be an acceptable compromise.\n2. **Preload fonts while using the `fallback` value for `font-display`.** `fallback` is a compromise between `swap` and `block`, in that it has an extremely short blocking period.\n3. **Use the `optional` value for `font-display` without a preload.** If a web font isn't crucial to the user experience, but it is still used to render a significant amount of page text, consider using the `optional` value. In adverse conditions, `optional` will display page text in a fallback font while it loads the font in the background for the next navigation. The net result in these conditions is improved CLS, as system fonts will render immediately, while subsequent page loads will load the font immediately without layout shifts.\n\nCLS is a difficult metric to optimize for when it comes to web fonts. As always, experiment in the [lab](/articles/lab-and-field-data-differences#lab_data), but trust your [field data](/articles/lab-and-field-data-differences#field_data) to determine if your font loading strategies are improving CLS or making it worse.\n\n### Interaction to Next Paint (INP)\n\n[Interaction to Next Paint](/articles/inp) is a metric that gauges responsiveness to user input. Since the lion's share of interactivity on the web is driven by JavaScript, preloading JavaScript that powers important interactions may help to keep a page's INP lower. However, be aware that preloading too much JavaScript during startup can carry unintended negative consequences if too many resources are contending for bandwidth.\n\nYou'll also want to be careful about how you go about [code splitting](/articles/reduce-javascript-payloads-with-code-splitting). Code splitting is an excellent optimization for reducing the amount of JavaScript loaded during startup, but interactions can be delayed if they rely on JavaScript loaded right at the start of the interaction. To compensate for this, you'll need to examine the user's intent, and inject a preload for the necessary chunk(s) of JavaScript before the interaction takes place. One example could be preloading JavaScript required for validating a form's contents when any of the fields in the form are focused.\n\n## Conclusion\n\nTo improve page speed, preload important resources that are discovered late by the browser. Preloading everything would be counterproductive so use `preload` sparingly and [measure the impact in the real-world](/explore/fast#measure-performance-in-the-field).\n\nExcept as otherwise noted, the content of this page is licensed under the [Creative Commons Attribution 4.0 License](https://creativecommons.org/licenses/by/4.0/), and code samples are licensed under the [Apache 2.0 License](https://www.apache.org/licenses/LICENSE-2.0). For details, see the [Google Developers Site Policies](https://developers.google.com/site-policies). Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2018-11-05 UTC.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2018-11-05 UTC.\"],[],[]]",
  "tags": [
    "performance",
    "web-vitals",
    "google",
    "optimization"
  ],
  "extracted_at": "2026-02-03T12:49:36.747428+00:00",
  "content_length": 10249,
  "content_hash": "2085381b582d5d89"
}