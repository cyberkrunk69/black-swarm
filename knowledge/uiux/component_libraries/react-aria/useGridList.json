{
  "id": "react-aria__react-aria_useGridList_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useGridList.html",
  "title": "useGridList",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseGridList\nProvides the behavior and accessibility implementation for a list component with interactive children. A grid list displays data in a single column and enables a user to navigate its contents via directional navigation keys.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useGridList, useGridListItem, useGridListSelectionCheckbox}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseGridList\n<\nT\n>\n(\nprops\n:\nAriaGridListOptions\n<\nT\n>\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridListAria\nuseGridListItem\n<\nT\n>\n(\nprops\n:\nAriaGridListItemOptions\n,\nstate\n:\nListState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridListItemAria\nuseGridListSelectionCheckbox\n<\nT\n>\n(\n(\nprops\n:\nAriaGridSelectionCheckboxProps\n,\n,\nstate\n:\nListState\n<\nT\n>\n)\n)\n:\nGridSelectionCheckboxAria\nFeatures\n#\nA list can be built using\n<ul>\nor\n<ol>\nHTML elements, but does not support any user interactions.\nHTML lists are meant for static content, rather than lists with rich interactions like focusable elements within rows, keyboard navigation, row selection, etc.\nuseGridList\nhelps achieve accessible and interactive list components that can be styled as needed.\nItem selection\n\u00e2\u0080\u0093 Single or multiple selection, with optional checkboxes, disabled rows, and both\ntoggle\nand\nreplace\nselection behaviors.\nInteractive children\n\u00e2\u0080\u0093 List items may include interactive elements such as buttons, checkboxes, menus, etc.\nActions\n\u00e2\u0080\u0093 Items support optional row actions such as navigation via click, tap, double click, or\nEnter\nkey.\nAsync loading\n\u00e2\u0080\u0093 Support for loading items asynchronously, with infinite and virtualized scrolling.\nKeyboard navigation\n\u00e2\u0080\u0093 List items and focusable children can be navigated using the arrow keys, along with page up/down, home/end, etc. Typeahead, auto scrolling, and selection modifier keys are supported as well.\nTouch friendly\n\u00e2\u0080\u0093 Selection and actions adapt their behavior depending on the device. For example, selection is activated via long press on touch when item actions are present.\nAccessible\n\u00e2\u0080\u0093 Follows the\nARIA grid pattern\n, with additional selection announcements via an ARIA live region. Extensively tested across many devices and\nassistive technologies\nto ensure announcements and behaviors are consistent.\nNote\n: Use\nuseGridList\nwhen your list items may contain interactive elements such as buttons, checkboxes, menus, etc. within them. If your list items contain only static content such as text and images, then consider using\nuseListBox\ninstead for a slightly better screen reader experience (especially on mobile).\nAnatomy\n#\nA grid list consists of a container element, with rows of data inside. The rows within a list may contain focusable elements or plain text content.\nIf the list supports row selection, each row can optionally include a selection checkbox.\nThe\nuseGridList\nand\nuseGridListItem\nhooks handle keyboard, mouse, and other interactions to support\nrow selection, in list navigation, and overall focus behavior. Those hooks handle exposing the list and its contents to assistive technology using ARIA.\nuseGridListSelectionCheckbox\nhandles row selection and associating each checkbox with its respective rows\nfor assistive technology.\nuseGridList\nreturns props that you should spread onto the list container element:\nName\nType\nDescription\ngridProps\nDOMAttributes\nProps for the grid element.\nuseGridListItem\nreturns props for an individual option and its children, along with states you can use for styling:\nName\nType\nDescription\nrowProps\nDOMAttributes\nProps for the list row element.\ngridCellProps\nDOMAttributes\nProps for the grid cell element within the list row.\ndescriptionProps\nDOMAttributes\nProps for the list item description element, if any.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisSelected\nboolean\nWhether the item is currently selected.\nisFocused\nboolean\nWhether the item is currently focused.\nisDisabled\nboolean\nWhether the item is non-interactive, i.e. both selection and actions are disabled and the item may\nnot be focused. Dependent on\ndisabledKeys\nand\ndisabledBehavior\n.\nallowsSelection\nboolean\nWhether the item may be selected, dependent on\nselectionMode\n,\ndisabledKeys\n, and\ndisabledBehavior\n.\nhasAction\nboolean\nWhether the item has an action, dependent on\nonAction\n,\ndisabledKeys\n,\nand\ndisabledBehavior\n. It may also change depending on the current selection state\nof the list (e.g. when selection is primary). This can be used to enable or disable hover\nstyles or other visual indications of interactivity.\nState is managed by the\nuseListState\nhook from\n@react-stately/list\n. The state object should be passed as an option to each of the above hooks where applicable.\nNote that an\naria-label\nor\naria-labelledby\nmust be passed to the list to identify the element to assistive technology.\nState management\n#\nuseGridList\nrequires knowledge of the rows in the list in order to handle keyboard\nnavigation and other interactions. It does this using\nthe\nCollection\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut\nuseListState\nfrom\n@react-stately/list\nimplements a JSX based interface for building collections instead.\nSee\nCollection Components\nfor more information.\nIn addition,\nuseListState\nmanages the state necessary for multiple selection and exposes\na\nSelectionManager\n,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see\nSelection\n.\nExample\n#\nLists are\ncollection components\nthat include rows as child elements.\nIn this example, we'll use the standard HTML unordered list elements along with hooks from React\nAria for each child. You may also use other elements like\n<div>\nto render these components as appropriate.\nWe'll walk through creating the list container and list item, then add some additional behavior such as selection.\nThe\nuseGridList\nhook will be used to render the outer most list element. It uses\nthe\nuseListState\nhook to construct the list's collection of rows,\nand manage state such as the focused row and row selection. We'll use the collection to iterate through\nthe rows of the List and render the relevant components, which we'll define below.\nYou may notice the extra\n<div>\nwith\ngridCellProps\nin our example. This is needed because we are following the\nARIA grid pattern\n, which does not allow rows without any child\ngridcell\nelements.\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseGridList\n,\nuseGridListItem\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nList\n(\nprops\n)\n{\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLUListElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridProps\n}\n=\nuseGridList\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"list\"\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nListItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nfunction\nListItem\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nrowProps\n,\ngridCellProps\n,\nisPressed\n}\n=\nuseGridListItem\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nshowCheckbox\n=\nstate\n.\nselectionManager\n.\nselectionMode\n!==\n'none'\n&&\nstate\n.\nselectionManager\n.\nselectionBehavior\n===\n'toggle'\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nisPressed\n?\n'pressed'\n:\n''\n}\n${\nisFocusVisible\n?\n'focus-visible'\n:\n''\n}\n`\n}\n>\n<\ndiv\n{\n...\ngridCellProps\n}\n>\n{\nshowCheckbox\n&&\n<\nListCheckbox\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n}\n{\nitem\n.\nrendered\n}\n<\n/\ndiv\n>\n<\n/\nli\n>\n)\n;\n}\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseGridList\n,\nuseGridListItem\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nList\n(\nprops\n)\n{\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLUListElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridProps\n}\n=\nuseGridList\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"list\"\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nListItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nfunction\nListItem\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nrowProps\n,\ngridCellProps\n,\nisPressed\n}\n=\nuseGridListItem\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nshowCheckbox\n=\nstate\n.\nselectionManager\n.\nselectionMode\n!==\n'none'\n&&\nstate\n.\nselectionManager\n.\nselectionBehavior\n===\n'toggle'\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nisPressed\n?\n'pressed'\n:\n''\n}\n${\nisFocusVisible\n?\n'focus-visible'\n:\n''\n}\n`\n}\n>\n<\ndiv\n{\n...\ngridCellProps\n}\n>\n{\nshowCheckbox\n&&\n(\n<\nListCheckbox\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n{\nitem\n.\nrendered\n}\n<\n/\ndiv\n>\n<\n/\nli\n>\n)\n;\n}\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseGridList\n,\nuseGridListItem\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nList\n(\nprops\n)\n{\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLUListElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridProps\n}\n=\nuseGridList\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"list\"\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nListItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nfunction\nListItem\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nrowProps\n,\ngridCellProps\n,\nisPressed\n}\n=\nuseGridListItem\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nshowCheckbox\n=\nstate\n.\nselectionManager\n.\nselectionMode\n!==\n'none'\n&&\nstate\n.\nselectionManager\n.\nselectionBehavior\n===\n'toggle'\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nisPressed\n?\n'pressed'\n:\n''\n}\n${\nisFocusVisible\n?\n'focus-visible'\n:\n''\n}\n`\n}\n>\n<\ndiv\n{\n...\ngridCellProps\n}\n>\n{\nshowCheckbox\n&&\n(\n<\nListCheckbox\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n{\nitem\n.\nrendered\n}\n<\n/\ndiv\n>\n<\n/\nli\n>\n)\n;\n}\nNow we can render a basic example list, with multiple selection and interactive children in each item.\nimport\n{\nItem\n}\nfrom\n'react-stately'\n;\n// Reuse the Button from your component library. See below.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\n<\nList\naria-label\n=\n\"Example List\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\nimport\n{\nItem\n}\nfrom\n'react-stately'\n;\n// Reuse the Button from your component library. See below.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\n<\nList\naria-label\n=\n\"Example List\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\nimport\n{\nItem\n}\nfrom\n'react-stately'\n;\n// Reuse the Button from your component library. See below.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\n<\nList\naria-label\n=\n\"Example List\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\nShow CSS\n.\nlist\n{\npadding\n:\n0\n;\nlist-style\n:\nnone;\nbackground\n:\nvar\n(\n--page-background\n);\nborder\n:\n1\npx\nsolid\nvar\n(\n--spectrum-global-color-gray-400\n);\nmax-width\n:\n400\npx\n;\nmin-width\n:\n200\npx\n;\nmax-height\n:\n250\npx\n;\noverflow\n:\nauto;\n}\n\n.\nlist\nli\n{\npadding\n:\n8\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\n}\n\n.\nlist\nli\n:\nnth-child\n(\n2\nn\n) {\nbackground\n:\nvar\n(\n--spectrum-alias-highlight-hover\n);\n}\n\n.\nlist\nli\n.\npressed\n{\nbackground\n:\nvar\n(\n--spectrum-global-color-gray-200\n);\n}\n\n.\nlist\nli\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\n}\n\n.\nlist\nli\n.\nfocus-visible\n{\noutline\n:\n2\npx\nsolid slateblue;\noutline-offset\n:\n-3\npx\n;\n}\n\n.\nlist\nli\n.\nfocus-visible\n[\naria-selected\n=\ntrue\n] {\noutline-color\n:\nwhite;\n}\n\n.\nlist\nli\n[\naria-disabled\n] {\nopacity\n:\n0.4\n;\n}\n\n.\nlist\n[\nrole\n=\ngridcell\n] {\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n4\npx\n;\n}\n\n.\nlist\nli\nbutton\n{\nmargin-left\n:\nauto;\n}\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports\nnot\n(\n-webkit-touch-callout\n:\nnone) {\n  .\nlist\nli\ninput\n[\ntype\n=\ncheckbox\n] {\naccent-color\n:\nwhite;\n  }\n}\n.\nlist\n{\npadding\n:\n0\n;\nlist-style\n:\nnone;\nbackground\n:\nvar\n(\n--page-background\n);\nborder\n:\n1\npx\nsolid\nvar\n(\n--spectrum-global-color-gray-400\n);\nmax-width\n:\n400\npx\n;\nmin-width\n:\n200\npx\n;\nmax-height\n:\n250\npx\n;\noverflow\n:\nauto;\n}\n\n.\nlist\nli\n{\npadding\n:\n8\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\n}\n\n.\nlist\nli\n:\nnth-child\n(\n2\nn\n) {\nbackground\n:\nvar\n(\n--spectrum-alias-highlight-hover\n);\n}\n\n.\nlist\nli\n.\npressed\n{\nbackground\n:\nvar\n(\n--spectrum-global-color-gray-200\n);\n}\n\n.\nlist\nli\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\n}\n\n.\nlist\nli\n.\nfocus-visible\n{\noutline\n:\n2\npx\nsolid slateblue;\noutline-offset\n:\n-3\npx\n;\n}\n\n.\nlist\nli\n.\nfocus-visible\n[\naria-selected\n=\ntrue\n] {\noutline-color\n:\nwhite;\n}\n\n.\nlist\nli\n[\naria-disabled\n] {\nopacity\n:\n0.4\n;\n}\n\n.\nlist\n[\nrole\n=\ngridcell\n] {\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n4\npx\n;\n}\n\n.\nlist\nli\nbutton\n{\nmargin-left\n:\nauto;\n}\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports\nnot\n(\n-webkit-touch-callout\n:\nnone) {\n  .\nlist\nli\ninput\n[\ntype\n=\ncheckbox\n] {\naccent-color\n:\nwhite;\n  }\n}\n.\nlist\n{\npadding\n:\n0\n;\nlist-style\n:\nnone;\nbackground\n:\nvar\n(\n--page-background\n);\nborder\n:\n1\npx\nsolid\nvar\n(\n--spectrum-global-color-gray-400\n);\nmax-width\n:\n400\npx\n;\nmin-width\n:\n200\npx\n;\nmax-height\n:\n250\npx\n;\noverflow\n:\nauto;\n}\n\n.\nlist\nli\n{\npadding\n:\n8\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\n}\n\n.\nlist\nli\n:\nnth-child\n(\n2\nn\n) {\nbackground\n:\nvar\n(\n--spectrum-alias-highlight-hover\n);\n}\n\n.\nlist\nli\n.\npressed\n{\nbackground\n:\nvar\n(\n--spectrum-global-color-gray-200\n);\n}\n\n.\nlist\nli\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\n}\n\n.\nlist\nli\n.\nfocus-visible\n{\noutline\n:\n2\npx\nsolid slateblue;\noutline-offset\n:\n-3\npx\n;\n}\n\n.\nlist\nli\n.\nfocus-visible\n[\naria-selected\n=\ntrue\n] {\noutline-color\n:\nwhite;\n}\n\n.\nlist\nli\n[\naria-disabled\n] {\nopacity\n:\n0.4\n;\n}\n\n.\nlist\n[\nrole\n=\ngridcell\n] {\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n4\npx\n;\n}\n\n.\nlist\nli\nbutton\n{\nmargin-left\n:\nauto;\n}\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports\nnot\n(\n-webkit-touch-callout\n:\nnone) {\n  .\nlist\nli\ninput\n[\ntype\n=\ncheckbox\n] {\naccent-color\n:\nwhite;\n  }\n}\nAdding selection checkboxes\n#\nNext, let's add support for selection checkboxes to allow the user to select items explicitly.\nThis is done using the\nuseGridListSelectionCheckbox\nhook. It is passed the\nkey\nof the item it is contained within. When the user\nchecks or unchecks the checkbox, the row will be added or removed from the List's selection.\nThe\nCheckbox\ncomponent used in this example is independent and can be used separately from\nuseGridList\n. The code is available below.\nimport\n{\nuseGridListSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nListCheckbox\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\n{\ncheckboxProps\n}\n=\nuseGridListSelectionCheckbox\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n)\n;\nreturn\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n;\n}\nimport\n{\nuseGridListSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nListCheckbox\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\n{\ncheckboxProps\n}\n=\nuseGridListSelectionCheckbox\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n)\n;\nreturn\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n;\n}\nimport\n{\nuseGridListSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nListCheckbox\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\n{\ncheckboxProps\n}\n=\nuseGridListSelectionCheckbox\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n)\n;\nreturn\n(\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n)\n;\n}\nThe following example shows an example list with multiple selection using checkboxes and the default\ntoggle\nselection behavior\n.\n<\nList\naria-label\n=\n\"List with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\n<\nList\naria-label\n=\n\"List with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\n<\nList\naria-label\n=\n\"List with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\ntextValue\n=\n\"Charizard\"\n>\nCharizard\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Charizard...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Blastoise\"\n>\nBlastoise\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Blastoise...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Venusaur\"\n>\nVenusaur\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Venusaur...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Pikachu\"\n>\nPikachu\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for Pikachu...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n<\n/\nList\n>\nAnd that's it! We now have a fully interactive List component that can support keyboard navigation, single or multiple selection.\nIn addition, it is fully accessible for screen readers and other assistive technology. See below for more\nexamples of how to use the List component that we've built.\nCheckbox\n#\nThe\nCheckbox\ncomponent is used in the above example for row selection. It is built using the\nuseCheckbox\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\ninputRef\n=\nuseRef\n(\nnull\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nuseToggleState\n(\nprops\n)\n,\ninputRef\n)\n;\nreturn\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\ninputRef\n}\n/\n>\n;\n}\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\ninputRef\n=\nuseRef\n(\nnull\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nuseToggleState\n(\nprops\n)\n,\ninputRef\n)\n;\nreturn\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\ninputRef\n}\n/\n>\n;\n}\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\ninputRef\n=\nuseRef\n(\nnull\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nuseToggleState\n(\nprops\n)\n,\ninputRef\n)\n;\nreturn\n(\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\ninputRef\n}\n/\n>\n)\n;\n}\nButton\n#\nThe\nButton\ncomponent is used in the above example to show how rows can contain interactive elements. It is built using the\nuseButton\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nUsage\n#\nDynamic collections\n#\nSo far, our examples have shown static collections, where the data is hard coded.\nDynamic collections, as shown below, can be used when the data comes from an external data source such as an API, or updates over time.\nIn the example below, the rows are provided to the List via a render function.\nfunction\nExampleList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n}\n]\n;\nreturn\n(\n<\nList\naria-label\n=\n\"Example dynamic collection List\"\nselectionMode\n=\n\"multiple\"\nitems\n=\n{\nrows\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\ntextValue\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for\n${\nitem\n.\nname\n}\n...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n)\n}\n<\n/\nList\n>\n)\n;\n}\nfunction\nExampleList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n}\n]\n;\nreturn\n(\n<\nList\naria-label\n=\n\"Example dynamic collection List\"\nselectionMode\n=\n\"multiple\"\nitems\n=\n{\nrows\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\ntextValue\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for\n${\nitem\n.\nname\n}\n...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n)\n}\n<\n/\nList\n>\n)\n;\n}\nfunction\nExampleList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n}\n]\n;\nreturn\n(\n<\nList\naria-label\n=\n\"Example dynamic collection List\"\nselectionMode\n=\n\"multiple\"\nitems\n=\n{\nrows\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\ntextValue\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n`Info for\n${\nitem\n.\nname\n}\n...`\n)\n}\n>\nInfo\n<\n/\nButton\n>\n<\n/\nItem\n>\n)\n}\n<\n/\nList\n>\n)\n;\n}\nSingle selection\n#\nBy default,\nuseListState\ndoesn't allow row selection but this can be enabled using the\nselectionMode\nprop. Use\ndefaultSelectedKeys\nto provide a default set of selected rows.\nNote that the value of the selected keys must match the\nkey\nprop of the row.\nThe example below enables single selection mode, and uses\ndefaultSelectedKeys\nto select the row with key equal to \"2\".\nA user can click on a different row to change the selection, or click on the same row again to deselect it entirely.\n// Using the example above\n<\nExampleList\naria-label\n=\n\"List with single selection\"\nselectionMode\n=\n\"single\"\nselectionBehavior\n=\n\"replace\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\n// Using the example above\n<\nExampleList\naria-label\n=\n\"List with single selection\"\nselectionMode\n=\n\"single\"\nselectionBehavior\n=\n\"replace\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\n// Using the example above\n<\nExampleList\naria-label\n=\n\"List with single selection\"\nselectionMode\n=\n\"single\"\nselectionBehavior\n=\n\"replace\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\nMultiple selection\n#\nMultiple selection can be enabled by setting\nselectionMode\nto\nmultiple\n.\n<\nExampleList\naria-label\n=\n\"List with multiple selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\n<\nExampleList\naria-label\n=\n\"List with multiple selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\n<\nExampleList\naria-label\n=\n\"List with multiple selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\nDisallow empty selection\n#\nuseGridList\nalso supports a\ndisallowEmptySelection\nprop which forces the user to have at least one row in the List selected at all times.\nIn this mode, if a single row is selected and the user presses it, it will not be deselected.\n<\nExampleList\naria-label\n=\n\"List with disallowed empty selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\n<\nExampleList\naria-label\n=\n\"List with disallowed empty selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\n<\nExampleList\naria-label\n=\n\"List with disallowed empty selection\"\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\nControlled selection\n#\nTo programmatically control row selection, use the\nselectedKeys\nprop paired with the\nonSelectionChange\ncallback. The\nkey\nprop from the selected rows will\nbe passed into the callback when the row is pressed, allowing you to update state accordingly.\nfunction\nPokemonList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nList\naria-label\n=\n\"List with controlled selection\"\nitems\n=\n{\nrows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nList\n>\n)\n;\n}\nfunction\nPokemonList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nList\naria-label\n=\n\"List with controlled selection\"\nitems\n=\n{\nrows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nList\n>\n)\n;\n}\nfunction\nPokemonList\n(\nprops\n)\n{\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nList\naria-label\n=\n\"List with controlled selection\"\nitems\n=\n{\nrows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nList\n>\n)\n;\n}\nDisabled rows\n#\nYou can disable specific rows by providing an array of keys to\nuseListState\nvia the\ndisabledKeys\nprop. This will disable all interactions on disabled rows,\nunless the\ndisabledBehavior\nprop is used to change this behavior.\nNote that you are responsible for the styling of disabled rows, however, the selection checkbox will be automatically disabled.\n// Using the example above\n<\nPokemonList\naria-label\n=\n\"List with disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\n// Using the example above\n<\nPokemonList\naria-label\n=\n\"List with disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\n// Using the example above\n<\nPokemonList\naria-label\n=\n\"List with disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\nWhen\ndisabledBehavior\nis set to\nselection\n, interactions such as focus, dragging, or actions can still be performed on disabled rows.\n<\nPokemonList\naria-label\n=\n\"List with selection disabled for disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\ndisabledBehavior\n=\n\"selection\"\n/\n>\n<\nPokemonList\naria-label\n=\n\"List with selection disabled for disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\ndisabledBehavior\n=\n\"selection\"\n/\n>\n<\nPokemonList\naria-label\n=\n\"List with selection disabled for disabled rows\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\ndisabledBehavior\n=\n\"selection\"\n/\n>\nSelection behavior\n#\nBy default,\nuseGridList\nuses the\n\"toggle\"\nselection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the\nSpace\nor\nEnter\nkeys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection. The\n\"toggle\"\nselection mode is often paired with a checkbox in each row as an explicit affordance for selection.\nWhen\nselectionBehavior\nis set to\n\"replace\"\n, clicking a row with the mouse replaces the selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as\nCtrl\n,\nCmd\n, and\nShift\ncan be used. On touch screen devices, selection always behaves as toggle since modifier keys may not be available.\nThese selection styles implement the behaviors defined in\nAria Practices\n.\n<\nPokemonList\naria-label\n=\n\"List with replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\n<\nPokemonList\naria-label\n=\n\"List with replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\n<\nPokemonList\naria-label\n=\n\"List with replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\nRow actions\n#\nuseGridList\nsupports row actions via the\nonAction\nprop, which is useful for functionality such as navigation. When nothing is selected, the list performs actions by default when clicking or tapping a row.\nItems may be selected using the checkbox, or by long pressing on touch devices. When at least one item is selected, the list is in selection mode, and clicking or tapping a row toggles the selection. Actions may also\nbe triggered via the\nEnter\nkey, and selection using the\nSpace\nkey.\nThis behavior is slightly different when\nselectionBehavior=\"replace\"\n, where single clicking selects the row and actions are performed via double click. Touch and keyboard behaviors are unaffected.\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n24\n}\n}\n>\n<\nExampleList\naria-label\n=\n\"Checkbox selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"toggle\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nExampleList\naria-label\n=\n\"Highlight selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n24\n}\n}\n>\n<\nExampleList\naria-label\n=\n\"Checkbox selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"toggle\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nExampleList\naria-label\n=\n\"Highlight selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n24\n}\n}\n>\n<\nExampleList\naria-label\n=\n\"Checkbox selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"toggle\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nExampleList\naria-label\n=\n\"Highlight selection list with row actions\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\nLinks\n#\nItems in a GridList may also be links to another page or website. This can be achieved by passing the\nhref\nprop to the\n<Item>\ncomponent. Links behave the same way as described above for row actions depending on the\nselectionMode\nand\nselectionBehavior\n.\n<\nList\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nList\n>\n<\nList\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nList\n>\n<\nList\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nList\n>\nClient side routing\n#\nThe\n<Item>\ncomponent works with frameworks and client side routers like\nNext.js\nand\nReact Router\n. As with other React Aria components that support links, this works via the\nRouterProvider\ncomponent at the root of your app. See the\nframework setup guide\nto learn how to set this up.\nAsynchronous loading\n#\nThis example uses the\nuseAsyncList\nhook to handle asynchronous loading of data from a server. You may additionally want to display a spinner to indicate the loading state to the user, or support features like infinite scroll to load more data.\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\nfunction\nAsyncList\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n(\n{\nasync\nload\n(\n{\nsignal\n,\ncursor\n}\n)\n{\nif\n(\ncursor\n)\n{\ncursor\n=\ncursor\n.\nreplace\n(\n/\n^\nhttp:\n\\/\n\\/\n/\ni\n,\n'https://'\n)\n;\n}\nlet\nres\n=\nawait\nfetch\n(\ncursor\n||\n`https://swapi.py4e.com/api/people/?search=`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n,\ncursor\n:\njson\n.\nnext\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nList\nselectionMode\n=\n\"multiple\"\naria-label\n=\n\"Async loading ListView example\"\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nList\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\nfunction\nAsyncList\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n(\n{\nasync\nload\n(\n{\nsignal\n,\ncursor\n}\n)\n{\nif\n(\ncursor\n)\n{\ncursor\n=\ncursor\n.\nreplace\n(\n/\n^\nhttp:\n\\/\n\\/\n/\ni\n,\n'https://'\n)\n;\n}\nlet\nres\n=\nawait\nfetch\n(\ncursor\n||\n`https://swapi.py4e.com/api/people/?search=`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n,\ncursor\n:\njson\n.\nnext\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nList\nselectionMode\n=\n\"multiple\"\naria-label\n=\n\"Async loading ListView example\"\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nList\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\nfunction\nAsyncList\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n(\n{\nasync\nload\n(\n{\nsignal\n,\ncursor\n}\n)\n{\nif\n(\ncursor\n)\n{\ncursor\n=\ncursor\n.\nreplace\n(\n/\n^\nhttp:\n\\/\n\\/\n/\ni\n,\n'https://'\n)\n;\n}\nlet\nres\n=\nawait\nfetch\n(\ncursor\n||\n`https://swapi.py4e.com/api/people/?search=`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n,\ncursor\n:\njson\n.\nnext\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nList\nselectionMode\n=\n\"multiple\"\naria-label\n=\n\"Async loading ListView example\"\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nList\n>\n)\n;\n}\nInternationalization\n#\nuseGridList\nhandles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\nIntl.Collator\nfor internationalized string matching, and keyboard navigation is mirrored in right-to-left languages.\nYou are responsible for localizing all text content within the List.\nRTL\n#\nIn right-to-left languages, the list layout should be mirrored. The row contents should be ordered from right to left and the row's text alignment should be inverted. Ensure that your CSS accounts for this.\nName\nType\nDefault\nDescription\nisVirtualized\nboolean\n\u00e2\u0080\u0094\nWhether the list uses virtual scrolling.\ndisallowTypeAhead\nboolean\nfalse\nWhether typeahead navigation is disabled.\nkeyboardDelegate\nKeyboardDelegate\n\u00e2\u0080\u0094\nAn optional keyboard delegate implementation for type to select,\nto override the default.\nlayoutDelegate\nLayoutDelegate\n\u00e2\u0080\u0094\nA delegate object that provides layout information for items in the collection.\nBy default this uses the DOM, but this can be overridden to implement things like\nvirtualized scrolling.\nshouldFocusWrap\nboolean\nfalse\nWhether focus should wrap around when the end/start is reached.\nlinkBehavior\n'action'\n|\u00c2\n'selection'\n|\u00c2\n'override'\n'action'\nThe behavior of links in the collection.\n- 'action': link behaves like onAction.\n- 'selection': link follows selection interactions (e.g. if URL drives selection).\n- 'override': links override all other interactions (link items are not selectable).\nkeyboardNavigationBehavior\n'arrow'\n|\u00c2\n'tab'\n'arrow'\nWhether keyboard navigation to focusable elements within grid list items is\nvia the left/right arrow keys or the tab key.\nescapeKeyBehavior\n'clearSelection'\n|\u00c2\n'none'\n'clearSelection'\nWhether pressing the escape key should clear selection in the grid list or not.\nMost experiences should not modify this option as it eliminates a keyboard user's ability to\neasily clear selection. Only use if the escape key is being handled externally or should not\ntrigger selection clearing contextually.\nautoFocus\nboolean\n|\u00c2\nFocusStrategy\n\u00e2\u0080\u0094\nWhether to auto focus the gridlist or an option.\nonAction\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a user performs an action on an item. The exact user event depends on\nthe collection's\nselectionBehavior\nprop and the interaction modality.\ndisabledBehavior\nDisabledBehavior\n\"all\"\nWhether\ndisabledKeys\napplies to all interactions, or only selection.\nshouldSelectOnPressUp\nboolean\n\u00e2\u0080\u0094\nWhether selection should occur on press up instead of press down.\nitems\nIterable\n<\nT\n>\n\u00e2\u0080\u0094\nItem objects in the collection.\ndisabledKeys\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\nselectionMode\nSelectionMode\n\u00e2\u0080\u0094\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\n\u00e2\u0080\u0094\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the selection changes.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nMethod\nDescription\ngetKeyBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually below the given one, or\nnull\nfor none.\ngetKeyAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually above the given one, or\nnull\nfor none.\ngetKeyLeftOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the left of the given one, or\nnull\nfor none.\ngetKeyRightOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the right of the given one, or\nnull\nfor none.\ngetKeyPageBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page below the given one, or\nnull\nfor none.\ngetKeyPageAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page above the given one, or\nnull\nfor none.\ngetFirstKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the first key, or\nnull\nfor none.\ngetLastKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the last key, or\nnull\nfor none.\ngetKeyForSearch\n(\n(\nsearch\n:\nstring\n,\n,\nfromKey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the next key after\nfromKey\nthat matches the given search string, or\nnull\nfor none.\nA LayoutDelegate provides layout information for collection items.\nMethod\nDescription\ngetItemRect\n(\n(\nkey\n:\nKey\n)\n)\n:\nRect\n|\u00c2\nnull\nReturns a rectangle for the item with the given key.\ngetVisibleRect\n(\n)\n:\nRect\nReturns the visible rectangle of the collection.\ngetContentSize\n(\n)\n:\nSize\nReturns the size of the scrollable content in the collection.\ngetKeyRange\n(\n(\nfrom\n:\nKey\n,\n,\nto\n:\nKey\n)\n)\n:\nKey\n[]\nReturns a list of keys between\nfrom\nand\nto\n.\nName\nType\nDescription\nx\nnumber\ny\nnumber\nwidth\nnumber\nheight\nnumber\nName\nType\nDescription\nwidth\nnumber\nheight\nnumber\n'first'\n|\u00c2\n'last'\nstring\n|\u00c2\nnumber\n'selection'\n|\u00c2\n'all'\n'none'\n|\u00c2\n'single'\n|\u00c2\n'multiple'\n'all'\n|\u00c2\nSet\n<\nKey\n>\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA collection of items in the list.\ndisabledKeys\nSet\n<\nKey\n>\nA set of items that are disabled.\nselectionManager\nSelectionManager\nA selection manager to read and update multiple selection state.\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\nExtends\n:\nIterable\nProperties\nName\nType\nDescription\nsize\nnumber\nThe number of items in the collection.\nMethods\nMethod\nDescription\ngetKeys\n(\n)\n:\nIterable\n<\nKey\n>\nIterate over all keys in the collection.\ngetItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by its key.\nat\n(\n(\nidx\n:\nnumber\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by the index of its key.\ngetKeyBefore\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes before the given key in the collection.\ngetKeyAfter\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes after the given key in the collection.\ngetFirstKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the first key in the collection.\ngetLastKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the last key in the collection.\ngetChildren\n(\n(\nkey\n:\nKey\n)\n)\n:\nIterable\n<\nT\n>\nIterate over the child items of the given key.\ngetTextValue\n(\n(\nkey\n:\nKey\n)\n)\n:\nstring\nReturns a string representation of the item's contents.\nfilter\n(\n(\nfilterFn\n:\n(\n(\nnodeValue\n:\nstring\n,\n,\nnode\n:\nT\n)\n)\n=>\nboolean\n)\n)\n:\nCollection\n<\nT\n>\nFilters the collection using the given function.\nName\nType\nDescription\ntype\nstring\nThe type of item this node represents.\nkey\nKey\nA unique key for the node.\nvalue\nT\n|\u00c2\nnull\nThe object value the node was created from.\nlevel\nnumber\nThe level of depth this node is at in the hierarchy.\nhasChildNodes\nboolean\nWhether this item has children, even if not loaded yet.\nrendered\nReactNode\nThe rendered contents of this node (e.g. JSX).\ntextValue\nstring\nA string value for this node, used for features like typeahead.\nindex\nnumber\nThe index of this node within its parent.\naria-label\nstring\nAn accessibility label for this node.\nwrapper\n(\n(\nelement\n:\nReactElement\n)\n)\n=>\nReactElement\nA function that should be called to wrap the rendered node.\nparentKey\nKey\n|\u00c2\nnull\nThe key of the parent node.\nprevKey\nKey\n|\u00c2\nnull\nThe key of the node before this node.\nnextKey\nKey\n|\u00c2\nnull\nThe key of the node after this node.\nprops\nany\nAdditional properties specific to a particular node type.\nrender\n(\n(\nnode\n:\nNode\n<\nany\n>\n)\n)\n=>\nReactElement\nA function that renders this node to a React Element in the DOM.\nAn interface for reading and updating multiple selection state.\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nunknown\n>\n>\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nselectedKeys\nSet\n<\nKey\n>\nThe currently selected keys in the collection.\nrawSelection\nSelection\nThe raw selection value for the collection.\nEither 'all' for select all, or a set of keys.\nisEmpty\nboolean\nWhether the selection is empty.\nisSelectAll\nboolean\nWhether all items in the collection are selected.\nfirstSelectedKey\nKey\n|\u00c2\nnull\nlastSelectedKey\nKey\n|\u00c2\nnull\ndisabledKeys\nSet\n<\nKey\n>\ndisabledBehavior\nDisabledBehavior\nMethods\nMethod\nDescription\nconstructor\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n,\nstate\n:\nMultipleSelectionState\n,\noptions\n?\n:\nSelectionManagerOptions\n)\n:\nvoid\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchildFocusStrategy\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key.\nisSelected\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nReturns whether a key is selected.\nextendSelection\n(\n(\ntoKey\n:\nKey\n)\n)\n:\nvoid\nExtends the selection to the given key.\ntoggleSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles whether the given key is selected.\nreplaceSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nReplaces the selection with only the given key.\nsetSelectedKeys\n(\n(\nkeys\n:\nIterable\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the selection with the given keys.\nselectAll\n(\n)\n:\nvoid\nSelects all items in the collection.\nclearSelection\n(\n)\n:\nvoid\nRemoves all keys from the selection.\ntoggleSelectAll\n(\n)\n:\nvoid\nToggles between select all and an empty selection.\nselect\n(\n(\nkey\n:\nKey\n,\n,\ne\n?\n:\nPressEvent\n|\u00c2\nLongPressEvent\n|\u00c2\nPointerEvent\n)\n)\n:\nvoid\nisSelectionEqual\n(\n(\nselection\n:\nSet\n<\nKey\n>\n)\n)\n:\nboolean\nReturns whether the current selection is equal to the given selection.\ncanSelectItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisDisabled\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisLink\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\ngetItemProps\n(\n(\nkey\n:\nKey\n)\n)\n:\nany\nwithCollection\n(\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n)\n)\n:\nSelectionManager\nProperties\nName\nType\nDescription\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\nSelection\nThe currently selected keys in the collection.\ndisabledKeys\nSet\n<\nKey\n>\nThe currently disabled keys in the collection.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to selection, actions, or both.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nMethods\nMethod\nDescription\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetSelectedKeys\n(\n(\nkeys\n:\nSelection\n)\n)\n:\nvoid\nSets the selected keys in the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchild\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key, and optionally, whether the first or last child of that key should receive focus.\n'toggle'\n|\u00c2\n'replace'\nName\nType\nDescription\nallowsCellSelection\nboolean\nlayoutDelegate\nLayoutDelegate\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nName\nType\nDescription\ntype\n'longpressstart'\n|\u00c2\n'longpressend'\n|\u00c2\n'longpress'\nThe type of long press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nName\nType\nDescription\ncurrent\nT\nName\nType\nDescription\ngridProps\nDOMAttributes\nProps for the grid element.\nAll DOM attributes supported across both HTML and SVG elements.\nExtends\n:\nAriaAttributes\n,\nReactDOMAttributes\nName\nType\nDescription\nid\nstring\n|\u00c2\nundefined\nrole\nAriaRole\n|\u00c2\nundefined\ntabIndex\nnumber\n|\u00c2\nundefined\nstyle\nCSSProperties\n|\u00c2\nundefined\nclassName\nstring\n|\u00c2\nundefined\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nName\nType\nDescription\nnode\nNode\n<\nunknown\n>\nAn object representing the list item. Contains all the relevant information that makes up the list row.\nisVirtualized\nboolean\nWhether the list row is contained in a virtual scroller.\nshouldSelectOnPressUp\nboolean\nWhether selection should occur on press up instead of press down.\nhasChildItems\nboolean\nWhether this item has children, even if not loaded yet.\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA collection of items in the tree.\ndisabledKeys\nSet\n<\nKey\n>\nA set of keys for items that are disabled.\nexpandedKeys\nSet\n<\nKey\n>\nA set of keys for items that are expanded.\nselectionManager\nSelectionManager\nA selection manager to read and update multiple selection state.\nMethods\nMethod\nDescription\ntoggleKey\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles the expanded state for an item by its key.\nsetExpandedKeys\n(\n(\nkeys\n:\nSet\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the set of expanded keys.\nName\nType\nDescription\nrowProps\nDOMAttributes\nProps for the list row element.\ngridCellProps\nDOMAttributes\nProps for the grid cell element within the list row.\ndescriptionProps\nDOMAttributes\nProps for the list item description element, if any.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisSelected\nboolean\nWhether the item is currently selected.\nisFocused\nboolean\nWhether the item is currently focused.\nisDisabled\nboolean\nWhether the item is non-interactive, i.e. both selection and actions are disabled and the item may\nnot be focused. Dependent on\ndisabledKeys\nand\ndisabledBehavior\n.\nallowsSelection\nboolean\nWhether the item may be selected, dependent on\nselectionMode\n,\ndisabledKeys\n, and\ndisabledBehavior\n.\nhasAction\nboolean\nWhether the item has an action, dependent on\nonAction\n,\ndisabledKeys\n,\nand\ndisabledBehavior\n. It may also change depending on the current selection state\nof the list (e.g. when selection is primary). This can be used to enable or disable hover\nstyles or other visual indications of interactivity.\nName\nType\nDescription\nkey\nKey\nA unique key for the checkbox.\nName\nType\nDescription\ncheckboxProps\nAriaCheckboxProps\nProps for the row selection checkbox element.\nName\nType\nDefault\nDescription\nisIndeterminate\nboolean\n\u00e2\u0080\u0094\nIndeterminism is presentational only.\nThe indeterminate visual representation remains regardless of user interaction.\nchildren\nReactNode\n\u00e2\u0080\u0094\nThe label for the element.\nvalue\nstring\n\u00e2\u0080\u0094\nThe value of the input element, used when submitting an HTML form. See\nMDN\n.\ndefaultSelected\nboolean\n\u00e2\u0080\u0094\nWhether the element should be selected (uncontrolled).\nisSelected\nboolean\n\u00e2\u0080\u0094\nWhether the element should be selected (controlled).\nonChange\n(\n(\nisSelected\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's selection state changes.\nisDisabled\nboolean\n\u00e2\u0080\u0094\nWhether the input is disabled.\nisReadOnly\nboolean\n\u00e2\u0080\u0094\nWhether the input can be selected but not changed by the user.\nisRequired\nboolean\n\u00e2\u0080\u0094\nWhether user input is required on the input before form submission.\nisInvalid\nboolean\n\u00e2\u0080\u0094\nWhether the input value is invalid.\nvalidationBehavior\n'aria'\n|\u00c2\n'native'\n'aria'\nWhether to use native HTML form validation to prevent form submission\nwhen the value is missing or invalid, or mark the field as required\nor invalid via ARIA.\nvalidate\n(\n(\nvalue\n:\nboolean\n)\n)\n=>\nValidationError\n|\u00c2\ntrue\n|\u00c2\nnull\n|\u00c2\nundefined\n\u00e2\u0080\u0094\nA function that returns an error message if a given value is invalid.\nValidation errors are displayed to the user when the form is submitted\nif\nvalidationBehavior=\"native\"\n. For realtime validation, use the\nisInvalid\nprop instead.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element should receive focus on render.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nname\nstring\n\u00e2\u0080\u0094\nThe name of the input element, used when submitting an HTML form. See\nMDN\n.\nform\nstring\n\u00e2\u0080\u0094\nThe\n<form>\nelement to associate the input with.\nThe value of this attribute must be the id of a\n<form>\nin the same document.\nSee\nMDN\n.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) whose contents or presence are controlled by the current element.\nexcludeFromTabOrder\nboolean\n\u00e2\u0080\u0094\nWhether to exclude the element from the sequential tab order. If true,\nthe element will not be focusable via the keyboard by tabbing. This should\nbe avoided except in rare scenarios where an alternative means of accessing\nthe element or its functionality via the keyboard is available.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\naria-errormessage\nstring\n\u00e2\u0080\u0094\nIdentifies the element that provides an error message for the object.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\n'valid'\n|\u00c2\n'invalid'\nstring\n|\u00c2\nstring\n[]\nBaseEvent\n<\nReactKeyboardEvent\n<\nany\n>\n>\nSyntheticEvent\n&\u00c2\n{\nstopPropagation\n:\n(\n)\n=>\nvoid\n,\ncontinuePropagation\n:\n(\n)\n=>\nvoid\n}\nProvides the behavior and accessibility implementation for a list component with interactive children.\nA grid list displays data in a single column and enables a user to navigate its contents via directional navigation keys.\nuseGridList\n<\nT\n>\n(\nprops\n:\nAriaGridListOptions\n<\nT\n>\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridListAria\nProvides the behavior and accessibility implementation for a row in a grid list.\nuseGridListItem\n<\nT\n>\n(\nprops\n:\nAriaGridListItemOptions\n,\nstate\n:\nListState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridListItemAria\nProvides the behavior and accessibility implementation for a selection checkbox in a grid list.\nuseGridListSelectionCheckbox\n<\nT\n>\n(\n(\nprops\n:\nAriaGridSelectionCheckboxProps\n,\n,\nstate\n:\nListState\n<\nT\n>\n)\n)\n:\nGridSelectionCheckboxAria\nProvides state management for list-like components. Handles building a collection\nof items from props, and manages multiple selection state.\nuseListState\n<\nT\nextends\nobject\n>\n(\n(\nprops\n:\nListProps\n<\nT\n>\n)\n)\n:\nListState\n<\nT\n>\nName\nType\nDescription\nfilter\n(\n(\nnodes\n:\nIterable\n<\nNode\n<\nT\n>\n>\n)\n)\n=>\nIterable\n<\nNode\n<\nT\n>\n>\nFilter function to generate a filtered list of nodes.\nlayoutDelegate\nLayoutDelegate\nA delegate object that provides layout information for items in the collection.\nThis can be used to override the behavior of shift selection.\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA pre-constructed collection to use instead of building one from items and children.\nselectionBehavior\nSelectionBehavior\nHow multiple selection should behave in the collection.\nallowDuplicateSelectionEvents\nboolean\nWhether onSelectionChange should fire even if the new set of keys is the same as the last.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to all interactions, or only selection.\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\nHandler that is called when the selection changes.\ndisabledKeys\nIterable\n<\nKey\n>\nThe currently disabled keys in the collection (controlled).\nA RouterProvider accepts a\nnavigate\nfunction from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\nName\nType\nDescription\nnavigate\n(\n(\npath\n:\nHref\n,\n,\nrouterOptions\n:\nRouterOptions\n|\u00c2\n|\u00c2\nundefined\n)\n)\n=>\nvoid\nchildren\nReactNode\nuseHref\n(\n(\nhref\n:\nHref\n)\n)\n=>\nstring\nRouterConfig\nextends\n{\nhref\n:\nany\n}\n?\nH\n:\nstring\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with\nhref\nand\nrouterOptions\nproperties to configure your router.\nRouterConfig\nextends\n{\nrouterOptions\n:\nany\n}\n?\nO\n:\nnever",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../GridList).\n\n# useGridList\n\nProvides the behavior and accessibility implementation for a list component with interactive children. A grid list displays data in a single column and enables a user to navigate its contents via directional navigation keys.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useGridList, useGridListItem, useGridListSelectionCheckbox} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/grid/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/gridlist \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/gridlist \"View package\")\n\n## API[#](#api)\n\n---\n\n`useGridList<T>(\nprops: AriaGridListOptions<T>,\nstate: ListState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridListAria`\n`useGridListItem<T>(\nprops: AriaGridListItemOptions,\nstate: ListState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridListItemAria`\n`useGridListSelectionCheckbox<T>(\n(props: AriaGridSelectionCheckboxProps,\n, state: ListState<T>\n)): GridSelectionCheckboxAria`\n\n## Features[#](#features)\n\n---\n\nA list can be built using [<ul>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul) or [<ol>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol) HTML elements, but does not support any user interactions.\nHTML lists are meant for static content, rather than lists with rich interactions like focusable elements within rows, keyboard navigation, row selection, etc.\n`useGridList` helps achieve accessible and interactive list components that can be styled as needed.\n\n- **Item selection** \u00e2\u0080\u0093 Single or multiple selection, with optional checkboxes, disabled rows, and both `toggle` and `replace` selection behaviors.\n- **Interactive children** \u00e2\u0080\u0093 List items may include interactive elements such as buttons, checkboxes, menus, etc.\n- **Actions** \u00e2\u0080\u0093 Items support optional row actions such as navigation via click, tap, double click, or `Enter` key.\n- **Async loading** \u00e2\u0080\u0093 Support for loading items asynchronously, with infinite and virtualized scrolling.\n- **Keyboard navigation** \u00e2\u0080\u0093 List items and focusable children can be navigated using the arrow keys, along with page up/down, home/end, etc. Typeahead, auto scrolling, and selection modifier keys are supported as well.\n- **Touch friendly** \u00e2\u0080\u0093 Selection and actions adapt their behavior depending on the device. For example, selection is activated via long press on touch when item actions are present.\n- **Accessible** \u00e2\u0080\u0093 Follows the [ARIA grid pattern](https://www.w3.org/WAI/ARIA/apg/patterns/grid/), with additional selection announcements via an ARIA live region. Extensively tested across many devices and [assistive technologies](../quality#supported-screen-readers) to ensure announcements and behaviors are consistent.\n\n**Note**: Use `useGridList` when your list items may contain interactive elements such as buttons, checkboxes, menus, etc. within them. If your list items contain only static content such as text and images, then consider using [useListBox](../ListBox/useListBox.html) instead for a slightly better screen reader experience (especially on mobile).\n\n## Anatomy[#](#anatomy)\n\n---\n\nA grid list consists of a container element, with rows of data inside. The rows within a list may contain focusable elements or plain text content.\nIf the list supports row selection, each row can optionally include a selection checkbox.\n\nThe `useGridList` and `useGridListItem` hooks handle keyboard, mouse, and other interactions to support\nrow selection, in list navigation, and overall focus behavior. Those hooks handle exposing the list and its contents to assistive technology using ARIA. `useGridListSelectionCheckbox` handles row selection and associating each checkbox with its respective rows\nfor assistive technology.\n\n`useGridList` returns props that you should spread onto the list container element:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `gridProps` | `DOMAttributes` | Props for the grid element. |\n\n`useGridListItem` returns props for an individual option and its children, along with states you can use for styling:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rowProps` | `DOMAttributes` | Props for the list row element. |\n| `gridCellProps` | `DOMAttributes` | Props for the grid cell element within the list row. |\n| `descriptionProps` | `DOMAttributes` | Props for the list item description element, if any. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isFocused` | `boolean` | Whether the item is currently focused. |\n| `isDisabled` | `boolean` | Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may not be focused. Dependent on `disabledKeys` and `disabledBehavior`. |\n| `allowsSelection` | `boolean` | Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`. |\n| `hasAction` | `boolean` | Whether the item has an action, dependent on `onAction`, `disabledKeys`, and `disabledBehavior`. It may also change depending on the current selection state of the list (e.g. when selection is primary). This can be used to enable or disable hover styles or other visual indications of interactivity. |\n\nState is managed by the `useListState`\nhook from `@react-stately/list`. The state object should be passed as an option to each of the above hooks where applicable.\n\nNote that an `aria-label` or `aria-labelledby` must be passed to the list to identify the element to assistive technology.\n\n## State management[#](#state-management)\n\n---\n\n`useGridList` requires knowledge of the rows in the list in order to handle keyboard\nnavigation and other interactions. It does this using\nthe `Collection`\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut `useListState` from\n`@react-stately/list` implements a JSX based interface for building collections instead.\nSee [Collection Components](https://react-spectrum.adobe.com/v3/collections.html) for more information.\n\nIn addition, `useListState`\nmanages the state necessary for multiple selection and exposes\na `SelectionManager`,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see [Selection](https://react-spectrum.adobe.com/v3/selection.html).\n\n## Example[#](#example)\n\n---\n\nLists are [collection components](https://react-spectrum.adobe.com/v3/collections.html) that include rows as child elements.\nIn this example, we'll use the standard HTML unordered list elements along with hooks from React\nAria for each child. You may also use other elements like `<div>` to render these components as appropriate.\nWe'll walk through creating the list container and list item, then add some additional behavior such as selection.\n\nThe `useGridList` hook will be used to render the outer most list element. It uses\nthe `useListState` hook to construct the list's collection of rows,\nand manage state such as the focused row and row selection. We'll use the collection to iterate through\nthe rows of the List and render the relevant components, which we'll define below.\n\nYou may notice the extra `<div>` with `gridCellProps` in our example. This is needed because we are following the [ARIA grid pattern](https://www.w3.org/WAI/ARIA/apg/patterns/grid/), which does not allow rows without any child `gridcell` elements.\n\n```\nimport {mergeProps, useFocusRing, useGridList, useGridListItem} from 'react-aria';\nimport {useListState} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction List(props) {\n  let state = useListState(props);\n  let ref = useRef<HTMLUListElement | null>(null);\n  let { gridProps } = useGridList(props, state, ref);\n\n  return (\n    <ul {...gridProps} ref={ref} className=\"list\">\n      {[...state.collection].map((item) => (\n        <ListItem key={item.key} item={item} state={state} />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item, state }) {\n  let ref = React.useRef(null);\n  let { rowProps, gridCellProps, isPressed } = useGridListItem(\n    { node: item },\n    state,\n    ref\n  );\n\n  let { isFocusVisible, focusProps } = useFocusRing();\n  let showCheckbox = state.selectionManager.selectionMode !== 'none' &&\n    state.selectionManager.selectionBehavior === 'toggle';\n\n  return (\n    <li\n      {...mergeProps(rowProps, focusProps)}\n      ref={ref}\n      className={`${isPressed ? 'pressed' : ''} ${\n        isFocusVisible ? 'focus-visible' : ''\n      }`}\n    >\n      <div {...gridCellProps}>\n        {showCheckbox && <ListCheckbox item={item} state={state} />}\n        {item.rendered}\n      </div>\n    </li>\n  );\n}\n```\n\n```\nimport {\n  mergeProps,\n  useFocusRing,\n  useGridList,\n  useGridListItem\n} from 'react-aria';\nimport {useListState} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction List(props) {\n  let state = useListState(props);\n  let ref = useRef<HTMLUListElement | null>(null);\n  let { gridProps } = useGridList(props, state, ref);\n\n  return (\n    <ul {...gridProps} ref={ref} className=\"list\">\n      {[...state.collection].map((item) => (\n        <ListItem\n          key={item.key}\n          item={item}\n          state={state}\n        />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem({ item, state }) {\n  let ref = React.useRef(null);\n  let { rowProps, gridCellProps, isPressed } =\n    useGridListItem(\n      { node: item },\n      state,\n      ref\n    );\n\n  let { isFocusVisible, focusProps } = useFocusRing();\n  let showCheckbox =\n    state.selectionManager.selectionMode !== 'none' &&\n    state.selectionManager.selectionBehavior === 'toggle';\n\n  return (\n    <li\n      {...mergeProps(rowProps, focusProps)}\n      ref={ref}\n      className={`${isPressed ? 'pressed' : ''} ${\n        isFocusVisible ? 'focus-visible' : ''\n      }`}\n    >\n      <div {...gridCellProps}>\n        {showCheckbox && (\n          <ListCheckbox item={item} state={state} />\n        )}\n        {item.rendered}\n      </div>\n    </li>\n  );\n}\n```\n\n```\nimport {\n  mergeProps,\n  useFocusRing,\n  useGridList,\n  useGridListItem\n} from 'react-aria';\nimport {useListState} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction List(props) {\n  let state =\n    useListState(props);\n  let ref = useRef<\n    | HTMLUListElement\n    | null\n  >(null);\n  let { gridProps } =\n    useGridList(\n      props,\n      state,\n      ref\n    );\n\n  return (\n    <ul\n      {...gridProps}\n      ref={ref}\n      className=\"list\"\n    >\n      {[\n        ...state\n          .collection\n      ].map((item) => (\n        <ListItem\n          key={item.key}\n          item={item}\n          state={state}\n        />\n      ))}\n    </ul>\n  );\n}\n\nfunction ListItem(\n  { item, state }\n) {\n  let ref = React.useRef(\n    null\n  );\n  let {\n    rowProps,\n    gridCellProps,\n    isPressed\n  } = useGridListItem(\n    { node: item },\n    state,\n    ref\n  );\n\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n  let showCheckbox =\n    state\n        .selectionManager\n        .selectionMode !==\n      'none' &&\n    state\n        .selectionManager\n        .selectionBehavior ===\n      'toggle';\n\n  return (\n    <li\n      {...mergeProps(\n        rowProps,\n        focusProps\n      )}\n      ref={ref}\n      className={`${\n        isPressed\n          ? 'pressed'\n          : ''\n      } ${\n        isFocusVisible\n          ? 'focus-visible'\n          : ''\n      }`}\n    >\n      <div\n        {...gridCellProps}\n      >\n        {showCheckbox &&\n          (\n            <ListCheckbox\n              item={item}\n              state={state}\n            />\n          )}\n        {item.rendered}\n      </div>\n    </li>\n  );\n}\n```\n\nNow we can render a basic example list, with multiple selection and interactive children in each item.\n\n```\nimport {Item} from 'react-stately';\n\n// Reuse the Button from your component library. See below.\nimport {Button} from 'your-component-library';\n\n<List\n  aria-label=\"Example List\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button onPress={() => alert(`Info for Charizard...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button onPress={() => alert(`Info for Blastoise...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button onPress={() => alert(`Info for Venusaur...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button onPress={() => alert(`Info for Pikachu...`)}>Info</Button>\n  </Item>\n</List>\n```\n\n```\nimport {Item} from 'react-stately';\n\n// Reuse the Button from your component library. See below.\nimport {Button} from 'your-component-library';\n\n<List\n  aria-label=\"Example List\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button\n      onPress={() => alert(`Info for Charizard...`)}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button\n      onPress={() => alert(`Info for Blastoise...`)}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button onPress={() => alert(`Info for Venusaur...`)}>\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button onPress={() => alert(`Info for Pikachu...`)}>\n      Info\n    </Button>\n  </Item>\n</List>\n```\n\n```\nimport {Item} from 'react-stately';\n\n// Reuse the Button from your component library. See below.\nimport {Button} from 'your-component-library';\n\n<List\n  aria-label=\"Example List\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Charizard...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Blastoise...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Venusaur...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Pikachu...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n</List>\n```\n\n Show CSS\n\n```\n.list {\n  padding: 0;\n  list-style: none;\n  background: var(--page-background);\n  border: 1px solid var(--spectrum-global-color-gray-400);\n  max-width: 400px;\n  min-width: 200px;\n  max-height: 250px;\n  overflow: auto;\n}\n\n.list li {\n  padding: 8px;\n  outline: none;\n  cursor: default;\n}\n\n.list li:nth-child(2n) {\n  background: var(--spectrum-alias-highlight-hover);\n}\n\n.list li.pressed {\n  background: var(--spectrum-global-color-gray-200);\n}\n\n.list li[aria-selected=true] {\n  background: slateblue;\n  color: white;\n}\n\n.list li.focus-visible {\n  outline: 2px solid slateblue;\n  outline-offset: -3px;\n}\n\n.list li.focus-visible[aria-selected=true] {\n  outline-color: white;\n}\n\n.list li[aria-disabled] {\n  opacity: 0.4;\n}\n\n.list [role=gridcell] {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.list li button {\n  margin-left: auto;\n}\n\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports not (-webkit-touch-callout: none) {\n  .list li input[type=checkbox] {\n    accent-color: white;\n  }\n}\n```\n\n```\n.list {\n  padding: 0;\n  list-style: none;\n  background: var(--page-background);\n  border: 1px solid var(--spectrum-global-color-gray-400);\n  max-width: 400px;\n  min-width: 200px;\n  max-height: 250px;\n  overflow: auto;\n}\n\n.list li {\n  padding: 8px;\n  outline: none;\n  cursor: default;\n}\n\n.list li:nth-child(2n) {\n  background: var(--spectrum-alias-highlight-hover);\n}\n\n.list li.pressed {\n  background: var(--spectrum-global-color-gray-200);\n}\n\n.list li[aria-selected=true] {\n  background: slateblue;\n  color: white;\n}\n\n.list li.focus-visible {\n  outline: 2px solid slateblue;\n  outline-offset: -3px;\n}\n\n.list li.focus-visible[aria-selected=true] {\n  outline-color: white;\n}\n\n.list li[aria-disabled] {\n  opacity: 0.4;\n}\n\n.list [role=gridcell] {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.list li button {\n  margin-left: auto;\n}\n\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports not (-webkit-touch-callout: none) {\n  .list li input[type=checkbox] {\n    accent-color: white;\n  }\n}\n```\n\n```\n.list {\n  padding: 0;\n  list-style: none;\n  background: var(--page-background);\n  border: 1px solid var(--spectrum-global-color-gray-400);\n  max-width: 400px;\n  min-width: 200px;\n  max-height: 250px;\n  overflow: auto;\n}\n\n.list li {\n  padding: 8px;\n  outline: none;\n  cursor: default;\n}\n\n.list li:nth-child(2n) {\n  background: var(--spectrum-alias-highlight-hover);\n}\n\n.list li.pressed {\n  background: var(--spectrum-global-color-gray-200);\n}\n\n.list li[aria-selected=true] {\n  background: slateblue;\n  color: white;\n}\n\n.list li.focus-visible {\n  outline: 2px solid slateblue;\n  outline-offset: -3px;\n}\n\n.list li.focus-visible[aria-selected=true] {\n  outline-color: white;\n}\n\n.list li[aria-disabled] {\n  opacity: 0.4;\n}\n\n.list [role=gridcell] {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n}\n\n.list li button {\n  margin-left: auto;\n}\n\n/* iOS Safari has a bug that prevents accent-color: white from working. */\n@supports not (-webkit-touch-callout: none) {\n  .list li input[type=checkbox] {\n    accent-color: white;\n  }\n}\n```\n\n### Adding selection checkboxes[#](#adding-selection-checkboxes)\n\nNext, let's add support for selection checkboxes to allow the user to select items explicitly.\nThis is done using the `useGridListSelectionCheckbox`\nhook. It is passed the `key` of the item it is contained within. When the user\nchecks or unchecks the checkbox, the row will be added or removed from the List's selection.\n\nThe `Checkbox` component used in this example is independent and can be used separately from `useGridList`. The code is available below.\n\n```\nimport {useGridListSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction ListCheckbox({ item, state }) {\n  let { checkboxProps } = useGridListSelectionCheckbox(\n    { key: item.key },\n    state\n  );\n  return <Checkbox {...checkboxProps} />;\n}\n```\n\n```\nimport {useGridListSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction ListCheckbox({ item, state }) {\n  let { checkboxProps } = useGridListSelectionCheckbox({\n    key: item.key\n  }, state);\n  return <Checkbox {...checkboxProps} />;\n}\n```\n\n```\nimport {useGridListSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction ListCheckbox(\n  { item, state }\n) {\n  let { checkboxProps } =\n    useGridListSelectionCheckbox(\n      { key: item.key },\n      state\n    );\n  return (\n    <Checkbox\n      {...checkboxProps}\n    />\n  );\n}\n```\n\nThe following example shows an example list with multiple selection using checkboxes and the default `toggle` [selection behavior](#selection-behavior).\n\n```\n<List aria-label=\"List with selection\" selectionMode=\"multiple\">\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button onPress={() => alert(`Info for Charizard...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button onPress={() => alert(`Info for Blastoise...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button onPress={() => alert(`Info for Venusaur...`)}>Info</Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button onPress={() => alert(`Info for Pikachu...`)}>Info</Button>\n  </Item>\n</List>\n```\n\n```\n<List\n  aria-label=\"List with selection\"\n  selectionMode=\"multiple\"\n>\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button\n      onPress={() => alert(`Info for Charizard...`)}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button\n      onPress={() => alert(`Info for Blastoise...`)}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button onPress={() => alert(`Info for Venusaur...`)}>\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button onPress={() => alert(`Info for Pikachu...`)}>\n      Info\n    </Button>\n  </Item>\n</List>\n```\n\n```\n<List\n  aria-label=\"List with selection\"\n  selectionMode=\"multiple\"\n>\n  <Item textValue=\"Charizard\">\n    Charizard\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Charizard...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Blastoise\">\n    Blastoise\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Blastoise...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Venusaur\">\n    Venusaur\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Venusaur...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n  <Item textValue=\"Pikachu\">\n    Pikachu\n    <Button\n      onPress={() =>\n        alert(\n          `Info for Pikachu...`\n        )}\n    >\n      Info\n    </Button>\n  </Item>\n</List>\n```\n\nAnd that's it! We now have a fully interactive List component that can support keyboard navigation, single or multiple selection.\nIn addition, it is fully accessible for screen readers and other assistive technology. See below for more\nexamples of how to use the List component that we've built.\n\n### Checkbox[#](#checkbox)\n\nThe `Checkbox` component is used in the above example for row selection. It is built using the [useCheckbox](../Checkbox/useCheckbox.html) hook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useToggleState} from 'react-stately';\nimport {useCheckbox} from 'react-aria';\n\nfunction Checkbox(props) {\n  let inputRef = useRef(null);\n  let { inputProps } = useCheckbox(\n    props,\n    useToggleState(props),\n    inputRef\n  );\n  return <input {...inputProps} ref={inputRef} />;\n}\n```\n\n```\nimport {useToggleState} from 'react-stately';\nimport {useCheckbox} from 'react-aria';\n\nfunction Checkbox(props) {\n  let inputRef = useRef(null);\n  let { inputProps } = useCheckbox(\n    props,\n    useToggleState(props),\n    inputRef\n  );\n  return <input {...inputProps} ref={inputRef} />;\n}\n```\n\n```\nimport {useToggleState} from 'react-stately';\nimport {useCheckbox} from 'react-aria';\n\nfunction Checkbox(\n  props\n) {\n  let inputRef = useRef(\n    null\n  );\n  let { inputProps } =\n    useCheckbox(\n      props,\n      useToggleState(\n        props\n      ),\n      inputRef\n    );\n  return (\n    <input\n      {...inputProps}\n      ref={inputRef}\n    />\n  );\n}\n```\n\n### Button[#](#button)\n\nThe `Button` component is used in the above example to show how rows can contain interactive elements. It is built using the [useButton](../Button/useButton.html) hook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(null);\n  let { buttonProps } = useButton(props, ref);\n  return <button {...buttonProps} ref={ref}>{props.children}</button>;\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(null);\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button {...buttonProps} ref={ref}>\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(\n    null\n  );\n  let { buttonProps } =\n    useButton(\n      props,\n      ref\n    );\n  return (\n    <button\n      {...buttonProps}\n      ref={ref}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n## Usage[#](#usage)\n\n---\n\n### Dynamic collections[#](#dynamic-collections)\n\nSo far, our examples have shown static collections, where the data is hard coded.\nDynamic collections, as shown below, can be used when the data comes from an external data source such as an API, or updates over time.\nIn the example below, the rows are provided to the List via a render function.\n\n```\nfunction ExampleList(props) {\n  let rows = [\n    { id: 1, name: 'Games' },\n    { id: 2, name: 'Program Files' },\n    { id: 3, name: 'bootmgr' },\n    { id: 4, name: 'log.txt' }\n  ];\n\n  return (\n    <List\n      aria-label=\"Example dynamic collection List\"\n      selectionMode=\"multiple\"\n      items={rows}\n      {...props}\n    >\n      {(item) => (\n        <Item textValue={item.name}>\n          {item.name}\n          <Button onPress={() => alert(`Info for ${item.name}...`)}>\n            Info\n          </Button>\n        </Item>\n      )}\n    </List>\n  );\n}\n```\n\n```\nfunction ExampleList(props) {\n  let rows = [\n    { id: 1, name: 'Games' },\n    { id: 2, name: 'Program Files' },\n    { id: 3, name: 'bootmgr' },\n    { id: 4, name: 'log.txt' }\n  ];\n\n  return (\n    <List\n      aria-label=\"Example dynamic collection List\"\n      selectionMode=\"multiple\"\n      items={rows}\n      {...props}\n    >\n      {(item) => (\n        <Item textValue={item.name}>\n          {item.name}\n          <Button\n            onPress={() =>\n              alert(`Info for ${item.name}...`)}\n          >\n            Info\n          </Button>\n        </Item>\n      )}\n    </List>\n  );\n}\n```\n\n```\nfunction ExampleList(\n  props\n) {\n  let rows = [\n    {\n      id: 1,\n      name: 'Games'\n    },\n    {\n      id: 2,\n      name:\n        'Program Files'\n    },\n    {\n      id: 3,\n      name: 'bootmgr'\n    },\n    {\n      id: 4,\n      name: 'log.txt'\n    }\n  ];\n\n  return (\n    <List\n      aria-label=\"Example dynamic collection List\"\n      selectionMode=\"multiple\"\n      items={rows}\n      {...props}\n    >\n      {(item) => (\n        <Item\n          textValue={item\n            .name}\n        >\n          {item.name}\n          <Button\n            onPress={() =>\n              alert(\n                `Info for ${item.name}...`\n              )}\n          >\n            Info\n          </Button>\n        </Item>\n      )}\n    </List>\n  );\n}\n```\n\n### Single selection[#](#single-selection)\n\nBy default, `useListState` doesn't allow row selection but this can be enabled using the `selectionMode` prop. Use `defaultSelectedKeys` to provide a default set of selected rows.\nNote that the value of the selected keys must match the `key` prop of the row.\n\nThe example below enables single selection mode, and uses `defaultSelectedKeys` to select the row with key equal to \"2\".\nA user can click on a different row to change the selection, or click on the same row again to deselect it entirely.\n\n```\n// Using the example above\n<ExampleList\n  aria-label=\"List with single selection\"\n  selectionMode=\"single\"\n  selectionBehavior=\"replace\"\n  defaultSelectedKeys={[2]}\n/>\n```\n\n```\n// Using the example above\n<ExampleList\n  aria-label=\"List with single selection\"\n  selectionMode=\"single\"\n  selectionBehavior=\"replace\"\n  defaultSelectedKeys={[2]}\n/>\n```\n\n```\n// Using the example above\n<ExampleList\n  aria-label=\"List with single selection\"\n  selectionMode=\"single\"\n  selectionBehavior=\"replace\"\n  defaultSelectedKeys={[\n    2\n  ]}\n/>\n```\n\n### Multiple selection[#](#multiple-selection)\n\nMultiple selection can be enabled by setting `selectionMode` to `multiple`.\n\n```\n<ExampleList\n  aria-label=\"List with multiple selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[2, 4]}\n/>\n```\n\n```\n<ExampleList\n  aria-label=\"List with multiple selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[2, 4]}\n/>\n```\n\n```\n<ExampleList\n  aria-label=\"List with multiple selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[\n    2,\n    4\n  ]}\n/>\n```\n\n### Disallow empty selection[#](#disallow-empty-selection)\n\n`useGridList` also supports a `disallowEmptySelection` prop which forces the user to have at least one row in the List selected at all times.\nIn this mode, if a single row is selected and the user presses it, it will not be deselected.\n\n```\n<ExampleList\n  aria-label=\"List with disallowed empty selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[2]}\n  disallowEmptySelection\n/>\n```\n\n```\n<ExampleList\n  aria-label=\"List with disallowed empty selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[2]}\n  disallowEmptySelection\n/>\n```\n\n```\n<ExampleList\n  aria-label=\"List with disallowed empty selection\"\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[\n    2\n  ]}\n  disallowEmptySelection\n/>\n```\n\n### Controlled selection[#](#controlled-selection)\n\nTo programmatically control row selection, use the `selectedKeys` prop paired with the `onSelectionChange` callback. The `key` prop from the selected rows will\nbe passed into the callback when the row is pressed, allowing you to update state accordingly.\n\n```\nfunction PokemonList(props) {\n  let rows = [\n    { id: 1, name: 'Charizard' },\n    { id: 2, name: 'Blastoise' },\n    { id: 3, name: 'Venusaur' },\n    { id: 4, name: 'Pikachu' }\n  ];\n\n  let [selectedKeys, setSelectedKeys] = React.useState(new Set([2]));\n\n  return (\n    <List\n      aria-label=\"List with controlled selection\"\n      items={rows}\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      {(item) => <Item>{item.name}</Item>}\n    </List>\n  );\n}\n```\n\n```\nfunction PokemonList(props) {\n  let rows = [\n    { id: 1, name: 'Charizard' },\n    { id: 2, name: 'Blastoise' },\n    { id: 3, name: 'Venusaur' },\n    { id: 4, name: 'Pikachu' }\n  ];\n\n  let [selectedKeys, setSelectedKeys] = React.useState(\n    new Set([2])\n  );\n\n  return (\n    <List\n      aria-label=\"List with controlled selection\"\n      items={rows}\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      {(item) => <Item>{item.name}</Item>}\n    </List>\n  );\n}\n```\n\n```\nfunction PokemonList(\n  props\n) {\n  let rows = [\n    {\n      id: 1,\n      name: 'Charizard'\n    },\n    {\n      id: 2,\n      name: 'Blastoise'\n    },\n    {\n      id: 3,\n      name: 'Venusaur'\n    },\n    {\n      id: 4,\n      name: 'Pikachu'\n    }\n  ];\n\n  let [\n    selectedKeys,\n    setSelectedKeys\n  ] = React.useState(\n    new Set([2])\n  );\n\n  return (\n    <List\n      aria-label=\"List with controlled selection\"\n      items={rows}\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      {(item) => (\n        <Item>\n          {item.name}\n        </Item>\n      )}\n    </List>\n  );\n}\n```\n\n### Disabled rows[#](#disabled-rows)\n\nYou can disable specific rows by providing an array of keys to `useListState` via the `disabledKeys` prop. This will disable all interactions on disabled rows,\nunless the `disabledBehavior` prop is used to change this behavior.\nNote that you are responsible for the styling of disabled rows, however, the selection checkbox will be automatically disabled.\n\n```\n// Using the example above\n<PokemonList\n  aria-label=\"List with disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n/>\n```\n\n```\n// Using the example above\n<PokemonList\n  aria-label=\"List with disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n/>\n```\n\n```\n// Using the example above\n<PokemonList\n  aria-label=\"List with disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n/>\n```\n\nWhen `disabledBehavior` is set to `selection`, interactions such as focus, dragging, or actions can still be performed on disabled rows.\n\n```\n<PokemonList\n  aria-label=\"List with selection disabled for disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n  disabledBehavior=\"selection\"\n/>\n```\n\n```\n<PokemonList\n  aria-label=\"List with selection disabled for disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n  disabledBehavior=\"selection\"\n/>\n```\n\n```\n<PokemonList\n  aria-label=\"List with selection disabled for disabled rows\"\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n  disabledBehavior=\"selection\"\n/>\n```\n\n### Selection behavior[#](#selection-behavior)\n\nBy default, `useGridList` uses the `\"toggle\"` selection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the `Space` or `Enter` keys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection. The `\"toggle\"` selection mode is often paired with a checkbox in each row as an explicit affordance for selection.\n\nWhen `selectionBehavior` is set to `\"replace\"`, clicking a row with the mouse replaces the selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as `Ctrl`, `Cmd`, and `Shift` can be used. On touch screen devices, selection always behaves as toggle since modifier keys may not be available.\n\nThese selection styles implement the behaviors defined in [Aria Practices](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/#keyboardinteraction).\n\n```\n<PokemonList\n  aria-label=\"List with replace selection behavior\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n/>\n```\n\n```\n<PokemonList\n  aria-label=\"List with replace selection behavior\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n/>\n```\n\n```\n<PokemonList\n  aria-label=\"List with replace selection behavior\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n/>\n```\n\n### Row actions[#](#row-actions)\n\n`useGridList` supports row actions via the `onAction` prop, which is useful for functionality such as navigation. When nothing is selected, the list performs actions by default when clicking or tapping a row.\nItems may be selected using the checkbox, or by long pressing on touch devices. When at least one item is selected, the list is in selection mode, and clicking or tapping a row toggles the selection. Actions may also\nbe triggered via the `Enter` key, and selection using the `Space` key.\n\nThis behavior is slightly different when `selectionBehavior=\"replace\"`, where single clicking selects the row and actions are performed via double click. Touch and keyboard behaviors are unaffected.\n\n```\n<div style={{ display: 'flex', flexWrap: 'wrap', gap: 24 }}>\n  <ExampleList\n    aria-label=\"Checkbox selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"toggle\"\n    onAction={(key) => alert(`Opening item ${key}...`)}\n  />\n  <ExampleList\n    aria-label=\"Highlight selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onAction={(key) => alert(`Opening item ${key}...`)}\n  />\n</div>\n```\n\n```\n<div style={{ display: 'flex', flexWrap: 'wrap', gap: 24 }}>\n  <ExampleList\n    aria-label=\"Checkbox selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"toggle\"\n    onAction={(key) => alert(`Opening item ${key}...`)}\n  />\n  <ExampleList\n    aria-label=\"Highlight selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onAction={(key) => alert(`Opening item ${key}...`)}\n  />\n</div>\n```\n\n```\n<div\n  style={{\n    display: 'flex',\n    flexWrap: 'wrap',\n    gap: 24\n  }}\n>\n  <ExampleList\n    aria-label=\"Checkbox selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"toggle\"\n    onAction={(key) =>\n      alert(\n        `Opening item ${key}...`\n      )}\n  />\n  <ExampleList\n    aria-label=\"Highlight selection list with row actions\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onAction={(key) =>\n      alert(\n        `Opening item ${key}...`\n      )}\n  />\n</div>\n```\n\n### Links[#](#links)\n\nItems in a GridList may also be links to another page or website. This can be achieved by passing the `href` prop to the `<Item>` component. Links behave the same way as described above for row actions depending on the `selectionMode` and `selectionBehavior`.\n\n```\n<List aria-label=\"Links\" selectionMode=\"multiple\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">Adobe</Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">Apple</Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">Google</Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">Microsoft</Item>\n</List>\n```\n\n```\n<List aria-label=\"Links\" selectionMode=\"multiple\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">\n    Adobe\n  </Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">\n    Apple\n  </Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">\n    Google\n  </Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">\n    Microsoft\n  </Item>\n</List>\n```\n\n```\n<List\n  aria-label=\"Links\"\n  selectionMode=\"multiple\"\n>\n  <Item\n    href=\"https://adobe.com/\"\n    target=\"_blank\"\n  >\n    Adobe\n  </Item>\n  <Item\n    href=\"https://apple.com/\"\n    target=\"_blank\"\n  >\n    Apple\n  </Item>\n  <Item\n    href=\"https://google.com/\"\n    target=\"_blank\"\n  >\n    Google\n  </Item>\n  <Item\n    href=\"https://microsoft.com/\"\n    target=\"_blank\"\n  >\n    Microsoft\n  </Item>\n</List>\n```\n\n#### Client side routing[#](#client-side-routing)\n\nThe `<Item>` component works with frameworks and client side routers like [Next.js](https://nextjs.org/) and [React Router](https://reactrouter.com/en/main). As with other React Aria components that support links, this works via the `RouterProvider` component at the root of your app. See the [framework setup guide](../frameworks) to learn how to set this up.\n\n### Asynchronous loading[#](#asynchronous-loading)\n\nThis example uses the [useAsyncList](../useAsyncList.html) hook to handle asynchronous loading of data from a server. You may additionally want to display a spinner to indicate the loading state to the user, or support features like infinite scroll to load more data.\n\n```\nimport {useAsyncList} from 'react-stately';\n\nfunction AsyncList() {\n  let list = useAsyncList({\n    async load({ signal, cursor }) {\n      if (cursor) {\n        cursor = cursor.replace(/^http:\\/\\//i, 'https://');\n      }\n\n      let res = await fetch(\n        cursor || `https://swapi.py4e.com/api/people/?search=`,\n        { signal }\n      );\n      let json = await res.json();\n\n      return {\n        items: json.results,\n        cursor: json.next\n      };\n    }\n  });\n\n  return (\n    <List\n      selectionMode=\"multiple\"\n      aria-label=\"Async loading ListView example\"\n      items={list.items}\n    >\n      {(item) => <Item key={item.name}>{item.name}</Item>}\n    </List>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\nfunction AsyncList() {\n  let list = useAsyncList({\n    async load({ signal, cursor }) {\n      if (cursor) {\n        cursor = cursor.replace(/^http:\\/\\//i, 'https://');\n      }\n\n      let res = await fetch(\n        cursor ||\n          `https://swapi.py4e.com/api/people/?search=`,\n        { signal }\n      );\n      let json = await res.json();\n\n      return {\n        items: json.results,\n        cursor: json.next\n      };\n    }\n  });\n\n  return (\n    <List\n      selectionMode=\"multiple\"\n      aria-label=\"Async loading ListView example\"\n      items={list.items}\n    >\n      {(item) => <Item key={item.name}>{item.name}</Item>}\n    </List>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\nfunction AsyncList() {\n  let list =\n    useAsyncList({\n      async load(\n        {\n          signal,\n          cursor\n        }\n      ) {\n        if (cursor) {\n          cursor = cursor\n            .replace(\n              /^http:\\/\\//i,\n              'https://'\n            );\n        }\n\n        let res =\n          await fetch(\n            cursor ||\n              `https://swapi.py4e.com/api/people/?search=`,\n            { signal }\n          );\n        let json =\n          await res\n            .json();\n\n        return {\n          items:\n            json.results,\n          cursor:\n            json.next\n        };\n      }\n    });\n\n  return (\n    <List\n      selectionMode=\"multiple\"\n      aria-label=\"Async loading ListView example\"\n      items={list.items}\n    >\n      {(item) => (\n        <Item\n          key={item.name}\n        >\n          {item.name}\n        </Item>\n      )}\n    </List>\n  );\n}\n```\n\n## Internationalization[#](#internationalization)\n\n---\n\n`useGridList` handles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\n[Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator)\nfor internationalized string matching, and keyboard navigation is mirrored in right-to-left languages.\nYou are responsible for localizing all text content within the List.\n\n### RTL[#](#rtl)\n\nIn right-to-left languages, the list layout should be mirrored. The row contents should be ordered from right to left and the row's text alignment should be inverted. Ensure that your CSS accounts for this.\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isVirtualized` | `boolean` | \u00e2\u0080\u0094 | Whether the list uses virtual scrolling. |\n| `disallowTypeAhead` | `boolean` | `false` | Whether typeahead navigation is disabled. |\n| `keyboardDelegate` | `KeyboardDelegate` | \u00e2\u0080\u0094 | An optional keyboard delegate implementation for type to select, to override the default. |\n| `layoutDelegate` | `LayoutDelegate` | \u00e2\u0080\u0094 | A delegate object that provides layout information for items in the collection. By default this uses the DOM, but this can be overridden to implement things like virtualized scrolling. |\n| `shouldFocusWrap` | `boolean` | `false` | Whether focus should wrap around when the end/start is reached. |\n| `linkBehavior` | `'action' |\u00c2\u00a0'selection' |\u00c2\u00a0'override'` | `'action'` | The behavior of links in the collection. - 'action': link behaves like onAction. - 'selection': link follows selection interactions (e.g. if URL drives selection). - 'override': links override all other interactions (link items are not selectable). |\n| `keyboardNavigationBehavior` | `'arrow' |\u00c2\u00a0'tab'` | `'arrow'` | Whether keyboard navigation to focusable elements within grid list items is via the left/right arrow keys or the tab key. |\n| `escapeKeyBehavior` | `'clearSelection' |\u00c2\u00a0'none'` | `'clearSelection'` | Whether pressing the escape key should clear selection in the grid list or not.  Most experiences should not modify this option as it eliminates a keyboard user's ability to easily clear selection. Only use if the escape key is being handled externally or should not trigger selection clearing contextually. |\n| `autoFocus` | `boolean |\u00c2\u00a0FocusStrategy` | \u00e2\u0080\u0094 | Whether to auto focus the gridlist or an option. |\n| `onAction` | `( (key: Key )) => void` | \u00e2\u0080\u0094 | Handler that is called when a user performs an action on an item. The exact user event depends on the collection's `selectionBehavior` prop and the interaction modality. |\n| `disabledBehavior` | `DisabledBehavior` | `\"all\"` | Whether `disabledKeys` applies to all interactions, or only selection. |\n| `shouldSelectOnPressUp` | `boolean` | \u00e2\u0080\u0094 | Whether selection should occur on press up instead of press down. |\n| `items` | `Iterable<T>` | \u00e2\u0080\u0094 | Item objects in the collection. |\n| `disabledKeys` | `Iterable<Key>` | \u00e2\u0080\u0094 | The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with. |\n| `selectionMode` | `SelectionMode` | \u00e2\u0080\u0094 | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | \u00e2\u0080\u0094 | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | \u00e2\u0080\u0094 | Handler that is called when the selection changes. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n| Method | Description |\n| --- | --- |\n| `getKeyBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually below the given one, or `null` for none. |\n| `getKeyAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually above the given one, or `null` for none. |\n| `getKeyLeftOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the left of the given one, or `null` for none. |\n| `getKeyRightOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the right of the given one, or `null` for none. |\n| `getKeyPageBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page below the given one, or `null` for none. |\n| `getKeyPageAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page above the given one, or `null` for none. |\n| `getFirstKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the first key, or `null` for none. |\n| `getLastKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the last key, or `null` for none. |\n| `getKeyForSearch( (search: string, , fromKey?: Key |\u00c2\u00a0 |\u00c2\u00a0null )): Key |\u00c2\u00a0null` | Returns the next key after `fromKey` that matches the given search string, or `null` for none. |\n\nA LayoutDelegate provides layout information for collection items.\n\n| Method | Description |\n| --- | --- |\n| `getItemRect( (key: Key )): Rect |\u00c2\u00a0null` | Returns a rectangle for the item with the given key. |\n| `getVisibleRect(): Rect` | Returns the visible rectangle of the collection. |\n| `getContentSize(): Size` | Returns the size of the scrollable content in the collection. |\n| `getKeyRange( (from: Key, , to: Key )): Key[]` | Returns a list of keys between `from` and `to`. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `x` | `number` |  |\n| `y` | `number` |  |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n`'first' |\u00c2\u00a0'last'`\n\n`string |\u00c2\u00a0number`\n\n`'selection' |\u00c2\u00a0'all'`\n\n`'none'\n|\u00c2\u00a0'single'\n|\u00c2\u00a0'multiple'`\n\n`'all' |\u00c2\u00a0Set<Key>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<T>>` | A collection of items in the list. |\n| `disabledKeys` | `Set<Key>` | A set of items that are disabled. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update multiple selection state. |\n\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\n\n**Extends**: `Iterable`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `size` | `number` | The number of items in the collection. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getKeys(): Iterable<Key>` | Iterate over all keys in the collection. |\n| `getItem( (key: Key )): T |\u00c2\u00a0null` | Get an item by its key. |\n| `at( (idx: number )): T |\u00c2\u00a0null` | Get an item by the index of its key. |\n| `getKeyBefore( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes before the given key in the collection. |\n| `getKeyAfter( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes after the given key in the collection. |\n| `getFirstKey(): Key |\u00c2\u00a0null` | Get the first key in the collection. |\n| `getLastKey(): Key |\u00c2\u00a0null` | Get the last key in the collection. |\n| `getChildren( (key: Key )): Iterable<T>` | Iterate over the child items of the given key. |\n| `getTextValue( (key: Key )): string` | Returns a string representation of the item's contents. |\n| `filter( (filterFn: ( (nodeValue: string, , node: T )) => boolean )): Collection<T>` | Filters the collection using the given function. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `string` | The type of item this node represents. |\n| `key` | `Key` | A unique key for the node. |\n| `value` | `T |\u00c2\u00a0null` | The object value the node was created from. |\n| `level` | `number` | The level of depth this node is at in the hierarchy. |\n| `hasChildNodes` | `boolean` | Whether this item has children, even if not loaded yet. |\n| `rendered` | `ReactNode` | The rendered contents of this node (e.g. JSX). |\n| `textValue` | `string` | A string value for this node, used for features like typeahead. |\n| `index` | `number` | The index of this node within its parent. |\n| `aria-label` | `string` | An accessibility label for this node. |\n| `wrapper` | `( (element: ReactElement )) => ReactElement` | A function that should be called to wrap the rendered node. |\n| `parentKey` | `Key |\u00c2\u00a0null` | The key of the parent node. |\n| `prevKey` | `Key |\u00c2\u00a0null` | The key of the node before this node. |\n| `nextKey` | `Key |\u00c2\u00a0null` | The key of the node after this node. |\n| `props` | `any` | Additional properties specific to a particular node type. |\n| `render` | `( (node: Node<any> )) => ReactElement` | A function that renders this node to a React Element in the DOM. |\n\nAn interface for reading and updating multiple selection state.\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<unknown>>` |  |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n| `selectedKeys` | `Set<Key>` | The currently selected keys in the collection. |\n| `rawSelection` | `Selection` | The raw selection value for the collection. Either 'all' for select all, or a set of keys. |\n| `isEmpty` | `boolean` | Whether the selection is empty. |\n| `isSelectAll` | `boolean` | Whether all items in the collection are selected. |\n| `firstSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `lastSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `disabledKeys` | `Set<Key>` |  |\n| `disabledBehavior` | `DisabledBehavior` |  |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `constructor( collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions ): void` |  |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , childFocusStrategy?: FocusStrategy )): void` | Sets the focused key. |\n| `isSelected( (key: Key )): boolean` | Returns whether a key is selected. |\n| `extendSelection( (toKey: Key )): void` | Extends the selection to the given key. |\n| `toggleSelection( (key: Key )): void` | Toggles whether the given key is selected. |\n| `replaceSelection( (key: Key )): void` | Replaces the selection with only the given key. |\n| `setSelectedKeys( (keys: Iterable<Key> )): void` | Replaces the selection with the given keys. |\n| `selectAll(): void` | Selects all items in the collection. |\n| `clearSelection(): void` | Removes all keys from the selection. |\n| `toggleSelectAll(): void` | Toggles between select all and an empty selection. |\n| `select( (key: Key, , e?: PressEvent |\u00c2\u00a0LongPressEvent |\u00c2\u00a0PointerEvent )): void` |  |\n| `isSelectionEqual( (selection: Set<Key> )): boolean` | Returns whether the current selection is equal to the given selection. |\n| `canSelectItem( (key: Key )): boolean` |  |\n| `isDisabled( (key: Key )): boolean` |  |\n| `isLink( (key: Key )): boolean` |  |\n| `getItemProps( (key: Key )): any` |  |\n| `withCollection( (collection: Collection<Node<unknown>> )): SelectionManager` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `Selection` | The currently selected keys in the collection. |\n| `disabledKeys` | `Set<Key>` | The currently disabled keys in the collection. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to selection, actions, or both. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setSelectedKeys( (keys: Selection )): void` | Sets the selected keys in the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , child?: FocusStrategy )): void` | Sets the focused key, and optionally, whether the first or last child of that key should receive focus. |\n\n`'toggle' |\u00c2\u00a0'replace'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `allowsCellSelection` | `boolean` |  |\n| `layoutDelegate` | `LayoutDelegate` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'longpressstart' |\u00c2\u00a0'longpressend' |\u00c2\u00a0'longpress'` | The type of long press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `current` | `T` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `gridProps` | `DOMAttributes` | Props for the grid element. |\n\nAll DOM attributes supported across both HTML and SVG elements.\n\n**Extends**: `AriaAttributes, ReactDOMAttributes`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `id` | `string |\u00c2\u00a0undefined` |  |\n| `role` | `AriaRole |\u00c2\u00a0undefined` |  |\n| `tabIndex` | `number |\u00c2\u00a0undefined` |  |\n| `style` | `CSSProperties |\u00c2\u00a0undefined` |  |\n| `className` | `string |\u00c2\u00a0undefined` |  |\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `node` | `Node<unknown>` | An object representing the list item. Contains all the relevant information that makes up the list row. |\n| `isVirtualized` | `boolean` | Whether the list row is contained in a virtual scroller. |\n| `shouldSelectOnPressUp` | `boolean` | Whether selection should occur on press up instead of press down. |\n| `hasChildItems` | `boolean` | Whether this item has children, even if not loaded yet. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<T>>` | A collection of items in the tree. |\n| `disabledKeys` | `Set<Key>` | A set of keys for items that are disabled. |\n| `expandedKeys` | `Set<Key>` | A set of keys for items that are expanded. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update multiple selection state. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `toggleKey( (key: Key )): void` | Toggles the expanded state for an item by its key. |\n| `setExpandedKeys( (keys: Set<Key> )): void` | Replaces the set of expanded keys. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rowProps` | `DOMAttributes` | Props for the list row element. |\n| `gridCellProps` | `DOMAttributes` | Props for the grid cell element within the list row. |\n| `descriptionProps` | `DOMAttributes` | Props for the list item description element, if any. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isFocused` | `boolean` | Whether the item is currently focused. |\n| `isDisabled` | `boolean` | Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may not be focused. Dependent on `disabledKeys` and `disabledBehavior`. |\n| `allowsSelection` | `boolean` | Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`. |\n| `hasAction` | `boolean` | Whether the item has an action, dependent on `onAction`, `disabledKeys`, and `disabledBehavior`. It may also change depending on the current selection state of the list (e.g. when selection is primary). This can be used to enable or disable hover styles or other visual indications of interactivity. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `key` | `Key` | A unique key for the checkbox. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `checkboxProps` | `AriaCheckboxProps` | Props for the row selection checkbox element. |\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isIndeterminate` | `boolean` | \u00e2\u0080\u0094 | Indeterminism is presentational only. The indeterminate visual representation remains regardless of user interaction. |\n| `children` | `ReactNode` | \u00e2\u0080\u0094 | The label for the element. |\n| `value` | `string` | \u00e2\u0080\u0094 | The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue). |\n| `defaultSelected` | `boolean` | \u00e2\u0080\u0094 | Whether the element should be selected (uncontrolled). |\n| `isSelected` | `boolean` | \u00e2\u0080\u0094 | Whether the element should be selected (controlled). |\n| `onChange` | `( (isSelected: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's selection state changes. |\n| `isDisabled` | `boolean` | \u00e2\u0080\u0094 | Whether the input is disabled. |\n| `isReadOnly` | `boolean` | \u00e2\u0080\u0094 | Whether the input can be selected but not changed by the user. |\n| `isRequired` | `boolean` | \u00e2\u0080\u0094 | Whether user input is required on the input before form submission. |\n| `isInvalid` | `boolean` | \u00e2\u0080\u0094 | Whether the input value is invalid. |\n| `validationBehavior` | `'aria' |\u00c2\u00a0'native'` | `'aria'` | Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA. |\n| `validate` | `( (value: boolean )) => ValidationError |\u00c2\u00a0true |\u00c2\u00a0null |\u00c2\u00a0undefined` | \u00e2\u0080\u0094 | A function that returns an error message if a given value is invalid. Validation errors are displayed to the user when the form is submitted if `validationBehavior=\"native\"`. For realtime validation, use the `isInvalid` prop instead. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element should receive focus on render. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `name` | `string` | \u00e2\u0080\u0094 | The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname). |\n| `form` | `string` | \u00e2\u0080\u0094 | The `<form>` element to associate the input with. The value of this attribute must be the id of a `<form>` in the same document. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#form). |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) whose contents or presence are controlled by the current element. |\n| `excludeFromTabOrder` | `boolean` | \u00e2\u0080\u0094 | Whether to exclude the element from the sequential tab order. If true, the element will not be focusable via the keyboard by tabbing. This should be avoided except in rare scenarios where an alternative means of accessing the element or its functionality via the keyboard is available. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n| `aria-errormessage` | `string` | \u00e2\u0080\u0094 | Identifies the element that provides an error message for the object. |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n\n`'valid' |\u00c2\u00a0'invalid'`\n\n`string |\u00c2\u00a0string[]`\n\n`BaseEvent<ReactKeyboardEvent<any>>`\n\n`SyntheticEvent &\u00c2\u00a0{\n\nstopPropagation: () => void,\n\ncontinuePropagation: () => void\n\n}`\n\nProvides the behavior and accessibility implementation for a list component with interactive children.\nA grid list displays data in a single column and enables a user to navigate its contents via directional navigation keys.\n\n`useGridList<T>(\nprops: AriaGridListOptions<T>,\nstate: ListState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridListAria`\n\nProvides the behavior and accessibility implementation for a row in a grid list.\n\n`useGridListItem<T>(\nprops: AriaGridListItemOptions,\nstate: ListState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridListItemAria`\n\nProvides the behavior and accessibility implementation for a selection checkbox in a grid list.\n\n`useGridListSelectionCheckbox<T>(\n(props: AriaGridSelectionCheckboxProps,\n, state: ListState<T>\n)): GridSelectionCheckboxAria`\n\nProvides state management for list-like components. Handles building a collection\nof items from props, and manages multiple selection state.\n\n`useListState<T extends object>(\n(props: ListProps<T>\n)): ListState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `filter` | `( (nodes: Iterable<Node<T>> )) => Iterable<Node<T>>` | Filter function to generate a filtered list of nodes. |\n| `layoutDelegate` | `LayoutDelegate` | A delegate object that provides layout information for items in the collection. This can be used to override the behavior of shift selection. |\n| `collection` | `Collection<Node<T>>` | A pre-constructed collection to use instead of building one from items and children. |\n| `selectionBehavior` | `SelectionBehavior` | How multiple selection should behave in the collection. |\n| `allowDuplicateSelectionEvents` | `boolean` | Whether onSelectionChange should fire even if the new set of keys is the same as the last. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to all interactions, or only selection. |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | Handler that is called when the selection changes. |\n| `disabledKeys` | `Iterable<Key>` | The currently disabled keys in the collection (controlled). |\n\nA RouterProvider accepts a `navigate` function from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `navigate` | `( (path: Href, , routerOptions: RouterOptions |\u00c2\u00a0 |\u00c2\u00a0undefined )) => void` |  |\n| `children` | `ReactNode` |  |\n| `useHref` | `( (href: Href )) => string` |  |\n\n`RouterConfig extends {\n\nhref: any\n\n} ? H : string`\n\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with `href` and `routerOptions` properties to configure your router.\n\n`RouterConfig extends {\n\nrouterOptions: any\n\n} ? O : never`",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:38:28.398643+00:00",
  "content_length": 59954,
  "content_hash": "d0abff1db8e3d779"
}