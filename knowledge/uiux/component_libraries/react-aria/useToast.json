{
  "id": "react-aria__react-aria_useToast_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useToast.html",
  "title": "useToast",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseToast\nProvides the behavior and accessibility implementation for a toast component.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useToastRegion, useToast}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseToastRegion\n<\nT\n>\n(\nprops\n:\nAriaToastRegionProps\n,\nstate\n:\nToastState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nToastRegionAria\nuseToast\n<\nT\n>\n(\nprops\n:\nAriaToastProps\n<\nT\n>\n,\nstate\n:\nToastState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nToastAria\nFeatures\n#\nThere is no built in way to display toast notifications in HTML.\nuseToastRegion\nand\nuseToast\nhelp achieve accessible toasts that can be styled as needed.\nAccessible\n\u00e2\u0080\u0093 Toasts follow the\nARIA alertdialog pattern\n. They are rendered in a\nlandmark region\n, which keyboard and screen reader users can easily jump to when an alert is announced.\nFocus management\n\u00e2\u0080\u0093 When a toast unmounts, focus is moved to the next toast if any. Otherwise, focus is restored to where it was before navigating to the toast region. Tabbing through the Toast region will move from newest to oldest.\nAnatomy\n#\nA toast region is an\nARIA landmark region\nlabeled \"Notifications\" by default. A toast region contains one or more visible toasts, in chronological order. When the limit is reached, additional toasts are queued until the user dismisses one. Each toast is a non-modal ARIA\nalertdialog\n, containing the content of the notification and a close button.\nLandmark regions including the toast container can be navigated using the keyboard by pressing the\nF6\nkey to move forward, and the\nShift\n+\nF6\nkey to move backward. This provides an easy way for keyboard users to jump to the toasts from anywhere in the app. When the last toast is closed, keyboard focus is restored.\nuseToastRegion\nreturns props that you should spread onto the toast container element:\nName\nType\nDescription\nregionProps\nDOMAttributes\nProps for the landmark region element.\nuseToast\nreturns props that you should spread onto an individual toast and its child elements:\nName\nType\nDescription\ntoastProps\nDOMAttributes\nProps for the toast container, non-modal dialog element.\ncontentProps\nDOMAttributes\nProps for the toast content alert message.\ntitleProps\nDOMAttributes\nProps for the toast title element.\ndescriptionProps\nDOMAttributes\nProps for the toast description element, if any.\ncloseButtonProps\nAriaButtonProps\nProps for the toast close button.\nExample\n#\nToasts consist of three components. The first is a\nToastProvider\ncomponent which will manage the state for the toast queue with the\nuseToastState\nhook. Alternatively, you could use a global toast queue (\nsee below\n).\nimport\n{\nuseToastState\n}\nfrom\n'react-stately'\n;\nfunction\nToastProvider\n(\n{\nchildren\n,\n...\nprops\n}\n)\n{\nlet\nstate\n=\nuseToastState\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nreturn\n(\n<\n>\n{\nchildren\n(\nstate\n)\n}\n{\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n&&\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n<\n/\n>\n)\n;\n}\nimport\n{\nuseToastState\n}\nfrom\n'react-stately'\n;\nfunction\nToastProvider\n(\n{\nchildren\n,\n...\nprops\n}\n)\n{\nlet\nstate\n=\nuseToastState\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nreturn\n(\n<\n>\n{\nchildren\n(\nstate\n)\n}\n{\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n&&\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n<\n/\n>\n)\n;\n}\nimport\n{\nuseToastState\n}\nfrom\n'react-stately'\n;\nfunction\nToastProvider\n(\n{\nchildren\n,\n...\nprops\n}\n)\n{\nlet\nstate\n=\nuseToastState\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nreturn\n(\n<\n>\n{\nchildren\n(\nstate\n)\n}\n{\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n&&\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n<\n/\n>\n)\n;\n}\nThe\nToastRegion\ncomponent will be rendered when there are toasts to display. It uses the\nuseToastRegion\nhook to create a landmark region, allowing keyboard and screen reader users to easily navigate to it.\nimport\ntype\n{\nToastState\n}\nfrom\n'react-stately'\n;\nimport\ntype\n{\nAriaToastRegionProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToastRegion\n}\nfrom\n'react-aria'\n;\ninterface\nToastRegionProps\n<\nT\n>\nextends\nAriaToastRegionProps\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToastRegion\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastRegionProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nregionProps\n}\n=\nuseToastRegion\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\nregionProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast-region\"\n>\n{\nstate\n.\nvisibleToasts\n.\nmap\n(\n(\ntoast\n)\n=>\n(\n<\nToast\nkey\n=\n{\ntoast\n.\nkey\n}\ntoast\n=\n{\ntoast\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\ndiv\n>\n)\n;\n}\nimport\ntype\n{\nToastState\n}\nfrom\n'react-stately'\n;\nimport\ntype\n{\nAriaToastRegionProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToastRegion\n}\nfrom\n'react-aria'\n;\ninterface\nToastRegionProps\n<\nT\n>\nextends\nAriaToastRegionProps\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToastRegion\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastRegionProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nregionProps\n}\n=\nuseToastRegion\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\nregionProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast-region\"\n>\n{\nstate\n.\nvisibleToasts\n.\nmap\n(\n(\ntoast\n)\n=>\n(\n<\nToast\nkey\n=\n{\ntoast\n.\nkey\n}\ntoast\n=\n{\ntoast\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\ndiv\n>\n)\n;\n}\nimport\ntype\n{\nToastState\n}\nfrom\n'react-stately'\n;\nimport\ntype\n{\nAriaToastRegionProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToastRegion\n}\nfrom\n'react-aria'\n;\ninterface\nToastRegionProps\n<\nT\n>\nextends\nAriaToastRegionProps\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToastRegion\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastRegionProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nregionProps\n}\n=\nuseToastRegion\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\nregionProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast-region\"\n>\n{\nstate\n.\nvisibleToasts\n.\nmap\n(\n(\ntoast\n)\n=>\n(\n<\nToast\nkey\n=\n{\ntoast\n.\nkey\n}\ntoast\n=\n{\ntoast\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\ndiv\n>\n)\n;\n}\nFinally, we need the\nToast\ncomponent to render an individual toast within a\nToastRegion\n, built with\nuseToast\n.\nimport\ntype\n{\nAriaToastProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToast\n}\nfrom\n'react-aria'\n;\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\ninterface\nToastProps\n<\nT\n>\nextends\nAriaToastProps\n<\nT\n>\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToast\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\ntoastProps\n,\ncontentProps\n,\ntitleProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n{\n...\ncontentProps\n}\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\ntype\n{\nAriaToastProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToast\n}\nfrom\n'react-aria'\n;\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\ninterface\nToastProps\n<\nT\n>\nextends\nAriaToastProps\n<\nT\n>\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToast\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\ntoastProps\n,\ncontentProps\n,\ntitleProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n{\n...\ncontentProps\n}\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\ntype\n{\nAriaToastProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToast\n}\nfrom\n'react-aria'\n;\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\ninterface\nToastProps\n<\nT\n>\nextends\nAriaToastProps\n<\nT\n>\n{\nstate\n:\nToastState\n<\nT\n>\n;\n}\nfunction\nToast\n<\nT\nextends\nReact\n.\nReactNode\n>\n(\n{\nstate\n,\n...\nprops\n}\n:\nToastProps\n<\nT\n>\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\ntoastProps\n,\ncontentProps\n,\ntitleProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n{\n...\ncontentProps\n}\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\n<\nToastProvider\n>\n{\nstate\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\nShow CSS\n.\ntoast-region\n{\nposition\n:\nfixed;\nbottom\n:\n16\npx\n;\nright\n:\n16\npx\n;\ndisplay\n:\nflex;\nflex-direction\n:\ncolumn-reverse;\ngap\n:\n8\npx\n;\n}\n\n.\ntoast\n{\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n16\npx\n;\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\npadding\n:\n12\npx\n16\npx\n;\nborder-radius\n:\n8\npx\n;\n}\n\n.\ntoast\nbutton\n{\nbackground\n:\nnone;\nborder\n:\nnone;\nappearance\n:\nnone;\nborder-radius\n:\n50\n%\n;\nheight\n:\n32\npx\n;\nwidth\n:\n32\npx\n;\nfont-size\n:\n16\npx\n;\nborder\n:\n1\npx\nsolid white;\ncolor\n:\nwhite;\npadding\n:\n0\n;\n}\n\n.\ntoast\nbutton\n:\nfocus-visible\n{\noutline\n:\nnone;\nbox-shadow\n:\n0\n0\n0\n2\npx\nslateblue\n,\n0\n0\n0\n4\npx\nwhite;\n}\n\n.\ntoast\nbutton\n:\nactive\n{\nbackground\n:\nrgba\n(\n255\n,\n255\n,\n255\n,\n0.2\n);\n}\n.\ntoast-region\n{\nposition\n:\nfixed;\nbottom\n:\n16\npx\n;\nright\n:\n16\npx\n;\ndisplay\n:\nflex;\nflex-direction\n:\ncolumn-reverse;\ngap\n:\n8\npx\n;\n}\n\n.\ntoast\n{\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n16\npx\n;\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\npadding\n:\n12\npx\n16\npx\n;\nborder-radius\n:\n8\npx\n;\n}\n\n.\ntoast\nbutton\n{\nbackground\n:\nnone;\nborder\n:\nnone;\nappearance\n:\nnone;\nborder-radius\n:\n50\n%\n;\nheight\n:\n32\npx\n;\nwidth\n:\n32\npx\n;\nfont-size\n:\n16\npx\n;\nborder\n:\n1\npx\nsolid white;\ncolor\n:\nwhite;\npadding\n:\n0\n;\n}\n\n.\ntoast\nbutton\n:\nfocus-visible\n{\noutline\n:\nnone;\nbox-shadow\n:\n0\n0\n0\n2\npx\nslateblue\n,\n0\n0\n0\n4\npx\nwhite;\n}\n\n.\ntoast\nbutton\n:\nactive\n{\nbackground\n:\nrgba\n(\n255\n,\n255\n,\n255\n,\n0.2\n);\n}\n.\ntoast-region\n{\nposition\n:\nfixed;\nbottom\n:\n16\npx\n;\nright\n:\n16\npx\n;\ndisplay\n:\nflex;\nflex-direction\n:\ncolumn-reverse;\ngap\n:\n8\npx\n;\n}\n\n.\ntoast\n{\ndisplay\n:\nflex;\nalign-items\n:\ncenter;\ngap\n:\n16\npx\n;\nbackground\n:\nslateblue;\ncolor\n:\nwhite;\npadding\n:\n12\npx\n16\npx\n;\nborder-radius\n:\n8\npx\n;\n}\n\n.\ntoast\nbutton\n{\nbackground\n:\nnone;\nborder\n:\nnone;\nappearance\n:\nnone;\nborder-radius\n:\n50\n%\n;\nheight\n:\n32\npx\n;\nwidth\n:\n32\npx\n;\nfont-size\n:\n16\npx\n;\nborder\n:\n1\npx\nsolid white;\ncolor\n:\nwhite;\npadding\n:\n0\n;\n}\n\n.\ntoast\nbutton\n:\nfocus-visible\n{\noutline\n:\nnone;\nbox-shadow\n:\n0\n0\n0\n2\npx\nslateblue\n,\n0\n0\n0\n4\npx\nwhite;\n}\n\n.\ntoast\nbutton\n:\nactive\n{\nbackground\n:\nrgba\n(\n255\n,\n255\n,\n255\n,\n0.2\n);\n}\nButton\n#\nThe\nButton\ncomponent is used in the above example to close a toast. It is built using the\nuseButton\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nUsage\n#\nThe following examples show how to use the\nToastProvider\ncomponent created in the above example.\nAuto-dismiss\n#\nToasts support a\ntimeout\noption to automatically hide them after a certain amount of time. For accessibility, toasts should have a minimum timeout of 5 seconds to give users enough time to read them. If a toast includes action buttons or other interactive elements it should not auto dismiss. In addition, timers will automatically pause when the user focuses or hovers over a toast.\nBe sure only to automatically dismiss toasts when the information is not important, or may be found elsewhere. Some users may require additional time to read a toast message, and screen zoom users may miss toasts entirely.\n<\nToastProvider\n>\n{\nstate\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast still toasting!'\n,\n{\ntimeout\n:\n5000\n}\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast still toasting!'\n,\n{\ntimeout\n:\n5000\n}\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nstate\n.\nadd\n(\n'Toast still toasting!'\n,\n{\ntimeout\n:\n5000\n}\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\nProgrammatic dismissal\n#\nToasts may be programmatically dismissed if they become irrelevant before the user manually closes them.\nstate.add\nreturns a key for the toast which may be passed to\nstate.close\nto dismiss the toast.\nfunction\nExample\n(\n)\n{\nlet\n[\ntoastKey\n,\nsetToastKey\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\n{\nif\n(\n!\ntoastKey\n)\n{\nsetToastKey\n(\nstate\n.\nadd\n(\n'Unable to save'\n,\n{\nonClose\n:\n(\n)\n=>\nsetToastKey\n(\nnull\n)\n}\n)\n)\n;\n}\nelse\n{\nstate\n.\nclose\n(\ntoastKey\n)\n;\n}\n}\n}\n>\n{\ntoastKey\n?\n'Hide'\n:\n'Show'\n}\nToast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\ntoastKey\n,\nsetToastKey\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\n{\nif\n(\n!\ntoastKey\n)\n{\nsetToastKey\n(\nstate\n.\nadd\n(\n'Unable to save'\n,\n{\nonClose\n:\n(\n)\n=>\nsetToastKey\n(\nnull\n)\n}\n)\n)\n;\n}\nelse\n{\nstate\n.\nclose\n(\ntoastKey\n)\n;\n}\n}\n}\n>\n{\ntoastKey\n?\n'Hide'\n:\n'Show'\n}\nToast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\ntoastKey\n,\nsetToastKey\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\nToastProvider\n>\n{\n(\nstate\n)\n=>\n(\n<\nButton\nonPress\n=\n{\n(\n)\n=>\n{\nif\n(\n!\ntoastKey\n)\n{\nsetToastKey\n(\nstate\n.\nadd\n(\n'Unable to save'\n,\n{\nonClose\n:\n(\n)\n=>\nsetToastKey\n(\nnull\n)\n}\n)\n)\n;\n}\nelse\n{\nstate\n.\nclose\n(\ntoastKey\n)\n;\n}\n}\n}\n>\n{\ntoastKey\n?\n'Hide'\n:\n'Show'\n}\n{\n' '\n}\nToast\n<\n/\nButton\n>\n)\n}\n<\n/\nToastProvider\n>\n)\n;\n}\nAdvanced topics\n#\nGlobal toast queue\n#\nIn the above examples, each\nToastProvider\nhas a separate queue. This setup is simple, and fine for most cases where you can wrap the entire app in a single\nToastProvider\n. However, in more complex situations, you may want to keep the toast queue outside the React tree so that toasts can be queued from anywhere. This can be done by creating your own\nToastQueue\nand subscribing to it using the\nuseToastQueue\nhook rather than\nuseToastState\n.\nimport\n{\nToastQueue\n,\nuseToastQueue\n}\nfrom\n'react-stately'\n;\nimport\n{\ncreatePortal\n}\nfrom\n'react-dom'\n;\n// Create a global toast queue.\nconst\ntoastQueue\n=\nnew\nToastQueue\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nfunction\nGlobalToastRegion\n(\nprops\n)\n{\n// Subscribe to it.\nlet\nstate\n=\nuseToastQueue\n(\ntoastQueue\n)\n;\n// Render toast region.\nreturn\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n?\ncreatePortal\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n,\ndocument\n.\nbody\n)\n:\nnull\n;\n}\n// Render it somewhere in your app.\n<\nGlobalToastRegion\n/\n>\nimport\n{\nToastQueue\n,\nuseToastQueue\n}\nfrom\n'react-stately'\n;\nimport\n{\ncreatePortal\n}\nfrom\n'react-dom'\n;\n// Create a global toast queue.\nconst\ntoastQueue\n=\nnew\nToastQueue\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nfunction\nGlobalToastRegion\n(\nprops\n)\n{\n// Subscribe to it.\nlet\nstate\n=\nuseToastQueue\n(\ntoastQueue\n)\n;\n// Render toast region.\nreturn\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n?\ncreatePortal\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n,\ndocument\n.\nbody\n)\n:\nnull\n;\n}\n// Render it somewhere in your app.\n<\nGlobalToastRegion\n/\n>\nimport\n{\nToastQueue\n,\nuseToastQueue\n}\nfrom\n'react-stately'\n;\nimport\n{\ncreatePortal\n}\nfrom\n'react-dom'\n;\n// Create a global toast queue.\nconst\ntoastQueue\n=\nnew\nToastQueue\n(\n{\nmaxVisibleToasts\n:\n5\n}\n)\n;\nfunction\nGlobalToastRegion\n(\nprops\n)\n{\n// Subscribe to it.\nlet\nstate\n=\nuseToastQueue\n(\ntoastQueue\n)\n;\n// Render toast region.\nreturn\nstate\n.\nvisibleToasts\n.\nlength\n>\n0\n?\ncreatePortal\n(\n<\nToastRegion\n{\n...\nprops\n}\nstate\n=\n{\nstate\n}\n/\n>\n,\ndocument\n.\nbody\n)\n:\nnull\n;\n}\n// Render it somewhere in your app.\n<\nGlobalToastRegion\n/\n>\nNow you can queue a toast from anywhere:\n<\nButton\nonPress\n=\n{\n(\n)\n=>\ntoastQueue\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n<\nButton\nonPress\n=\n{\n(\n)\n=>\ntoastQueue\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\n<\nButton\nonPress\n=\n{\n(\n)\n=>\ntoastQueue\n.\nadd\n(\n'Toast is done!'\n)\n}\n>\nShow toast\n<\n/\nButton\n>\nTypeScript\n#\nA\nToastQueue\nand\nuseToastState\nuse a generic type to represent toast content. The examples so far have used strings, but you can type this however you want to enable passing custom objects or options. This example uses a custom object to support toasts with both a title and description.\nimport\ntype\n{\nQueuedToast\n}\nfrom\n'react-stately'\n;\ninterface\nMyToast\n{\ntitle\n:\nstring\n;\ndescription\n:\nstring\n;\n}\nfunction\nToastProvider\n(\n)\n{\nlet\nstate\n=\nuseToastState\n<\nMyToast\n>\n(\n)\n;\n// ...\n}\ninterface\nToastProps\n{\ntoast\n:\nQueuedToast\n<\nMyToast\n>\n;\n}\nfunction\nToast\n(\nprops\n:\nToastProps\n)\n{\n// ...\nlet\n{\ntoastProps\n,\ntitleProps\n,\ndescriptionProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ntitle\n}\n<\n/\ndiv\n>\n<\ndiv\n{\n...\ndescriptionProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ndescription\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\n// Queuing a toast\nstate\n.\nadd\n(\n{\ntitle\n:\n'Success!'\n,\ndescription\n:\n'Toast is done.'\n}\n)\n;\nimport\ntype\n{\nQueuedToast\n}\nfrom\n'react-stately'\n;\ninterface\nMyToast\n{\ntitle\n:\nstring\n;\ndescription\n:\nstring\n;\n}\nfunction\nToastProvider\n(\n)\n{\nlet\nstate\n=\nuseToastState\n<\nMyToast\n>\n(\n)\n;\n// ...\n}\ninterface\nToastProps\n{\ntoast\n:\nQueuedToast\n<\nMyToast\n>\n;\n}\nfunction\nToast\n(\nprops\n:\nToastProps\n)\n{\n// ...\nlet\n{\ntoastProps\n,\ntitleProps\n,\ndescriptionProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ntitle\n}\n<\n/\ndiv\n>\n<\ndiv\n{\n...\ndescriptionProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ndescription\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\n// Queuing a toast\nstate\n.\nadd\n(\n{\ntitle\n:\n'Success!'\n,\ndescription\n:\n'Toast is done.'\n}\n)\n;\nimport\ntype\n{\nQueuedToast\n}\nfrom\n'react-stately'\n;\ninterface\nMyToast\n{\ntitle\n:\nstring\n;\ndescription\n:\nstring\n;\n}\nfunction\nToastProvider\n(\n)\n{\nlet\nstate\n=\nuseToastState\n<\nMyToast\n>\n(\n)\n;\n// ...\n}\ninterface\nToastProps\n{\ntoast\n:\nQueuedToast\n<\nMyToast\n>\n;\n}\nfunction\nToast\n(\nprops\n:\nToastProps\n)\n{\n// ...\nlet\n{\ntoastProps\n,\ntitleProps\n,\ndescriptionProps\n,\ncloseButtonProps\n}\n=\nuseToast\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ndiv\n{\n...\ntoastProps\n}\nref\n=\n{\nref\n}\nclassName\n=\n\"toast\"\n>\n<\ndiv\n>\n<\ndiv\n{\n...\ntitleProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ntitle\n}\n<\n/\ndiv\n>\n<\ndiv\n{\n...\ndescriptionProps\n}\n>\n{\nprops\n.\ntoast\n.\ncontent\n.\ndescription\n}\n<\n/\ndiv\n>\n<\n/\ndiv\n>\n<\nButton\n{\n...\ncloseButtonProps\n}\n>\nx\n<\n/\nButton\n>\n<\n/\ndiv\n>\n)\n;\n}\n// Queuing a toast\nstate\n.\nadd\n(\n{\ntitle\n:\n'Success!'\n,\ndescription\n:\n'Toast is done.'\n}\n)\n;\nName\nType\nDefault\nDescription\naria-label\nstring\n\"Notifications\"\nAn accessibility label for the toast region.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nProperties\nName\nType\nDescription\nvisibleToasts\nQueuedToast\n<\nT\n>\n[]\nThe visible toasts.\nMethods\nMethod\nDescription\nadd\n(\n(\ncontent\n:\nT\n,\n,\noptions\n?\n:\nToastOptions\n)\n)\n:\nstring\nAdds a new toast to the queue.\nclose\n(\n(\nkey\n:\nstring\n)\n)\n:\nvoid\nCloses a toast.\npauseAll\n(\n)\n:\nvoid\nPauses the timers for all visible toasts.\nresumeAll\n(\n)\n:\nvoid\nResumes the timers for all visible toasts.\nName\nType\nDescription\nonClose\n(\n)\n=>\nvoid\nHandler that is called when the toast is closed, either by the user or after a timeout.\ntimeout\nnumber\nA timeout to automatically close the toast after, in milliseconds.\nName\nType\nDescription\ncontent\nT\nThe content of the toast.\nkey\nstring\nA unique key for the toast.\ntimer\nTimer\nA timer for the toast, if a timeout was set.\nonClose\n(\n)\n=>\nvoid\nHandler that is called when the toast is closed, either by the user or after a timeout.\ntimeout\nnumber\nA timeout to automatically close the toast after, in milliseconds.\nMethod\nDescription\nconstructor\n(\n(\ncallback\n:\n(\n)\n=>\nvoid\n,\n,\ndelay\n:\nnumber\n)\n)\n:\nvoid\nreset\n(\n(\ndelay\n:\nnumber\n)\n)\n:\nvoid\npause\n(\n)\n:\nvoid\nresume\n(\n)\n:\nvoid\nName\nType\nDescription\ncurrent\nT\nName\nType\nDescription\nregionProps\nDOMAttributes\nProps for the landmark region element.\nAll DOM attributes supported across both HTML and SVG elements.\nExtends\n:\nAriaAttributes\n,\nReactDOMAttributes\nName\nType\nDescription\nid\nstring\n|\u00c2\nundefined\nrole\nAriaRole\n|\u00c2\nundefined\ntabIndex\nnumber\n|\u00c2\nundefined\nstyle\nCSSProperties\n|\u00c2\nundefined\nclassName\nstring\n|\u00c2\nundefined\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nName\nType\nDescription\ntoast\nQueuedToast\n<\nT\n>\nThe toast object.\naria-label\nstring\nDefines a string value that labels the current element.\naria-labelledby\nstring\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nName\nType\nDescription\ntoastProps\nDOMAttributes\nProps for the toast container, non-modal dialog element.\ncontentProps\nDOMAttributes\nProps for the toast content alert message.\ntitleProps\nDOMAttributes\nProps for the toast title element.\ndescriptionProps\nDOMAttributes\nProps for the toast description element, if any.\ncloseButtonProps\nAriaButtonProps\nProps for the toast close button.\nName\nType\nDefault\nDescription\nisDisabled\nboolean\n\u00e2\u0080\u0094\nWhether the button is disabled.\nchildren\nReactNode\n\u00e2\u0080\u0094\nThe content to display in the button.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element should receive focus on render.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nhref\nstring\n\u00e2\u0080\u0094\nA URL to link to if elementType=\"a\".\ntarget\nstring\n\u00e2\u0080\u0094\nThe target window for the link.\nrel\nstring\n\u00e2\u0080\u0094\nThe relationship between the linked resource and the current page. See\nMDN\n.\nelementType\nElementType\n|\u00c2\nJSXElementConstructor\n<\nany\n>\n'button'\nThe HTML element or React element used to render the button, e.g. 'div', 'a', or\nRouterLink\n.\naria-disabled\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element is disabled to users of assistive technology.\naria-expanded\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element, or another grouping element it controls, is currently expanded or collapsed.\naria-haspopup\nboolean\n|\u00c2\n'menu'\n|\u00c2\n'listbox'\n|\u00c2\n'tree'\n|\u00c2\n'grid'\n|\u00c2\n'dialog'\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) whose contents or presence are controlled by the current element.\naria-pressed\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'mixed'\n\u00e2\u0080\u0094\nIndicates the current \"pressed\" state of toggle buttons.\naria-current\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'page'\n|\u00c2\n'step'\n|\u00c2\n'location'\n|\u00c2\n'date'\n|\u00c2\n'time'\n\u00e2\u0080\u0094\nIndicates whether this element represents the current item within a container or set of related elements.\ntype\n'button'\n|\u00c2\n'submit'\n|\u00c2\n'reset'\n'button'\nThe behavior of the button when used in an HTML form.\npreventFocusOnPress\nboolean\n\u00e2\u0080\u0094\nWhether to prevent focus from moving to the button when pressing it.\nCaution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided,\nsuch as ComboBox's MenuTrigger or a NumberField's increment/decrement control.\nform\nstring\n\u00e2\u0080\u0094\nThe\n<form>\nelement to associate the button with.\nThe value of this attribute must be the id of a\n<form>\nin the same document.\nSee\nMDN\n.\nformAction\nstring\n\u00e2\u0080\u0094\nThe URL that processes the information submitted by the button.\nOverrides the action attribute of the button's form owner.\nformEncType\nstring\n\u00e2\u0080\u0094\nIndicates how to encode the form data that is submitted.\nformMethod\nstring\n\u00e2\u0080\u0094\nIndicates the HTTP method used to submit the form.\nformNoValidate\nboolean\n\u00e2\u0080\u0094\nIndicates that the form is not to be validated when it is submitted.\nformTarget\nstring\n\u00e2\u0080\u0094\nOverrides the target attribute of the button's form owner.\nname\nstring\n\u00e2\u0080\u0094\nSubmitted as a pair with the button's value as part of the form data.\nvalue\nstring\n\u00e2\u0080\u0094\nThe value associated with the button's name when it's submitted with the form data.\nexcludeFromTabOrder\nboolean\n\u00e2\u0080\u0094\nWhether to exclude the element from the sequential tab order. If true,\nthe element will not be focusable via the keyboard by tabbing. This should\nbe avoided except in rare scenarios where an alternative means of accessing\nthe element or its functionality via the keyboard is available.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nBaseEvent\n<\nReactKeyboardEvent\n<\nany\n>\n>\nSyntheticEvent\n&\u00c2\n{\nstopPropagation\n:\n(\n)\n=>\nvoid\n,\ncontinuePropagation\n:\n(\n)\n=>\nvoid\n}\nProvides the behavior and accessibility implementation for a toast region containing one or more toasts.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\nuseToastRegion\n<\nT\n>\n(\nprops\n:\nAriaToastRegionProps\n,\nstate\n:\nToastState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nToastRegionAria\nProvides the behavior and accessibility implementation for a toast component.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\nuseToast\n<\nT\n>\n(\nprops\n:\nAriaToastProps\n<\nT\n>\n,\nstate\n:\nToastState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nToastAria\nProvides state management for a toast queue. Toasts display brief, temporary notifications\nof actions, errors, or other events in an application.\nuseToastState\n<\nT\n>\n(\n(\nprops\n:\nToastStateProps\n)\n)\n:\nToastState\n<\nT\n>\nName\nType\nDescription\nmaxVisibleToasts\nnumber\nThe maximum number of toasts to display at a time.\nwrapUpdate\n(\n(\nfn\n:\n(\n)\n=>\nvoid\n,\n,\naction\n:\nToastAction\n)\n)\n=>\nvoid\nFunction to wrap updates in (i.e. document.startViewTransition()).\n'add'\n|\u00c2\n'remove'\n|\u00c2\n'clear'\nA ToastQueue manages the order of toasts.\nProperties\nName\nType\nDescription\nvisibleToasts\nQueuedToast\n<\nT\n>\n[]\nThe currently visible toasts.\nMethods\nMethod\nDescription\nconstructor\n(\n(\noptions\n?\n:\nToastStateProps\n)\n)\n:\nvoid\nsubscribe\n(\n(\nfn\n:\n(\n)\n=>\nvoid\n)\n)\n:\n(\n)\n=>\nvoid\nSubscribes to updates to the visible toasts.\nadd\n(\n(\ncontent\n:\nT\n,\n,\noptions\n:\nToastOptions\n)\n)\n:\nstring\nAdds a new toast to the queue.\nclose\n(\n(\nkey\n:\nstring\n)\n)\n:\nvoid\nCloses a toast.\npauseAll\n(\n)\n:\nvoid\nPauses the timers for all visible toasts.\nresumeAll\n(\n)\n:\nvoid\nResumes the timers for all visible toasts.\nclear\n(\n)\n:\nvoid\nSubscribes to a provided toast queue and provides methods to update it.\nuseToastQueue\n<\nT\n>\n(\n(\nqueue\n:\nToastQueue\n<\nT\n>\n)\n)\n:\nToastState\n<\nT\n>",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../Toast).\n\n# useToast\n\nProvides the behavior and accessibility implementation for a toast component.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useToastRegion, useToast} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/toast \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/toast \"View package\")\n\n## API[#](#api)\n\n---\n\n`useToastRegion<T>(\nprops: AriaToastRegionProps,\nstate: ToastState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ToastRegionAria`\n`useToast<T>(\nprops: AriaToastProps<T>,\nstate: ToastState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ToastAria`\n\n## Features[#](#features)\n\n---\n\nThere is no built in way to display toast notifications in HTML. `useToastRegion` and `useToast` help achieve accessible toasts that can be styled as needed.\n\n- **Accessible** \u00e2\u0080\u0093 Toasts follow the [ARIA alertdialog pattern](https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/). They are rendered in a [landmark region](https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/), which keyboard and screen reader users can easily jump to when an alert is announced.\n- **Focus management** \u00e2\u0080\u0093 When a toast unmounts, focus is moved to the next toast if any. Otherwise, focus is restored to where it was before navigating to the toast region. Tabbing through the Toast region will move from newest to oldest.\n\n## Anatomy[#](#anatomy)\n\n---\n\nA toast region is an [ARIA landmark region](https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/) labeled \"Notifications\" by default. A toast region contains one or more visible toasts, in chronological order. When the limit is reached, additional toasts are queued until the user dismisses one. Each toast is a non-modal ARIA [alertdialog](https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/), containing the content of the notification and a close button.\n\nLandmark regions including the toast container can be navigated using the keyboard by pressing the `F6` key to move forward, and the `Shift` + `F6` key to move backward. This provides an easy way for keyboard users to jump to the toasts from anywhere in the app. When the last toast is closed, keyboard focus is restored.\n\n`useToastRegion` returns props that you should spread onto the toast container element:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `regionProps` | `DOMAttributes` | Props for the landmark region element. |\n\n`useToast` returns props that you should spread onto an individual toast and its child elements:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `toastProps` | `DOMAttributes` | Props for the toast container, non-modal dialog element. |\n| `contentProps` | `DOMAttributes` | Props for the toast content alert message. |\n| `titleProps` | `DOMAttributes` | Props for the toast title element. |\n| `descriptionProps` | `DOMAttributes` | Props for the toast description element, if any. |\n| `closeButtonProps` | `AriaButtonProps` | Props for the toast close button. |\n\n## Example[#](#example)\n\n---\n\nToasts consist of three components. The first is a `ToastProvider` component which will manage the state for the toast queue with the `useToastState` hook. Alternatively, you could use a global toast queue ([see below](#global-toast-queue)).\n\n```\nimport {useToastState} from 'react-stately';\n\nfunction ToastProvider({ children, ...props }) {\n  let state = useToastState({\n    maxVisibleToasts: 5\n  });\n\n  return (\n    <>\n      {children(state)}\n      {state.visibleToasts.length > 0 && (\n        <ToastRegion {...props} state={state} />\n      )}\n    </>\n  );\n}\n```\n\n```\nimport {useToastState} from 'react-stately';\n\nfunction ToastProvider({ children, ...props }) {\n  let state = useToastState({\n    maxVisibleToasts: 5\n  });\n\n  return (\n    <>\n      {children(state)}\n      {state.visibleToasts.length > 0 && (\n        <ToastRegion {...props} state={state} />\n      )}\n    </>\n  );\n}\n```\n\n```\nimport {useToastState} from 'react-stately';\n\nfunction ToastProvider(\n  { children, ...props }\n) {\n  let state =\n    useToastState({\n      maxVisibleToasts: 5\n    });\n\n  return (\n    <>\n      {children(state)}\n      {state\n            .visibleToasts\n            .length >\n          0 && (\n        <ToastRegion\n          {...props}\n          state={state}\n        />\n      )}\n    </>\n  );\n}\n```\n\nThe `ToastRegion` component will be rendered when there are toasts to display. It uses the `useToastRegion` hook to create a landmark region, allowing keyboard and screen reader users to easily navigate to it.\n\n```\nimport type {ToastState} from 'react-stately';\nimport type {AriaToastRegionProps} from 'react-aria';\nimport {useToastRegion} from 'react-aria';\n\ninterface ToastRegionProps<T> extends AriaToastRegionProps {\n  state: ToastState<T>;\n}\n\nfunction ToastRegion<T extends React.ReactNode>(\n  { state, ...props }: ToastRegionProps<T>\n) {\n  let ref = React.useRef(null);\n  let { regionProps } = useToastRegion(props, state, ref);\n\n  return (\n    <div {...regionProps} ref={ref} className=\"toast-region\">\n      {state.visibleToasts.map((toast) => (\n        <Toast key={toast.key} toast={toast} state={state} />\n      ))}\n    </div>\n  );\n}\n```\n\n```\nimport type {ToastState} from 'react-stately';\nimport type {AriaToastRegionProps} from 'react-aria';\nimport {useToastRegion} from 'react-aria';\n\ninterface ToastRegionProps<T> extends AriaToastRegionProps {\n  state: ToastState<T>;\n}\n\nfunction ToastRegion<T extends React.ReactNode>(\n  { state, ...props }: ToastRegionProps<T>\n) {\n  let ref = React.useRef(null);\n  let { regionProps } = useToastRegion(props, state, ref);\n\n  return (\n    <div\n      {...regionProps}\n      ref={ref}\n      className=\"toast-region\"\n    >\n      {state.visibleToasts.map((toast) => (\n        <Toast\n          key={toast.key}\n          toast={toast}\n          state={state}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n```\nimport type {ToastState} from 'react-stately';\nimport type {AriaToastRegionProps} from 'react-aria';\nimport {useToastRegion} from 'react-aria';\n\ninterface ToastRegionProps<\n  T\n> extends\n  AriaToastRegionProps {\n  state: ToastState<T>;\n}\n\nfunction ToastRegion<\n  T\n    extends React.ReactNode\n>(\n  { state, ...props }:\n    ToastRegionProps<T>\n) {\n  let ref = React.useRef(\n    null\n  );\n  let { regionProps } =\n    useToastRegion(\n      props,\n      state,\n      ref\n    );\n\n  return (\n    <div\n      {...regionProps}\n      ref={ref}\n      className=\"toast-region\"\n    >\n      {state\n        .visibleToasts\n        .map((toast) => (\n          <Toast\n            key={toast\n              .key}\n            toast={toast}\n            state={state}\n          />\n        ))}\n    </div>\n  );\n}\n```\n\nFinally, we need the `Toast` component to render an individual toast within a `ToastRegion`, built with `useToast`.\n\n```\nimport type {AriaToastProps} from 'react-aria';\nimport {useToast} from 'react-aria';\n\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\ninterface ToastProps<T> extends AriaToastProps<T> {\n  state: ToastState<T>;\n}\n\nfunction Toast<T extends React.ReactNode>({ state, ...props }: ToastProps<T>) {\n  let ref = React.useRef(null);\n  let { toastProps, contentProps, titleProps, closeButtonProps } = useToast(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <div {...toastProps} ref={ref} className=\"toast\">\n      <div {...contentProps}>\n        <div {...titleProps}>{props.toast.content}</div>\n      </div>\n      <Button {...closeButtonProps}>x</Button>\n    </div>\n  );\n}\n```\n\n```\nimport type {AriaToastProps} from 'react-aria';\nimport {useToast} from 'react-aria';\n\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\ninterface ToastProps<T> extends AriaToastProps<T> {\n  state: ToastState<T>;\n}\n\nfunction Toast<T extends React.ReactNode>(\n  { state, ...props }: ToastProps<T>\n) {\n  let ref = React.useRef(null);\n  let {\n    toastProps,\n    contentProps,\n    titleProps,\n    closeButtonProps\n  } = useToast(props, state, ref);\n\n  return (\n    <div {...toastProps} ref={ref} className=\"toast\">\n      <div {...contentProps}>\n        <div {...titleProps}>{props.toast.content}</div>\n      </div>\n      <Button {...closeButtonProps}>x</Button>\n    </div>\n  );\n}\n```\n\n```\nimport type {AriaToastProps} from 'react-aria';\nimport {useToast} from 'react-aria';\n\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\ninterface ToastProps<T>\n  extends\n    AriaToastProps<T> {\n  state: ToastState<T>;\n}\n\nfunction Toast<\n  T\n    extends React.ReactNode\n>(\n  { state, ...props }:\n    ToastProps<T>\n) {\n  let ref = React.useRef(\n    null\n  );\n  let {\n    toastProps,\n    contentProps,\n    titleProps,\n    closeButtonProps\n  } = useToast(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <div\n      {...toastProps}\n      ref={ref}\n      className=\"toast\"\n    >\n      <div\n        {...contentProps}\n      >\n        <div\n          {...titleProps}\n        >\n          {props.toast\n            .content}\n        </div>\n      </div>\n      <Button\n        {...closeButtonProps}\n      >\n        x\n      </Button>\n    </div>\n  );\n}\n```\n\n```\n<ToastProvider>\n  {state => (\n    <Button onPress={() => state.add('Toast is done!')}>Show toast</Button>\n  )}\n</ToastProvider>\n```\n\n```\n<ToastProvider>\n  {(state) => (\n    <Button onPress={() => state.add('Toast is done!')}>\n      Show toast\n    </Button>\n  )}\n</ToastProvider>\n```\n\n```\n<ToastProvider>\n  {(state) => (\n    <Button\n      onPress={() =>\n        state.add(\n          'Toast is done!'\n        )}\n    >\n      Show toast\n    </Button>\n  )}\n</ToastProvider>\n```\n\n Show CSS\n\n```\n.toast-region {\n  position: fixed;\n  bottom: 16px;\n  right: 16px;\n  display: flex;\n  flex-direction: column-reverse;\n  gap: 8px;\n}\n\n.toast {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  background: slateblue;\n  color: white;\n  padding: 12px 16px;\n  border-radius: 8px;\n}\n\n.toast button {\n  background: none;\n  border: none;\n  appearance: none;\n  border-radius: 50%;\n  height: 32px;\n  width: 32px;\n  font-size: 16px;\n  border: 1px solid white;\n  color: white;\n  padding: 0;\n}\n\n.toast button:focus-visible {\n  outline: none;\n  box-shadow: 0 0 0 2px slateblue, 0 0 0 4px white;\n}\n\n.toast button:active {\n  background: rgba(255, 255, 255, 0.2);\n}\n```\n\n```\n.toast-region {\n  position: fixed;\n  bottom: 16px;\n  right: 16px;\n  display: flex;\n  flex-direction: column-reverse;\n  gap: 8px;\n}\n\n.toast {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  background: slateblue;\n  color: white;\n  padding: 12px 16px;\n  border-radius: 8px;\n}\n\n.toast button {\n  background: none;\n  border: none;\n  appearance: none;\n  border-radius: 50%;\n  height: 32px;\n  width: 32px;\n  font-size: 16px;\n  border: 1px solid white;\n  color: white;\n  padding: 0;\n}\n\n.toast button:focus-visible {\n  outline: none;\n  box-shadow: 0 0 0 2px slateblue, 0 0 0 4px white;\n}\n\n.toast button:active {\n  background: rgba(255, 255, 255, 0.2);\n}\n```\n\n```\n.toast-region {\n  position: fixed;\n  bottom: 16px;\n  right: 16px;\n  display: flex;\n  flex-direction: column-reverse;\n  gap: 8px;\n}\n\n.toast {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  background: slateblue;\n  color: white;\n  padding: 12px 16px;\n  border-radius: 8px;\n}\n\n.toast button {\n  background: none;\n  border: none;\n  appearance: none;\n  border-radius: 50%;\n  height: 32px;\n  width: 32px;\n  font-size: 16px;\n  border: 1px solid white;\n  color: white;\n  padding: 0;\n}\n\n.toast button:focus-visible {\n  outline: none;\n  box-shadow: 0 0 0 2px slateblue, 0 0 0 4px white;\n}\n\n.toast button:active {\n  background: rgba(255, 255, 255, 0.2);\n}\n```\n\n### Button[#](#button)\n\nThe `Button` component is used in the above example to close a toast. It is built using the [useButton](../Button/useButton.html) hook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(null);\n  let { buttonProps } = useButton(props, ref);\n  return <button {...buttonProps} ref={ref}>{props.children}</button>;\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(null);\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button {...buttonProps} ref={ref}>\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = React.useRef(\n    null\n  );\n  let { buttonProps } =\n    useButton(\n      props,\n      ref\n    );\n  return (\n    <button\n      {...buttonProps}\n      ref={ref}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n## Usage[#](#usage)\n\n---\n\nThe following examples show how to use the `ToastProvider` component created in the above example.\n\n### Auto-dismiss[#](#auto-dismiss)\n\nToasts support a `timeout` option to automatically hide them after a certain amount of time. For accessibility, toasts should have a minimum timeout of 5 seconds to give users enough time to read them. If a toast includes action buttons or other interactive elements it should not auto dismiss. In addition, timers will automatically pause when the user focuses or hovers over a toast.\n\nBe sure only to automatically dismiss toasts when the information is not important, or may be found elsewhere. Some users may require additional time to read a toast message, and screen zoom users may miss toasts entirely.\n\n```\n<ToastProvider>\n  {state => (\n    <Button onPress={() => state.add('Toast still toasting!', {timeout: 5000})}>      Show toast\n    </Button>\n  )}\n</ToastProvider>\n```\n\n```\n<ToastProvider>\n  {(state) => (\n    <Button\n      onPress={() =>\n        state.add('Toast still toasting!', {\n          timeout: 5000\n        })}\n    >      Show toast\n    </Button>\n  )}\n</ToastProvider>\n```\n\n```\n<ToastProvider>\n  {(state) => (\n    <Button\n      onPress={() =>\n        state.add(\n          'Toast still toasting!',\n          {\n            timeout:\n              5000\n          }\n        )}\n    >      Show toast\n    </Button>\n  )}\n</ToastProvider>\n```\n\n### Programmatic dismissal[#](#programmatic-dismissal)\n\nToasts may be programmatically dismissed if they become irrelevant before the user manually closes them. `state.add` returns a key for the toast which may be passed to `state.close` to dismiss the toast.\n\n```\nfunction Example() {\n  let [toastKey, setToastKey] = React.useState(null);\n\n  return (\n    <ToastProvider>\n      {(state) => (\n        <Button\n          onPress={() => {\n            if (!toastKey) {\n              setToastKey(\n                state.add('Unable to save', {\n                  onClose: () => setToastKey(null)\n                })\n              );            } else {\n              state.close(toastKey);            }\n          }}\n        >\n          {toastKey ? 'Hide' : 'Show'} Toast\n        </Button>\n      )}\n    </ToastProvider>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [toastKey, setToastKey] = React.useState(null);\n\n  return (\n    <ToastProvider>\n      {(state) => (\n        <Button\n          onPress={() => {\n            if (!toastKey) {\n              setToastKey(\n                state.add('Unable to save', {\n                  onClose: () => setToastKey(null)\n                })\n              );            } else {\n              state.close(toastKey);            }\n          }}\n        >\n          {toastKey ? 'Hide' : 'Show'} Toast\n        </Button>\n      )}\n    </ToastProvider>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [\n    toastKey,\n    setToastKey\n  ] = React.useState(\n    null\n  );\n\n  return (\n    <ToastProvider>\n      {(state) => (\n        <Button\n          onPress={() => {\n            if (\n              !toastKey\n            ) {\n              setToastKey(\n                state\n                  .add(\n                    'Unable to save',\n                    {\n                      onClose:\n                        () =>\n                          setToastKey(\n                            null\n                          )\n                    }\n                  )\n              );            } else {\n              state\n                .close(\n                  toastKey\n                );            }\n          }}\n        >\n          {toastKey\n            ? 'Hide'\n            : 'Show'}\n          {' '}\n          Toast\n        </Button>\n      )}\n    </ToastProvider>\n  );\n}\n```\n\n## Advanced topics[#](#advanced-topics)\n\n---\n\n### Global toast queue[#](#global-toast-queue)\n\nIn the above examples, each `ToastProvider` has a separate queue. This setup is simple, and fine for most cases where you can wrap the entire app in a single `ToastProvider`. However, in more complex situations, you may want to keep the toast queue outside the React tree so that toasts can be queued from anywhere. This can be done by creating your own `ToastQueue` and subscribing to it using the `useToastQueue` hook rather than `useToastState`.\n\n```\nimport {ToastQueue, useToastQueue} from 'react-stately';\nimport {createPortal} from 'react-dom';\n\n// Create a global toast queue.\nconst toastQueue = new ToastQueue({\n  maxVisibleToasts: 5\n});\nfunction GlobalToastRegion(props) {\n  // Subscribe to it.\n  let state = useToastQueue(toastQueue);\n  // Render toast region.\n  return state.visibleToasts.length > 0\n    ? createPortal(<ToastRegion {...props} state={state} />, document.body)\n    : null;\n}\n\n// Render it somewhere in your app.\n<GlobalToastRegion />\n```\n\n```\nimport {ToastQueue, useToastQueue} from 'react-stately';\nimport {createPortal} from 'react-dom';\n\n// Create a global toast queue.\nconst toastQueue = new ToastQueue({\n  maxVisibleToasts: 5\n});\nfunction GlobalToastRegion(props) {\n  // Subscribe to it.\n  let state = useToastQueue(toastQueue);\n  // Render toast region.\n  return state.visibleToasts.length > 0\n    ? createPortal(\n      <ToastRegion {...props} state={state} />,\n      document.body\n    )\n    : null;\n}\n\n// Render it somewhere in your app.\n<GlobalToastRegion />\n```\n\n```\nimport {\n  ToastQueue,\n  useToastQueue\n} from 'react-stately';\nimport {createPortal} from 'react-dom';\n\n// Create a global toast queue.\nconst toastQueue =\n  new ToastQueue({\n    maxVisibleToasts: 5\n  });\nfunction GlobalToastRegion(\n  props\n) {\n  // Subscribe to it.\n  let state =\n    useToastQueue(\n      toastQueue\n    );\n  // Render toast region.\n  return state\n      .visibleToasts\n      .length > 0\n    ? createPortal(\n      <ToastRegion\n        {...props}\n        state={state}\n      />,\n      document.body\n    )\n    : null;\n}\n\n// Render it somewhere in your app.\n<GlobalToastRegion />\n```\n\nNow you can queue a toast from anywhere:\n\n```\n<Button onPress={() => toastQueue.add('Toast is done!')}>Show toast</Button>\n```\n\n```\n<Button onPress={() => toastQueue.add('Toast is done!')}>\n  Show toast\n</Button>\n```\n\n```\n<Button\n  onPress={() =>\n    toastQueue.add(\n      'Toast is done!'\n    )}\n>\n  Show toast\n</Button>\n```\n\n### TypeScript[#](#typescript)\n\nA `ToastQueue` and `useToastState` use a generic type to represent toast content. The examples so far have used strings, but you can type this however you want to enable passing custom objects or options. This example uses a custom object to support toasts with both a title and description.\n\n```\nimport type {QueuedToast} from 'react-stately';\n\ninterface MyToast {\n  title: string;\n  description: string;\n}\nfunction ToastProvider() {\n  let state = useToastState<MyToast>();\n  // ...\n}\n\ninterface ToastProps {\n  toast: QueuedToast<MyToast>;}\n\nfunction Toast(props: ToastProps) {\n  // ...\n\n  let { toastProps, titleProps, descriptionProps, closeButtonProps } = useToast(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <div {...toastProps} ref={ref} className=\"toast\">\n      <div>\n        <div {...titleProps}>{props.toast.content.title}</div>\n        <div {...descriptionProps}>{props.toast.content.description}</div>      </div>\n      <Button {...closeButtonProps}>x</Button>\n    </div>\n  );\n}\n\n// Queuing a toast\nstate.add({ title: 'Success!', description: 'Toast is done.' });\n```\n\n```\nimport type {QueuedToast} from 'react-stately';\n\ninterface MyToast {\n  title: string;\n  description: string;\n}\nfunction ToastProvider() {\n  let state = useToastState<MyToast>();\n  // ...\n}\n\ninterface ToastProps {\n  toast: QueuedToast<MyToast>;}\n\nfunction Toast(props: ToastProps) {\n  // ...\n\n  let {\n    toastProps,\n    titleProps,\n    descriptionProps,\n    closeButtonProps\n  } = useToast(props, state, ref);\n\n  return (\n    <div {...toastProps} ref={ref} className=\"toast\">\n      <div>\n        <div {...titleProps}>\n          {props.toast.content.title}\n        </div>\n        <div {...descriptionProps}>\n          {props.toast.content.description}\n        </div>      </div>\n      <Button {...closeButtonProps}>x</Button>\n    </div>\n  );\n}\n\n// Queuing a toast\nstate.add({\n  title: 'Success!',\n  description: 'Toast is done.'\n});\n```\n\n```\nimport type {QueuedToast} from 'react-stately';\n\ninterface MyToast {\n  title: string;\n  description: string;\n}\nfunction ToastProvider() {\n  let state =\n    useToastState<\n      MyToast\n    >();\n  // ...\n}\n\ninterface ToastProps {\n  toast: QueuedToast<\n    MyToast\n  >;}\n\nfunction Toast(\n  props: ToastProps\n) {\n  // ...\n\n  let {\n    toastProps,\n    titleProps,\n    descriptionProps,\n    closeButtonProps\n  } = useToast(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <div\n      {...toastProps}\n      ref={ref}\n      className=\"toast\"\n    >\n      <div>\n        <div\n          {...titleProps}\n        >\n          {props.toast\n            .content\n            .title}\n        </div>\n        <div\n          {...descriptionProps}\n        >\n          {props.toast\n            .content\n            .description}\n        </div>      </div>\n      <Button\n        {...closeButtonProps}\n      >\n        x\n      </Button>\n    </div>\n  );\n}\n\n// Queuing a toast\nstate.add({\n  title: 'Success!',\n  description:\n    'Toast is done.'\n});\n```\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `aria-label` | `string` | `\"Notifications\"` | An accessibility label for the toast region. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `visibleToasts` | `QueuedToast<T>[]` | The visible toasts. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `add( (content: T, , options?: ToastOptions )): string` | Adds a new toast to the queue. |\n| `close( (key: string )): void` | Closes a toast. |\n| `pauseAll(): void` | Pauses the timers for all visible toasts. |\n| `resumeAll(): void` | Resumes the timers for all visible toasts. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `onClose` | `() => void` | Handler that is called when the toast is closed, either by the user or after a timeout. |\n| `timeout` | `number` | A timeout to automatically close the toast after, in milliseconds. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `content` | `T` | The content of the toast. |\n| `key` | `string` | A unique key for the toast. |\n| `timer` | `Timer` | A timer for the toast, if a timeout was set. |\n| `onClose` | `() => void` | Handler that is called when the toast is closed, either by the user or after a timeout. |\n| `timeout` | `number` | A timeout to automatically close the toast after, in milliseconds. |\n\n| Method | Description |\n| --- | --- |\n| `constructor( (callback: () => void, , delay: number )): void` |  |\n| `reset( (delay: number )): void` |  |\n| `pause(): void` |  |\n| `resume(): void` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `current` | `T` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `regionProps` | `DOMAttributes` | Props for the landmark region element. |\n\nAll DOM attributes supported across both HTML and SVG elements.\n\n**Extends**: `AriaAttributes, ReactDOMAttributes`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `id` | `string |\u00c2\u00a0undefined` |  |\n| `role` | `AriaRole |\u00c2\u00a0undefined` |  |\n| `tabIndex` | `number |\u00c2\u00a0undefined` |  |\n| `style` | `CSSProperties |\u00c2\u00a0undefined` |  |\n| `className` | `string |\u00c2\u00a0undefined` |  |\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `toast` | `QueuedToast<T>` | The toast object. |\n| `aria-label` | `string` | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `toastProps` | `DOMAttributes` | Props for the toast container, non-modal dialog element. |\n| `contentProps` | `DOMAttributes` | Props for the toast content alert message. |\n| `titleProps` | `DOMAttributes` | Props for the toast title element. |\n| `descriptionProps` | `DOMAttributes` | Props for the toast description element, if any. |\n| `closeButtonProps` | `AriaButtonProps` | Props for the toast close button. |\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isDisabled` | `boolean` | \u00e2\u0080\u0094 | Whether the button is disabled. |\n| `children` | `ReactNode` | \u00e2\u0080\u0094 | The content to display in the button. |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element should receive focus on render. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `href` | `string` | \u00e2\u0080\u0094 | A URL to link to if elementType=\"a\". |\n| `target` | `string` | \u00e2\u0080\u0094 | The target window for the link. |\n| `rel` | `string` | \u00e2\u0080\u0094 | The relationship between the linked resource and the current page. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel). |\n| `elementType` | `ElementType |\u00c2\u00a0JSXElementConstructor<any>` | `'button'` | The HTML element or React element used to render the button, e.g. 'div', 'a', or `RouterLink`. |\n| `aria-disabled` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element is disabled to users of assistive technology. |\n| `aria-expanded` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed. |\n| `aria-haspopup` | `boolean |\u00c2\u00a0'menu' |\u00c2\u00a0'listbox' |\u00c2\u00a0'tree' |\u00c2\u00a0'grid' |\u00c2\u00a0'dialog' |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) whose contents or presence are controlled by the current element. |\n| `aria-pressed` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'mixed'` | \u00e2\u0080\u0094 | Indicates the current \"pressed\" state of toggle buttons. |\n| `aria-current` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'page' |\u00c2\u00a0'step' |\u00c2\u00a0'location' |\u00c2\u00a0'date' |\u00c2\u00a0'time'` | \u00e2\u0080\u0094 | Indicates whether this element represents the current item within a container or set of related elements. |\n| `type` | `'button' |\u00c2\u00a0'submit' |\u00c2\u00a0'reset'` | `'button'` | The behavior of the button when used in an HTML form. |\n| `preventFocusOnPress` | `boolean` | \u00e2\u0080\u0094 | Whether to prevent focus from moving to the button when pressing it.  Caution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided, such as ComboBox's MenuTrigger or a NumberField's increment/decrement control. |\n| `form` | `string` | \u00e2\u0080\u0094 | The `<form>` element to associate the button with. The value of this attribute must be the id of a `<form>` in the same document. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/button#form). |\n| `formAction` | `string` | \u00e2\u0080\u0094 | The URL that processes the information submitted by the button. Overrides the action attribute of the button's form owner. |\n| `formEncType` | `string` | \u00e2\u0080\u0094 | Indicates how to encode the form data that is submitted. |\n| `formMethod` | `string` | \u00e2\u0080\u0094 | Indicates the HTTP method used to submit the form. |\n| `formNoValidate` | `boolean` | \u00e2\u0080\u0094 | Indicates that the form is not to be validated when it is submitted. |\n| `formTarget` | `string` | \u00e2\u0080\u0094 | Overrides the target attribute of the button's form owner. |\n| `name` | `string` | \u00e2\u0080\u0094 | Submitted as a pair with the button's value as part of the form data. |\n| `value` | `string` | \u00e2\u0080\u0094 | The value associated with the button's name when it's submitted with the form data. |\n| `excludeFromTabOrder` | `boolean` | \u00e2\u0080\u0094 | Whether to exclude the element from the sequential tab order. If true, the element will not be focusable via the keyboard by tabbing. This should be avoided except in rare scenarios where an alternative means of accessing the element or its functionality via the keyboard is available. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\n`BaseEvent<ReactKeyboardEvent<any>>`\n\n`SyntheticEvent &\u00c2\u00a0{\n\nstopPropagation: () => void,\n\ncontinuePropagation: () => void\n\n}`\n\nProvides the behavior and accessibility implementation for a toast region containing one or more toasts.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\n\n`useToastRegion<T>(\nprops: AriaToastRegionProps,\nstate: ToastState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ToastRegionAria`\n\nProvides the behavior and accessibility implementation for a toast component.\nToasts display brief, temporary notifications of actions, errors, or other events in an application.\n\n`useToast<T>(\nprops: AriaToastProps<T>,\nstate: ToastState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ToastAria`\n\nProvides state management for a toast queue. Toasts display brief, temporary notifications\nof actions, errors, or other events in an application.\n\n`useToastState<T>(\n(props: ToastStateProps\n)): ToastState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `maxVisibleToasts` | `number` | The maximum number of toasts to display at a time. |\n| `wrapUpdate` | `( (fn: () => void, , action: ToastAction )) => void` | Function to wrap updates in (i.e. document.startViewTransition()). |\n\n`'add'\n|\u00c2\u00a0'remove'\n|\u00c2\u00a0'clear'`\n\nA ToastQueue manages the order of toasts.\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `visibleToasts` | `QueuedToast<T>[]` | The currently visible toasts. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `constructor( (options?: ToastStateProps )): void` |  |\n| `subscribe( (fn: () => void )): () => void` | Subscribes to updates to the visible toasts. |\n| `add( (content: T, , options: ToastOptions )): string` | Adds a new toast to the queue. |\n| `close( (key: string )): void` | Closes a toast. |\n| `pauseAll(): void` | Pauses the timers for all visible toasts. |\n| `resumeAll(): void` | Resumes the timers for all visible toasts. |\n| `clear(): void` |  |\n\nSubscribes to a provided toast queue and provides methods to update it.\n\n`useToastQueue<T>(\n(queue: ToastQueue<T>\n)): ToastState<T>`",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:38:45.026581+00:00",
  "content_length": 30421,
  "content_hash": "3577d1c32ef386b0"
}