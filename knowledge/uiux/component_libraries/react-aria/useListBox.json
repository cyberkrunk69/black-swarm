{
  "id": "react-aria__react-aria_useListBox_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useListBox.html",
  "title": "useListBox",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseListBox\nProvides the behavior and accessibility implementation for a listbox component.\nA listbox displays a list of options and allows a user to select one or more of them.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useListBox, useOption, useListBoxSection}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseListBox\n<\nT\n>\n(\nprops\n:\nAriaListBoxOptions\n<\nT\n>\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nListBoxAria\nuseOption\n<\nT\n>\n(\nprops\n:\nAriaOptionProps\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nOptionAria\nuseListBoxSection\n(\n(\nprops\n:\nAriaListBoxSectionProps\n)\n)\n:\nListBoxSectionAria\nFeatures\n#\nA listbox can be built using the\n<select>\nand\n<option>\nHTML elements, but this is\nnot possible to style consistently cross browser.\nuseListBox\nhelps achieve accessible\nlistbox components that can be styled as needed.\nNote:\nuseListBox\nonly handles the list itself. For a dropdown similar to a\n<select>\n, see\nuseSelect\n.\nExposed to assistive technology as a\nlistbox\nusing ARIA\nSupport for single, multiple, or no selection\nSupport for disabled items\nSupport for sections\nLabeling support for accessibility\nSupport for mouse, touch, and keyboard interactions\nTab stop focus management\nKeyboard navigation support including arrow keys, home/end, page up/down, select all, and clear\nAutomatic scrolling support during keyboard navigation\nTypeahead to allow focusing options by typing text\nSupport for use with virtualized lists\nAnatomy\n#\nA listbox consists of a container element, with a list of options or groups inside.\nuseListBox\n,\nuseOption\n, and\nuseListBoxSection\nhandle exposing this to assistive\ntechnology using ARIA, along with handling keyboard, mouse, and interactions to support\nselection and focus behavior.\nuseListBox\nreturns props that you should spread onto the list container element,\nalong with props for an optional visual label:\nName\nType\nDescription\nlistBoxProps\nDOMAttributes\nProps for the listbox element.\nlabelProps\nDOMAttributes\nProps for the listbox's visual label element (if any).\nuseOption\nreturns props for an individual option and its children, along with states you can use for styling:\nName\nType\nDescription\noptionProps\nDOMAttributes\nProps for the option element.\nlabelProps\nDOMAttributes\nProps for the main text element inside the option.\ndescriptionProps\nDOMAttributes\nProps for the description text element inside the option, if any.\nisFocused\nboolean\nWhether the option is currently focused.\nisFocusVisible\nboolean\nWhether the option is keyboard focused.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisSelected\nboolean\nWhether the item is currently selected.\nisDisabled\nboolean\nWhether the item is non-interactive, i.e. both selection and actions are disabled and the item may\nnot be focused. Dependent on\ndisabledKeys\nand\ndisabledBehavior\n.\nallowsSelection\nboolean\nWhether the item may be selected, dependent on\nselectionMode\n,\ndisabledKeys\n, and\ndisabledBehavior\n.\nhasAction\nboolean\nWhether the item has an action, dependent on\nonAction\n,\ndisabledKeys\n,\nand\ndisabledBehavior\n. It may also change depending on the current selection state\nof the list (e.g. when selection is primary). This can be used to enable or disable hover\nstyles or other visual indications of interactivity.\nuseListBoxSection\nreturns props for a section:\nName\nType\nDescription\nitemProps\nDOMAttributes\nProps for the wrapper list item.\nheadingProps\nDOMAttributes\nProps for the heading element, if any.\ngroupProps\nDOMAttributes\nProps for the group element.\nState is managed by the\nuseListState\nhook from\n@react-stately/list\n. The state object should be passed as an option to\neach of the above hooks.\nIf a listbox, options, or group does not have a visible label, an\naria-label\nor\naria-labelledby\nprop must be passed instead to identify the element to assistive technology.\nState management\n#\nuseListBox\nrequires knowledge of the options in the listbox in order to handle keyboard\nnavigation and other interactions. It does this using\nthe\nCollection\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut\nuseListState\nfrom\n@react-stately/list\nimplements a JSX based interface for building collections instead.\nSee\nCollection Components\nfor more information.\nIn addition,\nuseListState\nmanages the state necessary for multiple selection and exposes\na\nSelectionManager\n,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see\nSelection\n.\nExample\n#\nThis example uses HTML\n<ul>\nand\n<li>\nelements to represent the list, and applies\nprops from\nuseListBox\nand\nuseOption\n.\nFor each item in the collection in state, either an\nOption\nor\nListBoxSection\n(defined\nbelow\n)\nis rendered according to the item's\ntype\nproperty.\nimport\ntype\n{\nAriaListBoxProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseListBox\n,\nuseOption\n}\nfrom\n'react-aria'\n;\nfunction\nListBox\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaListBoxProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\n// Get props for the listbox element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nlistBoxProps\n,\nlabelProps\n}\n=\nuseListBox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\ndiv\n{\n...\nlabelProps\n}\n>\n{\nprops\n.\nlabel\n}\n<\n/\ndiv\n>\n<\nul\n{\n...\nlistBoxProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n<\nListBoxSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n:\n<\nOption\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\n>\n)\n;\n}\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the option element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Determine whether we should show a keyboard\n// focus ring for accessibility\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\n>\nLeft\n<\n/\nItem\n>\n<\nItem\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\n>\nRight\n<\n/\nItem\n>\n<\n/\nListBox\n>\nimport\ntype\n{\nAriaListBoxProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseListBox\n,\nuseOption\n}\nfrom\n'react-aria'\n;\nfunction\nListBox\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaListBoxProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\n// Get props for the listbox element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nlistBoxProps\n,\nlabelProps\n}\n=\nuseListBox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\ndiv\n{\n...\nlabelProps\n}\n>\n{\nprops\n.\nlabel\n}\n<\n/\ndiv\n>\n<\nul\n{\n...\nlistBoxProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n(\n<\nListBoxSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nOption\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n)\n}\n<\n/\nul\n>\n<\n/\n>\n)\n;\n}\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the option element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Determine whether we should show a keyboard\n// focus ring for accessibility\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\n>\nLeft\n<\n/\nItem\n>\n<\nItem\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\n>\nRight\n<\n/\nItem\n>\n<\n/\nListBox\n>\nimport\ntype\n{\nAriaListBoxProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseListState\n}\nfrom\n'react-stately'\n;\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseListBox\n,\nuseOption\n}\nfrom\n'react-aria'\n;\nfunction\nListBox\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaListBoxProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseListState\n(\nprops\n)\n;\n// Get props for the listbox element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nlistBoxProps\n,\nlabelProps\n}\n=\nuseListBox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\ndiv\n{\n...\nlabelProps\n}\n>\n{\nprops\n.\nlabel\n}\n<\n/\ndiv\n>\n<\nul\n{\n...\nlistBoxProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n(\n<\nListBoxSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nOption\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n)\n}\n<\n/\nul\n>\n<\n/\n>\n)\n;\n}\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the option element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Determine whether we should show a keyboard\n// focus ring for accessibility\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\n>\nLeft\n<\n/\nItem\n>\n<\nItem\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\n>\nRight\n<\n/\nItem\n>\n<\n/\nListBox\n>\nShow CSS\n[\nrole\n=\nlistbox\n] {\npadding\n:\n0\n;\nmargin\n:\n5\npx\n0\n;\nlist-style\n:\nnone;\nborder\n:\n1\npx\nsolid gray;\nmax-width\n:\n250\npx\n;\nmax-height\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n[\nrole\n=\noption\n] {\ndisplay\n:\nblock;\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ncolor\n:\ninherit;\n&\n[\ndata-focus-visible\n=\ntrue\n] {\noutline\n:\n2\npx\nsolid orange;\n  }\n&\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nblueviolet;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\n#\naaa\n;\n  }\n}\n[\nrole\n=\nlistbox\n] {\npadding\n:\n0\n;\nmargin\n:\n5\npx\n0\n;\nlist-style\n:\nnone;\nborder\n:\n1\npx\nsolid gray;\nmax-width\n:\n250\npx\n;\nmax-height\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n[\nrole\n=\noption\n] {\ndisplay\n:\nblock;\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ncolor\n:\ninherit;\n&\n[\ndata-focus-visible\n=\ntrue\n] {\noutline\n:\n2\npx\nsolid orange;\n  }\n&\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nblueviolet;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\n#\naaa\n;\n  }\n}\n[\nrole\n=\nlistbox\n] {\npadding\n:\n0\n;\nmargin\n:\n5\npx\n0\n;\nlist-style\n:\nnone;\nborder\n:\n1\npx\nsolid gray;\nmax-width\n:\n250\npx\n;\nmax-height\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n[\nrole\n=\noption\n] {\ndisplay\n:\nblock;\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ncolor\n:\ninherit;\n&\n[\ndata-focus-visible\n=\ntrue\n] {\noutline\n:\n2\npx\nsolid orange;\n  }\n&\n[\naria-selected\n=\ntrue\n] {\nbackground\n:\nblueviolet;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\n#\naaa\n;\n  }\n}\nDynamic collections\n#\nListBox\nfollows the\nCollection Components API\n, accepting both static and dynamic collections.\nThe example above shows static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,\nas shown below, can be used when the options come from an external data source such as an API call, or update over time.\nAs seen below, an iterable list of options is passed to the ListBox using the\nitems\nprop. Each item accepts a\nkey\nprop, which\nis passed to the\nonSelectionChange\nhandler to identify the selected item. Alternatively, if the item objects contain an\nid\nproperty,\nas shown in the example below, then this is used automatically and a\nkey\nprop is not required.\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Aardvark'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Cat'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Dog'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Penguin'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Snake'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Turtle'\n}\n,\n{\nid\n:\n9\n,\nname\n:\n'Wombat'\n}\n]\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Animals\"\nitems\n=\n{\noptions\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nListBox\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Aardvark'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Cat'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Dog'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Penguin'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Snake'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Turtle'\n}\n,\n{\nid\n:\n9\n,\nname\n:\n'Wombat'\n}\n]\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Animals\"\nitems\n=\n{\noptions\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nListBox\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Aardvark'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Cat'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Dog'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Penguin'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Snake'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Turtle'\n}\n,\n{\nid\n:\n9\n,\nname\n:\n'Wombat'\n}\n]\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Animals\"\nitems\n=\n{\noptions\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nListBox\n>\n)\n;\n}\nSelection\n#\nListBox supports multiple selection modes. By default, selection is disabled, however this can be changed using the\nselectionMode\nprop.\nUse\ndefaultSelectedKeys\nto provide a default set of selected items (uncontrolled) and\nselectedKeys\nto set the selected items (controlled). The value of the selected keys must match the\nkey\nprop of the items.\nSee the\nreact-stately\nSelection docs\nfor more details.\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'cheese'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\np\n>\nCurrent selection (controlled):\n{\n' '\n}\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'cheese'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\np\n>\nCurrent selection (controlled):\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'cheese'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\np\n>\nCurrent selection\n        (controlled):\n{\n' '\n}\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nSelection behavior\n#\nBy default,\nuseListBox\nuses the\n\"toggle\"\nselection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the\nSpace\nor\nEnter\nkeys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection.\nWhen\nselectionBehavior\nis set to\n\"replace\"\n, clicking a row with the mouse replaces the selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as\nCtrl\n,\nCmd\n, and\nShift\ncan be used. On touch screen devices, selection always behaves as toggle since modifier keys may not be available.\nThese selection behaviors are defined in\nAria Practices\n.\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\nSections\n#\nListBox supports sections with separators and headings in order to group options. Sections can be used by wrapping groups of Items in a\nSection\ncomponent. Each\nSection\ntakes a\ntitle\nand\nkey\nprop.\nTo implement sections, implement the\nListBoxSection\ncomponent referenced above\nusing the\nuseListBoxSection\nhook. It will include four extra elements:\nan\n<li>\nbetween the sections to represent the separator, an\n<li>\nto contain the heading\n<span>\nelement, and a\n<ul>\nto contain the child items. This structure is necessary to ensure HTML semantics\nare correct.\nimport\n{\nuseListBoxSection\n}\nfrom\n'react-aria'\n;\nfunction\nListBoxSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseListBoxSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\n// If the section is not the first, add a separator element to provide visual separation.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\nrole\n=\n\"presentation\"\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nOption\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nimport\n{\nuseListBoxSection\n}\nfrom\n'react-aria'\n;\nfunction\nListBoxSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseListBoxSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\n// If the section is not the first, add a separator element to provide visual separation.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\nrole\n=\n\"presentation\"\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nOption\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nimport\n{\nuseListBoxSection\n}\nfrom\n'react-aria'\n;\nfunction\nListBoxSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseListBoxSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\n// If the section is not the first, add a separator element to provide visual separation.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\nrole\n=\n\"presentation\"\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nOption\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nStatic items\n#\nWith this in place, we can now render a static ListBox with multiple sections:\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\n>\n<\nSection\ntitle\n=\n\"Veggies\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"onion\"\n>\nOnion\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Protein\"\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tofu\"\n>\nTofu\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Condiments\"\n>\n<\nItem\nkey\n=\n\"mayo\"\n>\nMayonaise\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"mustard\"\n>\nMustard\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ranch\"\n>\nRanch\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nListBox\n>\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\n>\n<\nSection\ntitle\n=\n\"Veggies\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"onion\"\n>\nOnion\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Protein\"\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tofu\"\n>\nTofu\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Condiments\"\n>\n<\nItem\nkey\n=\n\"mayo\"\n>\nMayonaise\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"mustard\"\n>\nMustard\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ranch\"\n>\nRanch\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nListBox\n>\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\n>\n<\nSection\ntitle\n=\n\"Veggies\"\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"onion\"\n>\nOnion\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Protein\"\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tofu\"\n>\nTofu\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Condiments\"\n>\n<\nItem\nkey\n=\n\"mayo\"\n>\nMayonaise\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"mustard\"\n>\nMustard\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ranch\"\n>\nRanch\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nListBox\n>\nDynamic items\n#\nThe above example shows sections with static items. Sections can also be populated from a hierarchical data structure.\nSimilarly to the props on ListBox,\n<Section>\ntakes an array of data using the\nitems\nprop.\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nname\n:\n'Australian'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Platypus'\n}\n]\n}\n,\n{\nname\n:\n'American'\n,\nchildren\n:\n[\n{\nid\n:\n6\n,\nname\n:\n'Bald Eagle'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Bison'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Skunk'\n}\n]\n}\n]\n;\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n)\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick an animal\"\nitems\n=\n{\noptions\n}\nselectedKeys\n=\n{\nselected\n}\nselectionMode\n=\n\"single\"\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\nitem\n=>\n(\n<\nSection\nkey\n=\n{\nitem\n.\nname\n}\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nListBox\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nname\n:\n'Australian'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Platypus'\n}\n]\n}\n,\n{\nname\n:\n'American'\n,\nchildren\n:\n[\n{\nid\n:\n6\n,\nname\n:\n'Bald Eagle'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Bison'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Skunk'\n}\n]\n}\n]\n;\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n)\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick an animal\"\nitems\n=\n{\noptions\n}\nselectedKeys\n=\n{\nselected\n}\nselectionMode\n=\n\"single\"\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nSection\nkey\n=\n{\nitem\n.\nname\n}\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nListBox\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\noptions\n=\n[\n{\nname\n:\n'Australian'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'Koala'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Kangaroo'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Platypus'\n}\n]\n}\n,\n{\nname\n:\n'American'\n,\nchildren\n:\n[\n{\nid\n:\n6\n,\nname\n:\n'Bald Eagle'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Bison'\n}\n,\n{\nid\n:\n8\n,\nname\n:\n'Skunk'\n}\n]\n}\n]\n;\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n)\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick an animal\"\nitems\n=\n{\noptions\n}\nselectedKeys\n=\n{\nselected\n}\nselectionMode\n=\n\"single\"\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nSection\nkey\n=\n{\nitem\n.\nname\n}\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nListBox\n>\n)\n;\n}\nAccessibility\n#\nSections without a\ntitle\nmust provide an\naria-label\nfor accessibility.\nComplex options\n#\nBy default, options that only contain text will be labeled by the contents of the option.\nFor options that have more complex content (e.g. icons, multiple lines of text, etc.), use\nlabelProps\nand\ndescriptionProps\nfrom\nuseOption\nas needed to apply to the main text element of the option and its description. This improves screen\nreader announcement.\nNOTE: listbox options cannot contain interactive content (e.g. buttons, checkboxes, etc.).\nFor these cases, see\nuseGridList\ninstead.\nTo implement this, we'll update the\nOption\ncomponent to apply the ARIA properties\nreturned by\nuseOption\nto the appropriate\nelements. In this example, we'll pull them out of\nprops.children\nand use\nReact.cloneElement\nto apply the props, but you may want to use a more robust approach (e.g. context).\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n,\nlabelProps\n,\ndescriptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\n// Pull out the two expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Text alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\ntextValue\n=\n\"Align Left\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Left\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text to the left\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Center\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Center\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text center\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Right\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Right\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text to the right\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\n/\nListBox\n>\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n,\nlabelProps\n,\ndescriptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\n// Pull out the two expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Text alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\ntextValue\n=\n\"Align Left\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Left\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text to the left\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Center\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Center\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text center\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Right\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Right\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the selected text to the right\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\n/\nListBox\n>\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n,\nlabelProps\n,\ndescriptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\n// Pull out the two expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nListBox\nlabel\n=\n\"Text alignment\"\nselectionMode\n=\n\"single\"\n>\n<\nItem\ntextValue\n=\n\"Align Left\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Left\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the\n      selected text to\n      the left\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Center\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Center\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the\n      selected text\n      center\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Align Right\"\n>\n<\ndiv\n>\n<\nstrong\n>\nAlign Right\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nAlign the\n      selected text to\n      the right\n<\n/\ndiv\n>\n<\n/\nItem\n>\n<\n/\nListBox\n>\nAsynchronous loading\n#\nThis example uses the\nuseAsyncList\nhook to handle asynchronous loading\nof data from a server. You may additionally want to display a spinner to indicate the loading\nstate to the user, or support features like infinite scroll to load more data.\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nPokemon\n{\nname\n:\nstring\n;\n}\nfunction\nAsyncLoadingExample\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nPokemon\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://pokeapi.co/api/v2/pokemon`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick a Pokemon\"\nitems\n=\n{\nlist\n.\nitems\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nListBox\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nPokemon\n{\nname\n:\nstring\n;\n}\nfunction\nAsyncLoadingExample\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nPokemon\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://pokeapi.co/api/v2/pokemon`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick a Pokemon\"\nitems\n=\n{\nlist\n.\nitems\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nListBox\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nPokemon\n{\nname\n:\nstring\n;\n}\nfunction\nAsyncLoadingExample\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nPokemon\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://pokeapi.co/api/v2/pokemon`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nListBox\nlabel\n=\n\"Pick a Pokemon\"\nitems\n=\n{\nlist\n.\nitems\n}\nselectionMode\n=\n\"single\"\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nListBox\n>\n)\n;\n}\nLinks\n#\nBy default, interacting with an item in a ListBox triggers\nonSelectionChange\n. Alternatively, items may be links to another page or website. This can be achieved by passing the\nhref\nprop to the\n<Item>\ncomponent.\nThis example shows how to update the\nOption\ncomponent with support for rendering an\n<a>\nelement if an\nhref\nprop is passed to the item. Note that you'll also need to render the\nListBox\nas a\n<div>\ninstead of a\n<ul>\n, since an\n<a>\ninside a\n<ul>\nis not valid HTML.\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nListBox\naria-label\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nListBox\naria-label\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\nfunction\nOption\n(\n{\nitem\n,\nstate\n}\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\noptionProps\n}\n=\nuseOption\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmergeProps\n(\noptionProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\ndata-focus-visible\n=\n{\nisFocusVisible\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nListBox\naria-label\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\nBy default, link items in a ListBox are not selectable, and only perform navigation when the user interacts with them. However, with the \"replace\"\nselection behavior\n, items will be selected when single clicking or pressing the\nSpace\nkey, and navigate to the link when double clicking or pressing the\nEnter\nkey.\n<\nListBox\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\naria-label\n=\n\"Links\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nListBox\n>\nClient side routing\n#\nThe\n<Item>\ncomponent works with frameworks and client side routers like\nNext.js\nand\nReact Router\n. As with other React Aria components that support links, this works via the\nRouterProvider\ncomponent at the root of your app. See the\nframework setup guide\nto learn how to set this up.\nDisabled items\n#\nuseListBox\nsupports marking items as disabled using the\ndisabledKeys\nprop. Each key in this list\ncorresponds with the\nkey\nprop passed to the\nItem\ncomponent, or automatically derived from the values passed\nto the\nitems\nprop. See\nCollections\nfor more details.\nDisabled items are not focusable, selectable, or keyboard navigable. The\nisDisabled\nproperty returned by\nuseOption\ncan be used to style the item appropriately.\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n'tuna'\n]\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n'tuna'\n]\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\n<\nListBox\nlabel\n=\n\"Choose sandwich contents\"\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n'tuna'\n]\n}\n>\n<\nItem\nkey\n=\n\"lettuce\"\n>\nLettuce\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tomato\"\n>\nTomato\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cheese\"\n>\nCheese\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tuna\"\n>\nTuna Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"egg\"\n>\nEgg Salad\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"ham\"\n>\nHam\n<\n/\nItem\n>\n<\n/\nListBox\n>\nInternationalization\n#\nuseListBox\nhandles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\nIntl.Collator\nfor internationalized string matching. You are responsible for localizing all labels and option\ncontent that is passed into the listbox.\nRTL\n#\nIn right-to-left languages, the listbox options should be mirrored. The text content should be\naligned to the right. Ensure that your CSS accounts for this.\nName\nType\nDefault\nDescription\nisVirtualized\nboolean\n\u00e2\u0080\u0094\nWhether the listbox uses virtual scrolling.\nkeyboardDelegate\nKeyboardDelegate\n\u00e2\u0080\u0094\nAn optional keyboard delegate implementation for type to select,\nto override the default.\nlayoutDelegate\nLayoutDelegate\n\u00e2\u0080\u0094\nA delegate object that provides layout information for items in the collection.\nBy default this uses the DOM, but this can be overridden to implement things like\nvirtualized scrolling.\nshouldUseVirtualFocus\nboolean\n\u00e2\u0080\u0094\nWhether the listbox items should use virtual focus instead of being focused directly.\nlinkBehavior\n'action'\n|\u00c2\n'selection'\n|\u00c2\n'override'\n'override'\nThe behavior of links in the collection.\n- 'action': link behaves like onAction.\n- 'selection': link follows selection interactions (e.g. if URL drives selection).\n- 'override': links override all other interactions (link items are not selectable).\nlabel\nReactNode\n\u00e2\u0080\u0094\nAn optional visual label for the listbox.\nselectionBehavior\nSelectionBehavior\n\u00e2\u0080\u0094\nHow multiple selection should behave in the collection.\nshouldSelectOnPressUp\nboolean\n\u00e2\u0080\u0094\nWhether selection should occur on press up instead of press down.\nshouldFocusOnHover\nboolean\n\u00e2\u0080\u0094\nWhether options should be focused when the user hovers over them.\nonAction\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a user performs an action on an item. The exact user event depends on\nthe collection's\nselectionBehavior\nprop and the interaction modality.\nescapeKeyBehavior\n'clearSelection'\n|\u00c2\n'none'\n'clearSelection'\nWhether pressing the escape key should clear selection in the listbox or not.\nMost experiences should not modify this option as it eliminates a keyboard user's ability to\neasily clear selection. Only use if the escape key is being handled externally or should not\ntrigger selection clearing contextually.\nautoFocus\nboolean\n|\u00c2\nFocusStrategy\n\u00e2\u0080\u0094\nWhether to auto focus the listbox or an option.\nshouldFocusWrap\nboolean\n\u00e2\u0080\u0094\nWhether focus should wrap around when the end/start is reached.\nitems\nIterable\n<\nT\n>\n\u00e2\u0080\u0094\nItem objects in the collection.\ndisabledKeys\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\nselectionMode\nSelectionMode\n\u00e2\u0080\u0094\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\n\u00e2\u0080\u0094\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the selection changes.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nMethod\nDescription\ngetKeyBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually below the given one, or\nnull\nfor none.\ngetKeyAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually above the given one, or\nnull\nfor none.\ngetKeyLeftOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the left of the given one, or\nnull\nfor none.\ngetKeyRightOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the right of the given one, or\nnull\nfor none.\ngetKeyPageBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page below the given one, or\nnull\nfor none.\ngetKeyPageAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page above the given one, or\nnull\nfor none.\ngetFirstKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the first key, or\nnull\nfor none.\ngetLastKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the last key, or\nnull\nfor none.\ngetKeyForSearch\n(\n(\nsearch\n:\nstring\n,\n,\nfromKey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the next key after\nfromKey\nthat matches the given search string, or\nnull\nfor none.\nA LayoutDelegate provides layout information for collection items.\nMethod\nDescription\ngetItemRect\n(\n(\nkey\n:\nKey\n)\n)\n:\nRect\n|\u00c2\nnull\nReturns a rectangle for the item with the given key.\ngetVisibleRect\n(\n)\n:\nRect\nReturns the visible rectangle of the collection.\ngetContentSize\n(\n)\n:\nSize\nReturns the size of the scrollable content in the collection.\ngetKeyRange\n(\n(\nfrom\n:\nKey\n,\n,\nto\n:\nKey\n)\n)\n:\nKey\n[]\nReturns a list of keys between\nfrom\nand\nto\n.\nName\nType\nDescription\nx\nnumber\ny\nnumber\nwidth\nnumber\nheight\nnumber\nName\nType\nDescription\nwidth\nnumber\nheight\nnumber\n'toggle'\n|\u00c2\n'replace'\nstring\n|\u00c2\nnumber\n'first'\n|\u00c2\n'last'\n'none'\n|\u00c2\n'single'\n|\u00c2\n'multiple'\n'all'\n|\u00c2\nSet\n<\nKey\n>\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA collection of items in the list.\ndisabledKeys\nSet\n<\nKey\n>\nA set of items that are disabled.\nselectionManager\nSelectionManager\nA selection manager to read and update multiple selection state.\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\nExtends\n:\nIterable\nProperties\nName\nType\nDescription\nsize\nnumber\nThe number of items in the collection.\nMethods\nMethod\nDescription\ngetKeys\n(\n)\n:\nIterable\n<\nKey\n>\nIterate over all keys in the collection.\ngetItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by its key.\nat\n(\n(\nidx\n:\nnumber\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by the index of its key.\ngetKeyBefore\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes before the given key in the collection.\ngetKeyAfter\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes after the given key in the collection.\ngetFirstKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the first key in the collection.\ngetLastKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the last key in the collection.\ngetChildren\n(\n(\nkey\n:\nKey\n)\n)\n:\nIterable\n<\nT\n>\nIterate over the child items of the given key.\ngetTextValue\n(\n(\nkey\n:\nKey\n)\n)\n:\nstring\nReturns a string representation of the item's contents.\nfilter\n(\n(\nfilterFn\n:\n(\n(\nnodeValue\n:\nstring\n,\n,\nnode\n:\nT\n)\n)\n=>\nboolean\n)\n)\n:\nCollection\n<\nT\n>\nFilters the collection using the given function.\nName\nType\nDescription\ntype\nstring\nThe type of item this node represents.\nkey\nKey\nA unique key for the node.\nvalue\nT\n|\u00c2\nnull\nThe object value the node was created from.\nlevel\nnumber\nThe level of depth this node is at in the hierarchy.\nhasChildNodes\nboolean\nWhether this item has children, even if not loaded yet.\nrendered\nReactNode\nThe rendered contents of this node (e.g. JSX).\ntextValue\nstring\nA string value for this node, used for features like typeahead.\nindex\nnumber\nThe index of this node within its parent.\naria-label\nstring\nAn accessibility label for this node.\nwrapper\n(\n(\nelement\n:\nReactElement\n)\n)\n=>\nReactElement\nA function that should be called to wrap the rendered node.\nparentKey\nKey\n|\u00c2\nnull\nThe key of the parent node.\nprevKey\nKey\n|\u00c2\nnull\nThe key of the node before this node.\nnextKey\nKey\n|\u00c2\nnull\nThe key of the node after this node.\nprops\nany\nAdditional properties specific to a particular node type.\nrender\n(\n(\nnode\n:\nNode\n<\nany\n>\n)\n)\n=>\nReactElement\nA function that renders this node to a React Element in the DOM.\nAn interface for reading and updating multiple selection state.\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nunknown\n>\n>\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nselectedKeys\nSet\n<\nKey\n>\nThe currently selected keys in the collection.\nrawSelection\nSelection\nThe raw selection value for the collection.\nEither 'all' for select all, or a set of keys.\nisEmpty\nboolean\nWhether the selection is empty.\nisSelectAll\nboolean\nWhether all items in the collection are selected.\nfirstSelectedKey\nKey\n|\u00c2\nnull\nlastSelectedKey\nKey\n|\u00c2\nnull\ndisabledKeys\nSet\n<\nKey\n>\ndisabledBehavior\nDisabledBehavior\nMethods\nMethod\nDescription\nconstructor\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n,\nstate\n:\nMultipleSelectionState\n,\noptions\n?\n:\nSelectionManagerOptions\n)\n:\nvoid\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchildFocusStrategy\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key.\nisSelected\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nReturns whether a key is selected.\nextendSelection\n(\n(\ntoKey\n:\nKey\n)\n)\n:\nvoid\nExtends the selection to the given key.\ntoggleSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles whether the given key is selected.\nreplaceSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nReplaces the selection with only the given key.\nsetSelectedKeys\n(\n(\nkeys\n:\nIterable\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the selection with the given keys.\nselectAll\n(\n)\n:\nvoid\nSelects all items in the collection.\nclearSelection\n(\n)\n:\nvoid\nRemoves all keys from the selection.\ntoggleSelectAll\n(\n)\n:\nvoid\nToggles between select all and an empty selection.\nselect\n(\n(\nkey\n:\nKey\n,\n,\ne\n?\n:\nPressEvent\n|\u00c2\nLongPressEvent\n|\u00c2\nPointerEvent\n)\n)\n:\nvoid\nisSelectionEqual\n(\n(\nselection\n:\nSet\n<\nKey\n>\n)\n)\n:\nboolean\nReturns whether the current selection is equal to the given selection.\ncanSelectItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisDisabled\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisLink\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\ngetItemProps\n(\n(\nkey\n:\nKey\n)\n)\n:\nany\nwithCollection\n(\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n)\n)\n:\nSelectionManager\nProperties\nName\nType\nDescription\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\nSelection\nThe currently selected keys in the collection.\ndisabledKeys\nSet\n<\nKey\n>\nThe currently disabled keys in the collection.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to selection, actions, or both.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nMethods\nMethod\nDescription\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetSelectedKeys\n(\n(\nkeys\n:\nSelection\n)\n)\n:\nvoid\nSets the selected keys in the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchild\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key, and optionally, whether the first or last child of that key should receive focus.\n'selection'\n|\u00c2\n'all'\nName\nType\nDescription\nallowsCellSelection\nboolean\nlayoutDelegate\nLayoutDelegate\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nName\nType\nDescription\ntype\n'longpressstart'\n|\u00c2\n'longpressend'\n|\u00c2\n'longpress'\nThe type of long press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nName\nType\nDescription\ncurrent\nT\nName\nType\nDescription\nlistBoxProps\nDOMAttributes\nProps for the listbox element.\nlabelProps\nDOMAttributes\nProps for the listbox's visual label element (if any).\nAll DOM attributes supported across both HTML and SVG elements.\nExtends\n:\nAriaAttributes\n,\nReactDOMAttributes\nName\nType\nDescription\nid\nstring\n|\u00c2\nundefined\nrole\nAriaRole\n|\u00c2\nundefined\ntabIndex\nnumber\n|\u00c2\nundefined\nstyle\nCSSProperties\n|\u00c2\nundefined\nclassName\nstring\n|\u00c2\nundefined\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nName\nType\nDescription\nkey\nKey\nThe unique key for the option.\naria-label\nstring\nA screen reader only label for the option.\nName\nType\nDescription\noptionProps\nDOMAttributes\nProps for the option element.\nlabelProps\nDOMAttributes\nProps for the main text element inside the option.\ndescriptionProps\nDOMAttributes\nProps for the description text element inside the option, if any.\nisFocused\nboolean\nWhether the option is currently focused.\nisFocusVisible\nboolean\nWhether the option is keyboard focused.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisSelected\nboolean\nWhether the item is currently selected.\nisDisabled\nboolean\nWhether the item is non-interactive, i.e. both selection and actions are disabled and the item may\nnot be focused. Dependent on\ndisabledKeys\nand\ndisabledBehavior\n.\nallowsSelection\nboolean\nWhether the item may be selected, dependent on\nselectionMode\n,\ndisabledKeys\n, and\ndisabledBehavior\n.\nhasAction\nboolean\nWhether the item has an action, dependent on\nonAction\n,\ndisabledKeys\n,\nand\ndisabledBehavior\n. It may also change depending on the current selection state\nof the list (e.g. when selection is primary). This can be used to enable or disable hover\nstyles or other visual indications of interactivity.\nName\nType\nDescription\nheading\nReactNode\nThe heading for the section.\naria-label\nstring\nAn accessibility label for the section. Required if\nheading\nis not present.\nName\nType\nDescription\nitemProps\nDOMAttributes\nProps for the wrapper list item.\nheadingProps\nDOMAttributes\nProps for the heading element, if any.\ngroupProps\nDOMAttributes\nProps for the group element.\nProvides state management for list-like components. Handles building a collection\nof items from props, and manages multiple selection state.\nuseListState\n<\nT\nextends\nobject\n>\n(\n(\nprops\n:\nListProps\n<\nT\n>\n)\n)\n:\nListState\n<\nT\n>\nName\nType\nDescription\nfilter\n(\n(\nnodes\n:\nIterable\n<\nNode\n<\nT\n>\n>\n)\n)\n=>\nIterable\n<\nNode\n<\nT\n>\n>\nFilter function to generate a filtered list of nodes.\nlayoutDelegate\nLayoutDelegate\nA delegate object that provides layout information for items in the collection.\nThis can be used to override the behavior of shift selection.\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA pre-constructed collection to use instead of building one from items and children.\nselectionBehavior\nSelectionBehavior\nHow multiple selection should behave in the collection.\nallowDuplicateSelectionEvents\nboolean\nWhether onSelectionChange should fire even if the new set of keys is the same as the last.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to all interactions, or only selection.\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\nHandler that is called when the selection changes.\ndisabledKeys\nIterable\n<\nKey\n>\nThe currently disabled keys in the collection (controlled).\nProvides the behavior and accessibility implementation for a listbox component.\nA listbox displays a list of options and allows a user to select one or more of them.\nuseListBox\n<\nT\n>\n(\nprops\n:\nAriaListBoxOptions\n<\nT\n>\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nListBoxAria\nProvides the behavior and accessibility implementation for an option in a listbox.\nSee\nuseListBox\nfor more details about listboxes.\nuseOption\n<\nT\n>\n(\nprops\n:\nAriaOptionProps\n,\nstate\n:\nListState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nOptionAria\nProvides the behavior and accessibility implementation for a section in a listbox.\nSee\nuseListBox\nfor more details about listboxes.\nuseListBoxSection\n(\n(\nprops\n:\nAriaListBoxSectionProps\n)\n)\n:\nListBoxSectionAria\nA RouterProvider accepts a\nnavigate\nfunction from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\nName\nType\nDescription\nnavigate\n(\n(\npath\n:\nHref\n,\n,\nrouterOptions\n:\nRouterOptions\n|\u00c2\n|\u00c2\nundefined\n)\n)\n=>\nvoid\nchildren\nReactNode\nuseHref\n(\n(\nhref\n:\nHref\n)\n)\n=>\nstring\nRouterConfig\nextends\n{\nhref\n:\nany\n}\n?\nH\n:\nstring\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with\nhref\nand\nrouterOptions\nproperties to configure your router.\nRouterConfig\nextends\n{\nrouterOptions\n:\nany\n}\n?\nO\n:\nnever",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../ListBox).\n\n# useListBox\n\nProvides the behavior and accessibility implementation for a listbox component.\nA listbox displays a list of options and allows a user to select one or more of them.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useListBox, useOption, useListBoxSection} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/listbox \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/listbox \"View package\")\n\n## API[#](#api)\n\n---\n\n`useListBox<T>(\nprops: AriaListBoxOptions<T>,\nstate: ListState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ListBoxAria`\n`useOption<T>(\nprops: AriaOptionProps,\nstate: ListState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): OptionAria`\n`useListBoxSection(\n(props: AriaListBoxSectionProps\n)): ListBoxSectionAria`\n\n## Features[#](#features)\n\n---\n\nA listbox can be built using the [<select>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select)\nand [<option>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option) HTML elements, but this is\nnot possible to style consistently cross browser. `useListBox` helps achieve accessible\nlistbox components that can be styled as needed.\n\nNote: `useListBox` only handles the list itself. For a dropdown similar to a `<select>`, see [useSelect](../Select/useSelect.html).\n\n- Exposed to assistive technology as a `listbox` using ARIA\n- Support for single, multiple, or no selection\n- Support for disabled items\n- Support for sections\n- Labeling support for accessibility\n- Support for mouse, touch, and keyboard interactions\n- Tab stop focus management\n- Keyboard navigation support including arrow keys, home/end, page up/down, select all, and clear\n- Automatic scrolling support during keyboard navigation\n- Typeahead to allow focusing options by typing text\n- Support for use with virtualized lists\n\n## Anatomy[#](#anatomy)\n\n---\n\nA listbox consists of a container element, with a list of options or groups inside.\n`useListBox`, `useOption`, and `useListBoxSection` handle exposing this to assistive\ntechnology using ARIA, along with handling keyboard, mouse, and interactions to support\nselection and focus behavior.\n\n`useListBox` returns props that you should spread onto the list container element,\nalong with props for an optional visual label:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `listBoxProps` | `DOMAttributes` | Props for the listbox element. |\n| `labelProps` | `DOMAttributes` | Props for the listbox's visual label element (if any). |\n\n`useOption` returns props for an individual option and its children, along with states you can use for styling:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `optionProps` | `DOMAttributes` | Props for the option element. |\n| `labelProps` | `DOMAttributes` | Props for the main text element inside the option. |\n| `descriptionProps` | `DOMAttributes` | Props for the description text element inside the option, if any. |\n| `isFocused` | `boolean` | Whether the option is currently focused. |\n| `isFocusVisible` | `boolean` | Whether the option is keyboard focused. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isDisabled` | `boolean` | Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may not be focused. Dependent on `disabledKeys` and `disabledBehavior`. |\n| `allowsSelection` | `boolean` | Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`. |\n| `hasAction` | `boolean` | Whether the item has an action, dependent on `onAction`, `disabledKeys`, and `disabledBehavior`. It may also change depending on the current selection state of the list (e.g. when selection is primary). This can be used to enable or disable hover styles or other visual indications of interactivity. |\n\n`useListBoxSection` returns props for a section:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `itemProps` | `DOMAttributes` | Props for the wrapper list item. |\n| `headingProps` | `DOMAttributes` | Props for the heading element, if any. |\n| `groupProps` | `DOMAttributes` | Props for the group element. |\n\nState is managed by the `useListState`\nhook from `@react-stately/list`. The state object should be passed as an option to\neach of the above hooks.\n\nIf a listbox, options, or group does not have a visible label, an `aria-label` or `aria-labelledby`\nprop must be passed instead to identify the element to assistive technology.\n\n## State management[#](#state-management)\n\n---\n\n`useListBox` requires knowledge of the options in the listbox in order to handle keyboard\nnavigation and other interactions. It does this using\nthe `Collection`\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut `useListState` from\n`@react-stately/list` implements a JSX based interface for building collections instead.\nSee [Collection Components](https://react-spectrum.adobe.com/v3/collections.html) for more information.\n\nIn addition, `useListState`\nmanages the state necessary for multiple selection and exposes\na `SelectionManager`,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see [Selection](https://react-spectrum.adobe.com/v3/selection.html).\n\n## Example[#](#example)\n\n---\n\nThis example uses HTML `<ul>` and `<li>` elements to represent the list, and applies\nprops from `useListBox`\nand `useOption`.\nFor each item in the collection in state, either an `Option` or `ListBoxSection` (defined [below](#sections))\nis rendered according to the item's `type` property.\n\n```\nimport type {AriaListBoxProps} from 'react-aria';\nimport {Item, useListState} from 'react-stately';\nimport {mergeProps, useFocusRing, useListBox, useOption} from 'react-aria';\n\nfunction ListBox<T extends object>(props: AriaListBoxProps<T>) {\n  // Create state based on the incoming props\n  let state = useListState(props);\n\n  // Get props for the listbox element\n  let ref = React.useRef(null);\n  let { listBoxProps, labelProps } = useListBox(props, state, ref);\n\n  return (\n    <>\n      <div {...labelProps}>{props.label}</div>\n      <ul {...listBoxProps} ref={ref}>\n        {[...state.collection].map((item) => (\n          item.type === 'section'\n            ? <ListBoxSection key={item.key} section={item} state={state} />\n            : <Option key={item.key} item={item} state={state} />\n        ))}\n      </ul>\n    </>\n  );\n}\n\nfunction Option({ item, state }) {\n  // Get props for the option element\n  let ref = React.useRef(null);\n  let { optionProps } = useOption({ key: item.key }, state, ref);\n\n  // Determine whether we should show a keyboard\n  // focus ring for accessibility\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <li\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {item.rendered}\n    </li>\n  );\n}\n\n<ListBox label=\"Alignment\" selectionMode=\"single\">\n  <Item>Left</Item>\n  <Item>Middle</Item>\n  <Item>Right</Item>\n</ListBox>\n```\n\n```\nimport type {AriaListBoxProps} from 'react-aria';\nimport {Item, useListState} from 'react-stately';\nimport {\n  mergeProps,\n  useFocusRing,\n  useListBox,\n  useOption\n} from 'react-aria';\n\nfunction ListBox<T extends object>(\n  props: AriaListBoxProps<T>\n) {\n  // Create state based on the incoming props\n  let state = useListState(props);\n\n  // Get props for the listbox element\n  let ref = React.useRef(null);\n  let { listBoxProps, labelProps } = useListBox(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <>\n      <div {...labelProps}>{props.label}</div>\n      <ul {...listBoxProps} ref={ref}>\n        {[...state.collection].map((item) => (\n          item.type === 'section'\n            ? (\n              <ListBoxSection\n                key={item.key}\n                section={item}\n                state={state}\n              />\n            )\n            : (\n              <Option\n                key={item.key}\n                item={item}\n                state={state}\n              />\n            )\n        ))}\n      </ul>\n    </>\n  );\n}\n\nfunction Option({ item, state }) {\n  // Get props for the option element\n  let ref = React.useRef(null);\n  let { optionProps } = useOption(\n    { key: item.key },\n    state,\n    ref\n  );\n\n  // Determine whether we should show a keyboard\n  // focus ring for accessibility\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <li\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {item.rendered}\n    </li>\n  );\n}\n\n<ListBox label=\"Alignment\" selectionMode=\"single\">\n  <Item>Left</Item>\n  <Item>Middle</Item>\n  <Item>Right</Item>\n</ListBox>\n```\n\n```\nimport type {AriaListBoxProps} from 'react-aria';\nimport {\n  Item,\n  useListState\n} from 'react-stately';\nimport {\n  mergeProps,\n  useFocusRing,\n  useListBox,\n  useOption\n} from 'react-aria';\n\nfunction ListBox<\n  T extends object\n>(\n  props:\n    AriaListBoxProps<T>\n) {\n  // Create state based on the incoming props\n  let state =\n    useListState(props);\n\n  // Get props for the listbox element\n  let ref = React.useRef(\n    null\n  );\n  let {\n    listBoxProps,\n    labelProps\n  } = useListBox(\n    props,\n    state,\n    ref\n  );\n\n  return (\n    <>\n      <div\n        {...labelProps}\n      >\n        {props.label}\n      </div>\n      <ul\n        {...listBoxProps}\n        ref={ref}\n      >\n        {[\n          ...state\n            .collection\n        ].map((item) => (\n          item.type ===\n              'section'\n            ? (\n              <ListBoxSection\n                key={item\n                  .key}\n                section={item}\n                state={state}\n              />\n            )\n            : (\n              <Option\n                key={item\n                  .key}\n                item={item}\n                state={state}\n              />\n            )\n        ))}\n      </ul>\n    </>\n  );\n}\n\nfunction Option(\n  { item, state }\n) {\n  // Get props for the option element\n  let ref = React.useRef(\n    null\n  );\n  let { optionProps } =\n    useOption(\n      { key: item.key },\n      state,\n      ref\n    );\n\n  // Determine whether we should show a keyboard\n  // focus ring for accessibility\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n\n  return (\n    <li\n      {...mergeProps(\n        optionProps,\n        focusProps\n      )}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {item.rendered}\n    </li>\n  );\n}\n\n<ListBox\n  label=\"Alignment\"\n  selectionMode=\"single\"\n>\n  <Item>Left</Item>\n  <Item>Middle</Item>\n  <Item>Right</Item>\n</ListBox>\n```\n\n Show CSS\n\n```\n[role=listbox] {\n  padding: 0;\n  margin: 5px 0;\n  list-style: none;\n  border: 1px solid gray;\n  max-width: 250px;\n  max-height: 300px;\n  overflow: auto;\n}\n\n[role=option] {\n  display: block;\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  color: inherit;\n\n  &[data-focus-visible=true] {\n    outline: 2px solid orange;\n  }\n\n  &[aria-selected=true] {\n    background: blueviolet;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: #aaa;\n  }\n}\n```\n\n```\n[role=listbox] {\n  padding: 0;\n  margin: 5px 0;\n  list-style: none;\n  border: 1px solid gray;\n  max-width: 250px;\n  max-height: 300px;\n  overflow: auto;\n}\n\n[role=option] {\n  display: block;\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  color: inherit;\n\n  &[data-focus-visible=true] {\n    outline: 2px solid orange;\n  }\n\n  &[aria-selected=true] {\n    background: blueviolet;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: #aaa;\n  }\n}\n```\n\n```\n[role=listbox] {\n  padding: 0;\n  margin: 5px 0;\n  list-style: none;\n  border: 1px solid gray;\n  max-width: 250px;\n  max-height: 300px;\n  overflow: auto;\n}\n\n[role=option] {\n  display: block;\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  color: inherit;\n\n  &[data-focus-visible=true] {\n    outline: 2px solid orange;\n  }\n\n  &[aria-selected=true] {\n    background: blueviolet;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: #aaa;\n  }\n}\n```\n\n## Dynamic collections[#](#dynamic-collections)\n\n---\n\n`ListBox` follows the [Collection Components API](https://react-spectrum.adobe.com/v3/collections.html), accepting both static and dynamic collections.\nThe example above shows static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,\nas shown below, can be used when the options come from an external data source such as an API call, or update over time.\n\nAs seen below, an iterable list of options is passed to the ListBox using the `items` prop. Each item accepts a `key` prop, which\nis passed to the `onSelectionChange` handler to identify the selected item. Alternatively, if the item objects contain an `id` property,\nas shown in the example below, then this is used automatically and a `key` prop is not required.\n\n```\nfunction Example() {\n  let options = [\n    { id: 1, name: 'Aardvark' },\n    { id: 2, name: 'Cat' },\n    { id: 3, name: 'Dog' },\n    { id: 4, name: 'Kangaroo' },\n    { id: 5, name: 'Koala' },\n    { id: 6, name: 'Penguin' },\n    { id: 7, name: 'Snake' },\n    { id: 8, name: 'Turtle' },\n    { id: 9, name: 'Wombat' }\n  ];\n\n  return (\n    <ListBox label=\"Animals\" items={options} selectionMode=\"single\">\n      {(item) => <Item>{item.name}</Item>}\n    </ListBox>\n  );\n}\n```\n\n```\nfunction Example() {\n  let options = [\n    { id: 1, name: 'Aardvark' },\n    { id: 2, name: 'Cat' },\n    { id: 3, name: 'Dog' },\n    { id: 4, name: 'Kangaroo' },\n    { id: 5, name: 'Koala' },\n    { id: 6, name: 'Penguin' },\n    { id: 7, name: 'Snake' },\n    { id: 8, name: 'Turtle' },\n    { id: 9, name: 'Wombat' }\n  ];\n\n  return (\n    <ListBox\n      label=\"Animals\"\n      items={options}\n      selectionMode=\"single\"\n    >\n      {(item) => <Item>{item.name}</Item>}\n    </ListBox>\n  );\n}\n```\n\n```\nfunction Example() {\n  let options = [\n    {\n      id: 1,\n      name: 'Aardvark'\n    },\n    {\n      id: 2,\n      name: 'Cat'\n    },\n    {\n      id: 3,\n      name: 'Dog'\n    },\n    {\n      id: 4,\n      name: 'Kangaroo'\n    },\n    {\n      id: 5,\n      name: 'Koala'\n    },\n    {\n      id: 6,\n      name: 'Penguin'\n    },\n    {\n      id: 7,\n      name: 'Snake'\n    },\n    {\n      id: 8,\n      name: 'Turtle'\n    },\n    {\n      id: 9,\n      name: 'Wombat'\n    }\n  ];\n\n  return (\n    <ListBox\n      label=\"Animals\"\n      items={options}\n      selectionMode=\"single\"\n    >\n      {(item) => (\n        <Item>\n          {item.name}\n        </Item>\n      )}\n    </ListBox>\n  );\n}\n```\n\n## Selection[#](#selection)\n\n---\n\nListBox supports multiple selection modes. By default, selection is disabled, however this can be changed using the `selectionMode` prop.\nUse `defaultSelectedKeys` to provide a default set of selected items (uncontrolled) and `selectedKeys` to set the selected items (controlled). The value of the selected keys must match the `key` prop of the items.\nSee the `react-stately` [Selection docs](https://react-spectrum.adobe.com/v3/selection.html) for more details.\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(new Set(['cheese']));\n\n  return (\n    <>\n      <ListBox\n        label=\"Choose sandwich contents\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"lettuce\">Lettuce</Item>\n        <Item key=\"tomato\">Tomato</Item>\n        <Item key=\"cheese\">Cheese</Item>\n        <Item key=\"tuna\">Tuna Salad</Item>\n        <Item key=\"egg\">Egg Salad</Item>\n        <Item key=\"ham\">Ham</Item>\n      </ListBox>\n      <p>\n        Current selection (controlled):{' '}\n        {selected === 'all' ? 'all' : [...selected].join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(\n    new Set(['cheese'])\n  );\n\n  return (\n    <>\n      <ListBox\n        label=\"Choose sandwich contents\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"lettuce\">Lettuce</Item>\n        <Item key=\"tomato\">Tomato</Item>\n        <Item key=\"cheese\">Cheese</Item>\n        <Item key=\"tuna\">Tuna Salad</Item>\n        <Item key=\"egg\">Egg Salad</Item>\n        <Item key=\"ham\">Ham</Item>\n      </ListBox>\n      <p>\n        Current selection (controlled): {selected === 'all'\n          ? 'all'\n          : [...selected].join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [\n    selected,\n    setSelected\n  ] = React.useState<\n    Selection\n  >(new Set(['cheese']));\n\n  return (\n    <>\n      <ListBox\n        label=\"Choose sandwich contents\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"lettuce\">\n          Lettuce\n        </Item>\n        <Item key=\"tomato\">\n          Tomato\n        </Item>\n        <Item key=\"cheese\">\n          Cheese\n        </Item>\n        <Item key=\"tuna\">\n          Tuna Salad\n        </Item>\n        <Item key=\"egg\">\n          Egg Salad\n        </Item>\n        <Item key=\"ham\">\n          Ham\n        </Item>\n      </ListBox>\n      <p>\n        Current selection\n        (controlled):\n        {' '}\n        {selected ===\n            'all'\n          ? 'all'\n          : [...selected]\n            .join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n### Selection behavior[#](#selection-behavior)\n\nBy default, `useListBox` uses the `\"toggle\"` selection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the `Space` or `Enter` keys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection.\n\nWhen `selectionBehavior` is set to `\"replace\"`, clicking a row with the mouse replaces the selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as `Ctrl`, `Cmd`, and `Shift` can be used. On touch screen devices, selection always behaves as toggle since modifier keys may not be available.\n\nThese selection behaviors are defined in [Aria Practices](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/#keyboardinteraction).\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item key=\"lettuce\">Lettuce</Item>\n  <Item key=\"tomato\">Tomato</Item>\n  <Item key=\"cheese\">Cheese</Item>\n  <Item key=\"tuna\">Tuna Salad</Item>\n  <Item key=\"egg\">Egg Salad</Item>\n  <Item key=\"ham\">Ham</Item>\n</ListBox>\n```\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item key=\"lettuce\">Lettuce</Item>\n  <Item key=\"tomato\">Tomato</Item>\n  <Item key=\"cheese\">Cheese</Item>\n  <Item key=\"tuna\">Tuna Salad</Item>\n  <Item key=\"egg\">Egg Salad</Item>\n  <Item key=\"ham\">Ham</Item>\n</ListBox>\n```\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item key=\"lettuce\">\n    Lettuce\n  </Item>\n  <Item key=\"tomato\">\n    Tomato\n  </Item>\n  <Item key=\"cheese\">\n    Cheese\n  </Item>\n  <Item key=\"tuna\">\n    Tuna Salad\n  </Item>\n  <Item key=\"egg\">\n    Egg Salad\n  </Item>\n  <Item key=\"ham\">\n    Ham\n  </Item>\n</ListBox>\n```\n\n## Sections[#](#sections)\n\n---\n\nListBox supports sections with separators and headings in order to group options. Sections can be used by wrapping groups of Items in a `Section` component. Each `Section` takes a `title` and `key` prop.\nTo implement sections, implement the `ListBoxSection` component referenced above\nusing the `useListBoxSection` hook. It will include four extra elements:\nan `<li>` between the sections to represent the separator, an `<li>` to contain the heading `<span>` element, and a\n`<ul>` to contain the child items. This structure is necessary to ensure HTML semantics\nare correct.\n\n```\nimport {useListBoxSection} from 'react-aria';\n\nfunction ListBoxSection({ section, state }) {\n  let { itemProps, headingProps, groupProps } = useListBoxSection({\n    heading: section.rendered,\n    'aria-label': section['aria-label']\n  });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() &&\n        (\n          <li\n            role=\"presentation\"\n            style={{\n              borderTop: '1px solid gray',\n              margin: '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section.rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight: 'bold',\n                fontSize: '1.1em',\n                padding: '2px 5px'\n              }}\n            >\n              {section.rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle: 'none'\n          }}\n        >\n          {[...section.childNodes].map((node) => (\n            <Option\n              key={node.key}\n              item={node}\n              state={state}\n            />\n          ))}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n```\nimport {useListBoxSection} from 'react-aria';\n\nfunction ListBoxSection({ section, state }) {\n  let { itemProps, headingProps, groupProps } =\n    useListBoxSection({\n      heading: section.rendered,\n      'aria-label': section['aria-label']\n    });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() &&\n        (\n          <li\n            role=\"presentation\"\n            style={{\n              borderTop: '1px solid gray',\n              margin: '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section.rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight: 'bold',\n                fontSize: '1.1em',\n                padding: '2px 5px'\n              }}\n            >\n              {section.rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle: 'none'\n          }}\n        >\n          {[...section.childNodes].map((node) => (\n            <Option\n              key={node.key}\n              item={node}\n              state={state}\n            />\n          ))}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n```\nimport {useListBoxSection} from 'react-aria';\n\nfunction ListBoxSection(\n  { section, state }\n) {\n  let {\n    itemProps,\n    headingProps,\n    groupProps\n  } = useListBoxSection({\n    heading:\n      section.rendered,\n    'aria-label':\n      section[\n        'aria-label'\n      ]\n  });\n\n  // If the section is not the first, add a separator element to provide visual separation.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !==\n          state\n            .collection\n            .getFirstKey() &&\n        (\n          <li\n            role=\"presentation\"\n            style={{\n              borderTop:\n                '1px solid gray',\n              margin:\n                '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section\n          .rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight:\n                  'bold',\n                fontSize:\n                  '1.1em',\n                padding:\n                  '2px 5px'\n              }}\n            >\n              {section\n                .rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle:\n              'none'\n          }}\n        >\n          {[\n            ...section\n              .childNodes\n          ].map(\n            (node) => (\n              <Option\n                key={node\n                  .key}\n                item={node}\n                state={state}\n              />\n            )\n          )}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n### Static items[#](#static-items)\n\nWith this in place, we can now render a static ListBox with multiple sections:\n\n```\nimport {Section} from 'react-stately';\n\n<ListBox label=\"Choose sandwich contents\" selectionMode=\"multiple\">\n  <Section title=\"Veggies\">\n    <Item key=\"lettuce\">Lettuce</Item>\n    <Item key=\"tomato\">Tomato</Item>\n    <Item key=\"onion\">Onion</Item>\n  </Section>\n  <Section title=\"Protein\">\n    <Item key=\"ham\">Ham</Item>\n    <Item key=\"tuna\">Tuna</Item>\n    <Item key=\"tofu\">Tofu</Item>\n  </Section>\n  <Section title=\"Condiments\">\n    <Item key=\"mayo\">Mayonaise</Item>\n    <Item key=\"mustard\">Mustard</Item>\n    <Item key=\"ranch\">Ranch</Item>\n  </Section>\n</ListBox>\n```\n\n```\nimport {Section} from 'react-stately';\n\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n>\n  <Section title=\"Veggies\">\n    <Item key=\"lettuce\">Lettuce</Item>\n    <Item key=\"tomato\">Tomato</Item>\n    <Item key=\"onion\">Onion</Item>\n  </Section>\n  <Section title=\"Protein\">\n    <Item key=\"ham\">Ham</Item>\n    <Item key=\"tuna\">Tuna</Item>\n    <Item key=\"tofu\">Tofu</Item>\n  </Section>\n  <Section title=\"Condiments\">\n    <Item key=\"mayo\">Mayonaise</Item>\n    <Item key=\"mustard\">Mustard</Item>\n    <Item key=\"ranch\">Ranch</Item>\n  </Section>\n</ListBox>\n```\n\n```\nimport {Section} from 'react-stately';\n\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n>\n  <Section title=\"Veggies\">\n    <Item key=\"lettuce\">\n      Lettuce\n    </Item>\n    <Item key=\"tomato\">\n      Tomato\n    </Item>\n    <Item key=\"onion\">\n      Onion\n    </Item>\n  </Section>\n  <Section title=\"Protein\">\n    <Item key=\"ham\">\n      Ham\n    </Item>\n    <Item key=\"tuna\">\n      Tuna\n    </Item>\n    <Item key=\"tofu\">\n      Tofu\n    </Item>\n  </Section>\n  <Section title=\"Condiments\">\n    <Item key=\"mayo\">\n      Mayonaise\n    </Item>\n    <Item key=\"mustard\">\n      Mustard\n    </Item>\n    <Item key=\"ranch\">\n      Ranch\n    </Item>\n  </Section>\n</ListBox>\n```\n\n### Dynamic items[#](#dynamic-items)\n\nThe above example shows sections with static items. Sections can also be populated from a hierarchical data structure.\nSimilarly to the props on ListBox, `<Section>` takes an array of data using the `items` prop.\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let options = [\n    {name: 'Australian', children: [\n      {id: 2, name: 'Koala'},\n      {id: 3, name: 'Kangaroo'},\n      {id: 4, name: 'Platypus'}\n    ]},\n    {name: 'American', children: [\n      {id: 6, name: 'Bald Eagle'},\n      {id: 7, name: 'Bison'},\n      {id: 8, name: 'Skunk'}\n    ]}\n  ];\n  let [selected, setSelected] = React.useState<Selection>(new Set());\n\n  return (\n    <ListBox\n      label=\"Pick an animal\"\n      items={options}\n      selectedKeys={selected}\n      selectionMode=\"single\"\n      onSelectionChange={setSelected}>\n      {item => (\n        <Section key={item.name} items={item.children} title={item.name}>\n          {item => <Item>{item.name}</Item>}\n        </Section>\n      )}\n    </ListBox>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let options = [\n    {\n      name: 'Australian',\n      children: [\n        { id: 2, name: 'Koala' },\n        { id: 3, name: 'Kangaroo' },\n        { id: 4, name: 'Platypus' }\n      ]\n    },\n    {\n      name: 'American',\n      children: [\n        { id: 6, name: 'Bald Eagle' },\n        { id: 7, name: 'Bison' },\n        { id: 8, name: 'Skunk' }\n      ]\n    }\n  ];\n  let [selected, setSelected] = React.useState<Selection>(\n    new Set()\n  );\n\n  return (\n    <ListBox\n      label=\"Pick an animal\"\n      items={options}\n      selectedKeys={selected}\n      selectionMode=\"single\"\n      onSelectionChange={setSelected}\n    >\n      {(item) => (\n        <Section\n          key={item.name}\n          items={item.children}\n          title={item.name}\n        >\n          {(item) => <Item>{item.name}</Item>}\n        </Section>\n      )}\n    </ListBox>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let options = [\n    {\n      name: 'Australian',\n      children: [\n        {\n          id: 2,\n          name: 'Koala'\n        },\n        {\n          id: 3,\n          name:\n            'Kangaroo'\n        },\n        {\n          id: 4,\n          name:\n            'Platypus'\n        }\n      ]\n    },\n    {\n      name: 'American',\n      children: [\n        {\n          id: 6,\n          name:\n            'Bald Eagle'\n        },\n        {\n          id: 7,\n          name: 'Bison'\n        },\n        {\n          id: 8,\n          name: 'Skunk'\n        }\n      ]\n    }\n  ];\n  let [\n    selected,\n    setSelected\n  ] = React.useState<\n    Selection\n  >(new Set());\n\n  return (\n    <ListBox\n      label=\"Pick an animal\"\n      items={options}\n      selectedKeys={selected}\n      selectionMode=\"single\"\n      onSelectionChange={setSelected}\n    >\n      {(item) => (\n        <Section\n          key={item.name}\n          items={item\n            .children}\n          title={item\n            .name}\n        >\n          {(item) => (\n            <Item>\n              {item.name}\n            </Item>\n          )}\n        </Section>\n      )}\n    </ListBox>\n  );\n}\n```\n\n### Accessibility[#](#accessibility)\n\nSections without a `title` must provide an `aria-label` for accessibility.\n\n## Complex options[#](#complex-options)\n\n---\n\nBy default, options that only contain text will be labeled by the contents of the option.\nFor options that have more complex content (e.g. icons, multiple lines of text, etc.), use\n`labelProps` and `descriptionProps` from `useOption`\nas needed to apply to the main text element of the option and its description. This improves screen\nreader announcement.\n\n**NOTE: listbox options cannot contain interactive content (e.g. buttons, checkboxes, etc.).\nFor these cases, see [useGridList](../GridList/useGridList.html) instead.**\n\nTo implement this, we'll update the `Option` component to apply the ARIA properties\nreturned by `useOption` to the appropriate\nelements. In this example, we'll pull them out of `props.children` and use `React.cloneElement`\nto apply the props, but you may want to use a more robust approach (e.g. context).\n\n```\nfunction Option({ item, state }) {\n  let ref = React.useRef(null);\n  let { optionProps, labelProps, descriptionProps } = useOption(\n    { key: item.key },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  // Pull out the two expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [title, description] = item.rendered;\n\n  return (\n    <li\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {React.cloneElement(title, labelProps)}\n      {React.cloneElement(description, descriptionProps)}\n    </li>\n  );\n}\n\n<ListBox label=\"Text alignment\" selectionMode=\"single\">\n  <Item textValue=\"Align Left\">\n    <div>\n      <strong>Align Left</strong>\n    </div>\n    <div>Align the selected text to the left</div>\n  </Item>\n  <Item textValue=\"Align Center\">\n    <div>\n      <strong>Align Center</strong>\n    </div>\n    <div>Align the selected text center</div>\n  </Item>\n  <Item textValue=\"Align Right\">\n    <div>\n      <strong>Align Right</strong>\n    </div>\n    <div>Align the selected text to the right</div>\n  </Item>\n</ListBox>\n```\n\n```\nfunction Option({ item, state }) {\n  let ref = React.useRef(null);\n  let { optionProps, labelProps, descriptionProps } =\n    useOption({ key: item.key }, state, ref);\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  // Pull out the two expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [title, description] = item.rendered;\n\n  return (\n    <li\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {React.cloneElement(title, labelProps)}\n      {React.cloneElement(description, descriptionProps)}\n    </li>\n  );\n}\n\n<ListBox label=\"Text alignment\" selectionMode=\"single\">\n  <Item textValue=\"Align Left\">\n    <div>\n      <strong>Align Left</strong>\n    </div>\n    <div>Align the selected text to the left</div>\n  </Item>\n  <Item textValue=\"Align Center\">\n    <div>\n      <strong>Align Center</strong>\n    </div>\n    <div>Align the selected text center</div>\n  </Item>\n  <Item textValue=\"Align Right\">\n    <div>\n      <strong>Align Right</strong>\n    </div>\n    <div>Align the selected text to the right</div>\n  </Item>\n</ListBox>\n```\n\n```\nfunction Option(\n  { item, state }\n) {\n  let ref = React.useRef(\n    null\n  );\n  let {\n    optionProps,\n    labelProps,\n    descriptionProps\n  } = useOption(\n    { key: item.key },\n    state,\n    ref\n  );\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n\n  // Pull out the two expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [\n    title,\n    description\n  ] = item.rendered;\n\n  return (\n    <li\n      {...mergeProps(\n        optionProps,\n        focusProps\n      )}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {React\n        .cloneElement(\n          title,\n          labelProps\n        )}\n      {React\n        .cloneElement(\n          description,\n          descriptionProps\n        )}\n    </li>\n  );\n}\n\n<ListBox\n  label=\"Text alignment\"\n  selectionMode=\"single\"\n>\n  <Item textValue=\"Align Left\">\n    <div>\n      <strong>\n        Align Left\n      </strong>\n    </div>\n    <div>\n      Align the\n      selected text to\n      the left\n    </div>\n  </Item>\n  <Item textValue=\"Align Center\">\n    <div>\n      <strong>\n        Align Center\n      </strong>\n    </div>\n    <div>\n      Align the\n      selected text\n      center\n    </div>\n  </Item>\n  <Item textValue=\"Align Right\">\n    <div>\n      <strong>\n        Align Right\n      </strong>\n    </div>\n    <div>\n      Align the\n      selected text to\n      the right\n    </div>\n  </Item>\n</ListBox>\n```\n\n## Asynchronous loading[#](#asynchronous-loading)\n\n---\n\nThis example uses the [useAsyncList](../useAsyncList.html) hook to handle asynchronous loading\nof data from a server. You may additionally want to display a spinner to indicate the loading\nstate to the user, or support features like infinite scroll to load more data.\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Pokemon {\n  name: string;\n}\n\nfunction AsyncLoadingExample() {\n  let list = useAsyncList<Pokemon>({\n    async load({ signal }) {\n      let res = await fetch(\n        `https://pokeapi.co/api/v2/pokemon`,\n        { signal }\n      );\n      let json = await res.json();\n\n      return {\n        items: json.results\n      };\n    }\n  });\n\n  return (\n    <ListBox label=\"Pick a Pokemon\" items={list.items} selectionMode=\"single\">\n      {(item) => <Item key={item.name}>{item.name}</Item>}\n    </ListBox>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Pokemon {\n  name: string;\n}\n\nfunction AsyncLoadingExample() {\n  let list = useAsyncList<Pokemon>({\n    async load({ signal }) {\n      let res = await fetch(\n        `https://pokeapi.co/api/v2/pokemon`,\n        { signal }\n      );\n      let json = await res.json();\n\n      return {\n        items: json.results\n      };\n    }\n  });\n\n  return (\n    <ListBox\n      label=\"Pick a Pokemon\"\n      items={list.items}\n      selectionMode=\"single\"\n    >\n      {(item) => <Item key={item.name}>{item.name}</Item>}\n    </ListBox>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Pokemon {\n  name: string;\n}\n\nfunction AsyncLoadingExample() {\n  let list =\n    useAsyncList<\n      Pokemon\n    >({\n      async load(\n        { signal }\n      ) {\n        let res =\n          await fetch(\n            `https://pokeapi.co/api/v2/pokemon`,\n            { signal }\n          );\n        let json =\n          await res\n            .json();\n\n        return {\n          items:\n            json.results\n        };\n      }\n    });\n\n  return (\n    <ListBox\n      label=\"Pick a Pokemon\"\n      items={list.items}\n      selectionMode=\"single\"\n    >\n      {(item) => (\n        <Item\n          key={item.name}\n        >\n          {item.name}\n        </Item>\n      )}\n    </ListBox>\n  );\n}\n```\n\n## Links[#](#links)\n\n---\n\nBy default, interacting with an item in a ListBox triggers `onSelectionChange`. Alternatively, items may be links to another page or website. This can be achieved by passing the `href` prop to the `<Item>` component.\n\nThis example shows how to update the `Option` component with support for rendering an `<a>` element if an `href` prop is passed to the item. Note that you'll also need to render the `ListBox` as a `<div>` instead of a `<ul>`, since an `<a>` inside a `<ul>` is not valid HTML.\n\n```\nfunction Option({item, state}) {\n  let ref = React.useRef(null);\n  let {optionProps} = useOption({key: item.key}, state, ref);\n  let {isFocusVisible, focusProps} = useFocusRing();\n  let ElementType: React.ElementType = item.props.href ? 'a' : 'div';\n  return (\n    <ElementType\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}>\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<ListBox aria-label=\"Links\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">Adobe</Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">Apple</Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">Google</Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">Microsoft</Item>\n</ListBox>\n```\n\n```\nfunction Option({ item, state }) {\n  let ref = React.useRef(null);\n  let { optionProps } = useOption(\n    { key: item.key },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n  let ElementType: React.ElementType = item.props.href\n    ? 'a'\n    : 'div';\n  return (\n    <ElementType\n      {...mergeProps(optionProps, focusProps)}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<ListBox aria-label=\"Links\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">\n    Adobe\n  </Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">\n    Apple\n  </Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">\n    Google\n  </Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">\n    Microsoft\n  </Item>\n</ListBox>\n```\n\n```\nfunction Option(\n  { item, state }\n) {\n  let ref = React.useRef(\n    null\n  );\n  let { optionProps } =\n    useOption(\n      { key: item.key },\n      state,\n      ref\n    );\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n  let ElementType:\n    React.ElementType =\n      item.props.href\n        ? 'a'\n        : 'div';\n  return (\n    <ElementType\n      {...mergeProps(\n        optionProps,\n        focusProps\n      )}\n      ref={ref}\n      data-focus-visible={isFocusVisible}\n    >\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<ListBox aria-label=\"Links\">\n  <Item\n    href=\"https://adobe.com/\"\n    target=\"_blank\"\n  >\n    Adobe\n  </Item>\n  <Item\n    href=\"https://apple.com/\"\n    target=\"_blank\"\n  >\n    Apple\n  </Item>\n  <Item\n    href=\"https://google.com/\"\n    target=\"_blank\"\n  >\n    Google\n  </Item>\n  <Item\n    href=\"https://microsoft.com/\"\n    target=\"_blank\"\n  >\n    Microsoft\n  </Item>\n</ListBox>\n```\n\nBy default, link items in a ListBox are not selectable, and only perform navigation when the user interacts with them. However, with the \"replace\" [selection behavior](#selection-behavior), items will be selected when single clicking or pressing the `Space` key, and navigate to the link when double clicking or pressing the `Enter` key.\n\n```\n<ListBox\n  aria-label=\"Links\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item href=\"https://adobe.com/\" target=\"_blank\">Adobe</Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">Apple</Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">Google</Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">Microsoft</Item>\n</ListBox>\n```\n\n```\n<ListBox\n  aria-label=\"Links\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item href=\"https://adobe.com/\" target=\"_blank\">\n    Adobe\n  </Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">\n    Apple\n  </Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">\n    Google\n  </Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">\n    Microsoft\n  </Item>\n</ListBox>\n```\n\n```\n<ListBox\n  aria-label=\"Links\"\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n>\n  <Item\n    href=\"https://adobe.com/\"\n    target=\"_blank\"\n  >\n    Adobe\n  </Item>\n  <Item\n    href=\"https://apple.com/\"\n    target=\"_blank\"\n  >\n    Apple\n  </Item>\n  <Item\n    href=\"https://google.com/\"\n    target=\"_blank\"\n  >\n    Google\n  </Item>\n  <Item\n    href=\"https://microsoft.com/\"\n    target=\"_blank\"\n  >\n    Microsoft\n  </Item>\n</ListBox>\n```\n\n### Client side routing[#](#client-side-routing)\n\nThe `<Item>` component works with frameworks and client side routers like [Next.js](https://nextjs.org/) and [React Router](https://reactrouter.com/en/main). As with other React Aria components that support links, this works via the `RouterProvider` component at the root of your app. See the [framework setup guide](../frameworks) to learn how to set this up.\n\n## Disabled items[#](#disabled-items)\n\n---\n\n`useListBox` supports marking items as disabled using the `disabledKeys` prop. Each key in this list\ncorresponds with the `key` prop passed to the `Item` component, or automatically derived from the values passed\nto the `items` prop. See [Collections](https://react-spectrum.adobe.com/v3/collections.html) for more details.\n\nDisabled items are not focusable, selectable, or keyboard navigable. The `isDisabled` property returned by\n`useOption` can be used to style the item appropriately.\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  disabledKeys={['tuna']}\n>\n  <Item key=\"lettuce\">Lettuce</Item>\n  <Item key=\"tomato\">Tomato</Item>\n  <Item key=\"cheese\">Cheese</Item>\n  <Item key=\"tuna\">Tuna Salad</Item>\n  <Item key=\"egg\">Egg Salad</Item>\n  <Item key=\"ham\">Ham</Item>\n</ListBox>\n```\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  disabledKeys={['tuna']}\n>\n  <Item key=\"lettuce\">Lettuce</Item>\n  <Item key=\"tomato\">Tomato</Item>\n  <Item key=\"cheese\">Cheese</Item>\n  <Item key=\"tuna\">Tuna Salad</Item>\n  <Item key=\"egg\">Egg Salad</Item>\n  <Item key=\"ham\">Ham</Item>\n</ListBox>\n```\n\n```\n<ListBox\n  label=\"Choose sandwich contents\"\n  selectionMode=\"multiple\"\n  disabledKeys={[\n    'tuna'\n  ]}\n>\n  <Item key=\"lettuce\">\n    Lettuce\n  </Item>\n  <Item key=\"tomato\">\n    Tomato\n  </Item>\n  <Item key=\"cheese\">\n    Cheese\n  </Item>\n  <Item key=\"tuna\">\n    Tuna Salad\n  </Item>\n  <Item key=\"egg\">\n    Egg Salad\n  </Item>\n  <Item key=\"ham\">\n    Ham\n  </Item>\n</ListBox>\n```\n\n## Internationalization[#](#internationalization)\n\n---\n\n`useListBox` handles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\n[Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator)\nfor internationalized string matching. You are responsible for localizing all labels and option\ncontent that is passed into the listbox.\n\n### RTL[#](#rtl)\n\nIn right-to-left languages, the listbox options should be mirrored. The text content should be\naligned to the right. Ensure that your CSS accounts for this.\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isVirtualized` | `boolean` | \u00e2\u0080\u0094 | Whether the listbox uses virtual scrolling. |\n| `keyboardDelegate` | `KeyboardDelegate` | \u00e2\u0080\u0094 | An optional keyboard delegate implementation for type to select, to override the default. |\n| `layoutDelegate` | `LayoutDelegate` | \u00e2\u0080\u0094 | A delegate object that provides layout information for items in the collection. By default this uses the DOM, but this can be overridden to implement things like virtualized scrolling. |\n| `shouldUseVirtualFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the listbox items should use virtual focus instead of being focused directly. |\n| `linkBehavior` | `'action' |\u00c2\u00a0'selection' |\u00c2\u00a0'override'` | `'override'` | The behavior of links in the collection. - 'action': link behaves like onAction. - 'selection': link follows selection interactions (e.g. if URL drives selection). - 'override': links override all other interactions (link items are not selectable). |\n| `label` | `ReactNode` | \u00e2\u0080\u0094 | An optional visual label for the listbox. |\n| `selectionBehavior` | `SelectionBehavior` | \u00e2\u0080\u0094 | How multiple selection should behave in the collection. |\n| `shouldSelectOnPressUp` | `boolean` | \u00e2\u0080\u0094 | Whether selection should occur on press up instead of press down. |\n| `shouldFocusOnHover` | `boolean` | \u00e2\u0080\u0094 | Whether options should be focused when the user hovers over them. |\n| `onAction` | `( (key: Key )) => void` | \u00e2\u0080\u0094 | Handler that is called when a user performs an action on an item. The exact user event depends on the collection's `selectionBehavior` prop and the interaction modality. |\n| `escapeKeyBehavior` | `'clearSelection' |\u00c2\u00a0'none'` | `'clearSelection'` | Whether pressing the escape key should clear selection in the listbox or not.  Most experiences should not modify this option as it eliminates a keyboard user's ability to easily clear selection. Only use if the escape key is being handled externally or should not trigger selection clearing contextually. |\n| `autoFocus` | `boolean |\u00c2\u00a0FocusStrategy` | \u00e2\u0080\u0094 | Whether to auto focus the listbox or an option. |\n| `shouldFocusWrap` | `boolean` | \u00e2\u0080\u0094 | Whether focus should wrap around when the end/start is reached. |\n| `items` | `Iterable<T>` | \u00e2\u0080\u0094 | Item objects in the collection. |\n| `disabledKeys` | `Iterable<Key>` | \u00e2\u0080\u0094 | The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with. |\n| `selectionMode` | `SelectionMode` | \u00e2\u0080\u0094 | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | \u00e2\u0080\u0094 | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | \u00e2\u0080\u0094 | Handler that is called when the selection changes. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n| Method | Description |\n| --- | --- |\n| `getKeyBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually below the given one, or `null` for none. |\n| `getKeyAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually above the given one, or `null` for none. |\n| `getKeyLeftOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the left of the given one, or `null` for none. |\n| `getKeyRightOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the right of the given one, or `null` for none. |\n| `getKeyPageBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page below the given one, or `null` for none. |\n| `getKeyPageAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page above the given one, or `null` for none. |\n| `getFirstKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the first key, or `null` for none. |\n| `getLastKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the last key, or `null` for none. |\n| `getKeyForSearch( (search: string, , fromKey?: Key |\u00c2\u00a0 |\u00c2\u00a0null )): Key |\u00c2\u00a0null` | Returns the next key after `fromKey` that matches the given search string, or `null` for none. |\n\nA LayoutDelegate provides layout information for collection items.\n\n| Method | Description |\n| --- | --- |\n| `getItemRect( (key: Key )): Rect |\u00c2\u00a0null` | Returns a rectangle for the item with the given key. |\n| `getVisibleRect(): Rect` | Returns the visible rectangle of the collection. |\n| `getContentSize(): Size` | Returns the size of the scrollable content in the collection. |\n| `getKeyRange( (from: Key, , to: Key )): Key[]` | Returns a list of keys between `from` and `to`. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `x` | `number` |  |\n| `y` | `number` |  |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n`'toggle' |\u00c2\u00a0'replace'`\n\n`string |\u00c2\u00a0number`\n\n`'first' |\u00c2\u00a0'last'`\n\n`'none'\n|\u00c2\u00a0'single'\n|\u00c2\u00a0'multiple'`\n\n`'all' |\u00c2\u00a0Set<Key>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<T>>` | A collection of items in the list. |\n| `disabledKeys` | `Set<Key>` | A set of items that are disabled. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update multiple selection state. |\n\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\n\n**Extends**: `Iterable`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `size` | `number` | The number of items in the collection. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getKeys(): Iterable<Key>` | Iterate over all keys in the collection. |\n| `getItem( (key: Key )): T |\u00c2\u00a0null` | Get an item by its key. |\n| `at( (idx: number )): T |\u00c2\u00a0null` | Get an item by the index of its key. |\n| `getKeyBefore( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes before the given key in the collection. |\n| `getKeyAfter( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes after the given key in the collection. |\n| `getFirstKey(): Key |\u00c2\u00a0null` | Get the first key in the collection. |\n| `getLastKey(): Key |\u00c2\u00a0null` | Get the last key in the collection. |\n| `getChildren( (key: Key )): Iterable<T>` | Iterate over the child items of the given key. |\n| `getTextValue( (key: Key )): string` | Returns a string representation of the item's contents. |\n| `filter( (filterFn: ( (nodeValue: string, , node: T )) => boolean )): Collection<T>` | Filters the collection using the given function. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `string` | The type of item this node represents. |\n| `key` | `Key` | A unique key for the node. |\n| `value` | `T |\u00c2\u00a0null` | The object value the node was created from. |\n| `level` | `number` | The level of depth this node is at in the hierarchy. |\n| `hasChildNodes` | `boolean` | Whether this item has children, even if not loaded yet. |\n| `rendered` | `ReactNode` | The rendered contents of this node (e.g. JSX). |\n| `textValue` | `string` | A string value for this node, used for features like typeahead. |\n| `index` | `number` | The index of this node within its parent. |\n| `aria-label` | `string` | An accessibility label for this node. |\n| `wrapper` | `( (element: ReactElement )) => ReactElement` | A function that should be called to wrap the rendered node. |\n| `parentKey` | `Key |\u00c2\u00a0null` | The key of the parent node. |\n| `prevKey` | `Key |\u00c2\u00a0null` | The key of the node before this node. |\n| `nextKey` | `Key |\u00c2\u00a0null` | The key of the node after this node. |\n| `props` | `any` | Additional properties specific to a particular node type. |\n| `render` | `( (node: Node<any> )) => ReactElement` | A function that renders this node to a React Element in the DOM. |\n\nAn interface for reading and updating multiple selection state.\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<unknown>>` |  |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n| `selectedKeys` | `Set<Key>` | The currently selected keys in the collection. |\n| `rawSelection` | `Selection` | The raw selection value for the collection. Either 'all' for select all, or a set of keys. |\n| `isEmpty` | `boolean` | Whether the selection is empty. |\n| `isSelectAll` | `boolean` | Whether all items in the collection are selected. |\n| `firstSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `lastSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `disabledKeys` | `Set<Key>` |  |\n| `disabledBehavior` | `DisabledBehavior` |  |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `constructor( collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions ): void` |  |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , childFocusStrategy?: FocusStrategy )): void` | Sets the focused key. |\n| `isSelected( (key: Key )): boolean` | Returns whether a key is selected. |\n| `extendSelection( (toKey: Key )): void` | Extends the selection to the given key. |\n| `toggleSelection( (key: Key )): void` | Toggles whether the given key is selected. |\n| `replaceSelection( (key: Key )): void` | Replaces the selection with only the given key. |\n| `setSelectedKeys( (keys: Iterable<Key> )): void` | Replaces the selection with the given keys. |\n| `selectAll(): void` | Selects all items in the collection. |\n| `clearSelection(): void` | Removes all keys from the selection. |\n| `toggleSelectAll(): void` | Toggles between select all and an empty selection. |\n| `select( (key: Key, , e?: PressEvent |\u00c2\u00a0LongPressEvent |\u00c2\u00a0PointerEvent )): void` |  |\n| `isSelectionEqual( (selection: Set<Key> )): boolean` | Returns whether the current selection is equal to the given selection. |\n| `canSelectItem( (key: Key )): boolean` |  |\n| `isDisabled( (key: Key )): boolean` |  |\n| `isLink( (key: Key )): boolean` |  |\n| `getItemProps( (key: Key )): any` |  |\n| `withCollection( (collection: Collection<Node<unknown>> )): SelectionManager` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `Selection` | The currently selected keys in the collection. |\n| `disabledKeys` | `Set<Key>` | The currently disabled keys in the collection. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to selection, actions, or both. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setSelectedKeys( (keys: Selection )): void` | Sets the selected keys in the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , child?: FocusStrategy )): void` | Sets the focused key, and optionally, whether the first or last child of that key should receive focus. |\n\n`'selection' |\u00c2\u00a0'all'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `allowsCellSelection` | `boolean` |  |\n| `layoutDelegate` | `LayoutDelegate` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'longpressstart' |\u00c2\u00a0'longpressend' |\u00c2\u00a0'longpress'` | The type of long press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `current` | `T` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `listBoxProps` | `DOMAttributes` | Props for the listbox element. |\n| `labelProps` | `DOMAttributes` | Props for the listbox's visual label element (if any). |\n\nAll DOM attributes supported across both HTML and SVG elements.\n\n**Extends**: `AriaAttributes, ReactDOMAttributes`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `id` | `string |\u00c2\u00a0undefined` |  |\n| `role` | `AriaRole |\u00c2\u00a0undefined` |  |\n| `tabIndex` | `number |\u00c2\u00a0undefined` |  |\n| `style` | `CSSProperties |\u00c2\u00a0undefined` |  |\n| `className` | `string |\u00c2\u00a0undefined` |  |\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `key` | `Key` | The unique key for the option. |\n| `aria-label` | `string` | A screen reader only label for the option. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `optionProps` | `DOMAttributes` | Props for the option element. |\n| `labelProps` | `DOMAttributes` | Props for the main text element inside the option. |\n| `descriptionProps` | `DOMAttributes` | Props for the description text element inside the option, if any. |\n| `isFocused` | `boolean` | Whether the option is currently focused. |\n| `isFocusVisible` | `boolean` | Whether the option is keyboard focused. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isDisabled` | `boolean` | Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may not be focused. Dependent on `disabledKeys` and `disabledBehavior`. |\n| `allowsSelection` | `boolean` | Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`. |\n| `hasAction` | `boolean` | Whether the item has an action, dependent on `onAction`, `disabledKeys`, and `disabledBehavior`. It may also change depending on the current selection state of the list (e.g. when selection is primary). This can be used to enable or disable hover styles or other visual indications of interactivity. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `heading` | `ReactNode` | The heading for the section. |\n| `aria-label` | `string` | An accessibility label for the section. Required if `heading` is not present. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `itemProps` | `DOMAttributes` | Props for the wrapper list item. |\n| `headingProps` | `DOMAttributes` | Props for the heading element, if any. |\n| `groupProps` | `DOMAttributes` | Props for the group element. |\n\nProvides state management for list-like components. Handles building a collection\nof items from props, and manages multiple selection state.\n\n`useListState<T extends object>(\n(props: ListProps<T>\n)): ListState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `filter` | `( (nodes: Iterable<Node<T>> )) => Iterable<Node<T>>` | Filter function to generate a filtered list of nodes. |\n| `layoutDelegate` | `LayoutDelegate` | A delegate object that provides layout information for items in the collection. This can be used to override the behavior of shift selection. |\n| `collection` | `Collection<Node<T>>` | A pre-constructed collection to use instead of building one from items and children. |\n| `selectionBehavior` | `SelectionBehavior` | How multiple selection should behave in the collection. |\n| `allowDuplicateSelectionEvents` | `boolean` | Whether onSelectionChange should fire even if the new set of keys is the same as the last. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to all interactions, or only selection. |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | Handler that is called when the selection changes. |\n| `disabledKeys` | `Iterable<Key>` | The currently disabled keys in the collection (controlled). |\n\nProvides the behavior and accessibility implementation for a listbox component.\nA listbox displays a list of options and allows a user to select one or more of them.\n\n`useListBox<T>(\nprops: AriaListBoxOptions<T>,\nstate: ListState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): ListBoxAria`\n\nProvides the behavior and accessibility implementation for an option in a listbox.\nSee `useListBox` for more details about listboxes.\n\n`useOption<T>(\nprops: AriaOptionProps,\nstate: ListState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): OptionAria`\n\nProvides the behavior and accessibility implementation for a section in a listbox.\nSee `useListBox` for more details about listboxes.\n\n`useListBoxSection(\n(props: AriaListBoxSectionProps\n)): ListBoxSectionAria`\n\nA RouterProvider accepts a `navigate` function from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `navigate` | `( (path: Href, , routerOptions: RouterOptions |\u00c2\u00a0 |\u00c2\u00a0undefined )) => void` |  |\n| `children` | `ReactNode` |  |\n| `useHref` | `( (href: Href )) => string` |  |\n\n`RouterConfig extends {\n\nhref: any\n\n} ? H : string`\n\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with `href` and `routerOptions` properties to configure your router.\n\n`RouterConfig extends {\n\nrouterOptions: any\n\n} ? O : never`",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:38:05.473937+00:00",
  "content_length": 57103,
  "content_hash": "34cf02f6ccb594a6"
}