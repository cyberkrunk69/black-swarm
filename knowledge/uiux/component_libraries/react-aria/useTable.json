{
  "id": "react-aria__react-aria_useTable_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useTable.html",
  "title": "useTable",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseTable\nProvides the behavior and accessibility implementation for a table component.\nA table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,\nand optionally supports row selection and sorting.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useTable, useTableCell, useTableColumnHeader, useTableRow, useTableHeaderRow, useTableRowGroup, useTableSelectAllCheckbox, useTableSelectionCheckbox, useTableColumnResize}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseTable\n<\nT\n>\n(\nprops\n:\nAriaTableProps\n,\nstate\n:\nTableState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeGridState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridAria\nuseTableRowGroup\n(\n)\n:\nGridRowGroupAria\nuseTableHeaderRow\n<\nT\n>\n(\nprops\n:\nGridRowProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableHeaderRowAria\nuseTableColumnHeader\n<\nT\n>\n(\nprops\n:\nAriaTableColumnHeaderProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableColumnHeaderAria\nuseTableRow\n<\nT\n>\n(\nprops\n:\nGridRowProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeGridState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridRowAria\nuseTableCell\n<\nT\n>\n(\nprops\n:\nAriaTableCellProps\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableCellAria\nuseTableSelectionCheckbox\n<\nT\n>\n(\n(\nprops\n:\nAriaTableSelectionCheckboxProps\n,\n,\nstate\n:\nTableState\n<\nT\n>\n)\n)\n:\nTableSelectionCheckboxAria\nuseTableSelectAllCheckbox\n<\nT\n>\n(\n(\nstate\n:\nTableState\n<\nT\n>\n)\n)\n:\nTableSelectAllCheckboxAria\nuseTableColumnResize\n<\nT\n>\n(\nprops\n:\nAriaTableColumnResizeProps\n<\nT\n>\n,\nstate\n:\nTableColumnResizeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLInputElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableColumnResizeAria\nFeatures\n#\nA table can be built using the\n<table>\n,\n<tr>\n,\n<td>\n, and other table specific HTML elements, but is very limited in functionality especially when it comes to user interactions.\nHTML tables are meant for static content, rather than tables with rich interactions like focusable elements within cells, keyboard navigation, row selection, sorting, etc.\nuseTable\nhelps achieve accessible and interactive table components that can be styled as needed.\nExposed to assistive technology as a\ngrid\nusing ARIA\nKeyboard navigation between columns, rows, cells, and in-cell focusable elements via the arrow keys\nSingle, multiple, or no row selection via mouse, touch, or keyboard interactions\nSupport for disabled rows, which cannot be selected\nOptional support for checkboxes in each row for selection, as well as in the header to select all rows\nSupport for both\ntoggle\nand\nreplace\nselection behaviors\nSupport for row actions via double click,\nEnter\nkey, or tapping\nLong press to enter selection mode on touch when there is both selection and row actions\nColumn sorting support\nAsync loading, infinite scrolling, filtering, and sorting support\nSupport for column groups via nested columns\nTypeahead to allow focusing rows by typing text\nAutomatic scrolling support during keyboard navigation\nLabeling support for accessibility\nSupport for marking columns as\nrow headers\n, which will be read when navigating the rows with a screen reader\nEnsures that selections are announced using an ARIA live region\nSupport for using HTML table elements, or custom element types (e.g.\n<div>\n) for layout flexibility\nSupport for use with virtualized lists\nSupport for resizable columns\nAnatomy\n#\nA table consists of a container element, with columns and rows of cells containing data inside. The cells within a table may contain focusable elements or plain text content.\nIf the table supports row selection, each row can optionally include a selection checkbox in the first column. Additionally, a \"select all\" checkbox is displayed as the first column header if the table supports multiple row selection.\nThe\nuseTable\n,\nuseTableRow\n,\nuseTableCell\n, and\nuseTableColumnHeader\nhooks handle keyboard, mouse, and other interactions to support\nrow selection, in table navigation, and overall focus behavior. Those hooks, along with\nuseTableRowGroup\nand\nuseTableHeaderRow\n, also handle exposing the table and its contents\nto assistive technology using ARIA.\nuseTableSelectAllCheckbox\nand\nuseTableSelectionCheckbox\nhandle row selection and associating each checkbox with its respective rows\nfor assistive technology. Each of these hooks returns props to be spread onto the appropriate HTML element.\nState is managed by the\nuseTableState\nhook from\n@react-stately/table\n. The state object should be passed as an option to each of the above hooks where applicable.\nNote that an\naria-label\nor\naria-labelledby\nmust be passed to the table to identify the element to assistive technology.\nState management\n#\nuseTable\nrequires knowledge of the rows, cells, and columns in the table in order to handle keyboard\nnavigation and other interactions. It does this using\nthe\nCollection\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut\nuseTableState\nfrom\n@react-stately/table\nimplements a JSX based interface for building collections instead.\nSee\nCollection Components\nfor more information.\nData is defined using the\nTableHeader\n,\nColumn\n,\nTableBody\n,\nRow\n, and\nCell\ncomponents, which support both static and dynamic data.\nSee the examples in the\nusage\nsection below for details on how to use these components.\nIn addition,\nuseTableState\nmanages the state necessary for multiple selection and exposes\na\nSelectionManager\n,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see\nSelection\n.\nExample\n#\nTables are complex\ncollection components\nthat are built up from many child elements\nincluding columns, rows, and cells. In this example, we'll use the standard HTML table elements along with hooks from React\nAria for each child. You may also use other elements like\n<div>\nto render these components as appropriate.\nSince there are many pieces, we'll walk through each of them one by one.\nThe\nuseTable\nhook will be used to render the outer most table element. It uses\nthe\nuseTableState\nhook to construct the table's collection of rows and columns,\nand manage state such as the focused row/cell, selection, and sort column/direction. We'll use the collection to iterate through\nthe rows and cells of the table and render the relevant components, which we'll define below.\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseTable\n}\nfrom\n'react-aria'\n;\nimport\n{\nCell\n,\nColumn\n,\nRow\n,\nTableBody\n,\nTableHeader\n,\nuseTableState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nTable\n(\nprops\n)\n{\nlet\n{\nselectionMode\n,\nselectionBehavior\n}\n=\nprops\n;\nlet\nstate\n=\nuseTableState\n(\n{\n...\nprops\n,\nshowSelectionCheckboxes\n:\nselectionMode\n===\n'multiple'\n&&\nselectionBehavior\n!==\n'replace'\n}\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntable\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nborderCollapse\n:\n'collapse'\n}\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\ncolumn\n.\nprops\n.\nisSelectionCell\n?\n(\n<\nTableSelectAllCell\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\ncell\n.\nprops\n.\nisSelectionCell\n?\n<\nTableCheckboxCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n:\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n)\n;\n}\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseTable\n}\nfrom\n'react-aria'\n;\nimport\n{\nCell\n,\nColumn\n,\nRow\n,\nTableBody\n,\nTableHeader\n,\nuseTableState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nTable\n(\nprops\n)\n{\nlet\n{\nselectionMode\n,\nselectionBehavior\n}\n=\nprops\n;\nlet\nstate\n=\nuseTableState\n(\n{\n...\nprops\n,\nshowSelectionCheckboxes\n:\nselectionMode\n===\n'multiple'\n&&\nselectionBehavior\n!==\n'replace'\n}\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntable\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nborderCollapse\n:\n'collapse'\n}\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\ncolumn\n.\nprops\n.\nisSelectionCell\n?\n(\n<\nTableSelectAllCell\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\ncell\n.\nprops\n.\nisSelectionCell\n?\n(\n<\nTableCheckboxCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n)\n;\n}\nimport\n{\nmergeProps\n,\nuseFocusRing\n,\nuseTable\n}\nfrom\n'react-aria'\n;\nimport\n{\nCell\n,\nColumn\n,\nRow\n,\nTableBody\n,\nTableHeader\n,\nuseTableState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nTable\n(\nprops\n)\n{\nlet\n{\nselectionMode\n,\nselectionBehavior\n}\n=\nprops\n;\nlet\nstate\n=\nuseTableState\n(\n{\n...\nprops\n,\nshowSelectionCheckboxes\n:\nselectionMode\n===\n'multiple'\n&&\nselectionBehavior\n!==\n'replace'\n}\n)\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntable\n{\n...\ngridProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nborderCollapse\n:\n'collapse'\n}\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\ncolumn\n.\nprops\n.\nisSelectionCell\n?\n(\n<\nTableSelectAllCell\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\ncell\n.\nprops\n.\nisSelectionCell\n?\n(\n<\nTableCheckboxCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n)\n;\n}\nTable header\n#\nA\nuseTableRowGroup\nhook will be used to group the rows in the table header and table body. In this example,\nwe're using HTML table elements, so this will be either a\n<thead>\nor\n<tbody>\nelement, as passed from the\nabove\nTable\ncomponent via the\ntype\nprop.\nimport\n{\nuseTableRowGroup\n}\nfrom\n'react-aria'\n;\nfunction\nTableRowGroup\n(\n{\ntype\n:\nElement\n,\nchildren\n}\n)\n{\nlet\n{\nrowGroupProps\n}\n=\nuseTableRowGroup\n(\n)\n;\nreturn\n(\n<\nElement\n{\n...\nrowGroupProps\n}\nstyle\n=\n{\nElement\n===\n'thead'\n?\n{\nborderBottom\n:\n'2px solid var(--spectrum-global-color-gray-800)'\n}\n:\nnull\n}\n>\n{\nchildren\n}\n<\n/\nElement\n>\n)\n;\n}\nimport\n{\nuseTableRowGroup\n}\nfrom\n'react-aria'\n;\nfunction\nTableRowGroup\n(\n{\ntype\n:\nElement\n,\nchildren\n}\n)\n{\nlet\n{\nrowGroupProps\n}\n=\nuseTableRowGroup\n(\n)\n;\nreturn\n(\n<\nElement\n{\n...\nrowGroupProps\n}\nstyle\n=\n{\nElement\n===\n'thead'\n?\n{\nborderBottom\n:\n'2px solid var(--spectrum-global-color-gray-800)'\n}\n:\nnull\n}\n>\n{\nchildren\n}\n<\n/\nElement\n>\n)\n;\n}\nimport\n{\nuseTableRowGroup\n}\nfrom\n'react-aria'\n;\nfunction\nTableRowGroup\n(\n{\ntype\n:\nElement\n,\nchildren\n}\n)\n{\nlet\n{\nrowGroupProps\n}\n=\nuseTableRowGroup\n(\n)\n;\nreturn\n(\n<\nElement\n{\n...\nrowGroupProps\n}\nstyle\n=\n{\nElement\n===\n'thead'\n?\n{\nborderBottom\n:\n'2px solid var(--spectrum-global-color-gray-800)'\n}\n:\nnull\n}\n>\n{\nchildren\n}\n<\n/\nElement\n>\n)\n;\n}\nThe\nuseTableHeaderRow\nhook will be used to render a header row. Header rows are similar to other rows,\nbut they don't support user interaction like selection. In this example, there's only one header\nrow, but there could be multiple in the case of nested columns. See the\nexample below\nfor details.\nimport\n{\nuseTableHeaderRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableHeaderRow\n(\n{\nitem\n,\nstate\n,\nchildren\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nrowProps\n}\n=\nuseTableHeaderRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntr\n{\n...\nrowProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nimport\n{\nuseTableHeaderRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableHeaderRow\n(\n{\nitem\n,\nstate\n,\nchildren\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nrowProps\n}\n=\nuseTableHeaderRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntr\n{\n...\nrowProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nimport\n{\nuseTableHeaderRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableHeaderRow\n(\n{\nitem\n,\nstate\n,\nchildren\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nrowProps\n}\n=\nuseTableHeaderRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ntr\n{\n...\nrowProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nThe\nuseTableColumnHeader\nhook will be used to render each column header. Column headers act as a label\nfor all of the cells in that column, and can optionally support user interaction to sort by the column\nand change the sort order.\nThe\nallowsSorting\nproperty of the column object can be used to determine\nif the column supports sorting at all.\nThe\nsortDescriptor\nobject stored in the\nstate\nobject indicates which column the table is currently sorted by,\nas well as the sort direction (ascending or descending). This is used to render an arrow icon to visually\nindicate the sort direction. When not sorted by this column, we use\nvisibility: hidden\nto ensure that\nwe reserve space for this icon at all times. That way the table's layout doesn't shift when we change the\ncolumn we're sorting by. See the\nexample below\nof all of this in action.\nFinally, we use the\nuseFocusRing\nhook to ensure that a focus ring is rendered when\nthe cell is navigated to with the keyboard.\nimport\n{\nuseTableColumnHeader\n}\nfrom\n'react-aria'\n;\nfunction\nTableColumnHeader\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\narrowIcon\n=\nstate\n.\nsortDescriptor\n?.\ndirection\n===\n'ascending'\n?\n'\u00e2\u0096\u00b2'\n:\n'\u00e2\u0096\u00bc'\n;\nreturn\n(\n<\nth\n{\n...\nmergeProps\n(\ncolumnHeaderProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\ntextAlign\n:\ncolumn\n.\ncolSpan\n>\n1\n?\n'center'\n:\n'left'\n,\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncolumn\n.\nrendered\n}\n{\ncolumn\n.\nprops\n.\nallowsSorting\n&&\n(\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npadding\n:\n'0 2px'\n,\nvisibility\n:\nstate\n.\nsortDescriptor\n?.\ncolumn\n===\ncolumn\n.\nkey\n?\n'visible'\n:\n'hidden'\n}\n}\n>\n{\narrowIcon\n}\n<\n/\nspan\n>\n)\n}\n<\n/\nth\n>\n)\n;\n}\nimport\n{\nuseTableColumnHeader\n}\nfrom\n'react-aria'\n;\nfunction\nTableColumnHeader\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\narrowIcon\n=\nstate\n.\nsortDescriptor\n?.\ndirection\n===\n'ascending'\n?\n'\u00e2\u0096\u00b2'\n:\n'\u00e2\u0096\u00bc'\n;\nreturn\n(\n<\nth\n{\n...\nmergeProps\n(\ncolumnHeaderProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\ntextAlign\n:\ncolumn\n.\ncolSpan\n>\n1\n?\n'center'\n:\n'left'\n,\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncolumn\n.\nrendered\n}\n{\ncolumn\n.\nprops\n.\nallowsSorting\n&&\n(\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npadding\n:\n'0 2px'\n,\nvisibility\n:\nstate\n.\nsortDescriptor\n?.\ncolumn\n===\ncolumn\n.\nkey\n?\n'visible'\n:\n'hidden'\n}\n}\n>\n{\narrowIcon\n}\n<\n/\nspan\n>\n)\n}\n<\n/\nth\n>\n)\n;\n}\nimport\n{\nuseTableColumnHeader\n}\nfrom\n'react-aria'\n;\nfunction\nTableColumnHeader\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nlet\narrowIcon\n=\nstate\n.\nsortDescriptor\n?.\ndirection\n===\n'ascending'\n?\n'\u00e2\u0096\u00b2'\n:\n'\u00e2\u0096\u00bc'\n;\nreturn\n(\n<\nth\n{\n...\nmergeProps\n(\ncolumnHeaderProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\ntextAlign\n:\ncolumn\n.\ncolSpan\n>\n1\n?\n'center'\n:\n'left'\n,\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncolumn\n.\nrendered\n}\n{\ncolumn\n.\nprops\n.\nallowsSorting\n&&\n(\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npadding\n:\n'0 2px'\n,\nvisibility\n:\nstate\n.\nsortDescriptor\n?.\ncolumn\n===\ncolumn\n.\nkey\n?\n'visible'\n:\n'hidden'\n}\n}\n>\n{\narrowIcon\n}\n<\n/\nspan\n>\n)\n}\n<\n/\nth\n>\n)\n;\n}\nTable body\n#\nNow that we've covered the table header, let's move on to the body. We'll use\nthe\nuseTableRow\nhook to render each row in the table.\nTable rows can be focused and navigated to using the keyboard via the arrow keys. In addition, table rows\ncan optionally support selection via mouse, touch, or keyboard. Clicking, tapping, or pressing the\nSpace\nkey anywhere in the row selects it. Row actions are also supported, see\nbelow\nfor details.\nWe'll use the\nSelectionManager\nobject exposed\nby the\nstate\nto determine if a row is selected, and render a pink background if so. We'll also use the\nuseFocusRing\nhook to render a focus ring when the user navigates to the row with the keyboard.\nimport\n{\nuseTableRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableRow\n(\n{\nitem\n,\nchildren\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nisSelected\n=\nstate\n.\nselectionManager\n.\nisSelected\n(\nitem\n.\nkey\n)\n;\nlet\n{\nrowProps\n,\nisPressed\n}\n=\nuseTableRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntr\nstyle\n=\n{\n{\nbackground\n:\nisSelected\n?\n'blueviolet'\n:\nisPressed\n?\n'var(--spectrum-global-color-gray-400)'\n:\nitem\n.\nindex\n%\n2\n?\n'var(--spectrum-alias-highlight-hover)'\n:\n'none'\n,\ncolor\n:\nisSelected\n?\n'white'\n:\nnull\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nimport\n{\nuseTableRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableRow\n(\n{\nitem\n,\nchildren\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nisSelected\n=\nstate\n.\nselectionManager\n.\nisSelected\n(\nitem\n.\nkey\n)\n;\nlet\n{\nrowProps\n,\nisPressed\n}\n=\nuseTableRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntr\nstyle\n=\n{\n{\nbackground\n:\nisSelected\n?\n'blueviolet'\n:\nisPressed\n?\n'var(--spectrum-global-color-gray-400)'\n:\nitem\n.\nindex\n%\n2\n?\n'var(--spectrum-alias-highlight-hover)'\n:\n'none'\n,\ncolor\n:\nisSelected\n?\n'white'\n:\nnull\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nimport\n{\nuseTableRow\n}\nfrom\n'react-aria'\n;\nfunction\nTableRow\n(\n{\nitem\n,\nchildren\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableRowElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nisSelected\n=\nstate\n.\nselectionManager\n.\nisSelected\n(\nitem\n.\nkey\n)\n;\nlet\n{\nrowProps\n,\nisPressed\n}\n=\nuseTableRow\n(\n{\nnode\n:\nitem\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntr\nstyle\n=\n{\n{\nbackground\n:\nisSelected\n?\n'blueviolet'\n:\nisPressed\n?\n'var(--spectrum-global-color-gray-400)'\n:\nitem\n.\nindex\n%\n2\n?\n'var(--spectrum-alias-highlight-hover)'\n:\n'none'\n,\ncolor\n:\nisSelected\n?\n'white'\n:\nnull\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n,\ncursor\n:\n'default'\n}\n}\n{\n...\nmergeProps\n(\nrowProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\ntr\n>\n)\n;\n}\nFinally, we'll use the\nuseTableCell\nhook to render each cell.\nUsers can use the left and right arrow keys to navigate to each cell in a row, as well as any focusable elements\nwithin a cell. This is indicated by the focus ring, as created with the\nuseFocusRing\nhook. The cell's contents are available in the\nrendered\nproperty of the cell\nNode\nobject.\nimport\n{\nuseTableCell\n}\nfrom\n'react-aria'\n;\nfunction\nTableCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntd\n{\n...\nmergeProps\n(\ngridCellProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncell\n.\nrendered\n}\n<\n/\ntd\n>\n)\n;\n}\nimport\n{\nuseTableCell\n}\nfrom\n'react-aria'\n;\nfunction\nTableCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntd\n{\n...\nmergeProps\n(\ngridCellProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncell\n.\nrendered\n}\n<\n/\ntd\n>\n)\n;\n}\nimport\n{\nuseTableCell\n}\nfrom\n'react-aria'\n;\nfunction\nTableCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\nisFocusVisible\n,\nfocusProps\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ntd\n{\n...\nmergeProps\n(\ngridCellProps\n,\nfocusProps\n)\n}\nstyle\n=\n{\n{\npadding\n:\n'5px 10px'\n,\noutline\n:\n'none'\n,\nboxShadow\n:\nisFocusVisible\n?\n'inset 0 0 0 2px orange'\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\ncell\n.\nrendered\n}\n<\n/\ntd\n>\n)\n;\n}\nWith all of the above components in place, we can render an example of our Table in action.\nThis example shows a static collection, where all of the data is hard coded.\nSee below\nfor examples of using this Table component with dynamic collections (e.g. from a server).\nTry tabbing into the table and navigating using the arrow keys.\n<\nTable\naria-label\n=\n\"Example static collection table\"\nstyle\n=\n{\n{\nheight\n:\n'210px'\n,\nmaxWidth\n:\n'400px'\n}\n}\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nDate Modified\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nGames\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n6/7/2020\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nProgram Files\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n4/7/2021\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nbootmgr\n<\n/\nCell\n>\n<\nCell\n>\nSystem file\n<\n/\nCell\n>\n<\nCell\n>\n11/20/2010\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nlog.txt\n<\n/\nCell\n>\n<\nCell\n>\nText Document\n<\n/\nCell\n>\n<\nCell\n>\n1/18/2016\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Example static collection table\"\nstyle\n=\n{\n{\nheight\n:\n'210px'\n,\nmaxWidth\n:\n'400px'\n}\n}\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nDate Modified\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nGames\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n6/7/2020\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nProgram Files\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n4/7/2021\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nbootmgr\n<\n/\nCell\n>\n<\nCell\n>\nSystem file\n<\n/\nCell\n>\n<\nCell\n>\n11/20/2010\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nlog.txt\n<\n/\nCell\n>\n<\nCell\n>\nText Document\n<\n/\nCell\n>\n<\nCell\n>\n1/18/2016\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Example static collection table\"\nstyle\n=\n{\n{\nheight\n:\n'210px'\n,\nmaxWidth\n:\n'400px'\n}\n}\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nDate Modified\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nGames\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n6/7/2020\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nProgram Files\n<\n/\nCell\n>\n<\nCell\n>\nFile folder\n<\n/\nCell\n>\n<\nCell\n>\n4/7/2021\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nbootmgr\n<\n/\nCell\n>\n<\nCell\n>\nSystem file\n<\n/\nCell\n>\n<\nCell\n>\n11/20/2010\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nlog.txt\n<\n/\nCell\n>\n<\nCell\n>\nText Document\n<\n/\nCell\n>\n<\nCell\n>\n1/18/2016\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\nAdding selection\n#\nNext, let's add support for selection. For multiple selection, we'll want to add a column of checkboxes to the left\nof the table to allow the user to select rows. This is done using the\nuseTableSelectionCheckbox\nhook. It is passed the\nparentKey\nof the cell, which refers to the row the cell is contained within. When the user\nchecks or unchecks the checkbox, the row will be added or removed from the Table's selection.\nThe\nCheckbox\ncomponent used in this example is independent and can be used separately from\nTable\n. The code is\navailable below. See\nuseCheckbox\nfor documentation.\nimport\n{\nuseTableSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nTableCheckboxCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectionCheckbox\n(\n{\nkey\n:\ncell\n.\nparentKey\n}\n,\nstate\n)\n;\nreturn\n(\n<\ntd\n{\n...\ngridCellProps\n}\nref\n=\n{\nref\n}\n>\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n<\n/\ntd\n>\n)\n;\n}\nimport\n{\nuseTableSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nTableCheckboxCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectionCheckbox\n(\n{\nkey\n:\ncell\n.\nparentKey\n}\n,\nstate\n)\n;\nreturn\n(\n<\ntd\n{\n...\ngridCellProps\n}\nref\n=\n{\nref\n}\n>\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n<\n/\ntd\n>\n)\n;\n}\nimport\n{\nuseTableSelectionCheckbox\n}\nfrom\n'react-aria'\n;\n// Reuse the Checkbox from your component library. See below for details.\nimport\n{\nCheckbox\n}\nfrom\n'your-component-library'\n;\nfunction\nTableCheckboxCell\n(\n{\ncell\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ngridCellProps\n}\n=\nuseTableCell\n(\n{\nnode\n:\ncell\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectionCheckbox\n(\n{\nkey\n:\ncell\n.\nparentKey\n}\n,\nstate\n)\n;\nreturn\n(\n<\ntd\n{\n...\ngridCellProps\n}\nref\n=\n{\nref\n}\n>\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n<\n/\ntd\n>\n)\n;\n}\nWe also want the user to be able to select all rows in the table at once. This is possible using the\n\u00e2\u008c\u0098 Cmd\n+\nA\nkeyboard shortcut, but we'll also add a checkbox into the table header to do this and represent the selection state visually.\nThis is done using the\nuseTableSelectAllCheckbox\nhook. When all rows are selected,\nthe checkbox will be shown as checked, and when only some rows are selected, the checkbox will be rendered in an indeterminate state.\nThe user can check or uncheck the checkbox to select all or clear the selection, respectively.\nNote\n: Always ensure that the cell has accessible content, even when the checkbox is hidden (i.e. in single selection mode). The\nVisuallyHidden\ncomponent can be used to do this.\nimport\n{\nuseTableSelectAllCheckbox\n,\nVisuallyHidden\n}\nfrom\n'react-aria'\n;\nfunction\nTableSelectAllCell\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectAllCheckbox\n(\nstate\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nref\n=\n{\nref\n}\n>\n{\nstate\n.\nselectionManager\n.\nselectionMode\n===\n'single'\n?\n<\nVisuallyHidden\n>\n{\ncheckboxProps\n[\n'aria-label'\n]\n}\n<\n/\nVisuallyHidden\n>\n:\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n}\n<\n/\nth\n>\n)\n;\n}\nimport\n{\nuseTableSelectAllCheckbox\n,\nVisuallyHidden\n}\nfrom\n'react-aria'\n;\nfunction\nTableSelectAllCell\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectAllCheckbox\n(\nstate\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nref\n=\n{\nref\n}\n>\n{\nstate\n.\nselectionManager\n.\nselectionMode\n===\n'single'\n?\n(\n<\nVisuallyHidden\n>\n{\ncheckboxProps\n[\n'aria-label'\n]\n}\n<\n/\nVisuallyHidden\n>\n)\n:\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n}\n<\n/\nth\n>\n)\n;\n}\nimport\n{\nuseTableSelectAllCheckbox\n,\nVisuallyHidden\n}\nfrom\n'react-aria'\n;\nfunction\nTableSelectAllCell\n(\n{\ncolumn\n,\nstate\n}\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nlet\n{\ncheckboxProps\n}\n=\nuseTableSelectAllCheckbox\n(\nstate\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nref\n=\n{\nref\n}\n>\n{\nstate\n.\nselectionManager\n.\nselectionMode\n===\n'single'\n?\n(\n<\nVisuallyHidden\n>\n{\ncheckboxProps\n[\n'aria-label'\n]\n}\n<\n/\nVisuallyHidden\n>\n)\n:\n(\n<\nCheckbox\n{\n...\ncheckboxProps\n}\n/\n>\n)\n}\n<\n/\nth\n>\n)\n;\n}\nThe following example shows how to enable multiple selection support using the Table component we built above.\nIt's as simple as setting the\nselectionMode\nprop to\n\"multiple\"\n. Because we set the\nshowSelectionCheckboxes\noption of\nuseTableState\nto true when multiple selection is enabled, an extra column for these checkboxes is\nautomatically added for us.\nAnd that's it! We now have a fully interactive table component that can support keyboard navigation, single or multiple selection,\nas well as column sorting. In addition, it is fully accessible for screen readers and other assistive technology. See below for more\nexamples of how to use the Table component that we've built.\n<\nTable\naria-label\n=\n\"Table with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Table with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Table with selection\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nType\n<\n/\nColumn\n>\n<\nColumn\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\nCheckbox\n#\nThe\nCheckbox\ncomponent used in the above example is used to implement row selection. It is built using the\nuseCheckbox\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n<\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nstate\n=\nuseToggleState\n(\nprops\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n/\n>\n;\n}\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n<\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nstate\n=\nuseToggleState\n(\nprops\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n/\n>\n)\n;\n}\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nfunction\nCheckbox\n(\nprops\n)\n{\nlet\nref\n=\nReact\n.\nuseRef\n<\n|\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nstate\n=\nuseToggleState\n(\nprops\n)\n;\nlet\n{\ninputProps\n}\n=\nuseCheckbox\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\ninput\n{\n...\ninputProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n/\n>\n)\n;\n}\nUsage\n#\nDynamic collections\n#\nSo far, our examples have shown static collections, where the data is hard coded.\nDynamic collections, as shown below, can be used when the table data comes from an external data source such as an API, or updates over time.\nIn the example below, both the columns and the rows are provided to the table via a render function. You can also make the columns static and\nonly the rows dynamic.\nfunction\nExampleTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nkey\n:\n'type'\n}\n,\n{\nname\n:\n'Date Modified'\n,\nkey\n:\n'date'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n,\ndate\n:\n'6/7/2020'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n,\ndate\n:\n'4/7/2021'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n,\ndate\n:\n'11/20/2010'\n,\ntype\n:\n'System file'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n,\ndate\n:\n'1/18/2016'\n,\ntype\n:\n'Text Document'\n}\n]\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example dynamic collection table\"\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\ncolumn\n=>\n(\n<\nColumn\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\nitem\n=>\n(\n<\nRow\n>\n{\ncolumnKey\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nfunction\nExampleTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nkey\n:\n'type'\n}\n,\n{\nname\n:\n'Date Modified'\n,\nkey\n:\n'date'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n,\ndate\n:\n'6/7/2020'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n,\ndate\n:\n'4/7/2021'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n,\ndate\n:\n'11/20/2010'\n,\ntype\n:\n'System file'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n,\ndate\n:\n'1/18/2016'\n,\ntype\n:\n'Text Document'\n}\n]\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example dynamic collection table\"\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nfunction\nExampleTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nkey\n:\n'type'\n}\n,\n{\nname\n:\n'Date Modified'\n,\nkey\n:\n'date'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Games'\n,\ndate\n:\n'6/7/2020'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Program Files'\n,\ndate\n:\n'4/7/2021'\n,\ntype\n:\n'File folder'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'bootmgr'\n,\ndate\n:\n'11/20/2010'\n,\ntype\n:\n'System file'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'log.txt'\n,\ndate\n:\n'1/18/2016'\n,\ntype\n:\n'Text Document'\n}\n]\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example dynamic collection table\"\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n(\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n)\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nSingle selection\n#\nBy default,\nuseTableState\ndoesn't allow row selection but this can be enabled using the\nselectionMode\nprop. Use\ndefaultSelectedKeys\nto provide a default set of selected rows.\nNote that the value of the selected keys must match the\nkey\nprop of the row.\nThe example below enables single selection mode, and uses\ndefaultSelectedKeys\nto select the row with key equal to \"2\".\nA user can click on a different row to change the selection, or click on the same row again to deselect it entirely.\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\n/\n>\nMultiple selection\n#\nMultiple selection can be enabled by setting\nselectionMode\nto\nmultiple\n.\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"multiple\"\ndefaultSelectedKeys\n=\n{\n[\n2\n,\n4\n]\n}\n/\n>\nDisallow empty selection\n#\nTable also supports a\ndisallowEmptySelection\nprop which forces the user to have at least one row in the Table selected at all times.\nIn this mode, if a single row is selected and the user presses it, it will not be deselected.\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\n// Using the example above\n<\nExampleTable\nselectionMode\n=\n\"single\"\ndefaultSelectedKeys\n=\n{\n[\n2\n]\n}\ndisallowEmptySelection\n/\n>\nControlled selection\n#\nTo programmatically control row selection, use the\nselectedKeys\nprop paired with the\nonSelectionChange\ncallback. The\nkey\nprop from the selected rows will\nbe passed into the callback when the row is pressed, allowing you to update state accordingly.\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nPokemonTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nuid\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nuid\n:\n'type'\n}\n,\n{\nname\n:\n'Level'\n,\nuid\n:\n'level'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n,\ntype\n:\n'Fire, Flying'\n,\nlevel\n:\n'67'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n,\ntype\n:\n'Water'\n,\nlevel\n:\n'56'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n,\ntype\n:\n'Grass, Poison'\n,\nlevel\n:\n'83'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n,\ntype\n:\n'Electric'\n,\nlevel\n:\n'100'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Table with controlled selection\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\nkey\n=\n{\ncolumn\n.\nuid\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nPokemonTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nuid\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nuid\n:\n'type'\n}\n,\n{\nname\n:\n'Level'\n,\nuid\n:\n'level'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n,\ntype\n:\n'Fire, Flying'\n,\nlevel\n:\n'67'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n,\ntype\n:\n'Water'\n,\nlevel\n:\n'56'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n,\ntype\n:\n'Grass, Poison'\n,\nlevel\n:\n'83'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n,\ntype\n:\n'Electric'\n,\nlevel\n:\n'100'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Table with controlled selection\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\nkey\n=\n{\ncolumn\n.\nuid\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nPokemonTable\n(\nprops\n)\n{\nlet\ncolumns\n=\n[\n{\nname\n:\n'Name'\n,\nuid\n:\n'name'\n}\n,\n{\nname\n:\n'Type'\n,\nuid\n:\n'type'\n}\n,\n{\nname\n:\n'Level'\n,\nuid\n:\n'level'\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Charizard'\n,\ntype\n:\n'Fire, Flying'\n,\nlevel\n:\n'67'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Blastoise'\n,\ntype\n:\n'Water'\n,\nlevel\n:\n'56'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Venusaur'\n,\ntype\n:\n'Grass, Poison'\n,\nlevel\n:\n'83'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Pikachu'\n,\ntype\n:\n'Electric'\n,\nlevel\n:\n'100'\n}\n]\n;\nlet\n[\nselectedKeys\n,\nsetSelectedKeys\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n2\n]\n)\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Table with controlled selection\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselectedKeys\n}\nonSelectionChange\n=\n{\nsetSelectedKeys\n}\n{\n...\nprops\n}\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\nkey\n=\n{\ncolumn\n.\nuid\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n(\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n)\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nDisabled rows\n#\nYou can disable specific rows by providing an array of keys to\nuseTableState\nvia the\ndisabledKeys\nprop. This will prevent rows from being selectable as shown in the example below.\nNote that you are responsible for the styling of disabled rows, however, the selection checkbox will be automatically disabled.\n// Using the same table as above\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\n// Using the same table as above\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\n// Using the same table as above\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\ndisabledKeys\n=\n{\n[\n3\n]\n}\n/\n>\nSelection behavior\n#\nBy default,\nuseTable\nuses the\n\"toggle\"\nselection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the\nSpace\nor\nEnter\nkeys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection. The\n\"toggle\"\nselection mode is often paired with a column of checkboxes in each row as an explicit affordance for selection.\nWhen the\nselectionBehavior\nprop is set to\n\"replace\"\n, clicking a row with the mouse\nreplaces\nthe selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as\nCtrl\n,\nCmd\n, and\nShift\ncan be used. To move focus without moving selection, the\nCtrl\nkey on Windows or the\nOption\nkey on macOS can be held while pressing the arrow keys. Holding this modifier while pressing the\nSpace\nkey toggles selection for the focused row, which allows multiple selection of non-contiguous items. On touch screen devices, selection always behaves as toggle since modifier keys may not be available. This behavior emulates native platforms such as macOS and Windows, and is often used when checkboxes in each row are not desired.\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\n<\nPokemonTable\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\n/\n>\nRow actions\n#\nuseTable\nsupports row actions via the\nonRowAction\nprop, which is useful for functionality such as navigation. In the default\n\"toggle\"\nselection behavior, when nothing is selected, clicking or tapping the row triggers the row action.\nWhen at least one item is selected, the table is in selection mode, and clicking or tapping a row toggles the selection. Actions may also be triggered via the\nEnter\nkey, and selection using the\nSpace\nkey.\nThis behavior is slightly different in the\n\"replace\"\nselection behavior, where single clicking selects the row and actions are performed via double click. On touch devices, the action becomes the primary tap interaction,\nand a long press enters into selection mode, which temporarily swaps the selection behavior to\n\"toggle\"\nto perform selection (you may wish to display checkboxes when this happens). Deselecting all items exits selection mode\nand reverts the selection behavior back to\n\"replace\"\n. Keyboard behaviors are unaffected.\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n'24px'\n}\n}\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and toggle selection behavior\"\nselectionMode\n=\n\"multiple\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n'24px'\n}\n}\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and toggle selection behavior\"\nselectionMode\n=\n\"multiple\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nflexWrap\n:\n'wrap'\n,\ngap\n:\n'24px'\n}\n}\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and toggle selection behavior\"\nselectionMode\n=\n\"multiple\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\nPokemonTable\naria-label\n=\n\"Pokemon table with row actions and replace selection behavior\"\nselectionMode\n=\n\"multiple\"\nselectionBehavior\n=\n\"replace\"\nonRowAction\n=\n{\n(\nkey\n)\n=>\nalert\n(\n`Opening item\n${\nkey\n}\n...`\n)\n}\n/\n>\n<\n/\ndiv\n>\nLinks\n#\nTable rows may also be links to another page or website. This can be achieved by passing the\nhref\nprop to the\n<Row>\ncomponent. Links behave the same way as described above for row actions depending on the\nselectionMode\nand\nselectionBehavior\n.\n<\nTable\naria-label\n=\n\"Bookmarks\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\nisRowHeader\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nURL\n<\n/\nColumn\n>\n<\nColumn\n>\nDate added\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nAdobe\n<\n/\nCell\n>\n<\nCell\n>\nhttps://adobe.com/\n<\n/\nCell\n>\n<\nCell\n>\nJanuary 28, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nGoogle\n<\n/\nCell\n>\n<\nCell\n>\nhttps://google.com/\n<\n/\nCell\n>\n<\nCell\n>\nApril 5, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://nytimes.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nNew York Times\n<\n/\nCell\n>\n<\nCell\n>\nhttps://nytimes.com/\n<\n/\nCell\n>\n<\nCell\n>\nJuly 12, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Bookmarks\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\nisRowHeader\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nURL\n<\n/\nColumn\n>\n<\nColumn\n>\nDate added\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nAdobe\n<\n/\nCell\n>\n<\nCell\n>\nhttps://adobe.com/\n<\n/\nCell\n>\n<\nCell\n>\nJanuary 28, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nGoogle\n<\n/\nCell\n>\n<\nCell\n>\nhttps://google.com/\n<\n/\nCell\n>\n<\nCell\n>\nApril 5, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://nytimes.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nNew York Times\n<\n/\nCell\n>\n<\nCell\n>\nhttps://nytimes.com/\n<\n/\nCell\n>\n<\nCell\n>\nJuly 12, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Bookmarks\"\nselectionMode\n=\n\"multiple\"\n>\n<\nTableHeader\n>\n<\nColumn\nisRowHeader\n>\nName\n<\n/\nColumn\n>\n<\nColumn\n>\nURL\n<\n/\nColumn\n>\n<\nColumn\n>\nDate added\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nAdobe\n<\n/\nCell\n>\n<\nCell\n>\nhttps://adobe.com/\n<\n/\nCell\n>\n<\nCell\n>\nJanuary 28,\n        2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nGoogle\n<\n/\nCell\n>\n<\nCell\n>\nhttps://google.com/\n<\n/\nCell\n>\n<\nCell\n>\nApril 5, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nhref\n=\n\"https://nytimes.com/\"\ntarget\n=\n\"_blank\"\n>\n<\nCell\n>\nNew York Times\n<\n/\nCell\n>\n<\nCell\n>\nhttps://nytimes.com/\n<\n/\nCell\n>\n<\nCell\n>\nJuly 12, 2023\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\nClient side routing\n#\nThe\n<Row>\ncomponent works with frameworks and client side routers like\nNext.js\nand\nReact Router\n. As with other React Aria components that support links, this works via the\nRouterProvider\ncomponent at the root of your app. See the\nframework setup guide\nto learn how to set this up.\nSorting\n#\nTable supports sorting its data when a column header is pressed. To designate that a Column should support sorting, provide it with\nthe\nallowsSorting\nprop. The Table accepts a\nsortDescriptor\nprop that defines the current column key to sort by and the sort direction (ascending/descending).\nWhen the user presses a sortable column header, the column's key and sort direction is passed into the\nonSortChange\ncallback, allowing you to update\nthe\nsortDescriptor\nappropriately.\nThis example performs client side sorting by passing a\nsort\nfunction to the\nuseAsyncList\nhook.\nSee the docs for more information on how to perform server side sorting.\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nCharacter\n{\nname\n:\nstring\n;\nheight\n:\nnumber\n;\nmass\n:\nnumber\n;\nbirth_year\n:\nnumber\n;\n}\nfunction\nAsyncSortTable\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nCharacter\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://swapi.py4e.com/api/people/?search`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n,\nasync\nsort\n(\n{\nitems\n,\nsortDescriptor\n}\n)\n{\nreturn\n{\nitems\n:\nitems\n.\nsort\n(\n(\na\n,\nb\n)\n=>\n{\nlet\nfirst\n=\na\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\nsecond\n=\nb\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\ncmp\n=\n(\nparseInt\n(\nfirst\n)\n||\nfirst\n)\n<\n(\nparseInt\n(\nsecond\n)\n||\nsecond\n)\n?\n-\n1\n:\n1\n;\nif\n(\nsortDescriptor\n.\ndirection\n===\n'descending'\n)\n{\ncmp\n*=\n-\n1\n;\n}\nreturn\ncmp\n;\n}\n)\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example table with client side sorting\"\nsortDescriptor\n=\n{\nlist\n.\nsortDescriptor\n}\nonSortChange\n=\n{\nlist\n.\nsort\n}\n>\n<\nTableHeader\n>\n<\nColumn\nkey\n=\n\"name\"\nallowsSorting\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"height\"\nallowsSorting\n>\nHeight\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"mass\"\nallowsSorting\n>\nMass\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"birth_year\"\nallowsSorting\n>\nBirth Year\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nCharacter\n{\nname\n:\nstring\n;\nheight\n:\nnumber\n;\nmass\n:\nnumber\n;\nbirth_year\n:\nnumber\n;\n}\nfunction\nAsyncSortTable\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nCharacter\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://swapi.py4e.com/api/people/?search`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n,\nasync\nsort\n(\n{\nitems\n,\nsortDescriptor\n}\n)\n{\nreturn\n{\nitems\n:\nitems\n.\nsort\n(\n(\na\n,\nb\n)\n=>\n{\nlet\nfirst\n=\na\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\nsecond\n=\nb\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\ncmp\n=\n(\nparseInt\n(\nfirst\n)\n||\nfirst\n)\n<\n(\nparseInt\n(\nsecond\n)\n||\nsecond\n)\n?\n-\n1\n:\n1\n;\nif\n(\nsortDescriptor\n.\ndirection\n===\n'descending'\n)\n{\ncmp\n*=\n-\n1\n;\n}\nreturn\ncmp\n;\n}\n)\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example table with client side sorting\"\nsortDescriptor\n=\n{\nlist\n.\nsortDescriptor\n}\nonSortChange\n=\n{\nlist\n.\nsort\n}\n>\n<\nTableHeader\n>\n<\nColumn\nkey\n=\n\"name\"\nallowsSorting\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"height\"\nallowsSorting\n>\nHeight\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"mass\"\nallowsSorting\n>\nMass\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"birth_year\"\nallowsSorting\n>\nBirth Year\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nimport\n{\nuseAsyncList\n}\nfrom\n'react-stately'\n;\ninterface\nCharacter\n{\nname\n:\nstring\n;\nheight\n:\nnumber\n;\nmass\n:\nnumber\n;\nbirth_year\n:\nnumber\n;\n}\nfunction\nAsyncSortTable\n(\n)\n{\nlet\nlist\n=\nuseAsyncList\n<\nCharacter\n>\n(\n{\nasync\nload\n(\n{\nsignal\n}\n)\n{\nlet\nres\n=\nawait\nfetch\n(\n`https://swapi.py4e.com/api/people/?search`\n,\n{\nsignal\n}\n)\n;\nlet\njson\n=\nawait\nres\n.\njson\n(\n)\n;\nreturn\n{\nitems\n:\njson\n.\nresults\n}\n;\n}\n,\nasync\nsort\n(\n{\nitems\n,\nsortDescriptor\n}\n)\n{\nreturn\n{\nitems\n:\nitems\n.\nsort\n(\n(\na\n,\nb\n)\n=>\n{\nlet\nfirst\n=\na\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\nsecond\n=\nb\n[\nsortDescriptor\n.\ncolumn\n]\n;\nlet\ncmp\n=\n(\nparseInt\n(\nfirst\n)\n||\nfirst\n)\n<\n(\nparseInt\n(\nsecond\n)\n||\nsecond\n)\n?\n-\n1\n:\n1\n;\nif\n(\nsortDescriptor\n.\ndirection\n===\n'descending'\n)\n{\ncmp\n*=\n-\n1\n;\n}\nreturn\ncmp\n;\n}\n)\n}\n;\n}\n}\n)\n;\nreturn\n(\n<\nTable\naria-label\n=\n\"Example table with client side sorting\"\nsortDescriptor\n=\n{\nlist\n.\nsortDescriptor\n}\nonSortChange\n=\n{\nlist\n.\nsort\n}\n>\n<\nTableHeader\n>\n<\nColumn\nkey\n=\n\"name\"\nallowsSorting\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"height\"\nallowsSorting\n>\nHeight\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"mass\"\nallowsSorting\n>\nMass\n<\n/\nColumn\n>\n<\nColumn\nkey\n=\n\"birth_year\"\nallowsSorting\n>\nBirth Year\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nlist\n.\nitems\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\nkey\n=\n{\nitem\n.\nname\n}\n>\n{\n(\ncolumnKey\n)\n=>\n(\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n)\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n)\n;\n}\nNested columns\n#\nColumns can be nested to create column groups. This will result in more than one header row to be created, with the\ncolSpan\nattribute of each column header cell set to the appropriate value so that the columns line up. Data for the leaf columns\nappears in each row of the table body.\nThis example also shows the use of the\nisRowHeader\nprop for\nColumn\n, which controls which columns are included in the\naccessibility name for each row. By default, only the first column is included, but in some cases more than one column may\nbe used to represent the row. In this example, the first and last name columns are combined to form the ARIA label for the row.\nOnly leaf columns may be marked as row headers.\n<\nTable\naria-label\n=\n\"Example table with nested columns\"\n>\n<\nTableHeader\n>\n<\nColumn\ntitle\n=\n\"Name\"\n>\n<\nColumn\nisRowHeader\n>\nFirst Name\n<\n/\nColumn\n>\n<\nColumn\nisRowHeader\n>\nLast Name\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\nColumn\ntitle\n=\n\"Information\"\n>\n<\nColumn\n>\nAge\n<\n/\nColumn\n>\n<\nColumn\n>\nBirthday\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nSam\n<\n/\nCell\n>\n<\nCell\n>\nSmith\n<\n/\nCell\n>\n<\nCell\n>\n36\n<\n/\nCell\n>\n<\nCell\n>\nMay 3\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nJulia\n<\n/\nCell\n>\n<\nCell\n>\nJones\n<\n/\nCell\n>\n<\nCell\n>\n24\n<\n/\nCell\n>\n<\nCell\n>\nFebruary 10\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nPeter\n<\n/\nCell\n>\n<\nCell\n>\nParker\n<\n/\nCell\n>\n<\nCell\n>\n28\n<\n/\nCell\n>\n<\nCell\n>\nSeptember 7\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nBruce\n<\n/\nCell\n>\n<\nCell\n>\nWayne\n<\n/\nCell\n>\n<\nCell\n>\n32\n<\n/\nCell\n>\n<\nCell\n>\nDecember 18\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Example table with nested columns\"\n>\n<\nTableHeader\n>\n<\nColumn\ntitle\n=\n\"Name\"\n>\n<\nColumn\nisRowHeader\n>\nFirst Name\n<\n/\nColumn\n>\n<\nColumn\nisRowHeader\n>\nLast Name\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\nColumn\ntitle\n=\n\"Information\"\n>\n<\nColumn\n>\nAge\n<\n/\nColumn\n>\n<\nColumn\n>\nBirthday\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nSam\n<\n/\nCell\n>\n<\nCell\n>\nSmith\n<\n/\nCell\n>\n<\nCell\n>\n36\n<\n/\nCell\n>\n<\nCell\n>\nMay 3\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nJulia\n<\n/\nCell\n>\n<\nCell\n>\nJones\n<\n/\nCell\n>\n<\nCell\n>\n24\n<\n/\nCell\n>\n<\nCell\n>\nFebruary 10\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nPeter\n<\n/\nCell\n>\n<\nCell\n>\nParker\n<\n/\nCell\n>\n<\nCell\n>\n28\n<\n/\nCell\n>\n<\nCell\n>\nSeptember 7\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nBruce\n<\n/\nCell\n>\n<\nCell\n>\nWayne\n<\n/\nCell\n>\n<\nCell\n>\n32\n<\n/\nCell\n>\n<\nCell\n>\nDecember 18\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\n<\nTable\naria-label\n=\n\"Example table with nested columns\"\n>\n<\nTableHeader\n>\n<\nColumn\ntitle\n=\n\"Name\"\n>\n<\nColumn\nisRowHeader\n>\nFirst Name\n<\n/\nColumn\n>\n<\nColumn\nisRowHeader\n>\nLast Name\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\nColumn\ntitle\n=\n\"Information\"\n>\n<\nColumn\n>\nAge\n<\n/\nColumn\n>\n<\nColumn\n>\nBirthday\n<\n/\nColumn\n>\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\n>\n<\nCell\n>\nSam\n<\n/\nCell\n>\n<\nCell\n>\nSmith\n<\n/\nCell\n>\n<\nCell\n>\n36\n<\n/\nCell\n>\n<\nCell\n>\nMay 3\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nJulia\n<\n/\nCell\n>\n<\nCell\n>\nJones\n<\n/\nCell\n>\n<\nCell\n>\n24\n<\n/\nCell\n>\n<\nCell\n>\nFebruary 10\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nPeter\n<\n/\nCell\n>\n<\nCell\n>\nParker\n<\n/\nCell\n>\n<\nCell\n>\n28\n<\n/\nCell\n>\n<\nCell\n>\nSeptember 7\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\n>\n<\nCell\n>\nBruce\n<\n/\nCell\n>\n<\nCell\n>\nWayne\n<\n/\nCell\n>\n<\nCell\n>\n32\n<\n/\nCell\n>\n<\nCell\n>\nDecember 18\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nTable\n>\nDynamic nested columns\n#\nNested columns can also be defined dynamically using the function syntax and the\nchildColumns\nprop.\nThe following example is the same as the example above, but defined dynamically.\ninterface\nColumnDefinition\n{\nname\n:\nstring\n,\nkey\n:\nstring\n,\nchildren\n?:\nColumnDefinition\n[\n]\n,\nisRowHeader\n?:\nboolean\n}\nlet\ncolumns\n:\nColumnDefinition\n[\n]\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n,\nchildren\n:\n[\n{\nname\n:\n'First Name'\n,\nkey\n:\n'first'\n,\nisRowHeader\n:\ntrue\n}\n,\n{\nname\n:\n'Last Name'\n,\nkey\n:\n'last'\n,\nisRowHeader\n:\ntrue\n}\n]\n}\n,\n{\nname\n:\n'Information'\n,\nkey\n:\n'info'\n,\nchildren\n:\n[\n{\nname\n:\n'Age'\n,\nkey\n:\n'age'\n}\n,\n{\nname\n:\n'Birthday'\n,\nkey\n:\n'birthday'\n}\n]\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nfirst\n:\n'Sam'\n,\nlast\n:\n'Smith'\n,\nage\n:\n36\n,\nbirthday\n:\n'May 3'\n}\n,\n{\nid\n:\n2\n,\nfirst\n:\n'Julia'\n,\nlast\n:\n'Jones'\n,\nage\n:\n24\n,\nbirthday\n:\n'February 10'\n}\n,\n{\nid\n:\n3\n,\nfirst\n:\n'Peter'\n,\nlast\n:\n'Parker'\n,\nage\n:\n28\n,\nbirthday\n:\n'September 7'\n}\n,\n{\nid\n:\n4\n,\nfirst\n:\n'Bruce'\n,\nlast\n:\n'Wayne'\n,\nage\n:\n32\n,\nbirthday\n:\n'December 18'\n}\n]\n;\n<\nTable\naria-label\n=\n\"Example table with dynamic nested columns\"\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\ncolumn\n=>\n(\n<\nColumn\nisRowHeader\n=\n{\ncolumn\n.\nisRowHeader\n}\nchildColumns\n=\n{\ncolumn\n.\nchildren\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\nitem\n=>\n(\n<\nRow\n>\n{\ncolumnKey\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\ninterface\nColumnDefinition\n{\nname\n:\nstring\n;\nkey\n:\nstring\n;\nchildren\n?:\nColumnDefinition\n[\n]\n;\nisRowHeader\n?:\nboolean\n;\n}\nlet\ncolumns\n:\nColumnDefinition\n[\n]\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n,\nchildren\n:\n[\n{\nname\n:\n'First Name'\n,\nkey\n:\n'first'\n,\nisRowHeader\n:\ntrue\n}\n,\n{\nname\n:\n'Last Name'\n,\nkey\n:\n'last'\n,\nisRowHeader\n:\ntrue\n}\n]\n}\n,\n{\nname\n:\n'Information'\n,\nkey\n:\n'info'\n,\nchildren\n:\n[\n{\nname\n:\n'Age'\n,\nkey\n:\n'age'\n}\n,\n{\nname\n:\n'Birthday'\n,\nkey\n:\n'birthday'\n}\n]\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nfirst\n:\n'Sam'\n,\nlast\n:\n'Smith'\n,\nage\n:\n36\n,\nbirthday\n:\n'May 3'\n}\n,\n{\nid\n:\n2\n,\nfirst\n:\n'Julia'\n,\nlast\n:\n'Jones'\n,\nage\n:\n24\n,\nbirthday\n:\n'February 10'\n}\n,\n{\nid\n:\n3\n,\nfirst\n:\n'Peter'\n,\nlast\n:\n'Parker'\n,\nage\n:\n28\n,\nbirthday\n:\n'September 7'\n}\n,\n{\nid\n:\n4\n,\nfirst\n:\n'Bruce'\n,\nlast\n:\n'Wayne'\n,\nage\n:\n32\n,\nbirthday\n:\n'December 18'\n}\n]\n;\n<\nTable\naria-label\n=\n\"Example table with dynamic nested columns\"\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\nisRowHeader\n=\n{\ncolumn\n.\nisRowHeader\n}\nchildColumns\n=\n{\ncolumn\n.\nchildren\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\ninterface\nColumnDefinition\n{\nname\n:\nstring\n;\nkey\n:\nstring\n;\nchildren\n?:\nColumnDefinition\n[\n]\n;\nisRowHeader\n?:\nboolean\n;\n}\nlet\ncolumns\n:\nColumnDefinition\n[\n]\n=\n[\n{\nname\n:\n'Name'\n,\nkey\n:\n'name'\n,\nchildren\n:\n[\n{\nname\n:\n'First Name'\n,\nkey\n:\n'first'\n,\nisRowHeader\n:\ntrue\n}\n,\n{\nname\n:\n'Last Name'\n,\nkey\n:\n'last'\n,\nisRowHeader\n:\ntrue\n}\n]\n}\n,\n{\nname\n:\n'Information'\n,\nkey\n:\n'info'\n,\nchildren\n:\n[\n{\nname\n:\n'Age'\n,\nkey\n:\n'age'\n}\n,\n{\nname\n:\n'Birthday'\n,\nkey\n:\n'birthday'\n}\n]\n}\n]\n;\nlet\nrows\n=\n[\n{\nid\n:\n1\n,\nfirst\n:\n'Sam'\n,\nlast\n:\n'Smith'\n,\nage\n:\n36\n,\nbirthday\n:\n'May 3'\n}\n,\n{\nid\n:\n2\n,\nfirst\n:\n'Julia'\n,\nlast\n:\n'Jones'\n,\nage\n:\n24\n,\nbirthday\n:\n'February 10'\n}\n,\n{\nid\n:\n3\n,\nfirst\n:\n'Peter'\n,\nlast\n:\n'Parker'\n,\nage\n:\n28\n,\nbirthday\n:\n'September 7'\n}\n,\n{\nid\n:\n4\n,\nfirst\n:\n'Bruce'\n,\nlast\n:\n'Wayne'\n,\nage\n:\n32\n,\nbirthday\n:\n'December 18'\n}\n]\n;\n<\nTable\naria-label\n=\n\"Example table with dynamic nested columns\"\n>\n<\nTableHeader\ncolumns\n=\n{\ncolumns\n}\n>\n{\n(\ncolumn\n)\n=>\n(\n<\nColumn\nisRowHeader\n=\n{\ncolumn\n.\nisRowHeader\n}\nchildColumns\n=\n{\ncolumn\n.\nchildren\n}\n>\n{\ncolumn\n.\nname\n}\n<\n/\nColumn\n>\n)\n}\n<\n/\nTableHeader\n>\n<\nTableBody\nitems\n=\n{\nrows\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nRow\n>\n{\n(\ncolumnKey\n)\n=>\n(\n<\nCell\n>\n{\nitem\n[\ncolumnKey\n]\n}\n<\n/\nCell\n>\n)\n}\n<\n/\nRow\n>\n)\n}\n<\n/\nTableBody\n>\n<\n/\nTable\n>\nResizable Columns\n#\nFor resizable column support, two additional hooks need to be added to the table implementation above. The\nuseTableColumnResizeState\nhook from\n@react-stately/table\nis responsible for initializing and tracking the widths of every column in your table, returning functions that you can use to\nupdate the column widths during a column resize operation. Note that this state is supplementary to the state returned by\nuseTableState\n.\nThe second column resizing hook is\nuseTableColumnResize\n. This hook handles the interactions for a table column's resizer\nelement, allowing the user to drag the resizer or use the keyboard arrows to expand the column's width. Be sure to pass the state returned by\nuseTableColumnResizeState\nto this hook so the tracked widths can be updated appropriately. We'll walk through all the required changes to the previous table implementation step by step below. For simplicity's sake, we'll be\nomitting support for selection, sorting, and nested columns.\nTable\n#\nAs mentioned previously, we first need to call\nuseTableColumnResizeState\nto initialize the widths for our table's columns.\nWe'll pass the state returned by\nuseTableColumnResizeState\nalong with any user defined\nonResize\nhandlers\nto our\nResizableTableColumnHeaders\nso it can be used by\nuseTableColumnResize\n.\nThe various style changes below are to add a wrapper div so the table is scrollable when the row content overflows and to support table body/column widths greater than the 300px applied to the table itself.\nimport\n{\nuseTableColumnResizeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCallback\n}\nfrom\n'react'\n;\nfunction\nResizableColumnsTable\n(\nprops\n)\n{\nlet\nstate\n=\nuseTableState\n(\nprops\n)\n;\nlet\nscrollRef\n=\nuseRef\n<\nHTMLDivElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\n{\n...\nprops\n,\n// The table wrapper is scrollable rather than just the body\nscrollRef\n}\n,\nstate\n,\nref\n)\n;\n// Set the minimum width of the columns to 40px\nlet\ngetDefaultMinWidth\n=\nuseCallback\n(\n(\n)\n=>\n{\nreturn\n40\n;\n}\n,\n[\n]\n)\n;\nlet\nlayoutState\n=\nuseTableColumnResizeState\n(\n{\n// Matches the width of the table itself\ntableWidth\n:\n300\n,\ngetDefaultMinWidth\n}\n,\nstate\n)\n;\nreturn\n(\n<\ndiv\nclassName\n=\n\"aria-table-wrapper\"\nref\n=\n{\nscrollRef\n}\n>\n<\ntable\n{\n...\ngridProps\n}\nclassName\n=\n\"aria-table\"\nref\n=\n{\nref\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\n(\n<\nResizableTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nprops\n.\nonResizeStart\n}\nonResize\n=\n{\nprops\n.\nonResize\n}\nonResizeEnd\n=\n{\nprops\n.\nonResizeEnd\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\n(\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\n{\nuseTableColumnResizeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCallback\n}\nfrom\n'react'\n;\nfunction\nResizableColumnsTable\n(\nprops\n)\n{\nlet\nstate\n=\nuseTableState\n(\nprops\n)\n;\nlet\nscrollRef\n=\nuseRef\n<\nHTMLDivElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\n{\n...\nprops\n,\n// The table wrapper is scrollable rather than just the body\nscrollRef\n}\n,\nstate\n,\nref\n)\n;\n// Set the minimum width of the columns to 40px\nlet\ngetDefaultMinWidth\n=\nuseCallback\n(\n(\n)\n=>\n{\nreturn\n40\n;\n}\n,\n[\n]\n)\n;\nlet\nlayoutState\n=\nuseTableColumnResizeState\n(\n{\n// Matches the width of the table itself\ntableWidth\n:\n300\n,\ngetDefaultMinWidth\n}\n,\nstate\n)\n;\nreturn\n(\n<\ndiv\nclassName\n=\n\"aria-table-wrapper\"\nref\n=\n{\nscrollRef\n}\n>\n<\ntable\n{\n...\ngridProps\n}\nclassName\n=\n\"aria-table\"\nref\n=\n{\nref\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\n(\n<\nResizableTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nprops\n.\nonResizeStart\n}\nonResize\n=\n{\nprops\n.\nonResize\n}\nonResizeEnd\n=\n{\nprops\n.\nonResizeEnd\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\n(\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\n{\nuseTableColumnResizeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCallback\n}\nfrom\n'react'\n;\nfunction\nResizableColumnsTable\n(\nprops\n)\n{\nlet\nstate\n=\nuseTableState\n(\nprops\n)\n;\nlet\nscrollRef\n=\nuseRef\n<\nHTMLDivElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncollection\n}\n=\nstate\n;\nlet\n{\ngridProps\n}\n=\nuseTable\n(\n{\n...\nprops\n,\n// The table wrapper is scrollable rather than just the body\nscrollRef\n}\n,\nstate\n,\nref\n)\n;\n// Set the minimum width of the columns to 40px\nlet\ngetDefaultMinWidth\n=\nuseCallback\n(\n(\n)\n=>\n{\nreturn\n40\n;\n}\n,\n[\n]\n)\n;\nlet\nlayoutState\n=\nuseTableColumnResizeState\n(\n{\n// Matches the width of the table itself\ntableWidth\n:\n300\n,\ngetDefaultMinWidth\n}\n,\nstate\n)\n;\nreturn\n(\n<\ndiv\nclassName\n=\n\"aria-table-wrapper\"\nref\n=\n{\nscrollRef\n}\n>\n<\ntable\n{\n...\ngridProps\n}\nclassName\n=\n\"aria-table\"\nref\n=\n{\nref\n}\n>\n<\nTableRowGroup\ntype\n=\n\"thead\"\n>\n{\ncollection\n.\nheaderRows\n.\nmap\n(\n(\nheaderRow\n)\n=>\n(\n<\nTableHeaderRow\nkey\n=\n{\nheaderRow\n.\nkey\n}\nitem\n=\n{\nheaderRow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nheaderRow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncolumn\n)\n=>\n(\n<\nResizableTableColumnHeader\nkey\n=\n{\ncolumn\n.\nkey\n}\ncolumn\n=\n{\ncolumn\n}\nstate\n=\n{\nstate\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nprops\n.\nonResizeStart\n}\nonResize\n=\n{\nprops\n.\nonResize\n}\nonResizeEnd\n=\n{\nprops\n.\nonResizeEnd\n}\n/\n>\n)\n)\n}\n<\n/\nTableHeaderRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\nTableRowGroup\ntype\n=\n\"tbody\"\n>\n{\n[\n...\ncollection\n.\nbody\n.\nchildNodes\n]\n.\nmap\n(\n(\nrow\n)\n=>\n(\n<\nTableRow\nkey\n=\n{\nrow\n.\nkey\n}\nitem\n=\n{\nrow\n}\nstate\n=\n{\nstate\n}\n>\n{\n[\n...\nrow\n.\nchildNodes\n]\n.\nmap\n(\n(\ncell\n)\n=>\n(\n<\nTableCell\nkey\n=\n{\ncell\n.\nkey\n}\ncell\n=\n{\ncell\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nTableRow\n>\n)\n)\n}\n<\n/\nTableRowGroup\n>\n<\n/\ntable\n>\n<\n/\ndiv\n>\n)\n;\n}\nShow CSS\n.\naria-table-wrapper\n{\nwidth\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n.\naria-table\n{\nborder-collapse\n:\ncollapse;\ntable-layout\n:\nfixed;\nwidth\n:\nfit-content;\n&\ntd\n{\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\n  }\n}\n.\naria-table-wrapper\n{\nwidth\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n.\naria-table\n{\nborder-collapse\n:\ncollapse;\ntable-layout\n:\nfixed;\nwidth\n:\nfit-content;\n&\ntd\n{\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\n  }\n}\n.\naria-table-wrapper\n{\nwidth\n:\n300\npx\n;\noverflow\n:\nauto;\n}\n\n.\naria-table\n{\nborder-collapse\n:\ncollapse;\ntable-layout\n:\nfixed;\nwidth\n:\nfit-content;\n&\ntd\n{\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\n  }\n}\nResizable table header\n#\nThe\nTableColumnHeader\nis where we see the bulk of the changes required to support resizable columns. First of all, we need to accommodate a\nResizer\nelement in every resizable column that\nthe user can drag or focus to perform a resize operation. Since the resizer will be a focusable element within the table header, we need to make the header title a focusable element as well so keyboard\nfocus won't be immediately sent to the resizer as you navigate between the column headers. Finally, we apply the computed width of our column from\nuseTableColumnResizeState\nto the header element.\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\nfunction\nResizableTableColumnHeader\n(\n{\ncolumn\n,\nstate\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n)\n{\nlet\nallowsResizing\n=\ncolumn\n.\nprops\n.\nallowsResizing\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nclassName\n=\n\"aria-table-headerCell\"\nstyle\n=\n{\n{\nwidth\n:\nlayoutState\n.\ngetColumnWidth\n(\ncolumn\n.\nkey\n)\n}\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nposition\n:\n'relative'\n}\n}\n>\n<\nButton\nclassName\n=\n\"aria-table-headerTitle\"\n>\n{\ncolumn\n.\nrendered\n}\n<\n/\nButton\n>\n{\nallowsResizing\n&&\n(\n<\nResizer\ncolumn\n=\n{\ncolumn\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nonResizeStart\n}\nonResize\n=\n{\nonResize\n}\nonResizeEnd\n=\n{\nonResizeEnd\n}\n/\n>\n)\n}\n<\n/\ndiv\n>\n<\n/\nth\n>\n)\n;\n}\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\nfunction\nResizableTableColumnHeader\n(\n{\ncolumn\n,\nstate\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n)\n{\nlet\nallowsResizing\n=\ncolumn\n.\nprops\n.\nallowsResizing\n;\nlet\nref\n=\nuseRef\n<\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nclassName\n=\n\"aria-table-headerCell\"\nstyle\n=\n{\n{\nwidth\n:\nlayoutState\n.\ngetColumnWidth\n(\ncolumn\n.\nkey\n)\n}\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nposition\n:\n'relative'\n}\n}\n>\n<\nButton\nclassName\n=\n\"aria-table-headerTitle\"\n>\n{\ncolumn\n.\nrendered\n}\n<\n/\nButton\n>\n{\nallowsResizing\n&&\n(\n<\nResizer\ncolumn\n=\n{\ncolumn\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nonResizeStart\n}\nonResize\n=\n{\nonResize\n}\nonResizeEnd\n=\n{\nonResizeEnd\n}\n/\n>\n)\n}\n<\n/\ndiv\n>\n<\n/\nth\n>\n)\n;\n}\n// Reuse the Button from your component library. See below for details.\nimport\n{\nButton\n}\nfrom\n'your-component-library'\n;\nfunction\nResizableTableColumnHeader\n(\n{\ncolumn\n,\nstate\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n)\n{\nlet\nallowsResizing\n=\ncolumn\n.\nprops\n.\nallowsResizing\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLTableCellElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\ncolumnHeaderProps\n}\n=\nuseTableColumnHeader\n(\n{\nnode\n:\ncolumn\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nth\n{\n...\ncolumnHeaderProps\n}\nclassName\n=\n\"aria-table-headerCell\"\nstyle\n=\n{\n{\nwidth\n:\nlayoutState\n.\ngetColumnWidth\n(\ncolumn\n.\nkey\n)\n}\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\nstyle\n=\n{\n{\ndisplay\n:\n'flex'\n,\nposition\n:\n'relative'\n}\n}\n>\n<\nButton\nclassName\n=\n\"aria-table-headerTitle\"\n>\n{\ncolumn\n.\nrendered\n}\n<\n/\nButton\n>\n{\nallowsResizing\n&&\n(\n<\nResizer\ncolumn\n=\n{\ncolumn\n}\nlayoutState\n=\n{\nlayoutState\n}\nonResizeStart\n=\n{\nonResizeStart\n}\nonResize\n=\n{\nonResize\n}\nonResizeEnd\n=\n{\nonResizeEnd\n}\n/\n>\n)\n}\n<\n/\ndiv\n>\n<\n/\nth\n>\n)\n;\n}\nShow CSS\n.\naria-table-headerCell\n{\npadding\n:\n5\npx\n10\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\nbox-sizing\n:\nborder-box;\nbox-shadow\n:\nnone;\ntext-align\n:\nleft;\n}\n\n.\naria-table-headerTitle\n{\nwidth\n:\n100\n%\n;\ntext-align\n:\nleft;\nborder\n:\nnone;\nbackground\n:\ntransparent;\nflex\n:\n1\n1\nauto;\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\nmargin-inline-start\n:\n-6\npx\n;\noutline\n:\nnone;\n}\n\n.\naria-table-headerTitle\n.\nfocus\n{\noutline\n:\n2\npx\nsolid orange;\n}\n.\naria-table-headerCell\n{\npadding\n:\n5\npx\n10\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\nbox-sizing\n:\nborder-box;\nbox-shadow\n:\nnone;\ntext-align\n:\nleft;\n}\n\n.\naria-table-headerTitle\n{\nwidth\n:\n100\n%\n;\ntext-align\n:\nleft;\nborder\n:\nnone;\nbackground\n:\ntransparent;\nflex\n:\n1\n1\nauto;\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\nmargin-inline-start\n:\n-6\npx\n;\noutline\n:\nnone;\n}\n\n.\naria-table-headerTitle\n.\nfocus\n{\noutline\n:\n2\npx\nsolid orange;\n}\n.\naria-table-headerCell\n{\npadding\n:\n5\npx\n10\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\nbox-sizing\n:\nborder-box;\nbox-shadow\n:\nnone;\ntext-align\n:\nleft;\n}\n\n.\naria-table-headerTitle\n{\nwidth\n:\n100\n%\n;\ntext-align\n:\nleft;\nborder\n:\nnone;\nbackground\n:\ntransparent;\nflex\n:\n1\n1\nauto;\noverflow\n:\nhidden;\nwhite-space\n:\nnowrap;\ntext-overflow\n:\nellipsis;\nmargin-inline-start\n:\n-6\npx\n;\noutline\n:\nnone;\n}\n\n.\naria-table-headerTitle\n.\nfocus\n{\noutline\n:\n2\npx\nsolid orange;\n}\nButton\n#\nThe\nButton\ncomponent is used in the above example to represent the table column header title. It is built using the\nuseButton\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nmergeProps\n(\nbuttonProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nprops\n.\nclassName\n}\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n`\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nmergeProps\n(\nbuttonProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nprops\n.\nclassName\n}\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n`\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nmergeProps\n(\nbuttonProps\n,\nfocusProps\n)\n}\nref\n=\n{\nref\n}\nclassName\n=\n{\n`\n${\nprops\n.\nclassName\n}\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n`\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nResizer\n#\nAs described above, we need to implement an element that the user can drag/interact with to resize a column. Here we'll use the\nuseTableColumnResize\nhook to create a visible resizer div for physical drag operations and a visually hidden input responsible for keyboard and screenreader interactions, similar to a\nslider\n.\nUsers can press and drag on the visible resizer to trigger the\nonResize\ncallbacks and update the tracked column widths accordingly. When focused, keyboard users can begin resizing the column by pressing\nEnter\n.\nOnce resizing is activated, they can use the arrow keys to trigger the same resize events and press\nEnter\n,\nEsc\n, or\nSpace\nto exit resizing. Touch screen reader users can swipe\nleft or right to focus the column's resizer input and swipe up and down to resize the column.\nimport\n{\nuseTableColumnResize\n}\nfrom\n'react-aria'\n;\nfunction\nResizer\n(\nprops\n)\n{\nlet\n{\ncolumn\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nresizerProps\n,\ninputProps\n,\nisResizing\n}\n=\nuseTableColumnResize\n(\n{\ncolumn\n,\n'aria-label'\n:\n'Resizer'\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n,\nlayoutState\n,\nref\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ndiv\nrole\n=\n\"presentation\"\nclassName\n=\n{\n`aria-table-resizer\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n${\nisResizing\n?\n'resizing'\n:\n''\n}\n`\n}\n{\n...\nresizerProps\n}\n>\n<\ninput\nref\n=\n{\nref\n}\n{\n...\nmergeProps\n(\ninputProps\n,\nfocusProps\n)\n}\n/\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\n{\nuseTableColumnResize\n}\nfrom\n'react-aria'\n;\nfunction\nResizer\n(\nprops\n)\n{\nlet\n{\ncolumn\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nresizerProps\n,\ninputProps\n,\nisResizing\n}\n=\nuseTableColumnResize\n(\n{\ncolumn\n,\n'aria-label'\n:\n'Resizer'\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n,\nlayoutState\n,\nref\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ndiv\nrole\n=\n\"presentation\"\nclassName\n=\n{\n`aria-table-resizer\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n${\nisResizing\n?\n'resizing'\n:\n''\n}\n`\n}\n{\n...\nresizerProps\n}\n>\n<\ninput\nref\n=\n{\nref\n}\n{\n...\nmergeProps\n(\ninputProps\n,\nfocusProps\n)\n}\n/\n>\n<\n/\ndiv\n>\n)\n;\n}\nimport\n{\nuseTableColumnResize\n}\nfrom\n'react-aria'\n;\nfunction\nResizer\n(\nprops\n)\n{\nlet\n{\ncolumn\n,\nlayoutState\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLInputElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nresizerProps\n,\ninputProps\n,\nisResizing\n}\n=\nuseTableColumnResize\n(\n{\ncolumn\n,\n'aria-label'\n:\n'Resizer'\n,\nonResizeStart\n,\nonResize\n,\nonResizeEnd\n}\n,\nlayoutState\n,\nref\n)\n;\nlet\n{\nfocusProps\n,\nisFocusVisible\n}\n=\nuseFocusRing\n(\n)\n;\nreturn\n(\n<\ndiv\nrole\n=\n\"presentation\"\nclassName\n=\n{\n`aria-table-resizer\n${\nisFocusVisible\n?\n'focus'\n:\n''\n}\n${\nisResizing\n?\n'resizing'\n:\n''\n}\n`\n}\n{\n...\nresizerProps\n}\n>\n<\ninput\nref\n=\n{\nref\n}\n{\n...\nmergeProps\n(\ninputProps\n,\nfocusProps\n)\n}\n/\n>\n<\n/\ndiv\n>\n)\n;\n}\nShow CSS\n.\naria-table-resizer\n{\nwidth\n:\n15\npx\n;\nbackground-color\n:\ngrey;\ncursor\n:\ncol-resize;\nheight\n:\n30\npx\n;\ntouch-action\n:\nnone;\nflex\n:\n0\n0\nauto;\nbox-sizing\n:\nborder-box;\nborder\n:\n5\npx\n;\nborder-style\n:\nnone solid;\nborder-color\n:\ntransparent;\nbackground-clip\n:\ncontent-box;\n}\n\n.\naria-table-resizer\n.\nfocus\n{\nbackground-color\n:\norange;\n}\n\n.\naria-table-resizer\n.\nresizing\n{\nborder-color\n:\norange;\nbackground-color\n:\ntransparent;\n}\n.\naria-table-resizer\n{\nwidth\n:\n15\npx\n;\nbackground-color\n:\ngrey;\ncursor\n:\ncol-resize;\nheight\n:\n30\npx\n;\ntouch-action\n:\nnone;\nflex\n:\n0\n0\nauto;\nbox-sizing\n:\nborder-box;\nborder\n:\n5\npx\n;\nborder-style\n:\nnone solid;\nborder-color\n:\ntransparent;\nbackground-clip\n:\ncontent-box;\n}\n\n.\naria-table-resizer\n.\nfocus\n{\nbackground-color\n:\norange;\n}\n\n.\naria-table-resizer\n.\nresizing\n{\nborder-color\n:\norange;\nbackground-color\n:\ntransparent;\n}\n.\naria-table-resizer\n{\nwidth\n:\n15\npx\n;\nbackground-color\n:\ngrey;\ncursor\n:\ncol-resize;\nheight\n:\n30\npx\n;\ntouch-action\n:\nnone;\nflex\n:\n0\n0\nauto;\nbox-sizing\n:\nborder-box;\nborder\n:\n5\npx\n;\nborder-style\n:\nnone solid;\nborder-color\n:\ntransparent;\nbackground-clip\n:\ncontent-box;\n}\n\n.\naria-table-resizer\n.\nfocus\n{\nbackground-color\n:\norange;\n}\n\n.\naria-table-resizer\n.\nresizing\n{\nborder-color\n:\norange;\nbackground-color\n:\ntransparent;\n}\nAnd with that, all necessary changes to the previous table implementation have been made and we now have a table that supports resizable columns!\nThe example below supports resizing via mouse, keyboard, touch, and screen reader interactions. To see an example with sorting and selection, see the\nstyled example\n!\n<\nResizableColumnsTable\naria-label\n=\n\"Table with resizable columns\"\n>\n<\nTableHeader\n>\n<\nColumn\nallowsResizing\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nType\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nResizableColumnsTable\n>\n<\nResizableColumnsTable\naria-label\n=\n\"Table with resizable columns\"\n>\n<\nTableHeader\n>\n<\nColumn\nallowsResizing\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nType\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nResizableColumnsTable\n>\n<\nResizableColumnsTable\naria-label\n=\n\"Table with resizable columns\"\n>\n<\nTableHeader\n>\n<\nColumn\nallowsResizing\n>\nName\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nType\n<\n/\nColumn\n>\n<\nColumn\nallowsResizing\n>\nLevel\n<\n/\nColumn\n>\n<\n/\nTableHeader\n>\n<\nTableBody\n>\n<\nRow\nkey\n=\n\"1\"\n>\n<\nCell\n>\nCharizard\n<\n/\nCell\n>\n<\nCell\n>\nFire, Flying\n<\n/\nCell\n>\n<\nCell\n>\n67\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"2\"\n>\n<\nCell\n>\nBlastoise\n<\n/\nCell\n>\n<\nCell\n>\nWater\n<\n/\nCell\n>\n<\nCell\n>\n56\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"3\"\n>\n<\nCell\n>\nVenusaur\n<\n/\nCell\n>\n<\nCell\n>\nGrass, Poison\n<\n/\nCell\n>\n<\nCell\n>\n83\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\nRow\nkey\n=\n\"4\"\n>\n<\nCell\n>\nPikachu\n<\n/\nCell\n>\n<\nCell\n>\nElectric\n<\n/\nCell\n>\n<\nCell\n>\n100\n<\n/\nCell\n>\n<\n/\nRow\n>\n<\n/\nTableBody\n>\n<\n/\nResizableColumnsTable\n>\nStyled examples\n#\nTailwind CSS\nA table supporting resizable columns, selection, and sorting built with Tailwind and React Aria.\nInternationalization\n#\nuseTable\nhandles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\nIntl.Collator\nfor internationalized string matching, and keyboard navigation is mirrored in right-to-left languages.\nYou are responsible for localizing all text content within the table.\nRTL\n#\nIn right-to-left languages, the table layout should be mirrored. The columns should be ordered from right to left and the\nindividual column text alignment should be inverted. Ensure that your CSS accounts for this.\nName\nType\nDefault\nDescription\nlayoutDelegate\nLayoutDelegate\n\u00e2\u0080\u0094\nThe layout object for the table. Computes what content is visible and how to position and style them.\nisVirtualized\nboolean\n\u00e2\u0080\u0094\nWhether the grid uses virtual scrolling.\ndisallowTypeAhead\nboolean\nfalse\nWhether typeahead navigation is disabled.\nkeyboardDelegate\nKeyboardDelegate\n\u00e2\u0080\u0094\nAn optional keyboard delegate implementation for type to select,\nto override the default.\nfocusMode\n'row'\n|\u00c2\n'cell'\n'row'\nWhether initial grid focus should be placed on the grid row or grid cell.\ngetRowText\n(\n(\nkey\n:\nKey\n)\n)\n=>\nstring\n(key) => state.collection.getItem(key)?.textValue\nA function that returns the text that should be announced by assistive technology when a row is added or removed from selection.\nscrollRef\nRefObject\n<\nHTMLElement\n|\u00c2\nnull\n>\n\u00e2\u0080\u0094\nThe ref attached to the scrollable body. Used to provided automatic scrolling on item focus for non-virtualized grids.\nonRowAction\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a user performs an action on the row.\nonCellAction\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a user performs an action on the cell.\nescapeKeyBehavior\n'clearSelection'\n|\u00c2\n'none'\n'clearSelection'\nWhether pressing the escape key should clear selection in the grid or not.\nMost experiences should not modify this option as it eliminates a keyboard user's ability to\neasily clear selection. Only use if the escape key is being handled externally or should not\ntrigger selection clearing contextually.\nshouldSelectOnPressUp\nboolean\n\u00e2\u0080\u0094\nWhether selection should occur on press up instead of press down.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nA LayoutDelegate provides layout information for collection items.\nMethod\nDescription\ngetItemRect\n(\n(\nkey\n:\nKey\n)\n)\n:\nRect\n|\u00c2\nnull\nReturns a rectangle for the item with the given key.\ngetVisibleRect\n(\n)\n:\nRect\nReturns the visible rectangle of the collection.\ngetContentSize\n(\n)\n:\nSize\nReturns the size of the scrollable content in the collection.\ngetKeyRange\n(\n(\nfrom\n:\nKey\n,\n,\nto\n:\nKey\n)\n)\n:\nKey\n[]\nReturns a list of keys between\nfrom\nand\nto\n.\nName\nType\nDescription\nx\nnumber\ny\nnumber\nwidth\nnumber\nheight\nnumber\nName\nType\nDescription\nwidth\nnumber\nheight\nnumber\nProperties\nName\nType\nDescription\nvirtualizer\nDeprecatedVirtualizer\nMethods\nMethod\nDescription\ngetLayoutInfo\n(\n(\nkey\n:\nKey\n)\n)\n:\nDeprecatedLayoutInfo\ngetContentSize\n(\n)\n:\nSize\nstring\n|\u00c2\nnumber\nName\nType\nDescription\nrect\nRect\nName\nType\nDescription\nvisibleRect\nRect\nMethod\nDescription\ngetKeyBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually below the given one, or\nnull\nfor none.\ngetKeyAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually above the given one, or\nnull\nfor none.\ngetKeyLeftOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the left of the given one, or\nnull\nfor none.\ngetKeyRightOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the right of the given one, or\nnull\nfor none.\ngetKeyPageBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page below the given one, or\nnull\nfor none.\ngetKeyPageAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page above the given one, or\nnull\nfor none.\ngetFirstKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the first key, or\nnull\nfor none.\ngetLastKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the last key, or\nnull\nfor none.\ngetKeyForSearch\n(\n(\nsearch\n:\nstring\n,\n,\nfromKey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the next key after\nfromKey\nthat matches the given search string, or\nnull\nfor none.\nName\nType\nDescription\ncurrent\nT\nProperties\nName\nType\nDescription\ncollection\nTableCollection\n<\nT\n>\nA collection of rows and columns in the table.\nshowSelectionCheckboxes\nboolean\nWhether the row selection checkboxes should be displayed.\nsortDescriptor\nSortDescriptor\n|\u00c2\nnull\nThe current sorted column and direction.\nisKeyboardNavigationDisabled\nboolean\nWhether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell.\nsetKeyboardNavigationDisabled\n(\n(\nval\n:\nboolean\n)\n)\n=>\nvoid\nSet whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell.\ndisabledKeys\nSet\n<\nKey\n>\nA set of keys for rows that are disabled.\nselectionManager\nSelectionManager\nA selection manager to read and update row selection state.\nMethods\nMethod\nDescription\nsort\n(\n(\ncolumnKey\n:\nKey\n,\n,\ndirection\n?\n:\n'ascending'\n|\u00c2\n|\u00c2\n'descending'\n)\n)\n:\nvoid\nCalls the provided onSortChange handler with the provided column key and sort direction.\nProperties\nName\nType\nDescription\nheaderRows\nGridNode\n<\nT\n>\n[]\nA list of header row nodes in the table.\ncolumns\nGridNode\n<\nT\n>\n[]\nA list of column nodes in the table.\nrowHeaderColumnKeys\nSet\n<\nKey\n>\nA set of column keys that serve as the\nrow header\n.\nbody\nGridNode\n<\nT\n>\nThe node that makes up the body of the table.\ncolumnCount\nnumber\nThe number of columns in the grid.\nrows\nGridNode\n<\nT\n>\n[]\nA list of rows in the grid.\nsize\nnumber\nThe number of items in the collection.\nhead\nGridNode\n<\nT\n>\nThe node that makes up the header of the table.\nMethods\nMethod\nDescription\ngetKeys\n(\n)\n:\nIterable\n<\nKey\n>\nIterate over all keys in the collection.\ngetItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nGridNode\n<\nT\n>\n|\u00c2\nnull\nGet an item by its key.\nat\n(\n(\nidx\n:\nnumber\n)\n)\n:\nGridNode\n<\nT\n>\n|\u00c2\nnull\nGet an item by the index of its key.\ngetKeyBefore\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes before the given key in the collection.\ngetKeyAfter\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes after the given key in the collection.\ngetFirstKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the first key in the collection.\ngetLastKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the last key in the collection.\ngetChildren\n(\n(\nkey\n:\nKey\n)\n)\n:\nIterable\n<\nGridNode\n<\nT\n>\n>\nIterate over the child items of the given key.\ngetTextValue\n(\n(\nkey\n:\nKey\n)\n)\n:\nstring\nReturns a string representation of the item's contents.\nfilter\n(\n(\nfilterFn\n:\n(\n(\nnodeValue\n:\nstring\n,\n,\nnode\n:\nGridNode\n<\nT\n>\n)\n)\n=>\nboolean\n)\n)\n:\nCollection\n<\nGridNode\n<\nT\n>\n>\nFilters the collection using the given function.\nName\nType\nDescription\ntype\nstring\nThe type of item this node represents.\nkey\nKey\nA unique key for the node.\nvalue\nT\n|\u00c2\nnull\nThe object value the node was created from.\nlevel\nnumber\nThe level of depth this node is at in the hierarchy.\nhasChildNodes\nboolean\nWhether this item has children, even if not loaded yet.\nrendered\nReactNode\nThe rendered contents of this node (e.g. JSX).\ntextValue\nstring\nA string value for this node, used for features like typeahead.\nindex\nnumber\nThe index of this node within its parent.\ncolumn\nGridNode\n<\nT\n>\ncolSpan\nnumber\n|\u00c2\nnull\nThe number of columns spanned by this cell.\ncolIndex\nnumber\n|\u00c2\nnull\nThe column index of this cell, accounting for any colSpans.\nindexOfType\nnumber\nThe index of this node within its parent, ignoring sibling nodes that aren't of the same type.\naria-label\nstring\nAn accessibility label for this node.\nwrapper\n(\n(\nelement\n:\nReactElement\n)\n)\n=>\nReactElement\nA function that should be called to wrap the rendered node.\nparentKey\nKey\n|\u00c2\nnull\nThe key of the parent node.\nprevKey\nKey\n|\u00c2\nnull\nThe key of the node before this node.\nnextKey\nKey\n|\u00c2\nnull\nThe key of the node after this node.\nprops\nany\nAdditional properties specific to a particular node type.\nrender\n(\n(\nnode\n:\nNode\n<\nany\n>\n)\n)\n=>\nReactElement\nA function that renders this node to a React Element in the DOM.\nName\nType\nDescription\ntype\nstring\nThe type of item this node represents.\nkey\nKey\nA unique key for the node.\nvalue\nT\n|\u00c2\nnull\nThe object value the node was created from.\nlevel\nnumber\nThe level of depth this node is at in the hierarchy.\nhasChildNodes\nboolean\nWhether this item has children, even if not loaded yet.\nrendered\nReactNode\nThe rendered contents of this node (e.g. JSX).\ntextValue\nstring\nA string value for this node, used for features like typeahead.\nindex\nnumber\nThe index of this node within its parent.\naria-label\nstring\nAn accessibility label for this node.\nwrapper\n(\n(\nelement\n:\nReactElement\n)\n)\n=>\nReactElement\nA function that should be called to wrap the rendered node.\nparentKey\nKey\n|\u00c2\nnull\nThe key of the parent node.\nprevKey\nKey\n|\u00c2\nnull\nThe key of the node before this node.\nnextKey\nKey\n|\u00c2\nnull\nThe key of the node after this node.\nprops\nany\nAdditional properties specific to a particular node type.\nrender\n(\n(\nnode\n:\nNode\n<\nany\n>\n)\n)\n=>\nReactElement\nA function that renders this node to a React Element in the DOM.\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\nExtends\n:\nIterable\nProperties\nName\nType\nDescription\nsize\nnumber\nThe number of items in the collection.\nMethods\nMethod\nDescription\ngetKeys\n(\n)\n:\nIterable\n<\nKey\n>\nIterate over all keys in the collection.\ngetItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by its key.\nat\n(\n(\nidx\n:\nnumber\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by the index of its key.\ngetKeyBefore\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes before the given key in the collection.\ngetKeyAfter\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes after the given key in the collection.\ngetFirstKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the first key in the collection.\ngetLastKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the last key in the collection.\ngetChildren\n(\n(\nkey\n:\nKey\n)\n)\n:\nIterable\n<\nT\n>\nIterate over the child items of the given key.\ngetTextValue\n(\n(\nkey\n:\nKey\n)\n)\n:\nstring\nReturns a string representation of the item's contents.\nfilter\n(\n(\nfilterFn\n:\n(\n(\nnodeValue\n:\nstring\n,\n,\nnode\n:\nT\n)\n)\n=>\nboolean\n)\n)\n:\nCollection\n<\nT\n>\nFilters the collection using the given function.\nName\nType\nDescription\ncolumn\nKey\nThe key of the column to sort by.\ndirection\nSortDirection\nThe direction to sort by.\n'ascending'\n|\u00c2\n'descending'\nAn interface for reading and updating multiple selection state.\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nunknown\n>\n>\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nselectedKeys\nSet\n<\nKey\n>\nThe currently selected keys in the collection.\nrawSelection\nSelection\nThe raw selection value for the collection.\nEither 'all' for select all, or a set of keys.\nisEmpty\nboolean\nWhether the selection is empty.\nisSelectAll\nboolean\nWhether all items in the collection are selected.\nfirstSelectedKey\nKey\n|\u00c2\nnull\nlastSelectedKey\nKey\n|\u00c2\nnull\ndisabledKeys\nSet\n<\nKey\n>\ndisabledBehavior\nDisabledBehavior\nMethods\nMethod\nDescription\nconstructor\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n,\nstate\n:\nMultipleSelectionState\n,\noptions\n?\n:\nSelectionManagerOptions\n)\n:\nvoid\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchildFocusStrategy\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key.\nisSelected\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nReturns whether a key is selected.\nextendSelection\n(\n(\ntoKey\n:\nKey\n)\n)\n:\nvoid\nExtends the selection to the given key.\ntoggleSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles whether the given key is selected.\nreplaceSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nReplaces the selection with only the given key.\nsetSelectedKeys\n(\n(\nkeys\n:\nIterable\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the selection with the given keys.\nselectAll\n(\n)\n:\nvoid\nSelects all items in the collection.\nclearSelection\n(\n)\n:\nvoid\nRemoves all keys from the selection.\ntoggleSelectAll\n(\n)\n:\nvoid\nToggles between select all and an empty selection.\nselect\n(\n(\nkey\n:\nKey\n,\n,\ne\n?\n:\nPressEvent\n|\u00c2\nLongPressEvent\n|\u00c2\nPointerEvent\n)\n)\n:\nvoid\nisSelectionEqual\n(\n(\nselection\n:\nSet\n<\nKey\n>\n)\n)\n:\nboolean\nReturns whether the current selection is equal to the given selection.\ncanSelectItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisDisabled\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisLink\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\ngetItemProps\n(\n(\nkey\n:\nKey\n)\n)\n:\nany\nwithCollection\n(\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n)\n)\n:\nSelectionManager\nProperties\nName\nType\nDescription\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\nSelection\nThe currently selected keys in the collection.\ndisabledKeys\nSet\n<\nKey\n>\nThe currently disabled keys in the collection.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to selection, actions, or both.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nMethods\nMethod\nDescription\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetSelectedKeys\n(\n(\nkeys\n:\nSelection\n)\n)\n:\nvoid\nSets the selected keys in the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchild\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key, and optionally, whether the first or last child of that key should receive focus.\n'none'\n|\u00c2\n'single'\n|\u00c2\n'multiple'\n'toggle'\n|\u00c2\n'replace'\n'all'\n|\u00c2\nSet\n<\nKey\n>\n'selection'\n|\u00c2\n'all'\n'first'\n|\u00c2\n'last'\nName\nType\nDescription\nallowsCellSelection\nboolean\nlayoutDelegate\nLayoutDelegate\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nName\nType\nDescription\ntype\n'longpressstart'\n|\u00c2\n'longpressend'\n|\u00c2\n'longpress'\nThe type of long press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nProperties\nName\nType\nDescription\nexpandedKeys\n'all'\n|\u00c2\nSet\n<\nKey\n>\nA set of keys for items that are expanded.\nkeyMap\nMap\n<\nKey\n,\nGridNode\n<\nT\n>\n>\nThe key map containing nodes representing the collection's tree grid structure.\nuserColumnCount\nnumber\nThe number of leaf columns provided by the user.\ncollection\nTableCollection\n<\nT\n>\nA collection of rows and columns in the table.\nshowSelectionCheckboxes\nboolean\nWhether the row selection checkboxes should be displayed.\nsortDescriptor\nSortDescriptor\n|\u00c2\nnull\nThe current sorted column and direction.\nisKeyboardNavigationDisabled\nboolean\nWhether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell.\nsetKeyboardNavigationDisabled\n(\n(\nval\n:\nboolean\n)\n)\n=>\nvoid\nSet whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell.\ndisabledKeys\nSet\n<\nKey\n>\nA set of keys for rows that are disabled.\nselectionManager\nSelectionManager\nA selection manager to read and update row selection state.\nMethods\nMethod\nDescription\ntoggleKey\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles the expanded state for a row by its key.\nsort\n(\n(\ncolumnKey\n:\nKey\n,\n,\ndirection\n?\n:\n'ascending'\n|\u00c2\n|\u00c2\n'descending'\n)\n)\n:\nvoid\nCalls the provided onSortChange handler with the provided column key and sort direction.\nName\nType\nDescription\ngridProps\nDOMAttributes\nProps for the grid element.\nAll DOM attributes supported across both HTML and SVG elements.\nExtends\n:\nAriaAttributes\n,\nReactDOMAttributes\nName\nType\nDescription\nid\nstring\n|\u00c2\nundefined\nrole\nAriaRole\n|\u00c2\nundefined\ntabIndex\nnumber\n|\u00c2\nundefined\nstyle\nCSSProperties\n|\u00c2\nundefined\nclassName\nstring\n|\u00c2\nundefined\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nName\nType\nDescription\nrowGroupProps\nDOMAttributes\nProps for the row group element.\nName\nType\nDescription\nnode\nGridNode\n<\nT\n>\nAn object representing the grid row. Contains all the relevant information that makes up the grid row.\nisVirtualized\nboolean\nWhether the grid row is contained in a virtual scroller.\nshouldSelectOnPressUp\nboolean\nWhether selection should occur on press up instead of press down.\nName\nType\nDescription\nrowProps\nDOMAttributes\nProps for the grid row element.\nName\nType\nDescription\nnode\nGridNode\n<\nT\n>\nAn object representing the\ncolumn header\n. Contains all the relevant information that makes up the column header.\nisVirtualized\nboolean\nWhether the\ncolumn header\nis contained in a virtual scroller.\nName\nType\nDescription\ncolumnHeaderProps\nDOMAttributes\nProps for the\ncolumn header\nelement.\nisPressed\nboolean\nWhether the column is currently in a pressed state.\nName\nType\nDescription\nrowProps\nDOMAttributes\nProps for the grid row element.\nisPressed\nboolean\nWhether the row is currently in a pressed state.\nisSelected\nboolean\nWhether the item is currently selected.\nisFocused\nboolean\nWhether the item is currently focused.\nisDisabled\nboolean\nWhether the item is non-interactive, i.e. both selection and actions are disabled and the item may\nnot be focused. Dependent on\ndisabledKeys\nand\ndisabledBehavior\n.\nallowsSelection\nboolean\nWhether the item may be selected, dependent on\nselectionMode\n,\ndisabledKeys\n, and\ndisabledBehavior\n.\nhasAction\nboolean\nWhether the item has an action, dependent on\nonAction\n,\ndisabledKeys\n,\nand\ndisabledBehavior\n. It may also change depending on the current selection state\nof the list (e.g. when selection is primary). This can be used to enable or disable hover\nstyles or other visual indications of interactivity.\nName\nType\nDescription\nnode\nGridNode\n<\nunknown\n>\nAn object representing the table cell. Contains all the relevant information that makes up the row header.\nisVirtualized\nboolean\nWhether the cell is contained in a virtual scroller.\nshouldSelectOnPressUp\nboolean\nWhether selection should occur on press up instead of press down.\nName\nType\nDescription\ngridCellProps\nDOMAttributes\nProps for the table cell element.\nisPressed\nboolean\nWhether the cell is currently in a pressed state.\nName\nType\nDescription\nkey\nKey\nA unique key for the checkbox.\nName\nType\nDescription\ncheckboxProps\nAriaCheckboxProps\nProps for the row selection checkbox element.\nName\nType\nDefault\nDescription\nisIndeterminate\nboolean\n\u00e2\u0080\u0094\nIndeterminism is presentational only.\nThe indeterminate visual representation remains regardless of user interaction.\nchildren\nReactNode\n\u00e2\u0080\u0094\nThe label for the element.\nvalue\nstring\n\u00e2\u0080\u0094\nThe value of the input element, used when submitting an HTML form. See\nMDN\n.\ndefaultSelected\nboolean\n\u00e2\u0080\u0094\nWhether the element should be selected (uncontrolled).\nisSelected\nboolean\n\u00e2\u0080\u0094\nWhether the element should be selected (controlled).\nonChange\n(\n(\nisSelected\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's selection state changes.\nisDisabled\nboolean\n\u00e2\u0080\u0094\nWhether the input is disabled.\nisReadOnly\nboolean\n\u00e2\u0080\u0094\nWhether the input can be selected but not changed by the user.\nisRequired\nboolean\n\u00e2\u0080\u0094\nWhether user input is required on the input before form submission.\nisInvalid\nboolean\n\u00e2\u0080\u0094\nWhether the input value is invalid.\nvalidationBehavior\n'aria'\n|\u00c2\n'native'\n'aria'\nWhether to use native HTML form validation to prevent form submission\nwhen the value is missing or invalid, or mark the field as required\nor invalid via ARIA.\nvalidate\n(\n(\nvalue\n:\nboolean\n)\n)\n=>\nValidationError\n|\u00c2\ntrue\n|\u00c2\nnull\n|\u00c2\nundefined\n\u00e2\u0080\u0094\nA function that returns an error message if a given value is invalid.\nValidation errors are displayed to the user when the form is submitted\nif\nvalidationBehavior=\"native\"\n. For realtime validation, use the\nisInvalid\nprop instead.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element should receive focus on render.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nname\nstring\n\u00e2\u0080\u0094\nThe name of the input element, used when submitting an HTML form. See\nMDN\n.\nform\nstring\n\u00e2\u0080\u0094\nThe\n<form>\nelement to associate the input with.\nThe value of this attribute must be the id of a\n<form>\nin the same document.\nSee\nMDN\n.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) whose contents or presence are controlled by the current element.\nexcludeFromTabOrder\nboolean\n\u00e2\u0080\u0094\nWhether to exclude the element from the sequential tab order. If true,\nthe element will not be focusable via the keyboard by tabbing. This should\nbe avoided except in rare scenarios where an alternative means of accessing\nthe element or its functionality via the keyboard is available.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\naria-errormessage\nstring\n\u00e2\u0080\u0094\nIdentifies the element that provides an error message for the object.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\n'valid'\n|\u00c2\n'invalid'\nstring\n|\u00c2\nstring\n[]\nBaseEvent\n<\nReactKeyboardEvent\n<\nany\n>\n>\nSyntheticEvent\n&\u00c2\n{\nstopPropagation\n:\n(\n)\n=>\nvoid\n,\ncontinuePropagation\n:\n(\n)\n=>\nvoid\n}\nName\nType\nDescription\ncheckboxProps\nAriaCheckboxProps\nProps for the select all checkbox element.\nName\nType\nDescription\ncolumn\nGridNode\n<\nT\n>\nAn object representing the\ncolumn header\n. Contains all the relevant information that makes up the column header.\naria-label\nstring\nAria label for the hidden input. Gets read when resizing.\ntriggerRef\nRefObject\n<\nFocusableElement\n|\u00c2\nnull\n>\nRef to the trigger if resizing was started from a column header menu. If it's provided,\nfocus will be returned there when resizing is done. If it isn't provided, it is assumed that the resizer is\nvisible at all time and keyboard resizing is started via pressing Enter on the resizer and not on focus.\nisDisabled\nboolean\nIf resizing is disabled.\nonResizeStart\n(\n(\nwidths\n:\nMap\n<\nKey\n,\nColumnSize\n>\n)\n)\n=>\nvoid\nCalled when resizing starts.\nonResize\n(\n(\nwidths\n:\nMap\n<\nKey\n,\nColumnSize\n>\n)\n)\n=>\nvoid\nCalled for every resize event that results in new column sizes.\nonResizeEnd\n(\n(\nwidths\n:\nMap\n<\nKey\n,\nColumnSize\n>\n)\n)\n=>\nvoid\nCalled when resizing ends.\nAll possible sizes a column can be assigned.\nColumnStaticSize\n|\u00c2\nColumnDynamicSize\nWidths that result in a constant pixel value for the same Table width.\nnumber\n|\u00c2\n`\n${\nnumber\n}\n`\n|\u00c2\n`\n${\nnumber\n}\n%\n`\nWidths that change size in relation to the remaining space and in ratio to other dynamic columns.\nAll numbers must be integers and greater than 0.\nFR units take up remaining, if any, space in the table.\n`\n${\nnumber\n}\nfr\n`\nName\nType\nDescription\nupdateResizedColumns\n(\n(\nkey\n:\nKey\n,\n,\nwidth\n:\nnumber\n)\n)\n=>\nMap\n<\nKey\n,\nColumnSize\n>\nCalled to update the state that a resize event has occurred.\nReturns the new widths for all columns based on the resized column.\nstartResize\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\nCallback for when onColumnResize has started.\nendResize\n(\n)\n=>\nvoid\nCallback for when onColumnResize has ended.\ngetColumnWidth\n(\n(\nkey\n:\nKey\n)\n)\n=>\nnumber\nGets the current width for the specified column.\ngetColumnMinWidth\n(\n(\nkey\n:\nKey\n)\n)\n=>\nnumber\nGets the current minWidth for the specified column.\ngetColumnMaxWidth\n(\n(\nkey\n:\nKey\n)\n)\n=>\nnumber\nGets the current maxWidth for the specified column.\nresizingColumn\nKey\n|\u00c2\nnull\nKey of the currently resizing column.\ntableState\nTableState\n<\nT\n>\nA reference to the table state.\ncolumnWidths\nMap\n<\nKey\n,\nnumber\n>\nA map of the current column widths.\nName\nType\nDescription\ninputProps\nDOMAttributes\nProps for the visually hidden input element.\nresizerProps\nDOMAttributes\nProps for the resizer element.\nisResizing\nboolean\nWhether this column is currently being resized.\nProvides the behavior and accessibility implementation for a table component.\nA table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,\nand optionally supports row selection and sorting.\nuseTable\n<\nT\n>\n(\nprops\n:\nAriaTableProps\n,\nstate\n:\nTableState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeGridState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridAria\nProvides the behavior and accessibility implementation for a row in a table.\nuseTableRow\n<\nT\n>\n(\nprops\n:\nGridRowProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n|\u00c2\n|\u00c2\nTreeGridState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nGridRowAria\nProvides the behavior and accessibility implementation for a cell in a table.\nuseTableCell\n<\nT\n>\n(\nprops\n:\nAriaTableCellProps\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableCellAria\nProvides the behavior and accessibility implementation for a column header in a table.\nuseTableColumnHeader\n<\nT\n>\n(\nprops\n:\nAriaTableColumnHeaderProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableColumnHeaderAria\nuseTableRowGroup\n(\n)\n:\nGridRowGroupAria\nProvides the behavior and accessibility implementation for a header row in a table.\nuseTableHeaderRow\n<\nT\n>\n(\nprops\n:\nGridRowProps\n<\nT\n>\n,\nstate\n:\nTableState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableHeaderRowAria\nProvides the behavior and accessibility implementation for the select all checkbox in a table.\nuseTableSelectAllCheckbox\n<\nT\n>\n(\n(\nstate\n:\nTableState\n<\nT\n>\n)\n)\n:\nTableSelectAllCheckboxAria\nProvides the behavior and accessibility implementation for a selection checkbox in a table.\nuseTableSelectionCheckbox\n<\nT\n>\n(\n(\nprops\n:\nAriaTableSelectionCheckboxProps\n,\n,\nstate\n:\nTableState\n<\nT\n>\n)\n)\n:\nTableSelectionCheckboxAria\nProvides state management for a table component. Handles building a collection\nof columns and rows from props. In addition, it tracks row selection and manages sort order changes.\nuseTableState\n<\nT\nextends\nobject\n>\n(\n(\nprops\n:\nTableStateProps\n<\nT\n>\n)\n)\n:\nTableState\n<\nT\n>\nName\nType\nDescription\nchildren\n[\nReactElement\n<\nTableHeaderProps\n<\nT\n>\n>\n,\nReactElement\n<\nTableBodyProps\n<\nT\n>\n>\n]\nThe elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows.\ndisabledKeys\nIterable\n<\nKey\n>\nA list of row keys to disable.\ncollection\nTableCollection\n<\nT\n>\nA pre-constructed collection to use instead of building one from items and children.\nshowSelectionCheckboxes\nboolean\nWhether the row selection checkboxes should be displayed.\nselectionBehavior\nSelectionBehavior\nHow multiple selection should behave in the collection.\nallowDuplicateSelectionEvents\nboolean\nWhether onSelectionChange should fire even if the new set of keys is the same as the last.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to all interactions, or only selection.\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\nHandler that is called when the selection changes.\nsortDescriptor\nSortDescriptor\nThe current sorted column and direction.\nonSortChange\n(\n(\ndescriptor\n:\nSortDescriptor\n)\n)\n=>\nany\nHandler that is called when the sorted column or direction changes.\nName\nType\nDescription\nchildren\nColumnElement\n<\nT\n>\n|\u00c2\nColumnElement\n<\nT\n>\n[]\n|\u00c2\nColumnRenderer\n<\nT\n>\nA list of\nColumn(s)\nor a function. If the latter, a list of columns must be provided using the\ncolumns\nprop.\ncolumns\nT\n[]\nA list of table columns.\nReactElement\n<\nColumnProps\n<\nT\n>\n>\nName\nType\nDescription\nchildren\nReactNode\n|\u00c2\nColumnElement\n<\nT\n>\n|\u00c2\nColumnElement\n<\nT\n>\n[]\nStatic child columns or content to render as the column header.\ntitle\nReactNode\nRendered contents of the column if\nchildren\ncontains child columns.\nchildColumns\nT\n[]\nA list of child columns used when dynamically rendering nested child columns.\nwidth\nColumnSize\n|\u00c2\nnull\nThe width of the column.\nminWidth\nColumnStaticSize\n|\u00c2\nnull\nThe minimum width of the column.\nmaxWidth\nColumnStaticSize\n|\u00c2\nnull\nThe maximum width of the column.\ndefaultWidth\nColumnSize\n|\u00c2\nnull\nThe default width of the column.\nallowsResizing\nboolean\nWhether the column allows resizing.\nallowsSorting\nboolean\nWhether the column allows sorting.\nisRowHeader\nboolean\nWhether a column is a\nrow header\nand should be announced by assistive technology during row navigation.\ntextValue\nstring\nA string representation of the column's contents, used for accessibility announcements.\n(\n(\nitem\n:\nT\n)\n)\n=>\nColumnElement\n<\nT\n>\nName\nType\nDescription\nchildren\nRowElement\n<\nT\n>\n|\u00c2\nRowElement\n<\nT\n>\n[]\n|\u00c2\n(\n(\nitem\n:\nT\n)\n)\n=>\nRowElement\n<\nT\n>\nThe contents of the table body. Supports static items or a function for dynamic rendering.\nitems\nIterable\n<\nT\n>\nA list of row objects in the table body used when dynamically rendering rows.\nloadingState\nLoadingState\nThe current loading state of the table.\nonLoadMore\n(\n)\n=>\nany\nHandler that is called when more items should be loaded, e.g. while scrolling near the bottom.\nReactElement\n<\nRowProps\n<\nT\n>\n>\nName\nType\nDescription\nchildren\nCellElement\n|\u00c2\nCellElement\n[]\n|\u00c2\nCellRenderer\nRendered contents of the row or row child items.\ntextValue\nstring\nA string representation of the row's contents, used for features like typeahead.\nhref\nHref\nA URL to link to. See\nMDN\n.\nhrefLang\nstring\nHints at the human language of the linked URL. See\nMDN\n.\ntarget\nHTMLAttributeAnchorTarget\nThe target window for the link. See\nMDN\n.\nrel\nstring\nThe relationship between the linked resource and the current page. See\nMDN\n.\ndownload\nboolean\n|\u00c2\nstring\nCauses the browser to download the linked URL. A string may be provided to suggest a file name. See\nMDN\n.\nping\nstring\nA space-separated list of URLs to ping when the link is followed. See\nMDN\n.\nreferrerPolicy\nHTMLAttributeReferrerPolicy\nHow much of the referrer to send when following the link. See\nMDN\n.\nrouterOptions\nRouterOptions\nOptions for the configured client side router.\nReactElement\n<\nCellProps\n>\nName\nType\nDescription\nchildren\nReactNode\nThe contents of the cell.\ntextValue\nstring\nA string representation of the cell's contents, used for features like typeahead.\ncolSpan\nnumber\nIndicates how many columns the data cell spans.\n(\n(\ncolumnKey\n:\nKey\n)\n)\n=>\nCellElement\nRouterConfig\nextends\n{\nhref\n:\nany\n}\n?\nH\n:\nstring\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with\nhref\nand\nrouterOptions\nproperties to configure your router.\nRouterConfig\nextends\n{\nrouterOptions\n:\nany\n}\n?\nO\n:\nnever\n'loading'\n|\u00c2\n'sorting'\n|\u00c2\n'loadingMore'\n|\u00c2\n'error'\n|\u00c2\n'idle'\n|\u00c2\n'filtering'\nA TableHeader is a container for the Column elements in a Table. Columns can be statically defined\nas children, or generated dynamically using a function based on the data passed to the\ncolumns\nprop.\nTableHeader\n<\nT\n>\n(\n(\nprops\n:\nTableHeaderProps\n<\nT\n>\n)\n)\n:\nReactElement\n|\u00c2\nnull\nA Column represents a field of each item within a Table. Columns may also contain nested\nColumn elements to represent column groups. Nested columns can be statically defined as\nchildren, or dynamically generated using a function based on the\nchildColumns\nprop.\nColumn\n<\nT\n>\n(\n(\nprops\n:\nColumnProps\n<\nT\n>\n)\n)\n:\nReactElement\n|\u00c2\nnull\nA TableBody is a container for the Row elements of a Table. Rows can be statically defined\nas children, or generated dynamically using a function based on the data passed to the\nitems\nprop.\nTableBody\n<\nT\n>\n(\n(\nprops\n:\nTableBodyProps\n<\nT\n>\n)\n)\n:\nReactElement\n|\u00c2\nnull\nA Row represents a single item in a Table and contains Cell elements for each column.\nCells can be statically defined as children, or generated dynamically using a function\nbased on the columns defined in the TableHeader.\nRow\n<\nT\n>\n(\n(\nprops\n:\nRowProps\n<\nT\n>\n)\n)\n:\nReactElement\n|\u00c2\nnull\nA Cell represents the value of a single Column within a Table Row.\nCell\n(\n(\nprops\n:\nCellProps\n)\n)\n:\nReactElement\n|\u00c2\nnull\nDetermines whether a focus ring should be shown to indicate keyboard focus.\nFocus rings are visible only when the user is interacting with a keyboard,\nnot with a mouse, touch, or other input methods.\nuseFocusRing\n(\n(\nprops\n:\nAriaFocusRingProps\n)\n)\n:\nFocusRingAria\nName\nType\nDefault\nDescription\nwithin\nboolean\n'false'\nWhether to show the focus ring when something\ninside the container element has focus (true), or\nonly if the container itself has focus (false).\nisTextInput\nboolean\n\u00e2\u0080\u0094\nWhether the element is a text input.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element will be auto focused.\nName\nType\nDescription\nisFocused\nboolean\nWhether the element is currently focused.\nisFocusVisible\nboolean\nWhether keyboard focus should be visible.\nfocusProps\nDOMAttributes\nProps to apply to the container element with the focus ring.\nA RouterProvider accepts a\nnavigate\nfunction from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\nName\nType\nDescription\nnavigate\n(\n(\npath\n:\nHref\n,\n,\nrouterOptions\n:\nRouterOptions\n|\u00c2\n|\u00c2\nundefined\n)\n)\n=>\nvoid\nchildren\nReactNode\nuseHref\n(\n(\nhref\n:\nHref\n)\n)\n=>\nstring\nProvides column width state management for a table component with column resizing support. Handles building\na map of column widths calculated from the table's width and any provided column width information from the collection.\nIn addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\nuseTableColumnResizeState\n<\nT\n>\n(\n(\nprops\n:\nTableColumnResizeStateProps\n<\nT\n>\n,\n,\nstate\n:\nTableState\n<\nT\n>\n)\n)\n:\nTableColumnResizeState\n<\nT\n>\nName\nType\nDescription\ntableWidth\nnumber\nCurrent width of the table or table viewport that the columns\nshould be calculated against.\ngetDefaultWidth\n(\n(\nnode\n:\nGridNode\n<\nT\n>\n)\n)\n=>\nColumnSize\n|\u00c2\nnull\n|\u00c2\nundefined\nA function that is called to find the default width for a given column.\ngetDefaultMinWidth\n(\n(\nnode\n:\nGridNode\n<\nT\n>\n)\n)\n=>\nColumnSize\n|\u00c2\nnull\n|\u00c2\nundefined\nA function that is called to find the default minWidth for a given column.\nProvides the behavior and accessibility implementation for a table column resizer element.\nuseTableColumnResize\n<\nT\n>\n(\nprops\n:\nAriaTableColumnResizeProps\n<\nT\n>\n,\nstate\n:\nTableColumnResizeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLInputElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nTableColumnResizeAria",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../Table).\n\n# useTable\n\nProvides the behavior and accessibility implementation for a table component.\nA table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,\nand optionally supports row selection and sorting.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useTable, useTableCell, useTableColumnHeader, useTableRow, useTableHeaderRow, useTableRowGroup, useTableSelectAllCheckbox, useTableSelectionCheckbox, useTableColumnResize} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/grid/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/table \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/table \"View package\")\n\n## API[#](#api)\n\n---\n\n`useTable<T>(\nprops: AriaTableProps,\nstate: TableState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeGridState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridAria`\n`useTableRowGroup(): GridRowGroupAria`\n`useTableHeaderRow<T>(\nprops: GridRowProps<T>,\nstate: TableState<T>,\nref: RefObject<Element\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableHeaderRowAria`\n`useTableColumnHeader<T>(\nprops: AriaTableColumnHeaderProps<T>,\nstate: TableState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableColumnHeaderAria`\n`useTableRow<T>(\nprops: GridRowProps<T>,\nstate: TableState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeGridState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridRowAria`\n`useTableCell<T>(\nprops: AriaTableCellProps,\nstate: TableState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableCellAria`\n`useTableSelectionCheckbox<T>(\n(props: AriaTableSelectionCheckboxProps,\n, state: TableState<T>\n)): TableSelectionCheckboxAria`\n`useTableSelectAllCheckbox<T>(\n(state: TableState<T>\n)): TableSelectAllCheckboxAria`\n`useTableColumnResize<T>(\nprops: AriaTableColumnResizeProps<T>,\nstate: TableColumnResizeState<T>,\nref: RefObject<HTMLInputElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableColumnResizeAria`\n\n## Features[#](#features)\n\n---\n\nA table can be built using the [<table>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table), [<tr>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr),\n[<td>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td), and other table specific HTML elements, but is very limited in functionality especially when it comes to user interactions.\nHTML tables are meant for static content, rather than tables with rich interactions like focusable elements within cells, keyboard navigation, row selection, sorting, etc.\n`useTable` helps achieve accessible and interactive table components that can be styled as needed.\n\n- Exposed to assistive technology as a `grid` using ARIA\n- Keyboard navigation between columns, rows, cells, and in-cell focusable elements via the arrow keys\n- Single, multiple, or no row selection via mouse, touch, or keyboard interactions\n- Support for disabled rows, which cannot be selected\n- Optional support for checkboxes in each row for selection, as well as in the header to select all rows\n- Support for both `toggle` and `replace` selection behaviors\n- Support for row actions via double click, `Enter` key, or tapping\n- Long press to enter selection mode on touch when there is both selection and row actions\n- Column sorting support\n- Async loading, infinite scrolling, filtering, and sorting support\n- Support for column groups via nested columns\n- Typeahead to allow focusing rows by typing text\n- Automatic scrolling support during keyboard navigation\n- Labeling support for accessibility\n- Support for marking columns as [row headers](https://www.w3.org/TR/wai-aria-1.1/#rowheader), which will be read when navigating the rows with a screen reader\n- Ensures that selections are announced using an ARIA live region\n- Support for using HTML table elements, or custom element types (e.g. `<div>`) for layout flexibility\n- Support for use with virtualized lists\n- Support for resizable columns\n\n## Anatomy[#](#anatomy)\n\n---\n\nA table consists of a container element, with columns and rows of cells containing data inside. The cells within a table may contain focusable elements or plain text content.\nIf the table supports row selection, each row can optionally include a selection checkbox in the first column. Additionally, a \"select all\" checkbox is displayed as the first column header if the table supports multiple row selection.\n\nThe `useTable`, `useTableRow`, `useTableCell`, and `useTableColumnHeader` hooks handle keyboard, mouse, and other interactions to support\nrow selection, in table navigation, and overall focus behavior. Those hooks, along with `useTableRowGroup` and `useTableHeaderRow`, also handle exposing the table and its contents\nto assistive technology using ARIA. `useTableSelectAllCheckbox` and `useTableSelectionCheckbox` handle row selection and associating each checkbox with its respective rows\nfor assistive technology. Each of these hooks returns props to be spread onto the appropriate HTML element.\n\nState is managed by the `useTableState`\nhook from `@react-stately/table`. The state object should be passed as an option to each of the above hooks where applicable.\n\nNote that an `aria-label` or `aria-labelledby` must be passed to the table to identify the element to assistive technology.\n\n## State management[#](#state-management)\n\n---\n\n`useTable` requires knowledge of the rows, cells, and columns in the table in order to handle keyboard\nnavigation and other interactions. It does this using\nthe `Collection`\ninterface, which is a generic interface to access sequential unique keyed data. You can\nimplement this interface yourself, e.g. by using a prop to pass a list of item objects,\nbut `useTableState` from\n`@react-stately/table` implements a JSX based interface for building collections instead.\nSee [Collection Components](https://react-spectrum.adobe.com/v3/collections.html) for more information.\n\nData is defined using the `TableHeader`, `Column`, `TableBody`, `Row`, and `Cell` components, which support both static and dynamic data.\nSee the examples in the [usage](#usage) section below for details on how to use these components.\n\nIn addition, `useTableState`\nmanages the state necessary for multiple selection and exposes\na `SelectionManager`,\nwhich makes use of the collection to provide an interface to update the selection state.\nFor more information, see [Selection](https://react-spectrum.adobe.com/v3/selection.html).\n\n## Example[#](#example)\n\n---\n\nTables are complex [collection components](https://react-spectrum.adobe.com/v3/collections.html) that are built up from many child elements\nincluding columns, rows, and cells. In this example, we'll use the standard HTML table elements along with hooks from React\nAria for each child. You may also use other elements like `<div>` to render these components as appropriate.\nSince there are many pieces, we'll walk through each of them one by one.\n\nThe `useTable` hook will be used to render the outer most table element. It uses\nthe `useTableState` hook to construct the table's collection of rows and columns,\nand manage state such as the focused row/cell, selection, and sort column/direction. We'll use the collection to iterate through\nthe rows and cells of the table and render the relevant components, which we'll define below.\n\n```\nimport {mergeProps, useFocusRing, useTable} from 'react-aria';\nimport {Cell, Column, Row, TableBody, TableHeader, useTableState} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction Table(props) {\n  let { selectionMode, selectionBehavior } = props;\n  let state = useTableState({\n    ...props,\n    showSelectionCheckboxes: selectionMode === 'multiple' &&\n      selectionBehavior !== 'replace'\n  });\n\n  let ref = useRef<HTMLTableElement | null>(null);\n  let { collection } = state;\n  let { gridProps } = useTable(props, state, ref);\n\n  return (\n    <table {...gridProps} ref={ref} style={{ borderCollapse: 'collapse' }}>\n      <TableRowGroup type=\"thead\">\n        {collection.headerRows.map((headerRow) => (\n          <TableHeaderRow key={headerRow.key} item={headerRow} state={state}>\n            {[...headerRow.childNodes].map((column) =>\n              column.props.isSelectionCell\n                ? (\n                  <TableSelectAllCell\n                    key={column.key}\n                    column={column}\n                    state={state}\n                  />\n                )\n                : (\n                  <TableColumnHeader\n                    key={column.key}\n                    column={column}\n                    state={state}\n                  />\n                )\n            )}\n          </TableHeaderRow>\n        ))}\n      </TableRowGroup>\n      <TableRowGroup type=\"tbody\">\n        {[...collection.body.childNodes].map((row) => (\n          <TableRow key={row.key} item={row} state={state}>\n            {[...row.childNodes].map((cell) =>\n              cell.props.isSelectionCell\n                ? <TableCheckboxCell key={cell.key} cell={cell} state={state} />\n                : <TableCell key={cell.key} cell={cell} state={state} />\n            )}\n          </TableRow>\n        ))}\n      </TableRowGroup>\n    </table>\n  );\n}\n```\n\n```\nimport {\n  mergeProps,\n  useFocusRing,\n  useTable\n} from 'react-aria';\nimport {\n  Cell,\n  Column,\n  Row,\n  TableBody,\n  TableHeader,\n  useTableState\n} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction Table(props) {\n  let { selectionMode, selectionBehavior } = props;\n  let state = useTableState({\n    ...props,\n    showSelectionCheckboxes: selectionMode === 'multiple' &&\n      selectionBehavior !== 'replace'\n  });\n\n  let ref = useRef<HTMLTableElement | null>(null);\n  let { collection } = state;\n  let { gridProps } = useTable(props, state, ref);\n\n  return (\n    <table\n      {...gridProps}\n      ref={ref}\n      style={{ borderCollapse: 'collapse' }}\n    >\n      <TableRowGroup type=\"thead\">\n        {collection.headerRows.map((headerRow) => (\n          <TableHeaderRow\n            key={headerRow.key}\n            item={headerRow}\n            state={state}\n          >\n            {[...headerRow.childNodes].map((column) =>\n              column.props.isSelectionCell\n                ? (\n                  <TableSelectAllCell\n                    key={column.key}\n                    column={column}\n                    state={state}\n                  />\n                )\n                : (\n                  <TableColumnHeader\n                    key={column.key}\n                    column={column}\n                    state={state}\n                  />\n                )\n            )}\n          </TableHeaderRow>\n        ))}\n      </TableRowGroup>\n      <TableRowGroup type=\"tbody\">\n        {[...collection.body.childNodes].map((row) => (\n          <TableRow key={row.key} item={row} state={state}>\n            {[...row.childNodes].map((cell) =>\n              cell.props.isSelectionCell\n                ? (\n                  <TableCheckboxCell\n                    key={cell.key}\n                    cell={cell}\n                    state={state}\n                  />\n                )\n                : (\n                  <TableCell\n                    key={cell.key}\n                    cell={cell}\n                    state={state}\n                  />\n                )\n            )}\n          </TableRow>\n        ))}\n      </TableRowGroup>\n    </table>\n  );\n}\n```\n\n```\nimport {\n  mergeProps,\n  useFocusRing,\n  useTable\n} from 'react-aria';\nimport {\n  Cell,\n  Column,\n  Row,\n  TableBody,\n  TableHeader,\n  useTableState\n} from 'react-stately';\nimport {useRef} from 'react';\n\nfunction Table(props) {\n  let {\n    selectionMode,\n    selectionBehavior\n  } = props;\n  let state =\n    useTableState({\n      ...props,\n      showSelectionCheckboxes:\n        selectionMode ===\n          'multiple' &&\n        selectionBehavior !==\n          'replace'\n    });\n\n  let ref = useRef<\n    | HTMLTableElement\n    | null\n  >(null);\n  let { collection } =\n    state;\n  let { gridProps } =\n    useTable(\n      props,\n      state,\n      ref\n    );\n\n  return (\n    <table\n      {...gridProps}\n      ref={ref}\n      style={{\n        borderCollapse:\n          'collapse'\n      }}\n    >\n      <TableRowGroup type=\"thead\">\n        {collection\n          .headerRows\n          .map(\n            (headerRow) => (\n              <TableHeaderRow\n                key={headerRow\n                  .key}\n                item={headerRow}\n                state={state}\n              >\n                {[\n                  ...headerRow\n                    .childNodes\n                ].map(\n                  (column) =>\n                    column\n                        .props\n                        .isSelectionCell\n                      ? (\n                        <TableSelectAllCell\n                          key={column\n                            .key}\n                          column={column}\n                          state={state}\n                        />\n                      )\n                      : (\n                        <TableColumnHeader\n                          key={column\n                            .key}\n                          column={column}\n                          state={state}\n                        />\n                      )\n                )}\n              </TableHeaderRow>\n            )\n          )}\n      </TableRowGroup>\n      <TableRowGroup type=\"tbody\">\n        {[\n          ...collection\n            .body\n            .childNodes\n        ].map((row) => (\n          <TableRow\n            key={row.key}\n            item={row}\n            state={state}\n          >\n            {[\n              ...row\n                .childNodes\n            ].map(\n              (cell) =>\n                cell\n                    .props\n                    .isSelectionCell\n                  ? (\n                    <TableCheckboxCell\n                      key={cell\n                        .key}\n                      cell={cell}\n                      state={state}\n                    />\n                  )\n                  : (\n                    <TableCell\n                      key={cell\n                        .key}\n                      cell={cell}\n                      state={state}\n                    />\n                  )\n            )}\n          </TableRow>\n        ))}\n      </TableRowGroup>\n    </table>\n  );\n}\n```\n\n### Table header[#](#table-header)\n\nA `useTableRowGroup` hook will be used to group the rows in the table header and table body. In this example,\nwe're using HTML table elements, so this will be either a `<thead>` or `<tbody>` element, as passed from the\nabove `Table` component via the `type` prop.\n\n```\nimport {useTableRowGroup} from 'react-aria';\n\nfunction TableRowGroup({ type: Element, children }) {\n  let { rowGroupProps } = useTableRowGroup();\n  return (\n    <Element\n      {...rowGroupProps}\n      style={Element === 'thead'\n        ? { borderBottom: '2px solid var(--spectrum-global-color-gray-800)' }\n        : null}\n    >\n      {children}\n    </Element>\n  );\n}\n```\n\n```\nimport {useTableRowGroup} from 'react-aria';\n\nfunction TableRowGroup({ type: Element, children }) {\n  let { rowGroupProps } = useTableRowGroup();\n  return (\n    <Element\n      {...rowGroupProps}\n      style={Element === 'thead'\n        ? {\n          borderBottom:\n            '2px solid var(--spectrum-global-color-gray-800)'\n        }\n        : null}\n    >\n      {children}\n    </Element>\n  );\n}\n```\n\n```\nimport {useTableRowGroup} from 'react-aria';\n\nfunction TableRowGroup(\n  {\n    type: Element,\n    children\n  }\n) {\n  let { rowGroupProps } =\n    useTableRowGroup();\n  return (\n    <Element\n      {...rowGroupProps}\n      style={Element ===\n          'thead'\n        ? {\n          borderBottom:\n            '2px solid var(--spectrum-global-color-gray-800)'\n        }\n        : null}\n    >\n      {children}\n    </Element>\n  );\n}\n```\n\nThe `useTableHeaderRow` hook will be used to render a header row. Header rows are similar to other rows,\nbut they don't support user interaction like selection. In this example, there's only one header\nrow, but there could be multiple in the case of nested columns. See the [example below](#nested-columns) for details.\n\n```\nimport {useTableHeaderRow} from 'react-aria';\n\nfunction TableHeaderRow({ item, state, children }) {\n  let ref = useRef<HTMLTableRowElement | null>(null);\n  let { rowProps } = useTableHeaderRow({ node: item }, state, ref);\n\n  return (\n    <tr {...rowProps} ref={ref}>\n      {children}\n    </tr>\n  );\n}\n```\n\n```\nimport {useTableHeaderRow} from 'react-aria';\n\nfunction TableHeaderRow({ item, state, children }) {\n  let ref = useRef<HTMLTableRowElement | null>(null);\n  let { rowProps } = useTableHeaderRow(\n    { node: item },\n    state,\n    ref\n  );\n\n  return (\n    <tr {...rowProps} ref={ref}>\n      {children}\n    </tr>\n  );\n}\n```\n\n```\nimport {useTableHeaderRow} from 'react-aria';\n\nfunction TableHeaderRow(\n  {\n    item,\n    state,\n    children\n  }\n) {\n  let ref = useRef<\n    | HTMLTableRowElement\n    | null\n  >(null);\n  let { rowProps } =\n    useTableHeaderRow(\n      { node: item },\n      state,\n      ref\n    );\n\n  return (\n    <tr\n      {...rowProps}\n      ref={ref}\n    >\n      {children}\n    </tr>\n  );\n}\n```\n\nThe `useTableColumnHeader` hook will be used to render each column header. Column headers act as a label\nfor all of the cells in that column, and can optionally support user interaction to sort by the column\nand change the sort order.\n\nThe `allowsSorting` property of the column object can be used to determine\nif the column supports sorting at all.\n\nThe `sortDescriptor` object stored in the `state` object indicates which column the table is currently sorted by,\nas well as the sort direction (ascending or descending). This is used to render an arrow icon to visually\nindicate the sort direction. When not sorted by this column, we use `visibility: hidden` to ensure that\nwe reserve space for this icon at all times. That way the table's layout doesn't shift when we change the\ncolumn we're sorting by. See the [example below](#sorting) of all of this in action.\n\nFinally, we use the `useFocusRing` hook to ensure that a focus ring is rendered when\nthe cell is navigated to with the keyboard.\n\n```\nimport {useTableColumnHeader} from 'react-aria';\n\nfunction TableColumnHeader({ column, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n  let arrowIcon = state.sortDescriptor?.direction === 'ascending' ? '\u00e2\u0096\u00b2' : '\u00e2\u0096\u00bc';\n\n  return (\n    <th\n      {...mergeProps(columnHeaderProps, focusProps)}\n      style={{\n        textAlign: column.colSpan > 1 ? 'center' : 'left',\n        padding: '5px 10px',\n        outline: 'none',\n        boxShadow: isFocusVisible ? 'inset 0 0 0 2px orange' : 'none',\n        cursor: 'default'\n      }}\n      ref={ref}\n    >\n      {column.rendered}\n      {column.props.allowsSorting &&\n        (\n          <span\n            aria-hidden=\"true\"\n            style={{\n              padding: '0 2px',\n              visibility: state.sortDescriptor?.column === column.key\n                ? 'visible'\n                : 'hidden'\n            }}\n          >\n            {arrowIcon}\n          </span>\n        )}\n    </th>\n  );\n}\n```\n\n```\nimport {useTableColumnHeader} from 'react-aria';\n\nfunction TableColumnHeader({ column, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n  let arrowIcon =\n    state.sortDescriptor?.direction === 'ascending'\n      ? '\u00e2\u0096\u00b2'\n      : '\u00e2\u0096\u00bc';\n\n  return (\n    <th\n      {...mergeProps(columnHeaderProps, focusProps)}\n      style={{\n        textAlign: column.colSpan > 1 ? 'center' : 'left',\n        padding: '5px 10px',\n        outline: 'none',\n        boxShadow: isFocusVisible\n          ? 'inset 0 0 0 2px orange'\n          : 'none',\n        cursor: 'default'\n      }}\n      ref={ref}\n    >\n      {column.rendered}\n      {column.props.allowsSorting &&\n        (\n          <span\n            aria-hidden=\"true\"\n            style={{\n              padding: '0 2px',\n              visibility:\n                state.sortDescriptor?.column === column.key\n                  ? 'visible'\n                  : 'hidden'\n            }}\n          >\n            {arrowIcon}\n          </span>\n        )}\n    </th>\n  );\n}\n```\n\n```\nimport {useTableColumnHeader} from 'react-aria';\n\nfunction TableColumnHeader(\n  { column, state }\n) {\n  let ref = useRef<\n    | HTMLTableCellElement\n    | null\n  >(null);\n  let {\n    columnHeaderProps\n  } =\n    useTableColumnHeader(\n      { node: column },\n      state,\n      ref\n    );\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n  let arrowIcon =\n    state.sortDescriptor\n        ?.direction ===\n        'ascending'\n      ? '\u00e2\u0096\u00b2'\n      : '\u00e2\u0096\u00bc';\n\n  return (\n    <th\n      {...mergeProps(\n        columnHeaderProps,\n        focusProps\n      )}\n      style={{\n        textAlign:\n          column\n              .colSpan >\n              1\n            ? 'center'\n            : 'left',\n        padding:\n          '5px 10px',\n        outline: 'none',\n        boxShadow:\n          isFocusVisible\n            ? 'inset 0 0 0 2px orange'\n            : 'none',\n        cursor: 'default'\n      }}\n      ref={ref}\n    >\n      {column.rendered}\n      {column.props\n        .allowsSorting &&\n        (\n          <span\n            aria-hidden=\"true\"\n            style={{\n              padding:\n                '0 2px',\n              visibility:\n                state\n                    .sortDescriptor\n                    ?.column ===\n                    column\n                      .key\n                  ? 'visible'\n                  : 'hidden'\n            }}\n          >\n            {arrowIcon}\n          </span>\n        )}\n    </th>\n  );\n}\n```\n\n### Table body[#](#table-body)\n\nNow that we've covered the table header, let's move on to the body. We'll use\nthe `useTableRow` hook to render each row in the table.\nTable rows can be focused and navigated to using the keyboard via the arrow keys. In addition, table rows\ncan optionally support selection via mouse, touch, or keyboard. Clicking, tapping, or pressing the `Space`\nkey anywhere in the row selects it. Row actions are also supported, see [below](#row-actions) for details.\n\nWe'll use the `SelectionManager` object exposed\nby the `state` to determine if a row is selected, and render a pink background if so. We'll also use the `useFocusRing`\nhook to render a focus ring when the user navigates to the row with the keyboard.\n\n```\nimport {useTableRow} from 'react-aria';\n\nfunction TableRow({ item, children, state }) {\n  let ref = useRef<HTMLTableRowElement | null>(null);\n  let isSelected = state.selectionManager.isSelected(item.key);\n  let { rowProps, isPressed } = useTableRow(\n    {\n      node: item\n    },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <tr\n      style={{\n        background: isSelected\n          ? 'blueviolet'\n          : isPressed\n          ? 'var(--spectrum-global-color-gray-400)'\n          : item.index % 2\n          ? 'var(--spectrum-alias-highlight-hover)'\n          : 'none',\n        color: isSelected ? 'white' : null,\n        outline: 'none',\n        boxShadow: isFocusVisible ? 'inset 0 0 0 2px orange' : 'none',\n        cursor: 'default'\n      }}\n      {...mergeProps(rowProps, focusProps)}\n      ref={ref}\n    >\n      {children}\n    </tr>\n  );\n}\n```\n\n```\nimport {useTableRow} from 'react-aria';\n\nfunction TableRow({ item, children, state }) {\n  let ref = useRef<HTMLTableRowElement | null>(null);\n  let isSelected = state.selectionManager.isSelected(\n    item.key\n  );\n  let { rowProps, isPressed } = useTableRow(\n    {\n      node: item\n    },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <tr\n      style={{\n        background: isSelected\n          ? 'blueviolet'\n          : isPressed\n          ? 'var(--spectrum-global-color-gray-400)'\n          : item.index % 2\n          ? 'var(--spectrum-alias-highlight-hover)'\n          : 'none',\n        color: isSelected ? 'white' : null,\n        outline: 'none',\n        boxShadow: isFocusVisible\n          ? 'inset 0 0 0 2px orange'\n          : 'none',\n        cursor: 'default'\n      }}\n      {...mergeProps(rowProps, focusProps)}\n      ref={ref}\n    >\n      {children}\n    </tr>\n  );\n}\n```\n\n```\nimport {useTableRow} from 'react-aria';\n\nfunction TableRow(\n  {\n    item,\n    children,\n    state\n  }\n) {\n  let ref = useRef<\n    | HTMLTableRowElement\n    | null\n  >(null);\n  let isSelected = state\n    .selectionManager\n    .isSelected(\n      item.key\n    );\n  let {\n    rowProps,\n    isPressed\n  } = useTableRow(\n    {\n      node: item\n    },\n    state,\n    ref\n  );\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n\n  return (\n    <tr\n      style={{\n        background:\n          isSelected\n            ? 'blueviolet'\n            : isPressed\n            ? 'var(--spectrum-global-color-gray-400)'\n            : item\n                .index %\n                2\n            ? 'var(--spectrum-alias-highlight-hover)'\n            : 'none',\n        color: isSelected\n          ? 'white'\n          : null,\n        outline: 'none',\n        boxShadow:\n          isFocusVisible\n            ? 'inset 0 0 0 2px orange'\n            : 'none',\n        cursor: 'default'\n      }}\n      {...mergeProps(\n        rowProps,\n        focusProps\n      )}\n      ref={ref}\n    >\n      {children}\n    </tr>\n  );\n}\n```\n\nFinally, we'll use the `useTableCell` hook to render each cell.\nUsers can use the left and right arrow keys to navigate to each cell in a row, as well as any focusable elements\nwithin a cell. This is indicated by the focus ring, as created with the `useFocusRing`\nhook. The cell's contents are available in the `rendered` property of the cell `Node`\nobject.\n\n```\nimport {useTableCell} from 'react-aria';\n\nfunction TableCell({ cell, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { gridCellProps } = useTableCell({ node: cell }, state, ref);\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <td\n      {...mergeProps(gridCellProps, focusProps)}\n      style={{\n        padding: '5px 10px',\n        outline: 'none',\n        boxShadow: isFocusVisible ? 'inset 0 0 0 2px orange' : 'none'\n      }}\n      ref={ref}\n    >\n      {cell.rendered}\n    </td>\n  );\n}\n```\n\n```\nimport {useTableCell} from 'react-aria';\n\nfunction TableCell({ cell, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { gridCellProps } = useTableCell(\n    { node: cell },\n    state,\n    ref\n  );\n  let { isFocusVisible, focusProps } = useFocusRing();\n\n  return (\n    <td\n      {...mergeProps(gridCellProps, focusProps)}\n      style={{\n        padding: '5px 10px',\n        outline: 'none',\n        boxShadow: isFocusVisible\n          ? 'inset 0 0 0 2px orange'\n          : 'none'\n      }}\n      ref={ref}\n    >\n      {cell.rendered}\n    </td>\n  );\n}\n```\n\n```\nimport {useTableCell} from 'react-aria';\n\nfunction TableCell(\n  { cell, state }\n) {\n  let ref = useRef<\n    | HTMLTableCellElement\n    | null\n  >(null);\n  let { gridCellProps } =\n    useTableCell(\n      { node: cell },\n      state,\n      ref\n    );\n  let {\n    isFocusVisible,\n    focusProps\n  } = useFocusRing();\n\n  return (\n    <td\n      {...mergeProps(\n        gridCellProps,\n        focusProps\n      )}\n      style={{\n        padding:\n          '5px 10px',\n        outline: 'none',\n        boxShadow:\n          isFocusVisible\n            ? 'inset 0 0 0 2px orange'\n            : 'none'\n      }}\n      ref={ref}\n    >\n      {cell.rendered}\n    </td>\n  );\n}\n```\n\nWith all of the above components in place, we can render an example of our Table in action.\nThis example shows a static collection, where all of the data is hard coded. [See below](#dynamic-collections)\nfor examples of using this Table component with dynamic collections (e.g. from a server).\n\nTry tabbing into the table and navigating using the arrow keys.\n\n```\n<Table\n  aria-label=\"Example static collection table\"\n  style={{ height: '210px', maxWidth: '400px' }}\n>\n  <TableHeader>\n    <Column>Name</Column>\n    <Column>Type</Column>\n    <Column>Date Modified</Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>Games</Cell>\n      <Cell>File folder</Cell>\n      <Cell>6/7/2020</Cell>\n    </Row>\n    <Row>\n      <Cell>Program Files</Cell>\n      <Cell>File folder</Cell>\n      <Cell>4/7/2021</Cell>\n    </Row>\n    <Row>\n      <Cell>bootmgr</Cell>\n      <Cell>System file</Cell>\n      <Cell>11/20/2010</Cell>\n    </Row>\n    <Row>\n      <Cell>log.txt</Cell>\n      <Cell>Text Document</Cell>\n      <Cell>1/18/2016</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table\n  aria-label=\"Example static collection table\"\n  style={{ height: '210px', maxWidth: '400px' }}\n>\n  <TableHeader>\n    <Column>Name</Column>\n    <Column>Type</Column>\n    <Column>Date Modified</Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>Games</Cell>\n      <Cell>File folder</Cell>\n      <Cell>6/7/2020</Cell>\n    </Row>\n    <Row>\n      <Cell>Program Files</Cell>\n      <Cell>File folder</Cell>\n      <Cell>4/7/2021</Cell>\n    </Row>\n    <Row>\n      <Cell>bootmgr</Cell>\n      <Cell>System file</Cell>\n      <Cell>11/20/2010</Cell>\n    </Row>\n    <Row>\n      <Cell>log.txt</Cell>\n      <Cell>Text Document</Cell>\n      <Cell>1/18/2016</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table\n  aria-label=\"Example static collection table\"\n  style={{\n    height: '210px',\n    maxWidth: '400px'\n  }}\n>\n  <TableHeader>\n    <Column>\n      Name\n    </Column>\n    <Column>\n      Type\n    </Column>\n    <Column>\n      Date Modified\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>\n        Games\n      </Cell>\n      <Cell>\n        File folder\n      </Cell>\n      <Cell>\n        6/7/2020\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        Program Files\n      </Cell>\n      <Cell>\n        File folder\n      </Cell>\n      <Cell>\n        4/7/2021\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        bootmgr\n      </Cell>\n      <Cell>\n        System file\n      </Cell>\n      <Cell>\n        11/20/2010\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        log.txt\n      </Cell>\n      <Cell>\n        Text Document\n      </Cell>\n      <Cell>\n        1/18/2016\n      </Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n### Adding selection[#](#adding-selection)\n\nNext, let's add support for selection. For multiple selection, we'll want to add a column of checkboxes to the left\nof the table to allow the user to select rows. This is done using the `useTableSelectionCheckbox`\nhook. It is passed the `parentKey` of the cell, which refers to the row the cell is contained within. When the user\nchecks or unchecks the checkbox, the row will be added or removed from the Table's selection.\n\nThe `Checkbox` component used in this example is independent and can be used separately from `Table`. The code is\navailable below. See [useCheckbox](../Checkbox/useCheckbox.html) for documentation.\n\n```\nimport {useTableSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction TableCheckboxCell({ cell, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { gridCellProps } = useTableCell({ node: cell }, state, ref);\n  let { checkboxProps } = useTableSelectionCheckbox(\n    { key: cell.parentKey },\n    state\n  );\n\n  return (\n    <td\n      {...gridCellProps}\n      ref={ref}\n    >\n      <Checkbox {...checkboxProps} />\n    </td>\n  );\n}\n```\n\n```\nimport {useTableSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction TableCheckboxCell({ cell, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { gridCellProps } = useTableCell(\n    { node: cell },\n    state,\n    ref\n  );\n  let { checkboxProps } = useTableSelectionCheckbox({\n    key: cell.parentKey\n  }, state);\n\n  return (\n    <td\n      {...gridCellProps}\n      ref={ref}\n    >\n      <Checkbox {...checkboxProps} />\n    </td>\n  );\n}\n```\n\n```\nimport {useTableSelectionCheckbox} from 'react-aria';\n\n// Reuse the Checkbox from your component library. See below for details.\nimport {Checkbox} from 'your-component-library';\n\nfunction TableCheckboxCell(\n  { cell, state }\n) {\n  let ref = useRef<\n    | HTMLTableCellElement\n    | null\n  >(null);\n  let { gridCellProps } =\n    useTableCell(\n      { node: cell },\n      state,\n      ref\n    );\n  let { checkboxProps } =\n    useTableSelectionCheckbox(\n      {\n        key:\n          cell.parentKey\n      },\n      state\n    );\n\n  return (\n    <td\n      {...gridCellProps}\n      ref={ref}\n    >\n      <Checkbox\n        {...checkboxProps}\n      />\n    </td>\n  );\n}\n```\n\nWe also want the user to be able to select all rows in the table at once. This is possible using the `\u00e2\u008c\u0098 Cmd` + `A`\nkeyboard shortcut, but we'll also add a checkbox into the table header to do this and represent the selection state visually.\nThis is done using the `useTableSelectAllCheckbox` hook. When all rows are selected,\nthe checkbox will be shown as checked, and when only some rows are selected, the checkbox will be rendered in an indeterminate state.\nThe user can check or uncheck the checkbox to select all or clear the selection, respectively.\n\n**Note**: Always ensure that the cell has accessible content, even when the checkbox is hidden (i.e. in single selection mode). The\n[VisuallyHidden](../VisuallyHidden) component can be used to do this.\n\n```\nimport {useTableSelectAllCheckbox, VisuallyHidden} from 'react-aria';\n\nfunction TableSelectAllCell({ column, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n  let { checkboxProps } = useTableSelectAllCheckbox(state);\n\n  return (\n    <th\n      {...columnHeaderProps}\n      ref={ref}\n    >\n      {state.selectionManager.selectionMode === 'single'\n        ? <VisuallyHidden>{checkboxProps['aria-label']}</VisuallyHidden>\n        : <Checkbox {...checkboxProps} />}\n    </th>\n  );\n}\n```\n\n```\nimport {\n  useTableSelectAllCheckbox,\n  VisuallyHidden\n} from 'react-aria';\n\nfunction TableSelectAllCell({ column, state }) {\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n  let { checkboxProps } = useTableSelectAllCheckbox(state);\n\n  return (\n    <th\n      {...columnHeaderProps}\n      ref={ref}\n    >\n      {state.selectionManager.selectionMode === 'single'\n        ? (\n          <VisuallyHidden>\n            {checkboxProps['aria-label']}\n          </VisuallyHidden>\n        )\n        : <Checkbox {...checkboxProps} />}\n    </th>\n  );\n}\n```\n\n```\nimport {\n  useTableSelectAllCheckbox,\n  VisuallyHidden\n} from 'react-aria';\n\nfunction TableSelectAllCell(\n  { column, state }\n) {\n  let ref = useRef<\n    | HTMLTableCellElement\n    | null\n  >(null);\n  let {\n    columnHeaderProps\n  } =\n    useTableColumnHeader(\n      { node: column },\n      state,\n      ref\n    );\n  let { checkboxProps } =\n    useTableSelectAllCheckbox(\n      state\n    );\n\n  return (\n    <th\n      {...columnHeaderProps}\n      ref={ref}\n    >\n      {state\n          .selectionManager\n          .selectionMode ===\n          'single'\n        ? (\n          <VisuallyHidden>\n            {checkboxProps[\n              'aria-label'\n            ]}\n          </VisuallyHidden>\n        )\n        : (\n          <Checkbox\n            {...checkboxProps}\n          />\n        )}\n    </th>\n  );\n}\n```\n\nThe following example shows how to enable multiple selection support using the Table component we built above.\nIt's as simple as setting the `selectionMode` prop to `\"multiple\"`. Because we set the `showSelectionCheckboxes`\noption of `useTableState` to true when multiple selection is enabled, an extra column for these checkboxes is\nautomatically added for us.\n\nAnd that's it! We now have a fully interactive table component that can support keyboard navigation, single or multiple selection,\nas well as column sorting. In addition, it is fully accessible for screen readers and other assistive technology. See below for more\nexamples of how to use the Table component that we've built.\n\n```\n<Table aria-label=\"Table with selection\" selectionMode=\"multiple\">\n  <TableHeader>\n    <Column>Name</Column>\n    <Column>Type</Column>\n    <Column>Level</Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>Charizard</Cell>\n      <Cell>Fire, Flying</Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>Blastoise</Cell>\n      <Cell>Water</Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>Venusaur</Cell>\n      <Cell>Grass, Poison</Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>Pikachu</Cell>\n      <Cell>Electric</Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table\n  aria-label=\"Table with selection\"\n  selectionMode=\"multiple\"\n>\n  <TableHeader>\n    <Column>Name</Column>\n    <Column>Type</Column>\n    <Column>Level</Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>Charizard</Cell>\n      <Cell>Fire, Flying</Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>Blastoise</Cell>\n      <Cell>Water</Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>Venusaur</Cell>\n      <Cell>Grass, Poison</Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>Pikachu</Cell>\n      <Cell>Electric</Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table\n  aria-label=\"Table with selection\"\n  selectionMode=\"multiple\"\n>\n  <TableHeader>\n    <Column>\n      Name\n    </Column>\n    <Column>\n      Type\n    </Column>\n    <Column>\n      Level\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>\n        Charizard\n      </Cell>\n      <Cell>\n        Fire, Flying\n      </Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>\n        Blastoise\n      </Cell>\n      <Cell>\n        Water\n      </Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>\n        Venusaur\n      </Cell>\n      <Cell>\n        Grass, Poison\n      </Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>\n        Pikachu\n      </Cell>\n      <Cell>\n        Electric\n      </Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n### Checkbox[#](#checkbox)\n\nThe `Checkbox` component used in the above example is used to implement row selection. It is built using the [useCheckbox](../Checkbox/useCheckbox.html)\nhook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useCheckbox} from 'react-aria';\nimport {useToggleState} from 'react-stately';\n\nfunction Checkbox(props) {\n  let ref = React.useRef<HTMLInputElement | null>(null);\n  let state = useToggleState(props);\n  let { inputProps } = useCheckbox(props, state, ref);\n  return <input {...inputProps} ref={ref} style={props.style} />;\n}\n```\n\n```\nimport {useCheckbox} from 'react-aria';\nimport {useToggleState} from 'react-stately';\n\nfunction Checkbox(props) {\n  let ref = React.useRef<HTMLInputElement | null>(null);\n  let state = useToggleState(props);\n  let { inputProps } = useCheckbox(props, state, ref);\n  return (\n    <input {...inputProps} ref={ref} style={props.style} />\n  );\n}\n```\n\n```\nimport {useCheckbox} from 'react-aria';\nimport {useToggleState} from 'react-stately';\n\nfunction Checkbox(\n  props\n) {\n  let ref = React.useRef<\n    | HTMLInputElement\n    | null\n  >(null);\n  let state =\n    useToggleState(\n      props\n    );\n  let { inputProps } =\n    useCheckbox(\n      props,\n      state,\n      ref\n    );\n  return (\n    <input\n      {...inputProps}\n      ref={ref}\n      style={props.style}\n    />\n  );\n}\n```\n\n## Usage[#](#usage)\n\n---\n\n### Dynamic collections[#](#dynamic-collections)\n\nSo far, our examples have shown static collections, where the data is hard coded.\nDynamic collections, as shown below, can be used when the table data comes from an external data source such as an API, or updates over time.\nIn the example below, both the columns and the rows are provided to the table via a render function. You can also make the columns static and\nonly the rows dynamic.\n\n```\nfunction ExampleTable(props) {\n  let columns = [\n    {name: 'Name', key: 'name'},\n    {name: 'Type', key: 'type'},\n    {name: 'Date Modified', key: 'date'}\n  ];\n\n  let rows = [\n    {id: 1, name: 'Games', date: '6/7/2020', type: 'File folder'},\n    {id: 2, name: 'Program Files', date: '4/7/2021', type: 'File folder'},\n    {id: 3, name: 'bootmgr', date: '11/20/2010', type: 'System file'},\n    {id: 4, name: 'log.txt', date: '1/18/2016', type: 'Text Document'}\n  ];\n\n  return (\n    <Table aria-label=\"Example dynamic collection table\" {...props}>\n      <TableHeader columns={columns}>\n        {column => (\n          <Column>\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody items={rows}>\n        {item => (\n          <Row>\n            {columnKey => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nfunction ExampleTable(props) {\n  let columns = [\n    { name: 'Name', key: 'name' },\n    { name: 'Type', key: 'type' },\n    { name: 'Date Modified', key: 'date' }\n  ];\n\n  let rows = [\n    {\n      id: 1,\n      name: 'Games',\n      date: '6/7/2020',\n      type: 'File folder'\n    },\n    {\n      id: 2,\n      name: 'Program Files',\n      date: '4/7/2021',\n      type: 'File folder'\n    },\n    {\n      id: 3,\n      name: 'bootmgr',\n      date: '11/20/2010',\n      type: 'System file'\n    },\n    {\n      id: 4,\n      name: 'log.txt',\n      date: '1/18/2016',\n      type: 'Text Document'\n    }\n  ];\n\n  return (\n    <Table\n      aria-label=\"Example dynamic collection table\"\n      {...props}\n    >\n      <TableHeader columns={columns}>\n        {(column) => (\n          <Column>\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody items={rows}>\n        {(item) => (\n          <Row>\n            {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nfunction ExampleTable(\n  props\n) {\n  let columns = [\n    {\n      name: 'Name',\n      key: 'name'\n    },\n    {\n      name: 'Type',\n      key: 'type'\n    },\n    {\n      name:\n        'Date Modified',\n      key: 'date'\n    }\n  ];\n\n  let rows = [\n    {\n      id: 1,\n      name: 'Games',\n      date: '6/7/2020',\n      type: 'File folder'\n    },\n    {\n      id: 2,\n      name:\n        'Program Files',\n      date: '4/7/2021',\n      type: 'File folder'\n    },\n    {\n      id: 3,\n      name: 'bootmgr',\n      date: '11/20/2010',\n      type: 'System file'\n    },\n    {\n      id: 4,\n      name: 'log.txt',\n      date: '1/18/2016',\n      type:\n        'Text Document'\n    }\n  ];\n\n  return (\n    <Table\n      aria-label=\"Example dynamic collection table\"\n      {...props}\n    >\n      <TableHeader\n        columns={columns}\n      >\n        {(column) => (\n          <Column>\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody\n        items={rows}\n      >\n        {(item) => (\n          <Row>\n            {(columnKey) => (\n              <Cell>\n                {item[\n                  columnKey\n                ]}\n              </Cell>\n            )}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n### Single selection[#](#single-selection)\n\nBy default, `useTableState` doesn't allow row selection but this can be enabled using the `selectionMode` prop. Use `defaultSelectedKeys` to provide a default set of selected rows.\nNote that the value of the selected keys must match the `key` prop of the row.\n\nThe example below enables single selection mode, and uses `defaultSelectedKeys` to select the row with key equal to \"2\".\nA user can click on a different row to change the selection, or click on the same row again to deselect it entirely.\n\n```\n// Using the example above\n<ExampleTable selectionMode=\"single\" defaultSelectedKeys={[2]} />\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"single\"\n  defaultSelectedKeys={[2]}\n/>\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"single\"\n  defaultSelectedKeys={[\n    2\n  ]}\n/>\n```\n\n### Multiple selection[#](#multiple-selection)\n\nMultiple selection can be enabled by setting `selectionMode` to `multiple`.\n\n```\n// Using the example above\n<ExampleTable selectionMode=\"multiple\" defaultSelectedKeys={[2, 4]} />\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[2, 4]}\n/>\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"multiple\"\n  defaultSelectedKeys={[\n    2,\n    4\n  ]}\n/>\n```\n\n### Disallow empty selection[#](#disallow-empty-selection)\n\nTable also supports a `disallowEmptySelection` prop which forces the user to have at least one row in the Table selected at all times.\nIn this mode, if a single row is selected and the user presses it, it will not be deselected.\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"single\"\n  defaultSelectedKeys={[2]}\n  disallowEmptySelection\n/>\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"single\"\n  defaultSelectedKeys={[2]}\n  disallowEmptySelection\n/>\n```\n\n```\n// Using the example above\n<ExampleTable\n  selectionMode=\"single\"\n  defaultSelectedKeys={[\n    2\n  ]}\n  disallowEmptySelection\n/>\n```\n\n### Controlled selection[#](#controlled-selection)\n\nTo programmatically control row selection, use the `selectedKeys` prop paired with the `onSelectionChange` callback. The `key` prop from the selected rows will\nbe passed into the callback when the row is pressed, allowing you to update state accordingly.\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction PokemonTable(props) {\n  let columns = [\n    { name: 'Name', uid: 'name' },\n    { name: 'Type', uid: 'type' },\n    { name: 'Level', uid: 'level' }\n  ];\n\n  let rows = [\n    { id: 1, name: 'Charizard', type: 'Fire, Flying', level: '67' },\n    { id: 2, name: 'Blastoise', type: 'Water', level: '56' },\n    { id: 3, name: 'Venusaur', type: 'Grass, Poison', level: '83' },\n    { id: 4, name: 'Pikachu', type: 'Electric', level: '100' }\n  ];\n\n  let [selectedKeys, setSelectedKeys] = React.useState<Selection>(new Set([2]));\n\n  return (\n    <Table\n      aria-label=\"Table with controlled selection\"\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      <TableHeader columns={columns}>\n        {(column) => (\n          <Column key={column.uid}>\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody items={rows}>\n        {(item) => (\n          <Row>\n            {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction PokemonTable(props) {\n  let columns = [\n    { name: 'Name', uid: 'name' },\n    { name: 'Type', uid: 'type' },\n    { name: 'Level', uid: 'level' }\n  ];\n\n  let rows = [\n    {\n      id: 1,\n      name: 'Charizard',\n      type: 'Fire, Flying',\n      level: '67'\n    },\n    {\n      id: 2,\n      name: 'Blastoise',\n      type: 'Water',\n      level: '56'\n    },\n    {\n      id: 3,\n      name: 'Venusaur',\n      type: 'Grass, Poison',\n      level: '83'\n    },\n    {\n      id: 4,\n      name: 'Pikachu',\n      type: 'Electric',\n      level: '100'\n    }\n  ];\n\n  let [selectedKeys, setSelectedKeys] = React.useState<\n    Selection\n  >(new Set([2]));\n\n  return (\n    <Table\n      aria-label=\"Table with controlled selection\"\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      <TableHeader columns={columns}>\n        {(column) => (\n          <Column key={column.uid}>\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody items={rows}>\n        {(item) => (\n          <Row>\n            {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction PokemonTable(\n  props\n) {\n  let columns = [\n    {\n      name: 'Name',\n      uid: 'name'\n    },\n    {\n      name: 'Type',\n      uid: 'type'\n    },\n    {\n      name: 'Level',\n      uid: 'level'\n    }\n  ];\n\n  let rows = [\n    {\n      id: 1,\n      name: 'Charizard',\n      type:\n        'Fire, Flying',\n      level: '67'\n    },\n    {\n      id: 2,\n      name: 'Blastoise',\n      type: 'Water',\n      level: '56'\n    },\n    {\n      id: 3,\n      name: 'Venusaur',\n      type:\n        'Grass, Poison',\n      level: '83'\n    },\n    {\n      id: 4,\n      name: 'Pikachu',\n      type: 'Electric',\n      level: '100'\n    }\n  ];\n\n  let [\n    selectedKeys,\n    setSelectedKeys\n  ] = React.useState<\n    Selection\n  >(new Set([2]));\n\n  return (\n    <Table\n      aria-label=\"Table with controlled selection\"\n      selectionMode=\"multiple\"\n      selectedKeys={selectedKeys}\n      onSelectionChange={setSelectedKeys}\n      {...props}\n    >\n      <TableHeader\n        columns={columns}\n      >\n        {(column) => (\n          <Column\n            key={column\n              .uid}\n          >\n            {column.name}\n          </Column>\n        )}\n      </TableHeader>\n      <TableBody\n        items={rows}\n      >\n        {(item) => (\n          <Row>\n            {(columnKey) => (\n              <Cell>\n                {item[\n                  columnKey\n                ]}\n              </Cell>\n            )}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n### Disabled rows[#](#disabled-rows)\n\nYou can disable specific rows by providing an array of keys to `useTableState` via the `disabledKeys` prop. This will prevent rows from being selectable as shown in the example below.\nNote that you are responsible for the styling of disabled rows, however, the selection checkbox will be automatically disabled.\n\n```\n// Using the same table as above\n<PokemonTable selectionMode=\"multiple\" disabledKeys={[3]} />\n```\n\n```\n// Using the same table as above\n<PokemonTable selectionMode=\"multiple\" disabledKeys={[3]} />\n```\n\n```\n// Using the same table as above\n<PokemonTable\n  selectionMode=\"multiple\"\n  disabledKeys={[3]}\n/>\n```\n\n### Selection behavior[#](#selection-behavior)\n\nBy default, `useTable` uses the `\"toggle\"` selection behavior, which behaves like a checkbox group: clicking, tapping, or pressing the `Space` or `Enter` keys toggles selection for the focused row. Using the arrow keys moves focus but does not change selection. The `\"toggle\"` selection mode is often paired with a column of checkboxes in each row as an explicit affordance for selection.\n\nWhen the `selectionBehavior` prop is set to `\"replace\"`, clicking a row with the mouse *replaces* the selection with only that row. Using the arrow keys moves both focus and selection. To select multiple rows, modifier keys such as `Ctrl`, `Cmd`, and `Shift` can be used. To move focus without moving selection, the `Ctrl` key on Windows or the `Option` key on macOS can be held while pressing the arrow keys. Holding this modifier while pressing the `Space` key toggles selection for the focused row, which allows multiple selection of non-contiguous items. On touch screen devices, selection always behaves as toggle since modifier keys may not be available. This behavior emulates native platforms such as macOS and Windows, and is often used when checkboxes in each row are not desired.\n\n```\n<PokemonTable selectionMode=\"multiple\" selectionBehavior=\"replace\" />\n```\n\n```\n<PokemonTable\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n/>\n```\n\n```\n<PokemonTable\n  selectionMode=\"multiple\"\n  selectionBehavior=\"replace\"\n/>\n```\n\n### Row actions[#](#row-actions)\n\n`useTable` supports row actions via the `onRowAction` prop, which is useful for functionality such as navigation. In the default `\"toggle\"` selection behavior, when nothing is selected, clicking or tapping the row triggers the row action.\nWhen at least one item is selected, the table is in selection mode, and clicking or tapping a row toggles the selection. Actions may also be triggered via the `Enter` key, and selection using the `Space` key.\n\nThis behavior is slightly different in the `\"replace\"` selection behavior, where single clicking selects the row and actions are performed via double click. On touch devices, the action becomes the primary tap interaction,\nand a long press enters into selection mode, which temporarily swaps the selection behavior to `\"toggle\"` to perform selection (you may wish to display checkboxes when this happens). Deselecting all items exits selection mode\nand reverts the selection behavior back to `\"replace\"`. Keyboard behaviors are unaffected.\n\n```\n<div style={{ display: 'flex', flexWrap: 'wrap', gap: '24px' }}>\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and toggle selection behavior\"\n    selectionMode=\"multiple\"\n    onRowAction={(key) => alert(`Opening item ${key}...`)}\n  />\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and replace selection behavior\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onRowAction={(key) => alert(`Opening item ${key}...`)}\n  />\n</div>\n```\n\n```\n<div\n  style={{\n    display: 'flex',\n    flexWrap: 'wrap',\n    gap: '24px'\n  }}\n>\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and toggle selection behavior\"\n    selectionMode=\"multiple\"\n    onRowAction={(key) =>\n      alert(`Opening item ${key}...`)}\n  />\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and replace selection behavior\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onRowAction={(key) => alert(`Opening item ${key}...`)}\n  />\n</div>\n```\n\n```\n<div\n  style={{\n    display: 'flex',\n    flexWrap: 'wrap',\n    gap: '24px'\n  }}\n>\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and toggle selection behavior\"\n    selectionMode=\"multiple\"\n    onRowAction={(key) =>\n      alert(\n        `Opening item ${key}...`\n      )}\n  />\n  <PokemonTable\n    aria-label=\"Pokemon table with row actions and replace selection behavior\"\n    selectionMode=\"multiple\"\n    selectionBehavior=\"replace\"\n    onRowAction={(key) =>\n      alert(\n        `Opening item ${key}...`\n      )}\n  />\n</div>\n```\n\n### Links[#](#links)\n\nTable rows may also be links to another page or website. This can be achieved by passing the `href` prop to the `<Row>` component. Links behave the same way as described above for row actions depending on the `selectionMode` and `selectionBehavior`.\n\n```\n<Table aria-label=\"Bookmarks\" selectionMode=\"multiple\">\n  <TableHeader>\n    <Column isRowHeader>Name</Column>\n    <Column>URL</Column>\n    <Column>Date added</Column>\n  </TableHeader>\n  <TableBody>\n    <Row href=\"https://adobe.com/\" target=\"_blank\">\n      <Cell>Adobe</Cell>\n      <Cell>https://adobe.com/</Cell>\n      <Cell>January 28, 2023</Cell>\n    </Row>\n    <Row href=\"https://google.com/\" target=\"_blank\">\n      <Cell>Google</Cell>\n      <Cell>https://google.com/</Cell>\n      <Cell>April 5, 2023</Cell>\n    </Row>\n    <Row href=\"https://nytimes.com/\" target=\"_blank\">\n      <Cell>New York Times</Cell>\n      <Cell>https://nytimes.com/</Cell>\n      <Cell>July 12, 2023</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table aria-label=\"Bookmarks\" selectionMode=\"multiple\">\n  <TableHeader>\n    <Column isRowHeader>Name</Column>\n    <Column>URL</Column>\n    <Column>Date added</Column>\n  </TableHeader>\n  <TableBody>\n    <Row href=\"https://adobe.com/\" target=\"_blank\">\n      <Cell>Adobe</Cell>\n      <Cell>https://adobe.com/</Cell>\n      <Cell>January 28, 2023</Cell>\n    </Row>\n    <Row href=\"https://google.com/\" target=\"_blank\">\n      <Cell>Google</Cell>\n      <Cell>https://google.com/</Cell>\n      <Cell>April 5, 2023</Cell>\n    </Row>\n    <Row href=\"https://nytimes.com/\" target=\"_blank\">\n      <Cell>New York Times</Cell>\n      <Cell>https://nytimes.com/</Cell>\n      <Cell>July 12, 2023</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table\n  aria-label=\"Bookmarks\"\n  selectionMode=\"multiple\"\n>\n  <TableHeader>\n    <Column\n      isRowHeader\n    >\n      Name\n    </Column>\n    <Column>\n      URL\n    </Column>\n    <Column>\n      Date added\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row\n      href=\"https://adobe.com/\"\n      target=\"_blank\"\n    >\n      <Cell>\n        Adobe\n      </Cell>\n      <Cell>\n        https://adobe.com/\n      </Cell>\n      <Cell>\n        January 28,\n        2023\n      </Cell>\n    </Row>\n    <Row\n      href=\"https://google.com/\"\n      target=\"_blank\"\n    >\n      <Cell>\n        Google\n      </Cell>\n      <Cell>\n        https://google.com/\n      </Cell>\n      <Cell>\n        April 5, 2023\n      </Cell>\n    </Row>\n    <Row\n      href=\"https://nytimes.com/\"\n      target=\"_blank\"\n    >\n      <Cell>\n        New York Times\n      </Cell>\n      <Cell>\n        https://nytimes.com/\n      </Cell>\n      <Cell>\n        July 12, 2023\n      </Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n#### Client side routing[#](#client-side-routing)\n\nThe `<Row>` component works with frameworks and client side routers like [Next.js](https://nextjs.org/) and [React Router](https://reactrouter.com/en/main). As with other React Aria components that support links, this works via the `RouterProvider` component at the root of your app. See the [framework setup guide](../frameworks) to learn how to set this up.\n\n### Sorting[#](#sorting)\n\nTable supports sorting its data when a column header is pressed. To designate that a Column should support sorting, provide it with\nthe `allowsSorting` prop. The Table accepts a `sortDescriptor` prop that defines the current column key to sort by and the sort direction (ascending/descending).\nWhen the user presses a sortable column header, the column's key and sort direction is passed into the `onSortChange` callback, allowing you to update\nthe `sortDescriptor` appropriately.\n\nThis example performs client side sorting by passing a `sort` function to the [useAsyncList](../useAsyncList.html) hook.\nSee the docs for more information on how to perform server side sorting.\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Character {\n  name: string;\n  height: number;\n  mass: number;\n  birth_year: number;\n}\n\nfunction AsyncSortTable() {\n  let list = useAsyncList<Character>({\n    async load({ signal }) {\n      let res = await fetch(`https://swapi.py4e.com/api/people/?search`, {\n        signal\n      });\n      let json = await res.json();\n      return {\n        items: json.results\n      };\n    },\n    async sort({ items, sortDescriptor }) {\n      return {\n        items: items.sort((a, b) => {\n          let first = a[sortDescriptor.column];\n          let second = b[sortDescriptor.column];\n          let cmp = (parseInt(first) || first) < (parseInt(second) || second)\n            ? -1\n            : 1;\n          if (sortDescriptor.direction === 'descending') {\n            cmp *= -1;\n          }\n          return cmp;\n        })\n      };\n    }\n  });\n\n  return (\n    <Table\n      aria-label=\"Example table with client side sorting\"\n      sortDescriptor={list.sortDescriptor}\n      onSortChange={list.sort}\n    >\n      <TableHeader>\n        <Column key=\"name\" allowsSorting>Name</Column>\n        <Column key=\"height\" allowsSorting>Height</Column>\n        <Column key=\"mass\" allowsSorting>Mass</Column>\n        <Column key=\"birth_year\" allowsSorting>Birth Year</Column>\n      </TableHeader>\n      <TableBody items={list.items}>\n        {(item) => (\n          <Row key={item.name}>\n            {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Character {\n  name: string;\n  height: number;\n  mass: number;\n  birth_year: number;\n}\n\nfunction AsyncSortTable() {\n  let list = useAsyncList<Character>({\n    async load({ signal }) {\n      let res = await fetch(\n        `https://swapi.py4e.com/api/people/?search`,\n        { signal }\n      );\n      let json = await res.json();\n      return {\n        items: json.results\n      };\n    },\n    async sort({ items, sortDescriptor }) {\n      return {\n        items: items.sort((a, b) => {\n          let first = a[sortDescriptor.column];\n          let second = b[sortDescriptor.column];\n          let cmp =\n            (parseInt(first) || first) <\n                (parseInt(second) || second)\n              ? -1\n              : 1;\n          if (sortDescriptor.direction === 'descending') {\n            cmp *= -1;\n          }\n          return cmp;\n        })\n      };\n    }\n  });\n\n  return (\n    <Table\n      aria-label=\"Example table with client side sorting\"\n      sortDescriptor={list.sortDescriptor}\n      onSortChange={list.sort}\n    >\n      <TableHeader>\n        <Column key=\"name\" allowsSorting>Name</Column>\n        <Column key=\"height\" allowsSorting>Height</Column>\n        <Column key=\"mass\" allowsSorting>Mass</Column>\n        <Column key=\"birth_year\" allowsSorting>\n          Birth Year\n        </Column>\n      </TableHeader>\n      <TableBody items={list.items}>\n        {(item) => (\n          <Row key={item.name}>\n            {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n```\nimport {useAsyncList} from 'react-stately';\n\ninterface Character {\n  name: string;\n  height: number;\n  mass: number;\n  birth_year: number;\n}\n\nfunction AsyncSortTable() {\n  let list =\n    useAsyncList<\n      Character\n    >({\n      async load(\n        { signal }\n      ) {\n        let res =\n          await fetch(\n            `https://swapi.py4e.com/api/people/?search`,\n            { signal }\n          );\n        let json =\n          await res\n            .json();\n        return {\n          items:\n            json.results\n        };\n      },\n      async sort(\n        {\n          items,\n          sortDescriptor\n        }\n      ) {\n        return {\n          items: items\n            .sort(\n              (a, b) => {\n                let first =\n                  a[\n                    sortDescriptor\n                      .column\n                  ];\n                let second =\n                  b[\n                    sortDescriptor\n                      .column\n                  ];\n                let cmp =\n                  (parseInt(\n                      first\n                    ) ||\n                      first) <\n                      (parseInt(\n                        second\n                      ) ||\n                        second)\n                    ? -1\n                    : 1;\n                if (\n                  sortDescriptor\n                    .direction ===\n                    'descending'\n                ) {\n                  cmp *=\n                    -1;\n                }\n                return cmp;\n              }\n            )\n        };\n      }\n    });\n\n  return (\n    <Table\n      aria-label=\"Example table with client side sorting\"\n      sortDescriptor={list\n        .sortDescriptor}\n      onSortChange={list\n        .sort}\n    >\n      <TableHeader>\n        <Column\n          key=\"name\"\n          allowsSorting\n        >\n          Name\n        </Column>\n        <Column\n          key=\"height\"\n          allowsSorting\n        >\n          Height\n        </Column>\n        <Column\n          key=\"mass\"\n          allowsSorting\n        >\n          Mass\n        </Column>\n        <Column\n          key=\"birth_year\"\n          allowsSorting\n        >\n          Birth Year\n        </Column>\n      </TableHeader>\n      <TableBody\n        items={list\n          .items}\n      >\n        {(item) => (\n          <Row\n            key={item\n              .name}\n          >\n            {(columnKey) => (\n              <Cell>\n                {item[\n                  columnKey\n                ]}\n              </Cell>\n            )}\n          </Row>\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n\n### Nested columns[#](#nested-columns)\n\nColumns can be nested to create column groups. This will result in more than one header row to be created, with the `colSpan`\nattribute of each column header cell set to the appropriate value so that the columns line up. Data for the leaf columns\nappears in each row of the table body.\n\nThis example also shows the use of the `isRowHeader` prop for `Column`, which controls which columns are included in the\naccessibility name for each row. By default, only the first column is included, but in some cases more than one column may\nbe used to represent the row. In this example, the first and last name columns are combined to form the ARIA label for the row.\nOnly leaf columns may be marked as row headers.\n\n```\n<Table aria-label=\"Example table with nested columns\">\n  <TableHeader>\n    <Column title=\"Name\">\n      <Column isRowHeader>First Name</Column>\n      <Column isRowHeader>Last Name</Column>\n    </Column>\n    <Column title=\"Information\">\n      <Column>Age</Column>\n      <Column>Birthday</Column>\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>Sam</Cell>\n      <Cell>Smith</Cell>\n      <Cell>36</Cell>\n      <Cell>May 3</Cell>\n    </Row>\n    <Row>\n      <Cell>Julia</Cell>\n      <Cell>Jones</Cell>\n      <Cell>24</Cell>\n      <Cell>February 10</Cell>\n    </Row>\n    <Row>\n      <Cell>Peter</Cell>\n      <Cell>Parker</Cell>\n      <Cell>28</Cell>\n      <Cell>September 7</Cell>\n    </Row>\n    <Row>\n      <Cell>Bruce</Cell>\n      <Cell>Wayne</Cell>\n      <Cell>32</Cell>\n      <Cell>December 18</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table aria-label=\"Example table with nested columns\">\n  <TableHeader>\n    <Column title=\"Name\">\n      <Column isRowHeader>First Name</Column>\n      <Column isRowHeader>Last Name</Column>\n    </Column>\n    <Column title=\"Information\">\n      <Column>Age</Column>\n      <Column>Birthday</Column>\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>Sam</Cell>\n      <Cell>Smith</Cell>\n      <Cell>36</Cell>\n      <Cell>May 3</Cell>\n    </Row>\n    <Row>\n      <Cell>Julia</Cell>\n      <Cell>Jones</Cell>\n      <Cell>24</Cell>\n      <Cell>February 10</Cell>\n    </Row>\n    <Row>\n      <Cell>Peter</Cell>\n      <Cell>Parker</Cell>\n      <Cell>28</Cell>\n      <Cell>September 7</Cell>\n    </Row>\n    <Row>\n      <Cell>Bruce</Cell>\n      <Cell>Wayne</Cell>\n      <Cell>32</Cell>\n      <Cell>December 18</Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n```\n<Table aria-label=\"Example table with nested columns\">\n  <TableHeader>\n    <Column title=\"Name\">\n      <Column\n        isRowHeader\n      >\n        First Name\n      </Column>\n      <Column\n        isRowHeader\n      >\n        Last Name\n      </Column>\n    </Column>\n    <Column title=\"Information\">\n      <Column>\n        Age\n      </Column>\n      <Column>\n        Birthday\n      </Column>\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row>\n      <Cell>Sam</Cell>\n      <Cell>\n        Smith\n      </Cell>\n      <Cell>36</Cell>\n      <Cell>\n        May 3\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        Julia\n      </Cell>\n      <Cell>\n        Jones\n      </Cell>\n      <Cell>24</Cell>\n      <Cell>\n        February 10\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        Peter\n      </Cell>\n      <Cell>\n        Parker\n      </Cell>\n      <Cell>28</Cell>\n      <Cell>\n        September 7\n      </Cell>\n    </Row>\n    <Row>\n      <Cell>\n        Bruce\n      </Cell>\n      <Cell>\n        Wayne\n      </Cell>\n      <Cell>32</Cell>\n      <Cell>\n        December 18\n      </Cell>\n    </Row>\n  </TableBody>\n</Table>\n```\n\n### Dynamic nested columns[#](#dynamic-nested-columns)\n\nNested columns can also be defined dynamically using the function syntax and the `childColumns` prop.\nThe following example is the same as the example above, but defined dynamically.\n\n```\ninterface ColumnDefinition {\n  name: string,\n  key: string,\n  children?: ColumnDefinition[],\n  isRowHeader?: boolean\n}\n\nlet columns: ColumnDefinition[] = [\n  {name: 'Name', key: 'name', children: [\n    {name: 'First Name', key: 'first', isRowHeader: true},\n    {name: 'Last Name', key: 'last', isRowHeader: true}\n  ]},\n  {name: 'Information', key: 'info', children: [\n    {name: 'Age', key: 'age'},\n    {name: 'Birthday', key: 'birthday'}\n  ]}\n];\n\nlet rows = [\n  {id: 1, first: 'Sam', last: 'Smith', age: 36, birthday: 'May 3'},\n  {id: 2, first: 'Julia', last: 'Jones', age: 24, birthday: 'February 10'},\n  {id: 3, first: 'Peter', last: 'Parker', age: 28, birthday: 'September 7'},\n  {id: 4, first: 'Bruce', last: 'Wayne', age: 32, birthday: 'December 18'}\n];\n\n<Table aria-label=\"Example table with dynamic nested columns\">\n  <TableHeader columns={columns}>\n    {column => (\n      <Column isRowHeader={column.isRowHeader} childColumns={column.children}>\n        {column.name}\n      </Column>\n    )}\n  </TableHeader>\n  <TableBody items={rows}>\n    {item => (\n      <Row>\n        {columnKey => <Cell>{item[columnKey]}</Cell>}\n      </Row>\n    )}\n  </TableBody>\n</Table>\n```\n\n```\ninterface ColumnDefinition {\n  name: string;\n  key: string;\n  children?: ColumnDefinition[];\n  isRowHeader?: boolean;\n}\n\nlet columns: ColumnDefinition[] = [\n  {\n    name: 'Name',\n    key: 'name',\n    children: [\n      {\n        name: 'First Name',\n        key: 'first',\n        isRowHeader: true\n      },\n      { name: 'Last Name', key: 'last', isRowHeader: true }\n    ]\n  },\n  {\n    name: 'Information',\n    key: 'info',\n    children: [\n      { name: 'Age', key: 'age' },\n      { name: 'Birthday', key: 'birthday' }\n    ]\n  }\n];\n\nlet rows = [\n  {\n    id: 1,\n    first: 'Sam',\n    last: 'Smith',\n    age: 36,\n    birthday: 'May 3'\n  },\n  {\n    id: 2,\n    first: 'Julia',\n    last: 'Jones',\n    age: 24,\n    birthday: 'February 10'\n  },\n  {\n    id: 3,\n    first: 'Peter',\n    last: 'Parker',\n    age: 28,\n    birthday: 'September 7'\n  },\n  {\n    id: 4,\n    first: 'Bruce',\n    last: 'Wayne',\n    age: 32,\n    birthday: 'December 18'\n  }\n];\n\n<Table aria-label=\"Example table with dynamic nested columns\">\n  <TableHeader columns={columns}>\n    {(column) => (\n      <Column\n        isRowHeader={column.isRowHeader}\n        childColumns={column.children}\n      >\n        {column.name}\n      </Column>\n    )}\n  </TableHeader>\n  <TableBody items={rows}>\n    {(item) => (\n      <Row>\n        {(columnKey) => <Cell>{item[columnKey]}</Cell>}\n      </Row>\n    )}\n  </TableBody>\n</Table>\n```\n\n```\ninterface ColumnDefinition {\n  name: string;\n  key: string;\n  children?:\n    ColumnDefinition[];\n  isRowHeader?: boolean;\n}\n\nlet columns:\n  ColumnDefinition[] = [\n    {\n      name: 'Name',\n      key: 'name',\n      children: [\n        {\n          name:\n            'First Name',\n          key: 'first',\n          isRowHeader:\n            true\n        },\n        {\n          name:\n            'Last Name',\n          key: 'last',\n          isRowHeader:\n            true\n        }\n      ]\n    },\n    {\n      name:\n        'Information',\n      key: 'info',\n      children: [\n        {\n          name: 'Age',\n          key: 'age'\n        },\n        {\n          name:\n            'Birthday',\n          key: 'birthday'\n        }\n      ]\n    }\n  ];\n\nlet rows = [\n  {\n    id: 1,\n    first: 'Sam',\n    last: 'Smith',\n    age: 36,\n    birthday: 'May 3'\n  },\n  {\n    id: 2,\n    first: 'Julia',\n    last: 'Jones',\n    age: 24,\n    birthday:\n      'February 10'\n  },\n  {\n    id: 3,\n    first: 'Peter',\n    last: 'Parker',\n    age: 28,\n    birthday:\n      'September 7'\n  },\n  {\n    id: 4,\n    first: 'Bruce',\n    last: 'Wayne',\n    age: 32,\n    birthday:\n      'December 18'\n  }\n];\n\n<Table aria-label=\"Example table with dynamic nested columns\">\n  <TableHeader\n    columns={columns}\n  >\n    {(column) => (\n      <Column\n        isRowHeader={column\n          .isRowHeader}\n        childColumns={column\n          .children}\n      >\n        {column.name}\n      </Column>\n    )}\n  </TableHeader>\n  <TableBody\n    items={rows}\n  >\n    {(item) => (\n      <Row>\n        {(columnKey) => (\n          <Cell>\n            {item[\n              columnKey\n            ]}\n          </Cell>\n        )}\n      </Row>\n    )}\n  </TableBody>\n</Table>\n```\n\n## Resizable Columns[#](#resizable-columns)\n\n---\n\nFor resizable column support, two additional hooks need to be added to the table implementation above. The `useTableColumnResizeState`\nhook from `@react-stately/table` is responsible for initializing and tracking the widths of every column in your table, returning functions that you can use to\nupdate the column widths during a column resize operation. Note that this state is supplementary to the state returned by `useTableState`.\n\nThe second column resizing hook is `useTableColumnResize`. This hook handles the interactions for a table column's resizer\nelement, allowing the user to drag the resizer or use the keyboard arrows to expand the column's width. Be sure to pass the state returned by `useTableColumnResizeState`\nto this hook so the tracked widths can be updated appropriately. We'll walk through all the required changes to the previous table implementation step by step below. For simplicity's sake, we'll be\nomitting support for selection, sorting, and nested columns.\n\n### Table[#](#table)\n\nAs mentioned previously, we first need to call `useTableColumnResizeState` to initialize the widths for our table's columns.\nWe'll pass the state returned by `useTableColumnResizeState` along with any user defined `onResize` handlers\nto our `ResizableTableColumnHeaders` so it can be used by `useTableColumnResize`.\n\nThe various style changes below are to add a wrapper div so the table is scrollable when the row content overflows and to support table body/column widths greater than the 300px applied to the table itself.\n\n```\nimport {useTableColumnResizeState} from 'react-stately';\nimport {useCallback} from 'react';\n\nfunction ResizableColumnsTable(props) {\n  let state = useTableState(props);\n  let scrollRef = useRef<HTMLDivElement | null>(null);\n  let ref = useRef<HTMLTableElement | null>(null);\n  let { collection } = state;\n  let { gridProps } = useTable(\n    {\n      ...props,\n      // The table wrapper is scrollable rather than just the body\n      scrollRef\n          },\n    state,\n    ref\n  );\n\n  // Set the minimum width of the columns to 40px\n  let getDefaultMinWidth = useCallback(() => {\n    return 40;\n  }, []);\n\n  let layoutState = useTableColumnResizeState({\n    // Matches the width of the table itself\n    tableWidth: 300,\n    getDefaultMinWidth\n  }, state);\n  return (\n    <div className=\"aria-table-wrapper\" ref={scrollRef}>      <table\n        {...gridProps}\n        className=\"aria-table\"\n        ref={ref}\n      >\n        <TableRowGroup type=\"thead\">\n          {collection.headerRows.map((headerRow) => (\n            <TableHeaderRow key={headerRow.key} item={headerRow} state={state}>\n              {[...headerRow.childNodes].map((column) => (\n                <ResizableTableColumnHeader\n                  key={column.key}\n                  column={column}\n                  state={state}\n                  layoutState={layoutState}\n                  onResizeStart={props.onResizeStart}\n                  onResize={props.onResize}\n                  onResizeEnd={props.onResizeEnd}                />\n              ))}\n            </TableHeaderRow>\n          ))}\n        </TableRowGroup>\n        <TableRowGroup type=\"tbody\">\n          {[...collection.body.childNodes].map((row) => (\n            <TableRow key={row.key} item={row} state={state}>\n              {[...row.childNodes].map((cell) => (\n                <TableCell key={cell.key} cell={cell} state={state} />\n              ))}\n            </TableRow>\n          ))}\n        </TableRowGroup>\n      </table>\n    </div>\n  );\n}\n```\n\n```\nimport {useTableColumnResizeState} from 'react-stately';\nimport {useCallback} from 'react';\n\nfunction ResizableColumnsTable(props) {\n  let state = useTableState(props);\n  let scrollRef = useRef<HTMLDivElement | null>(null);\n  let ref = useRef<HTMLTableElement | null>(null);\n  let { collection } = state;\n  let { gridProps } = useTable(\n    {\n      ...props,\n      // The table wrapper is scrollable rather than just the body\n      scrollRef\n          },\n    state,\n    ref\n  );\n\n  // Set the minimum width of the columns to 40px\n  let getDefaultMinWidth = useCallback(() => {\n    return 40;\n  }, []);\n\n  let layoutState = useTableColumnResizeState({\n    // Matches the width of the table itself\n    tableWidth: 300,\n    getDefaultMinWidth\n  }, state);\n  return (\n    <div className=\"aria-table-wrapper\" ref={scrollRef}>      <table\n        {...gridProps}\n        className=\"aria-table\"\n        ref={ref}\n      >\n        <TableRowGroup type=\"thead\">\n          {collection.headerRows.map((headerRow) => (\n            <TableHeaderRow\n              key={headerRow.key}\n              item={headerRow}\n              state={state}\n            >\n              {[...headerRow.childNodes].map((column) => (\n                <ResizableTableColumnHeader\n                  key={column.key}\n                  column={column}\n                  state={state}\n                  layoutState={layoutState}\n                  onResizeStart={props.onResizeStart}\n                  onResize={props.onResize}\n                  onResizeEnd={props.onResizeEnd}                />\n              ))}\n            </TableHeaderRow>\n          ))}\n        </TableRowGroup>\n        <TableRowGroup type=\"tbody\">\n          {[...collection.body.childNodes].map((row) => (\n            <TableRow\n              key={row.key}\n              item={row}\n              state={state}\n            >\n              {[...row.childNodes].map((cell) => (\n                <TableCell\n                  key={cell.key}\n                  cell={cell}\n                  state={state}\n                />\n              ))}\n            </TableRow>\n          ))}\n        </TableRowGroup>\n      </table>\n    </div>\n  );\n}\n```\n\n```\nimport {useTableColumnResizeState} from 'react-stately';\nimport {useCallback} from 'react';\n\nfunction ResizableColumnsTable(\n  props\n) {\n  let state =\n    useTableState(props);\n  let scrollRef = useRef<\n    HTMLDivElement | null\n  >(null);\n  let ref = useRef<\n    | HTMLTableElement\n    | null\n  >(null);\n  let { collection } =\n    state;\n  let { gridProps } =\n    useTable(\n      {\n        ...props,\n        // The table wrapper is scrollable rather than just the body\n        scrollRef\n              },\n      state,\n      ref\n    );\n\n  // Set the minimum width of the columns to 40px\n  let getDefaultMinWidth =\n    useCallback(() => {\n      return 40;\n    }, []);\n\n  let layoutState =\n    useTableColumnResizeState(\n      {\n        // Matches the width of the table itself\n        tableWidth: 300,\n        getDefaultMinWidth\n      },\n      state\n    );\n  return (\n    <div\n      className=\"aria-table-wrapper\"\n      ref={scrollRef}\n    >      <table\n        {...gridProps}\n        className=\"aria-table\"\n        ref={ref}\n      >\n        <TableRowGroup type=\"thead\">\n          {collection\n            .headerRows\n            .map(\n              (headerRow) => (\n                <TableHeaderRow\n                  key={headerRow\n                    .key}\n                  item={headerRow}\n                  state={state}\n                >\n                  {[\n                    ...headerRow\n                      .childNodes\n                  ].map(\n                    (column) => (\n                      <ResizableTableColumnHeader\n                        key={column\n                          .key}\n                        column={column}\n                        state={state}\n                        layoutState={layoutState}\n                        onResizeStart={props\n                          .onResizeStart}\n                        onResize={props\n                          .onResize}\n                        onResizeEnd={props\n                          .onResizeEnd}                      />\n                    )\n                  )}\n                </TableHeaderRow>\n              )\n            )}\n        </TableRowGroup>\n        <TableRowGroup type=\"tbody\">\n          {[\n            ...collection\n              .body\n              .childNodes\n          ].map(\n            (row) => (\n              <TableRow\n                key={row\n                  .key}\n                item={row}\n                state={state}\n              >\n                {[\n                  ...row\n                    .childNodes\n                ].map(\n                  (cell) => (\n                    <TableCell\n                      key={cell\n                        .key}\n                      cell={cell}\n                      state={state}\n                    />\n                  )\n                )}\n              </TableRow>\n            )\n          )}\n        </TableRowGroup>\n      </table>\n    </div>\n  );\n}\n```\n\n Show CSS\n\n```\n.aria-table-wrapper {\n  width: 300px;\n  overflow: auto;\n}\n\n.aria-table {\n  border-collapse: collapse;\n  table-layout: fixed;\n  width: fit-content;\n\n  & td {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n}\n```\n\n```\n.aria-table-wrapper {\n  width: 300px;\n  overflow: auto;\n}\n\n.aria-table {\n  border-collapse: collapse;\n  table-layout: fixed;\n  width: fit-content;\n\n  & td {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n}\n```\n\n```\n.aria-table-wrapper {\n  width: 300px;\n  overflow: auto;\n}\n\n.aria-table {\n  border-collapse: collapse;\n  table-layout: fixed;\n  width: fit-content;\n\n  & td {\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n  }\n}\n```\n\n### Resizable table header[#](#resizable-table-header)\n\nThe `TableColumnHeader` is where we see the bulk of the changes required to support resizable columns. First of all, we need to accommodate a `Resizer` element in every resizable column that\nthe user can drag or focus to perform a resize operation. Since the resizer will be a focusable element within the table header, we need to make the header title a focusable element as well so keyboard\nfocus won't be immediately sent to the resizer as you navigate between the column headers. Finally, we apply the computed width of our column from `useTableColumnResizeState`\nto the header element.\n\n```\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\nfunction ResizableTableColumnHeader(\n  { column, state, layoutState, onResizeStart, onResize, onResizeEnd }\n) {\n  let allowsResizing = column.props.allowsResizing;\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n\n  return (\n    <th\n      {...columnHeaderProps}\n      className=\"aria-table-headerCell\"\n      style={{ width: layoutState.getColumnWidth(column.key) }}\n      ref={ref}\n    >\n      <div style={{ display: 'flex', position: 'relative' }}>\n        <Button className=\"aria-table-headerTitle\">\n          {column.rendered}\n        </Button>\n        {allowsResizing &&\n          (\n            <Resizer\n              column={column}\n              layoutState={layoutState}\n              onResizeStart={onResizeStart}\n              onResize={onResize}\n              onResizeEnd={onResizeEnd}\n            />\n          )}\n      </div>\n    </th>\n  );\n}\n```\n\n```\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\nfunction ResizableTableColumnHeader(\n  {\n    column,\n    state,\n    layoutState,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  }\n) {\n  let allowsResizing = column.props.allowsResizing;\n  let ref = useRef<HTMLTableCellElement | null>(null);\n  let { columnHeaderProps } = useTableColumnHeader(\n    { node: column },\n    state,\n    ref\n  );\n\n  return (\n    <th\n      {...columnHeaderProps}\n      className=\"aria-table-headerCell\"\n      style={{\n        width: layoutState.getColumnWidth(column.key)\n      }}\n      ref={ref}\n    >\n      <div\n        style={{ display: 'flex', position: 'relative' }}\n      >\n        <Button className=\"aria-table-headerTitle\">\n          {column.rendered}\n        </Button>\n        {allowsResizing &&\n          (\n            <Resizer\n              column={column}\n              layoutState={layoutState}\n              onResizeStart={onResizeStart}\n              onResize={onResize}\n              onResizeEnd={onResizeEnd}\n            />\n          )}\n      </div>\n    </th>\n  );\n}\n```\n\n```\n// Reuse the Button from your component library. See below for details.\nimport {Button} from 'your-component-library';\n\nfunction ResizableTableColumnHeader(\n  {\n    column,\n    state,\n    layoutState,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  }\n) {\n  let allowsResizing =\n    column.props\n      .allowsResizing;\n  let ref = useRef<\n    | HTMLTableCellElement\n    | null\n  >(null);\n  let {\n    columnHeaderProps\n  } =\n    useTableColumnHeader(\n      { node: column },\n      state,\n      ref\n    );\n\n  return (\n    <th\n      {...columnHeaderProps}\n      className=\"aria-table-headerCell\"\n      style={{\n        width:\n          layoutState\n            .getColumnWidth(\n              column.key\n            )\n      }}\n      ref={ref}\n    >\n      <div\n        style={{\n          display:\n            'flex',\n          position:\n            'relative'\n        }}\n      >\n        <Button className=\"aria-table-headerTitle\">\n          {column\n            .rendered}\n        </Button>\n        {allowsResizing &&\n          (\n            <Resizer\n              column={column}\n              layoutState={layoutState}\n              onResizeStart={onResizeStart}\n              onResize={onResize}\n              onResizeEnd={onResizeEnd}\n            />\n          )}\n      </div>\n    </th>\n  );\n}\n```\n\n Show CSS\n\n```\n.aria-table-headerCell {\n  padding: 5px 10px;\n  outline: none;\n  cursor: default;\n  box-sizing: border-box;\n  box-shadow: none;\n  text-align: left;\n}\n\n.aria-table-headerTitle {\n  width: 100%;\n  text-align: left;\n  border: none;\n  background: transparent;\n  flex: 1 1 auto;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  margin-inline-start: -6px;\n  outline: none;\n}\n\n.aria-table-headerTitle.focus {\n  outline: 2px solid orange;\n}\n```\n\n```\n.aria-table-headerCell {\n  padding: 5px 10px;\n  outline: none;\n  cursor: default;\n  box-sizing: border-box;\n  box-shadow: none;\n  text-align: left;\n}\n\n.aria-table-headerTitle {\n  width: 100%;\n  text-align: left;\n  border: none;\n  background: transparent;\n  flex: 1 1 auto;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  margin-inline-start: -6px;\n  outline: none;\n}\n\n.aria-table-headerTitle.focus {\n  outline: 2px solid orange;\n}\n```\n\n```\n.aria-table-headerCell {\n  padding: 5px 10px;\n  outline: none;\n  cursor: default;\n  box-sizing: border-box;\n  box-shadow: none;\n  text-align: left;\n}\n\n.aria-table-headerTitle {\n  width: 100%;\n  text-align: left;\n  border: none;\n  background: transparent;\n  flex: 1 1 auto;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  margin-inline-start: -6px;\n  outline: none;\n}\n\n.aria-table-headerTitle.focus {\n  outline: 2px solid orange;\n}\n```\n\n### Button[#](#button)\n\nThe `Button` component is used in the above example to represent the table column header title. It is built using the [useButton](../Button/useButton.html) hook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { focusProps, isFocusVisible } = useFocusRing();\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button\n      {...mergeProps(buttonProps, focusProps)}\n      ref={ref}\n      className={`${props.className} ${isFocusVisible ? 'focus' : ''}`}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { focusProps, isFocusVisible } = useFocusRing();\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button\n      {...mergeProps(buttonProps, focusProps)}\n      ref={ref}\n      className={`${props.className} ${\n        isFocusVisible ? 'focus' : ''\n      }`}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = useRef<\n    | HTMLButtonElement\n    | null\n  >(null);\n  let {\n    focusProps,\n    isFocusVisible\n  } = useFocusRing();\n  let { buttonProps } =\n    useButton(\n      props,\n      ref\n    );\n  return (\n    <button\n      {...mergeProps(\n        buttonProps,\n        focusProps\n      )}\n      ref={ref}\n      className={`${props.className} ${\n        isFocusVisible\n          ? 'focus'\n          : ''\n      }`}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n### Resizer[#](#resizer)\n\nAs described above, we need to implement an element that the user can drag/interact with to resize a column. Here we'll use the `useTableColumnResize`\nhook to create a visible resizer div for physical drag operations and a visually hidden input responsible for keyboard and screenreader interactions, similar to a [slider](../Slider/useSlider.html).\nUsers can press and drag on the visible resizer to trigger the `onResize` callbacks and update the tracked column widths accordingly. When focused, keyboard users can begin resizing the column by pressing `Enter`.\nOnce resizing is activated, they can use the arrow keys to trigger the same resize events and press `Enter`, `Esc`, or `Space` to exit resizing. Touch screen reader users can swipe\nleft or right to focus the column's resizer input and swipe up and down to resize the column.\n\n```\nimport {useTableColumnResize} from 'react-aria';\n\nfunction Resizer(props) {\n  let { column, layoutState, onResizeStart, onResize, onResizeEnd } = props;\n  let ref = useRef<HTMLInputElement | null>(null);\n  let { resizerProps, inputProps, isResizing } = useTableColumnResize(\n    {\n      column,\n      'aria-label': 'Resizer',\n      onResizeStart,\n      onResize,\n      onResizeEnd\n    },\n    layoutState,\n    ref\n  );\n  let { focusProps, isFocusVisible } = useFocusRing();\n\n  return (\n    <div\n      role=\"presentation\"\n      className={`aria-table-resizer ${isFocusVisible ? 'focus' : ''} ${\n        isResizing ? 'resizing' : ''\n      }`}\n      {...resizerProps}\n    >\n      <input\n        ref={ref}\n        {...mergeProps(inputProps, focusProps)}\n      />\n    </div>\n  );\n}\n```\n\n```\nimport {useTableColumnResize} from 'react-aria';\n\nfunction Resizer(props) {\n  let {\n    column,\n    layoutState,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = props;\n  let ref = useRef<HTMLInputElement | null>(null);\n  let { resizerProps, inputProps, isResizing } =\n    useTableColumnResize(\n      {\n        column,\n        'aria-label': 'Resizer',\n        onResizeStart,\n        onResize,\n        onResizeEnd\n      },\n      layoutState,\n      ref\n    );\n  let { focusProps, isFocusVisible } = useFocusRing();\n\n  return (\n    <div\n      role=\"presentation\"\n      className={`aria-table-resizer ${\n        isFocusVisible ? 'focus' : ''\n      } ${isResizing ? 'resizing' : ''}`}\n      {...resizerProps}\n    >\n      <input\n        ref={ref}\n        {...mergeProps(inputProps, focusProps)}\n      />\n    </div>\n  );\n}\n```\n\n```\nimport {useTableColumnResize} from 'react-aria';\n\nfunction Resizer(props) {\n  let {\n    column,\n    layoutState,\n    onResizeStart,\n    onResize,\n    onResizeEnd\n  } = props;\n  let ref = useRef<\n    | HTMLInputElement\n    | null\n  >(null);\n  let {\n    resizerProps,\n    inputProps,\n    isResizing\n  } =\n    useTableColumnResize(\n      {\n        column,\n        'aria-label':\n          'Resizer',\n        onResizeStart,\n        onResize,\n        onResizeEnd\n      },\n      layoutState,\n      ref\n    );\n  let {\n    focusProps,\n    isFocusVisible\n  } = useFocusRing();\n\n  return (\n    <div\n      role=\"presentation\"\n      className={`aria-table-resizer ${\n        isFocusVisible\n          ? 'focus'\n          : ''\n      } ${\n        isResizing\n          ? 'resizing'\n          : ''\n      }`}\n      {...resizerProps}\n    >\n      <input\n        ref={ref}\n        {...mergeProps(\n          inputProps,\n          focusProps\n        )}\n      />\n    </div>\n  );\n}\n```\n\n Show CSS\n\n```\n.aria-table-resizer {\n  width: 15px;\n  background-color: grey;\n  cursor: col-resize;\n  height: 30px;\n  touch-action: none;\n  flex: 0 0 auto;\n  box-sizing: border-box;\n  border: 5px;\n  border-style: none solid;\n  border-color: transparent;\n  background-clip: content-box;\n}\n\n.aria-table-resizer.focus {\n  background-color: orange;\n}\n\n.aria-table-resizer.resizing {\n  border-color: orange;\n  background-color: transparent;\n}\n```\n\n```\n.aria-table-resizer {\n  width: 15px;\n  background-color: grey;\n  cursor: col-resize;\n  height: 30px;\n  touch-action: none;\n  flex: 0 0 auto;\n  box-sizing: border-box;\n  border: 5px;\n  border-style: none solid;\n  border-color: transparent;\n  background-clip: content-box;\n}\n\n.aria-table-resizer.focus {\n  background-color: orange;\n}\n\n.aria-table-resizer.resizing {\n  border-color: orange;\n  background-color: transparent;\n}\n```\n\n```\n.aria-table-resizer {\n  width: 15px;\n  background-color: grey;\n  cursor: col-resize;\n  height: 30px;\n  touch-action: none;\n  flex: 0 0 auto;\n  box-sizing: border-box;\n  border: 5px;\n  border-style: none solid;\n  border-color: transparent;\n  background-clip: content-box;\n}\n\n.aria-table-resizer.focus {\n  background-color: orange;\n}\n\n.aria-table-resizer.resizing {\n  border-color: orange;\n  background-color: transparent;\n}\n```\n\nAnd with that, all necessary changes to the previous table implementation have been made and we now have a table that supports resizable columns!\nThe example below supports resizing via mouse, keyboard, touch, and screen reader interactions. To see an example with sorting and selection, see the\n[styled example](#styled-examples)!\n\n```\n<ResizableColumnsTable aria-label=\"Table with resizable columns\">\n  <TableHeader>\n    <Column allowsResizing>Name</Column>\n    <Column allowsResizing>Type</Column>\n    <Column allowsResizing>Level</Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>Charizard</Cell>\n      <Cell>Fire, Flying</Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>Blastoise</Cell>\n      <Cell>Water</Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>Venusaur</Cell>\n      <Cell>Grass, Poison</Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>Pikachu</Cell>\n      <Cell>Electric</Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</ResizableColumnsTable>\n```\n\n```\n<ResizableColumnsTable aria-label=\"Table with resizable columns\">\n  <TableHeader>\n    <Column allowsResizing>Name</Column>\n    <Column allowsResizing>Type</Column>\n    <Column allowsResizing>Level</Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>Charizard</Cell>\n      <Cell>Fire, Flying</Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>Blastoise</Cell>\n      <Cell>Water</Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>Venusaur</Cell>\n      <Cell>Grass, Poison</Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>Pikachu</Cell>\n      <Cell>Electric</Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</ResizableColumnsTable>\n```\n\n```\n<ResizableColumnsTable aria-label=\"Table with resizable columns\">\n  <TableHeader>\n    <Column\n      allowsResizing\n    >\n      Name\n    </Column>\n    <Column\n      allowsResizing\n    >\n      Type\n    </Column>\n    <Column\n      allowsResizing\n    >\n      Level\n    </Column>\n  </TableHeader>\n  <TableBody>\n    <Row key=\"1\">\n      <Cell>\n        Charizard\n      </Cell>\n      <Cell>\n        Fire, Flying\n      </Cell>\n      <Cell>67</Cell>\n    </Row>\n    <Row key=\"2\">\n      <Cell>\n        Blastoise\n      </Cell>\n      <Cell>\n        Water\n      </Cell>\n      <Cell>56</Cell>\n    </Row>\n    <Row key=\"3\">\n      <Cell>\n        Venusaur\n      </Cell>\n      <Cell>\n        Grass, Poison\n      </Cell>\n      <Cell>83</Cell>\n    </Row>\n    <Row key=\"4\">\n      <Cell>\n        Pikachu\n      </Cell>\n      <Cell>\n        Electric\n      </Cell>\n      <Cell>100</Cell>\n    </Row>\n  </TableBody>\n</ResizableColumnsTable>\n```\n\n### Styled examples[#](#styled-examples)\n\n[![](/Table-tailwind.36cf5f3e.png)\n\nTailwind CSS\n\nA table supporting resizable columns, selection, and sorting built with Tailwind and React Aria.](https://codesandbox.io/s/objective-cherry-g837on?file=/src/Table.tsx)\n\n## Internationalization[#](#internationalization)\n\n---\n\n`useTable` handles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\n[Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator)\nfor internationalized string matching, and keyboard navigation is mirrored in right-to-left languages.\nYou are responsible for localizing all text content within the table.\n\n### RTL[#](#rtl)\n\nIn right-to-left languages, the table layout should be mirrored. The columns should be ordered from right to left and the\nindividual column text alignment should be inverted. Ensure that your CSS accounts for this.\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `layoutDelegate` | `LayoutDelegate` | \u00e2\u0080\u0094 | The layout object for the table. Computes what content is visible and how to position and style them. |\n| `isVirtualized` | `boolean` | \u00e2\u0080\u0094 | Whether the grid uses virtual scrolling. |\n| `disallowTypeAhead` | `boolean` | `false` | Whether typeahead navigation is disabled. |\n| `keyboardDelegate` | `KeyboardDelegate` | \u00e2\u0080\u0094 | An optional keyboard delegate implementation for type to select, to override the default. |\n| `focusMode` | `'row' |\u00c2\u00a0'cell'` | `'row'` | Whether initial grid focus should be placed on the grid row or grid cell. |\n| `getRowText` | `( (key: Key )) => string` | `(key) => state.collection.getItem(key)?.textValue` | A function that returns the text that should be announced by assistive technology when a row is added or removed from selection. |\n| `scrollRef` | `RefObject<HTMLElement |\u00c2\u00a0null>` | \u00e2\u0080\u0094 | The ref attached to the scrollable body. Used to provided automatic scrolling on item focus for non-virtualized grids. |\n| `onRowAction` | `( (key: Key )) => void` | \u00e2\u0080\u0094 | Handler that is called when a user performs an action on the row. |\n| `onCellAction` | `( (key: Key )) => void` | \u00e2\u0080\u0094 | Handler that is called when a user performs an action on the cell. |\n| `escapeKeyBehavior` | `'clearSelection' |\u00c2\u00a0'none'` | `'clearSelection'` | Whether pressing the escape key should clear selection in the grid or not.  Most experiences should not modify this option as it eliminates a keyboard user's ability to easily clear selection. Only use if the escape key is being handled externally or should not trigger selection clearing contextually. |\n| `shouldSelectOnPressUp` | `boolean` | \u00e2\u0080\u0094 | Whether selection should occur on press up instead of press down. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\nA LayoutDelegate provides layout information for collection items.\n\n| Method | Description |\n| --- | --- |\n| `getItemRect( (key: Key )): Rect |\u00c2\u00a0null` | Returns a rectangle for the item with the given key. |\n| `getVisibleRect(): Rect` | Returns the visible rectangle of the collection. |\n| `getContentSize(): Size` | Returns the size of the scrollable content in the collection. |\n| `getKeyRange( (from: Key, , to: Key )): Key[]` | Returns a list of keys between `from` and `to`. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `x` | `number` |  |\n| `y` | `number` |  |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `virtualizer` | `DeprecatedVirtualizer` |  |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getLayoutInfo( (key: Key )): DeprecatedLayoutInfo` |  |\n| `getContentSize(): Size` |  |\n\n`string |\u00c2\u00a0number`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rect` | `Rect` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `visibleRect` | `Rect` |  |\n\n| Method | Description |\n| --- | --- |\n| `getKeyBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually below the given one, or `null` for none. |\n| `getKeyAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually above the given one, or `null` for none. |\n| `getKeyLeftOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the left of the given one, or `null` for none. |\n| `getKeyRightOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the right of the given one, or `null` for none. |\n| `getKeyPageBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page below the given one, or `null` for none. |\n| `getKeyPageAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page above the given one, or `null` for none. |\n| `getFirstKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the first key, or `null` for none. |\n| `getLastKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the last key, or `null` for none. |\n| `getKeyForSearch( (search: string, , fromKey?: Key |\u00c2\u00a0 |\u00c2\u00a0null )): Key |\u00c2\u00a0null` | Returns the next key after `fromKey` that matches the given search string, or `null` for none. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `current` | `T` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `TableCollection<T>` | A collection of rows and columns in the table. |\n| `showSelectionCheckboxes` | `boolean` | Whether the row selection checkboxes should be displayed. |\n| `sortDescriptor` | `SortDescriptor |\u00c2\u00a0null` | The current sorted column and direction. |\n| `isKeyboardNavigationDisabled` | `boolean` | Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. |\n| `setKeyboardNavigationDisabled` | `( (val: boolean )) => void` | Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. |\n| `disabledKeys` | `Set<Key>` | A set of keys for rows that are disabled. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update row selection state. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `sort( (columnKey: Key, , direction?: 'ascending' |\u00c2\u00a0 |\u00c2\u00a0'descending' )): void` | Calls the provided onSortChange handler with the provided column key and sort direction. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `headerRows` | `GridNode<T>[]` | A list of header row nodes in the table. |\n| `columns` | `GridNode<T>[]` | A list of column nodes in the table. |\n| `rowHeaderColumnKeys` | `Set<Key>` | A set of column keys that serve as the [row header](https://www.w3.org/TR/wai-aria-1.1/#rowheader). |\n| `body` | `GridNode<T>` | The node that makes up the body of the table. |\n| `columnCount` | `number` | The number of columns in the grid. |\n| `rows` | `GridNode<T>[]` | A list of rows in the grid. |\n| `size` | `number` | The number of items in the collection. |\n| `head` | `GridNode<T>` | The node that makes up the header of the table. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getKeys(): Iterable<Key>` | Iterate over all keys in the collection. |\n| `getItem( (key: Key )): GridNode<T> |\u00c2\u00a0null` | Get an item by its key. |\n| `at( (idx: number )): GridNode<T> |\u00c2\u00a0null` | Get an item by the index of its key. |\n| `getKeyBefore( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes before the given key in the collection. |\n| `getKeyAfter( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes after the given key in the collection. |\n| `getFirstKey(): Key |\u00c2\u00a0null` | Get the first key in the collection. |\n| `getLastKey(): Key |\u00c2\u00a0null` | Get the last key in the collection. |\n| `getChildren( (key: Key )): Iterable<GridNode<T>>` | Iterate over the child items of the given key. |\n| `getTextValue( (key: Key )): string` | Returns a string representation of the item's contents. |\n| `filter( (filterFn: ( (nodeValue: string, , node: GridNode<T> )) => boolean )): Collection<GridNode<T>>` | Filters the collection using the given function. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `string` | The type of item this node represents. |\n| `key` | `Key` | A unique key for the node. |\n| `value` | `T |\u00c2\u00a0null` | The object value the node was created from. |\n| `level` | `number` | The level of depth this node is at in the hierarchy. |\n| `hasChildNodes` | `boolean` | Whether this item has children, even if not loaded yet. |\n| `rendered` | `ReactNode` | The rendered contents of this node (e.g. JSX). |\n| `textValue` | `string` | A string value for this node, used for features like typeahead. |\n| `index` | `number` | The index of this node within its parent. |\n| `column` | `GridNode<T>` |  |\n| `colSpan` | `number |\u00c2\u00a0null` | The number of columns spanned by this cell. |\n| `colIndex` | `number |\u00c2\u00a0null` | The column index of this cell, accounting for any colSpans. |\n| `indexOfType` | `number` | The index of this node within its parent, ignoring sibling nodes that aren't of the same type. |\n| `aria-label` | `string` | An accessibility label for this node. |\n| `wrapper` | `( (element: ReactElement )) => ReactElement` | A function that should be called to wrap the rendered node. |\n| `parentKey` | `Key |\u00c2\u00a0null` | The key of the parent node. |\n| `prevKey` | `Key |\u00c2\u00a0null` | The key of the node before this node. |\n| `nextKey` | `Key |\u00c2\u00a0null` | The key of the node after this node. |\n| `props` | `any` | Additional properties specific to a particular node type. |\n| `render` | `( (node: Node<any> )) => ReactElement` | A function that renders this node to a React Element in the DOM. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `string` | The type of item this node represents. |\n| `key` | `Key` | A unique key for the node. |\n| `value` | `T |\u00c2\u00a0null` | The object value the node was created from. |\n| `level` | `number` | The level of depth this node is at in the hierarchy. |\n| `hasChildNodes` | `boolean` | Whether this item has children, even if not loaded yet. |\n| `rendered` | `ReactNode` | The rendered contents of this node (e.g. JSX). |\n| `textValue` | `string` | A string value for this node, used for features like typeahead. |\n| `index` | `number` | The index of this node within its parent. |\n| `aria-label` | `string` | An accessibility label for this node. |\n| `wrapper` | `( (element: ReactElement )) => ReactElement` | A function that should be called to wrap the rendered node. |\n| `parentKey` | `Key |\u00c2\u00a0null` | The key of the parent node. |\n| `prevKey` | `Key |\u00c2\u00a0null` | The key of the node before this node. |\n| `nextKey` | `Key |\u00c2\u00a0null` | The key of the node after this node. |\n| `props` | `any` | Additional properties specific to a particular node type. |\n| `render` | `( (node: Node<any> )) => ReactElement` | A function that renders this node to a React Element in the DOM. |\n\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\n\n**Extends**: `Iterable`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `size` | `number` | The number of items in the collection. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getKeys(): Iterable<Key>` | Iterate over all keys in the collection. |\n| `getItem( (key: Key )): T |\u00c2\u00a0null` | Get an item by its key. |\n| `at( (idx: number )): T |\u00c2\u00a0null` | Get an item by the index of its key. |\n| `getKeyBefore( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes before the given key in the collection. |\n| `getKeyAfter( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes after the given key in the collection. |\n| `getFirstKey(): Key |\u00c2\u00a0null` | Get the first key in the collection. |\n| `getLastKey(): Key |\u00c2\u00a0null` | Get the last key in the collection. |\n| `getChildren( (key: Key )): Iterable<T>` | Iterate over the child items of the given key. |\n| `getTextValue( (key: Key )): string` | Returns a string representation of the item's contents. |\n| `filter( (filterFn: ( (nodeValue: string, , node: T )) => boolean )): Collection<T>` | Filters the collection using the given function. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `column` | `Key` | The key of the column to sort by. |\n| `direction` | `SortDirection` | The direction to sort by. |\n\n`'ascending' |\u00c2\u00a0'descending'`\n\nAn interface for reading and updating multiple selection state.\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<unknown>>` |  |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n| `selectedKeys` | `Set<Key>` | The currently selected keys in the collection. |\n| `rawSelection` | `Selection` | The raw selection value for the collection. Either 'all' for select all, or a set of keys. |\n| `isEmpty` | `boolean` | Whether the selection is empty. |\n| `isSelectAll` | `boolean` | Whether all items in the collection are selected. |\n| `firstSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `lastSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `disabledKeys` | `Set<Key>` |  |\n| `disabledBehavior` | `DisabledBehavior` |  |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `constructor( collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions ): void` |  |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , childFocusStrategy?: FocusStrategy )): void` | Sets the focused key. |\n| `isSelected( (key: Key )): boolean` | Returns whether a key is selected. |\n| `extendSelection( (toKey: Key )): void` | Extends the selection to the given key. |\n| `toggleSelection( (key: Key )): void` | Toggles whether the given key is selected. |\n| `replaceSelection( (key: Key )): void` | Replaces the selection with only the given key. |\n| `setSelectedKeys( (keys: Iterable<Key> )): void` | Replaces the selection with the given keys. |\n| `selectAll(): void` | Selects all items in the collection. |\n| `clearSelection(): void` | Removes all keys from the selection. |\n| `toggleSelectAll(): void` | Toggles between select all and an empty selection. |\n| `select( (key: Key, , e?: PressEvent |\u00c2\u00a0LongPressEvent |\u00c2\u00a0PointerEvent )): void` |  |\n| `isSelectionEqual( (selection: Set<Key> )): boolean` | Returns whether the current selection is equal to the given selection. |\n| `canSelectItem( (key: Key )): boolean` |  |\n| `isDisabled( (key: Key )): boolean` |  |\n| `isLink( (key: Key )): boolean` |  |\n| `getItemProps( (key: Key )): any` |  |\n| `withCollection( (collection: Collection<Node<unknown>> )): SelectionManager` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `Selection` | The currently selected keys in the collection. |\n| `disabledKeys` | `Set<Key>` | The currently disabled keys in the collection. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to selection, actions, or both. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setSelectedKeys( (keys: Selection )): void` | Sets the selected keys in the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , child?: FocusStrategy )): void` | Sets the focused key, and optionally, whether the first or last child of that key should receive focus. |\n\n`'none'\n|\u00c2\u00a0'single'\n|\u00c2\u00a0'multiple'`\n\n`'toggle' |\u00c2\u00a0'replace'`\n\n`'all' |\u00c2\u00a0Set<Key>`\n\n`'selection' |\u00c2\u00a0'all'`\n\n`'first' |\u00c2\u00a0'last'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `allowsCellSelection` | `boolean` |  |\n| `layoutDelegate` | `LayoutDelegate` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'longpressstart' |\u00c2\u00a0'longpressend' |\u00c2\u00a0'longpress'` | The type of long press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `expandedKeys` | `'all' |\u00c2\u00a0Set<Key>` | A set of keys for items that are expanded. |\n| `keyMap` | `Map<Key, GridNode<T>>` | The key map containing nodes representing the collection's tree grid structure. |\n| `userColumnCount` | `number` | The number of leaf columns provided by the user. |\n| `collection` | `TableCollection<T>` | A collection of rows and columns in the table. |\n| `showSelectionCheckboxes` | `boolean` | Whether the row selection checkboxes should be displayed. |\n| `sortDescriptor` | `SortDescriptor |\u00c2\u00a0null` | The current sorted column and direction. |\n| `isKeyboardNavigationDisabled` | `boolean` | Whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. |\n| `setKeyboardNavigationDisabled` | `( (val: boolean )) => void` | Set whether keyboard navigation is disabled, such as when the arrow keys should be handled by a component within a cell. |\n| `disabledKeys` | `Set<Key>` | A set of keys for rows that are disabled. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update row selection state. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `toggleKey( (key: Key )): void` | Toggles the expanded state for a row by its key. |\n| `sort( (columnKey: Key, , direction?: 'ascending' |\u00c2\u00a0 |\u00c2\u00a0'descending' )): void` | Calls the provided onSortChange handler with the provided column key and sort direction. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `gridProps` | `DOMAttributes` | Props for the grid element. |\n\nAll DOM attributes supported across both HTML and SVG elements.\n\n**Extends**: `AriaAttributes, ReactDOMAttributes`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `id` | `string |\u00c2\u00a0undefined` |  |\n| `role` | `AriaRole |\u00c2\u00a0undefined` |  |\n| `tabIndex` | `number |\u00c2\u00a0undefined` |  |\n| `style` | `CSSProperties |\u00c2\u00a0undefined` |  |\n| `className` | `string |\u00c2\u00a0undefined` |  |\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rowGroupProps` | `DOMAttributes` | Props for the row group element. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `node` | `GridNode<T>` | An object representing the grid row. Contains all the relevant information that makes up the grid row. |\n| `isVirtualized` | `boolean` | Whether the grid row is contained in a virtual scroller. |\n| `shouldSelectOnPressUp` | `boolean` | Whether selection should occur on press up instead of press down. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rowProps` | `DOMAttributes` | Props for the grid row element. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `node` | `GridNode<T>` | An object representing the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader). Contains all the relevant information that makes up the column header. |\n| `isVirtualized` | `boolean` | Whether the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader) is contained in a virtual scroller. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `columnHeaderProps` | `DOMAttributes` | Props for the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader) element. |\n| `isPressed` | `boolean` | Whether the column is currently in a pressed state. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `rowProps` | `DOMAttributes` | Props for the grid row element. |\n| `isPressed` | `boolean` | Whether the row is currently in a pressed state. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isFocused` | `boolean` | Whether the item is currently focused. |\n| `isDisabled` | `boolean` | Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may not be focused. Dependent on `disabledKeys` and `disabledBehavior`. |\n| `allowsSelection` | `boolean` | Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`. |\n| `hasAction` | `boolean` | Whether the item has an action, dependent on `onAction`, `disabledKeys`, and `disabledBehavior`. It may also change depending on the current selection state of the list (e.g. when selection is primary). This can be used to enable or disable hover styles or other visual indications of interactivity. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `node` | `GridNode<unknown>` | An object representing the table cell. Contains all the relevant information that makes up the row header. |\n| `isVirtualized` | `boolean` | Whether the cell is contained in a virtual scroller. |\n| `shouldSelectOnPressUp` | `boolean` | Whether selection should occur on press up instead of press down. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `gridCellProps` | `DOMAttributes` | Props for the table cell element. |\n| `isPressed` | `boolean` | Whether the cell is currently in a pressed state. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `key` | `Key` | A unique key for the checkbox. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `checkboxProps` | `AriaCheckboxProps` | Props for the row selection checkbox element. |\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isIndeterminate` | `boolean` | \u00e2\u0080\u0094 | Indeterminism is presentational only. The indeterminate visual representation remains regardless of user interaction. |\n| `children` | `ReactNode` | \u00e2\u0080\u0094 | The label for the element. |\n| `value` | `string` | \u00e2\u0080\u0094 | The value of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefvalue). |\n| `defaultSelected` | `boolean` | \u00e2\u0080\u0094 | Whether the element should be selected (uncontrolled). |\n| `isSelected` | `boolean` | \u00e2\u0080\u0094 | Whether the element should be selected (controlled). |\n| `onChange` | `( (isSelected: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's selection state changes. |\n| `isDisabled` | `boolean` | \u00e2\u0080\u0094 | Whether the input is disabled. |\n| `isReadOnly` | `boolean` | \u00e2\u0080\u0094 | Whether the input can be selected but not changed by the user. |\n| `isRequired` | `boolean` | \u00e2\u0080\u0094 | Whether user input is required on the input before form submission. |\n| `isInvalid` | `boolean` | \u00e2\u0080\u0094 | Whether the input value is invalid. |\n| `validationBehavior` | `'aria' |\u00c2\u00a0'native'` | `'aria'` | Whether to use native HTML form validation to prevent form submission when the value is missing or invalid, or mark the field as required or invalid via ARIA. |\n| `validate` | `( (value: boolean )) => ValidationError |\u00c2\u00a0true |\u00c2\u00a0null |\u00c2\u00a0undefined` | \u00e2\u0080\u0094 | A function that returns an error message if a given value is invalid. Validation errors are displayed to the user when the form is submitted if `validationBehavior=\"native\"`. For realtime validation, use the `isInvalid` prop instead. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element should receive focus on render. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `name` | `string` | \u00e2\u0080\u0094 | The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname). |\n| `form` | `string` | \u00e2\u0080\u0094 | The `<form>` element to associate the input with. The value of this attribute must be the id of a `<form>` in the same document. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#form). |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) whose contents or presence are controlled by the current element. |\n| `excludeFromTabOrder` | `boolean` | \u00e2\u0080\u0094 | Whether to exclude the element from the sequential tab order. If true, the element will not be focusable via the keyboard by tabbing. This should be avoided except in rare scenarios where an alternative means of accessing the element or its functionality via the keyboard is available. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n| `aria-errormessage` | `string` | \u00e2\u0080\u0094 | Identifies the element that provides an error message for the object. |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n\n`'valid' |\u00c2\u00a0'invalid'`\n\n`string |\u00c2\u00a0string[]`\n\n`BaseEvent<ReactKeyboardEvent<any>>`\n\n`SyntheticEvent &\u00c2\u00a0{\n\nstopPropagation: () => void,\n\ncontinuePropagation: () => void\n\n}`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `checkboxProps` | `AriaCheckboxProps` | Props for the select all checkbox element. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `column` | `GridNode<T>` | An object representing the [column header](https://www.w3.org/TR/wai-aria-1.1/#columnheader). Contains all the relevant information that makes up the column header. |\n| `aria-label` | `string` | Aria label for the hidden input. Gets read when resizing. |\n| `triggerRef` | `RefObject<FocusableElement |\u00c2\u00a0null>` | Ref to the trigger if resizing was started from a column header menu. If it's provided, focus will be returned there when resizing is done. If it isn't provided, it is assumed that the resizer is visible at all time and keyboard resizing is started via pressing Enter on the resizer and not on focus. |\n| `isDisabled` | `boolean` | If resizing is disabled. |\n| `onResizeStart` | `( (widths: Map<Key, ColumnSize> )) => void` | Called when resizing starts. |\n| `onResize` | `( (widths: Map<Key, ColumnSize> )) => void` | Called for every resize event that results in new column sizes. |\n| `onResizeEnd` | `( (widths: Map<Key, ColumnSize> )) => void` | Called when resizing ends. |\n\nAll possible sizes a column can be assigned.\n\n`ColumnStaticSize |\u00c2\u00a0ColumnDynamicSize`\n\nWidths that result in a constant pixel value for the same Table width.\n\n`` number\n|\u00c2\u00a0`${number}`\n|\u00c2\u00a0`${number}%` ``\n\nWidths that change size in relation to the remaining space and in ratio to other dynamic columns.\nAll numbers must be integers and greater than 0.\nFR units take up remaining, if any, space in the table.\n\n`` `${number}fr` ``\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `updateResizedColumns` | `( (key: Key, , width: number )) => Map<Key, ColumnSize>` | Called to update the state that a resize event has occurred. Returns the new widths for all columns based on the resized column. |\n| `startResize` | `( (key: Key )) => void` | Callback for when onColumnResize has started. |\n| `endResize` | `() => void` | Callback for when onColumnResize has ended. |\n| `getColumnWidth` | `( (key: Key )) => number` | Gets the current width for the specified column. |\n| `getColumnMinWidth` | `( (key: Key )) => number` | Gets the current minWidth for the specified column. |\n| `getColumnMaxWidth` | `( (key: Key )) => number` | Gets the current maxWidth for the specified column. |\n| `resizingColumn` | `Key |\u00c2\u00a0null` | Key of the currently resizing column. |\n| `tableState` | `TableState<T>` | A reference to the table state. |\n| `columnWidths` | `Map<Key, number>` | A map of the current column widths. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `inputProps` | `DOMAttributes` | Props for the visually hidden input element. |\n| `resizerProps` | `DOMAttributes` | Props for the resizer element. |\n| `isResizing` | `boolean` | Whether this column is currently being resized. |\n\nProvides the behavior and accessibility implementation for a table component.\nA table displays data in rows and columns and enables a user to navigate its contents via directional navigation keys,\nand optionally supports row selection and sorting.\n\n`useTable<T>(\nprops: AriaTableProps,\nstate: TableState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeGridState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridAria`\n\nProvides the behavior and accessibility implementation for a row in a table.\n\n`useTableRow<T>(\nprops: GridRowProps<T>,\nstate: TableState<T>\n|\u00c2\u00a0 |\u00c2\u00a0TreeGridState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): GridRowAria`\n\nProvides the behavior and accessibility implementation for a cell in a table.\n\n`useTableCell<T>(\nprops: AriaTableCellProps,\nstate: TableState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableCellAria`\n\nProvides the behavior and accessibility implementation for a column header in a table.\n\n`useTableColumnHeader<T>(\nprops: AriaTableColumnHeaderProps<T>,\nstate: TableState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableColumnHeaderAria`\n\n`useTableRowGroup(): GridRowGroupAria`\n\nProvides the behavior and accessibility implementation for a header row in a table.\n\n`useTableHeaderRow<T>(\nprops: GridRowProps<T>,\nstate: TableState<T>,\nref: RefObject<Element\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableHeaderRowAria`\n\nProvides the behavior and accessibility implementation for the select all checkbox in a table.\n\n`useTableSelectAllCheckbox<T>(\n(state: TableState<T>\n)): TableSelectAllCheckboxAria`\n\nProvides the behavior and accessibility implementation for a selection checkbox in a table.\n\n`useTableSelectionCheckbox<T>(\n(props: AriaTableSelectionCheckboxProps,\n, state: TableState<T>\n)): TableSelectionCheckboxAria`\n\nProvides state management for a table component. Handles building a collection\nof columns and rows from props. In addition, it tracks row selection and manages sort order changes.\n\n`useTableState<T extends object>(\n(props: TableStateProps<T>\n)): TableState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `[ ReactElement<TableHeaderProps<T>>, ReactElement<TableBodyProps<T>> ]` | The elements that make up the table. Includes the TableHeader, TableBody, Columns, and Rows. |\n| `disabledKeys` | `Iterable<Key>` | A list of row keys to disable. |\n| `collection` | `TableCollection<T>` | A pre-constructed collection to use instead of building one from items and children. |\n| `showSelectionCheckboxes` | `boolean` | Whether the row selection checkboxes should be displayed. |\n| `selectionBehavior` | `SelectionBehavior` | How multiple selection should behave in the collection. |\n| `allowDuplicateSelectionEvents` | `boolean` | Whether onSelectionChange should fire even if the new set of keys is the same as the last. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to all interactions, or only selection. |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | Handler that is called when the selection changes. |\n| `sortDescriptor` | `SortDescriptor` | The current sorted column and direction. |\n| `onSortChange` | `( (descriptor: SortDescriptor )) => any` | Handler that is called when the sorted column or direction changes. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `ColumnElement<T> |\u00c2\u00a0ColumnElement<T>[] |\u00c2\u00a0ColumnRenderer<T>` | A list of `Column(s)` or a function. If the latter, a list of columns must be provided using the `columns` prop. |\n| `columns` | `T[]` | A list of table columns. |\n\n`ReactElement<ColumnProps<T>>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `ReactNode |\u00c2\u00a0ColumnElement<T> |\u00c2\u00a0ColumnElement<T>[]` | Static child columns or content to render as the column header. |\n| `title` | `ReactNode` | Rendered contents of the column if `children` contains child columns. |\n| `childColumns` | `T[]` | A list of child columns used when dynamically rendering nested child columns. |\n| `width` | `ColumnSize |\u00c2\u00a0null` | The width of the column. |\n| `minWidth` | `ColumnStaticSize |\u00c2\u00a0null` | The minimum width of the column. |\n| `maxWidth` | `ColumnStaticSize |\u00c2\u00a0null` | The maximum width of the column. |\n| `defaultWidth` | `ColumnSize |\u00c2\u00a0null` | The default width of the column. |\n| `allowsResizing` | `boolean` | Whether the column allows resizing. |\n| `allowsSorting` | `boolean` | Whether the column allows sorting. |\n| `isRowHeader` | `boolean` | Whether a column is a [row header](https://www.w3.org/TR/wai-aria-1.1/#rowheader) and should be announced by assistive technology during row navigation. |\n| `textValue` | `string` | A string representation of the column's contents, used for accessibility announcements. |\n\n`(\n(item: T\n)) => ColumnElement<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `RowElement<T> |\u00c2\u00a0RowElement<T>[] |\u00c2\u00a0( (item: T )) => RowElement<T>` | The contents of the table body. Supports static items or a function for dynamic rendering. |\n| `items` | `Iterable<T>` | A list of row objects in the table body used when dynamically rendering rows. |\n| `loadingState` | `LoadingState` | The current loading state of the table. |\n| `onLoadMore` | `() => any` | Handler that is called when more items should be loaded, e.g. while scrolling near the bottom. |\n\n`ReactElement<RowProps<T>>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `CellElement |\u00c2\u00a0CellElement[] |\u00c2\u00a0CellRenderer` | Rendered contents of the row or row child items. |\n| `textValue` | `string` | A string representation of the row's contents, used for features like typeahead. |\n| `href` | `Href` | A URL to link to. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#href). |\n| `hrefLang` | `string` | Hints at the human language of the linked URL. See[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#hreflang). |\n| `target` | `HTMLAttributeAnchorTarget` | The target window for the link. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#target). |\n| `rel` | `string` | The relationship between the linked resource and the current page. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel). |\n| `download` | `boolean |\u00c2\u00a0string` | Causes the browser to download the linked URL. A string may be provided to suggest a file name. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#download). |\n| `ping` | `string` | A space-separated list of URLs to ping when the link is followed. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#ping). |\n| `referrerPolicy` | `HTMLAttributeReferrerPolicy` | How much of the referrer to send when following the link. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#referrerpolicy). |\n| `routerOptions` | `RouterOptions` | Options for the configured client side router. |\n\n`ReactElement<CellProps>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `children` | `ReactNode` | The contents of the cell. |\n| `textValue` | `string` | A string representation of the cell's contents, used for features like typeahead. |\n| `colSpan` | `number` | Indicates how many columns the data cell spans. |\n\n`(\n(columnKey: Key\n)) => CellElement`\n\n`RouterConfig extends {\n\nhref: any\n\n} ? H : string`\n\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with `href` and `routerOptions` properties to configure your router.\n\n`RouterConfig extends {\n\nrouterOptions: any\n\n} ? O : never`\n\n`'loading'\n|\u00c2\u00a0'sorting'\n|\u00c2\u00a0'loadingMore'\n|\u00c2\u00a0'error'\n|\u00c2\u00a0'idle'\n|\u00c2\u00a0'filtering'`\n\nA TableHeader is a container for the Column elements in a Table. Columns can be statically defined\nas children, or generated dynamically using a function based on the data passed to the `columns` prop.\n\n`TableHeader<T>(\n(props: TableHeaderProps<T>\n)): ReactElement |\u00c2\u00a0null`\n\nA Column represents a field of each item within a Table. Columns may also contain nested\nColumn elements to represent column groups. Nested columns can be statically defined as\nchildren, or dynamically generated using a function based on the `childColumns` prop.\n\n`Column<T>(\n(props: ColumnProps<T>\n)): ReactElement |\u00c2\u00a0null`\n\nA TableBody is a container for the Row elements of a Table. Rows can be statically defined\nas children, or generated dynamically using a function based on the data passed to the `items` prop.\n\n`TableBody<T>(\n(props: TableBodyProps<T>\n)): ReactElement |\u00c2\u00a0null`\n\nA Row represents a single item in a Table and contains Cell elements for each column.\nCells can be statically defined as children, or generated dynamically using a function\nbased on the columns defined in the TableHeader.\n\n`Row<T>(\n(props: RowProps<T>\n)): ReactElement |\u00c2\u00a0null`\n\nA Cell represents the value of a single Column within a Table Row.\n\n`Cell(\n(props: CellProps\n)): ReactElement |\u00c2\u00a0null`\n\nDetermines whether a focus ring should be shown to indicate keyboard focus.\nFocus rings are visible only when the user is interacting with a keyboard,\nnot with a mouse, touch, or other input methods.\n\n`useFocusRing(\n(props: AriaFocusRingProps\n)): FocusRingAria`\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `within` | `boolean` | `'false'` | Whether to show the focus ring when something inside the container element has focus (true), or only if the container itself has focus (false). |\n| `isTextInput` | `boolean` | \u00e2\u0080\u0094 | Whether the element is a text input. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element will be auto focused. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `isFocused` | `boolean` | Whether the element is currently focused. |\n| `isFocusVisible` | `boolean` | Whether keyboard focus should be visible. |\n| `focusProps` | `DOMAttributes` | Props to apply to the container element with the focus ring. |\n\nA RouterProvider accepts a `navigate` function from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `navigate` | `( (path: Href, , routerOptions: RouterOptions |\u00c2\u00a0 |\u00c2\u00a0undefined )) => void` |  |\n| `children` | `ReactNode` |  |\n| `useHref` | `( (href: Href )) => string` |  |\n\nProvides column width state management for a table component with column resizing support. Handles building\na map of column widths calculated from the table's width and any provided column width information from the collection.\nIn addition, it tracks the currently resizing column and provides callbacks for updating the widths upon resize operations.\n\n`useTableColumnResizeState<T>(\n(props: TableColumnResizeStateProps<T>,\n, state: TableState<T>\n)): TableColumnResizeState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `tableWidth` | `number` | Current width of the table or table viewport that the columns should be calculated against. |\n| `getDefaultWidth` | `( (node: GridNode<T> )) => ColumnSize |\u00c2\u00a0null |\u00c2\u00a0undefined` | A function that is called to find the default width for a given column. |\n| `getDefaultMinWidth` | `( (node: GridNode<T> )) => ColumnSize |\u00c2\u00a0null |\u00c2\u00a0undefined` | A function that is called to find the default minWidth for a given column. |\n\nProvides the behavior and accessibility implementation for a table column resizer element.\n\n`useTableColumnResize<T>(\nprops: AriaTableColumnResizeProps<T>,\nstate: TableColumnResizeState<T>,\nref: RefObject<HTMLInputElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): TableColumnResizeAria`",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:38:25.867259+00:00",
  "content_length": 120408,
  "content_hash": "41b29aaff7455797"
}