{
  "id": "react-aria__react-aria_useMenu_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useMenu.html",
  "title": "useMenu",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseMenu\nProvides the behavior and accessibility implementation for a menu component.\nA menu displays a list of actions or options that a user can choose.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useMenuTrigger, useMenu, useMenuItem, useMenuSection}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseMenuTrigger\n<\nT\n>\n(\nprops\n:\nAriaMenuTriggerProps\n,\nstate\n:\nMenuTriggerState\n,\nref\n:\nRefObject\n<\nElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuTriggerAria\n<\nT\n>\nuseMenu\n<\nT\n>\n(\nprops\n:\nAriaMenuOptions\n<\nT\n>\n,\nstate\n:\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuAria\nuseMenuItem\n<\nT\n>\n(\nprops\n:\nAriaMenuItemProps\n,\nstate\n:\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuItemAria\nuseMenuSection\n(\n(\nprops\n:\nAriaMenuSectionProps\n)\n)\n:\nMenuSectionAria\nFeatures\n#\nThere is no native element to implement a menu in HTML that is widely supported.\nuseMenuTrigger\nand\nuseMenu\nhelp achieve accessible menu components that can be styled as needed.\nExposed to assistive technology as a button with a\nmenu\nusing ARIA\nSupport for single, multiple, or no selection\nSupport for disabled items\nSupport for sections\nComplex item labeling support for accessibility\nKeyboard navigation support including arrow keys, home/end, page up/down\nAutomatic scrolling support during keyboard navigation\nKeyboard support for opening the menu using the arrow keys, including automatically focusing\nthe first or last item accordingly\nTypeahead to allow focusing items by typing text\nSupport for use with virtualized lists\nAnatomy\n#\nA menu trigger consists of a button or other trigger element combined with a popup menu,\nwith a list of menu items or groups inside.\nuseMenuTrigger\n,\nuseMenu\n,\nuseMenuItem\n,\nand\nuseMenuSection\nhandle exposing this to assistive technology using ARIA, along with\nhandling keyboard, mouse, and interactions to support selection and focus behavior.\nuseMenuTrigger\nreturns props that you should spread onto the appropriate element:\nName\nType\nDescription\nmenuTriggerProps\nAriaButtonProps\nProps for the menu trigger element.\nmenuProps\nAriaMenuOptions\n<\nT\n>\nProps for the menu.\nuseMenu\nreturns props that you should spread onto the menu container element:\nName\nType\nDescription\nmenuProps\nDOMAttributes\nProps for the menu element.\nuseMenuItem\nreturns props for an individual item and its children:\nName\nType\nDescription\nmenuItemProps\nDOMAttributes\nProps for the menu item element.\nlabelProps\nDOMAttributes\nProps for the main text element inside the menu item.\ndescriptionProps\nDOMAttributes\nProps for the description text element inside the menu item, if any.\nkeyboardShortcutProps\nDOMAttributes\nProps for the keyboard shortcut text element inside the item, if any.\nisFocused\nboolean\nWhether the item is currently focused.\nisFocusVisible\nboolean\nWhether the item is keyboard focused.\nisSelected\nboolean\nWhether the item is currently selected.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisDisabled\nboolean\nWhether the item is disabled.\nuseMenuSection\nreturns props for a section:\nName\nType\nDescription\nitemProps\nDOMAttributes\nProps for the wrapper list item.\nheadingProps\nDOMAttributes\nProps for the heading element, if any.\ngroupProps\nDOMAttributes\nProps for the group element.\nState for the trigger is managed by the\nuseMenuTriggerState\nhook from\n@react-stately/menu\n. State for the menu itself is managed by the\nuseTreeState\nhook from\n@react-stately/tree\n. These state objects should be passed to the appropriate React Aria hooks.\nIf a menu, menu item, or group does not have a visible label, an\naria-label\nor\naria-labelledby\nprop must be passed instead to identify the element to assistive technology.\nExample\n#\nA menu consists of several components: a menu button to toggle the menu popup, and the menu itself, which contains\nitems or sections of items. We'll go through each component one by one.\nMenuButton\n#\nWe'll start with the\nMenuButton\ncomponent, which is what will trigger our menu to appear. This uses\nthe\nuseMenuTrigger\nand\nuseMenuTriggerState\nhooks.\nThe\nPopover\nand\nButton\ncomponents used in this example are independent, and can be shared by many other components.\nThe code is available below, and documentation is available on the corresponding pages.\nimport\ntype\n{\nMenuTriggerProps\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenuTrigger\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseMenuTriggerState\n}\nfrom\n'react-stately'\n;\n// Reuse the Popover, and Button from your component library. See below for details.\nimport\n{\nButton\n,\nPopover\n}\nfrom\n'your-component-library'\n;\ninterface\nMenuButtonProps\n<\nT\n>\nextends\nAriaMenuProps\n<\nT\n>\n,\nMenuTriggerProps\n{\nlabel\n?:\nstring\n;\n}\nfunction\nMenuButton\n<\nT\nextends\nobject\n>\n(\nprops\n:\nMenuButtonProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseMenuTriggerState\n(\nprops\n)\n;\n// Get props for the button and menu elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuTriggerProps\n,\nmenuProps\n}\n=\nuseMenuTrigger\n<\nT\n>\n(\n{\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\nButton\n{\n...\nmenuTriggerProps\n}\nbuttonRef\n=\n{\nref\n}\nstyle\n=\n{\n{\nheight\n:\n30\n,\nfontSize\n:\n14\n}\n}\n>\n{\nprops\n.\nlabel\n}\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npaddingLeft\n:\n5\n}\n}\n>\n\u00e2\u0096\u00bc\n<\n/\nspan\n>\n<\n/\nButton\n>\n{\nstate\n.\nisOpen\n&&\n(\n<\nPopover\nstate\n=\n{\nstate\n}\ntriggerRef\n=\n{\nref\n}\nplacement\n=\n\"bottom start\"\n>\n<\nMenu\n{\n...\nprops\n}\n{\n...\nmenuProps\n}\n/\n>\n<\n/\nPopover\n>\n)\n}\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nMenuTriggerProps\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenuTrigger\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseMenuTriggerState\n}\nfrom\n'react-stately'\n;\n// Reuse the Popover, and Button from your component library. See below for details.\nimport\n{\nButton\n,\nPopover\n}\nfrom\n'your-component-library'\n;\ninterface\nMenuButtonProps\n<\nT\n>\nextends\nAriaMenuProps\n<\nT\n>\n,\nMenuTriggerProps\n{\nlabel\n?:\nstring\n;\n}\nfunction\nMenuButton\n<\nT\nextends\nobject\n>\n(\nprops\n:\nMenuButtonProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseMenuTriggerState\n(\nprops\n)\n;\n// Get props for the button and menu elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuTriggerProps\n,\nmenuProps\n}\n=\nuseMenuTrigger\n<\nT\n>\n(\n{\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\nButton\n{\n...\nmenuTriggerProps\n}\nbuttonRef\n=\n{\nref\n}\nstyle\n=\n{\n{\nheight\n:\n30\n,\nfontSize\n:\n14\n}\n}\n>\n{\nprops\n.\nlabel\n}\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npaddingLeft\n:\n5\n}\n}\n>\n\u00e2\u0096\u00bc\n<\n/\nspan\n>\n<\n/\nButton\n>\n{\nstate\n.\nisOpen\n&&\n(\n<\nPopover\nstate\n=\n{\nstate\n}\ntriggerRef\n=\n{\nref\n}\nplacement\n=\n\"bottom start\"\n>\n<\nMenu\n{\n...\nprops\n}\n{\n...\nmenuProps\n}\n/\n>\n<\n/\nPopover\n>\n)\n}\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nMenuTriggerProps\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenuTrigger\n}\nfrom\n'react-aria'\n;\nimport\n{\nItem\n,\nuseMenuTriggerState\n}\nfrom\n'react-stately'\n;\n// Reuse the Popover, and Button from your component library. See below for details.\nimport\n{\nButton\n,\nPopover\n}\nfrom\n'your-component-library'\n;\ninterface\nMenuButtonProps\n<\nT\n>\nextends\nAriaMenuProps\n<\nT\n>\n,\nMenuTriggerProps\n{\nlabel\n?:\nstring\n;\n}\nfunction\nMenuButton\n<\nT\nextends\nobject\n>\n(\nprops\n:\nMenuButtonProps\n<\nT\n>\n)\n{\n// Create state based on the incoming props\nlet\nstate\n=\nuseMenuTriggerState\n(\nprops\n)\n;\n// Get props for the button and menu elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuTriggerProps\n,\nmenuProps\n}\n=\nuseMenuTrigger\n<\nT\n>\n(\n{\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\n>\n<\nButton\n{\n...\nmenuTriggerProps\n}\nbuttonRef\n=\n{\nref\n}\nstyle\n=\n{\n{\nheight\n:\n30\n,\nfontSize\n:\n14\n}\n}\n>\n{\nprops\n.\nlabel\n}\n<\nspan\naria-hidden\n=\n\"true\"\nstyle\n=\n{\n{\npaddingLeft\n:\n5\n}\n}\n>\n\u00e2\u0096\u00bc\n<\n/\nspan\n>\n<\n/\nButton\n>\n{\nstate\n.\nisOpen\n&&\n(\n<\nPopover\nstate\n=\n{\nstate\n}\ntriggerRef\n=\n{\nref\n}\nplacement\n=\n\"bottom start\"\n>\n<\nMenu\n{\n...\nprops\n}\n{\n...\nmenuProps\n}\n/\n>\n<\n/\nPopover\n>\n)\n}\n<\n/\n>\n)\n;\n}\nMenu\n#\nNext, let's implement the\nMenu\ncomponent. This will appear inside the\nPopover\nwhen the user presses the button.\nIt is built using the\nuseMenu\nand\nuseTreeState\nhooks.\nFor each item in the collection in state, we render either a\nMenuItem\nor\nMenuSection\n(defined\nbelow\n) according to the item's\ntype\nproperty.\nimport\ntype\n{\nAriaMenuProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseTreeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenu\n}\nfrom\n'react-aria'\n;\nfunction\nMenu\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaMenuProps\n<\nT\n>\n)\n{\n// Create menu state based on the incoming props\nlet\nstate\n=\nuseTreeState\n(\nprops\n)\n;\n// Get props for the menu element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuProps\n}\n=\nuseMenu\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\nmenuProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n<\nMenuSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n:\n<\nMenuItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nimport\ntype\n{\nAriaMenuProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseTreeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenu\n}\nfrom\n'react-aria'\n;\nfunction\nMenu\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaMenuProps\n<\nT\n>\n)\n{\n// Create menu state based on the incoming props\nlet\nstate\n=\nuseTreeState\n(\nprops\n)\n;\n// Get props for the menu element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuProps\n}\n=\nuseMenu\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\nmenuProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n(\n<\nMenuSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nMenuItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nimport\ntype\n{\nAriaMenuProps\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseTreeState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseMenu\n}\nfrom\n'react-aria'\n;\nfunction\nMenu\n<\nT\nextends\nobject\n>\n(\nprops\n:\nAriaMenuProps\n<\nT\n>\n)\n{\n// Create menu state based on the incoming props\nlet\nstate\n=\nuseTreeState\n(\nprops\n)\n;\n// Get props for the menu element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuProps\n}\n=\nuseMenu\n(\nprops\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nul\n{\n...\nmenuProps\n}\nref\n=\n{\nref\n}\n>\n{\n[\n...\nstate\n.\ncollection\n]\n.\nmap\n(\n(\nitem\n)\n=>\n(\nitem\n.\ntype\n===\n'section'\n?\n(\n<\nMenuSection\nkey\n=\n{\nitem\n.\nkey\n}\nsection\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n:\n(\n<\nMenuItem\nkey\n=\n{\nitem\n.\nkey\n}\nitem\n=\n{\nitem\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n)\n}\n<\n/\nul\n>\n)\n;\n}\nMenuItem\n#\nNow let's implement\nMenuItem\n. This is built using\nuseMenuItem\n,\nand the\nstate\nobject passed via props from\nMenu\n.\nimport\n{\nuseMenuItem\n}\nfrom\n'react-aria'\n;\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nisSelected\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n{\nisSelected\n&&\n<\nspan\naria-hidden\n=\n\"true\"\n>\n\u00e2\u009c\n<\n/\nspan\n>\n}\n<\n/\nli\n>\n)\n;\n}\nimport\n{\nuseMenuItem\n}\nfrom\n'react-aria'\n;\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nisSelected\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n{\nisSelected\n&&\n<\nspan\naria-hidden\n=\n\"true\"\n>\n\u00e2\u009c\n<\n/\nspan\n>\n}\n<\n/\nli\n>\n)\n;\n}\nimport\n{\nuseMenuItem\n}\nfrom\n'react-aria'\n;\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nisSelected\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n{\nisSelected\n&&\n(\n<\nspan\naria-hidden\n=\n\"true\"\n>\n\u00e2\u009c\n<\n/\nspan\n>\n)\n}\n<\n/\nli\n>\n)\n;\n}\nNow we can render a simple menu with actionable items:\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nShow CSS\n[\nrole\n=\nmenu\n] {\nmargin\n:\n0\n;\npadding\n:\n0\n;\nlist-style\n:\nnone;\nwidth\n:\n200\npx\n;\n}\n\n[\nrole\n=\nmenuitem\n]\n,\n[\nrole\n=\nmenuitemradio\n]\n,\n[\nrole\n=\nmenuitemcheckbox\n] {\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ndisplay\n:\nflex;\njustify-content\n:\nspace-between;\ncolor\n:\nblack;\n&\n:\nfocus\n{\nbackground\n:\ngray;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\ngray;\n  }\n}\n[\nrole\n=\nmenu\n] {\nmargin\n:\n0\n;\npadding\n:\n0\n;\nlist-style\n:\nnone;\nwidth\n:\n200\npx\n;\n}\n\n[\nrole\n=\nmenuitem\n]\n,\n[\nrole\n=\nmenuitemradio\n]\n,\n[\nrole\n=\nmenuitemcheckbox\n] {\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ndisplay\n:\nflex;\njustify-content\n:\nspace-between;\ncolor\n:\nblack;\n&\n:\nfocus\n{\nbackground\n:\ngray;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\ngray;\n  }\n}\n[\nrole\n=\nmenu\n] {\nmargin\n:\n0\n;\npadding\n:\n0\n;\nlist-style\n:\nnone;\nwidth\n:\n200\npx\n;\n}\n\n[\nrole\n=\nmenuitem\n]\n,\n[\nrole\n=\nmenuitemradio\n]\n,\n[\nrole\n=\nmenuitemcheckbox\n] {\npadding\n:\n2\npx\n5\npx\n;\noutline\n:\nnone;\ncursor\n:\ndefault;\ndisplay\n:\nflex;\njustify-content\n:\nspace-between;\ncolor\n:\nblack;\n&\n:\nfocus\n{\nbackground\n:\ngray;\ncolor\n:\nwhite;\n  }\n&\n[\naria-disabled\n] {\ncolor\n:\ngray;\n  }\n}\nPopover\n#\nThe\nPopover\ncomponent is used to contain the menu.\nIt can be shared between many other components, including\nComboBox\n,\nSelect\n, and others.\nSee\nusePopover\nfor more examples of popovers.\nShow code\nimport\n{\nDismissButton\n,\nOverlay\n,\nusePopover\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nAriaPopoverProps\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nOverlayTriggerState\n}\nfrom\n'react-stately'\n;\ninterface\nPopoverProps\nextends\nOmit\n<\nAriaPopoverProps\n,\n'popoverRef'\n>\n{\nchildren\n:\nReact\n.\nReactNode\n;\nstate\n:\nOverlayTriggerState\n;\n}\nfunction\nPopover\n(\n{\nchildren\n,\nstate\n,\n...\nprops\n}\n:\nPopoverProps\n)\n{\nlet\npopoverRef\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\npopoverProps\n,\nunderlayProps\n}\n=\nusePopover\n(\n{\n...\nprops\n,\npopoverRef\n}\n,\nstate\n)\n;\nreturn\n(\n<\nOverlay\n>\n<\ndiv\n{\n...\nunderlayProps\n}\nstyle\n=\n{\n{\nposition\n:\n'fixed'\n,\ninset\n:\n0\n}\n}\n/\n>\n<\ndiv\n{\n...\npopoverProps\n}\nref\n=\n{\npopoverRef\n}\nstyle\n=\n{\n{\n...\npopoverProps\n.\nstyle\n,\nbackground\n:\n'lightgray'\n,\nborder\n:\n'1px solid gray'\n}\n}\n>\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n{\nchildren\n}\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n<\n/\ndiv\n>\n<\n/\nOverlay\n>\n)\n;\n}\nimport\n{\nDismissButton\n,\nOverlay\n,\nusePopover\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nAriaPopoverProps\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nOverlayTriggerState\n}\nfrom\n'react-stately'\n;\ninterface\nPopoverProps\nextends\nOmit\n<\nAriaPopoverProps\n,\n'popoverRef'\n>\n{\nchildren\n:\nReact\n.\nReactNode\n;\nstate\n:\nOverlayTriggerState\n;\n}\nfunction\nPopover\n(\n{\nchildren\n,\nstate\n,\n...\nprops\n}\n:\nPopoverProps\n)\n{\nlet\npopoverRef\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\npopoverProps\n,\nunderlayProps\n}\n=\nusePopover\n(\n{\n...\nprops\n,\npopoverRef\n}\n,\nstate\n)\n;\nreturn\n(\n<\nOverlay\n>\n<\ndiv\n{\n...\nunderlayProps\n}\nstyle\n=\n{\n{\nposition\n:\n'fixed'\n,\ninset\n:\n0\n}\n}\n/\n>\n<\ndiv\n{\n...\npopoverProps\n}\nref\n=\n{\npopoverRef\n}\nstyle\n=\n{\n{\n...\npopoverProps\n.\nstyle\n,\nbackground\n:\n'lightgray'\n,\nborder\n:\n'1px solid gray'\n}\n}\n>\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n{\nchildren\n}\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n<\n/\ndiv\n>\n<\n/\nOverlay\n>\n)\n;\n}\nimport\n{\nDismissButton\n,\nOverlay\n,\nusePopover\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nAriaPopoverProps\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{\nOverlayTriggerState\n}\nfrom\n'react-stately'\n;\ninterface\nPopoverProps\nextends\nOmit\n<\nAriaPopoverProps\n,\n'popoverRef'\n>\n{\nchildren\n:\nReact\n.\nReactNode\n;\nstate\n:\nOverlayTriggerState\n;\n}\nfunction\nPopover\n(\n{\nchildren\n,\nstate\n,\n...\nprops\n}\n:\nPopoverProps\n)\n{\nlet\npopoverRef\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\npopoverProps\n,\nunderlayProps\n}\n=\nusePopover\n(\n{\n...\nprops\n,\npopoverRef\n}\n,\nstate\n)\n;\nreturn\n(\n<\nOverlay\n>\n<\ndiv\n{\n...\nunderlayProps\n}\nstyle\n=\n{\n{\nposition\n:\n'fixed'\n,\ninset\n:\n0\n}\n}\n/\n>\n<\ndiv\n{\n...\npopoverProps\n}\nref\n=\n{\npopoverRef\n}\nstyle\n=\n{\n{\n...\npopoverProps\n.\nstyle\n,\nbackground\n:\n'lightgray'\n,\nborder\n:\n'1px solid gray'\n}\n}\n>\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n{\nchildren\n}\n<\nDismissButton\nonDismiss\n=\n{\nstate\n.\nclose\n}\n/\n>\n<\n/\ndiv\n>\n<\n/\nOverlay\n>\n)\n;\n}\nButton\n#\nThe\nButton\ncomponent is used in the above example to toggle the menu. It is built using the\nuseButton\nhook, and can be shared with many other components.\nShow code\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nprops\n.\nbuttonRef\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nprops\n.\nbuttonRef\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nprops\n.\nbuttonRef\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\nstyle\n=\n{\nprops\n.\nstyle\n}\n>\n{\nprops\n.\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\nStyled examples\n#\nTailwind CSS\nAn example of styling a Menu with Tailwind.\nDynamic collections\n#\nMenu\nfollows the\nCollection Components API\n, accepting both static and dynamic collections.\nThe examples above show static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,\nas shown below, can be used when the options come from an external data source such as an API call, or update over time.\nAs seen below, an iterable list of options is passed to the ComboBox using the\nitems\nprop. Each item accepts a\nkey\nprop, which\nis passed to the\nonSelectionChange\nhandler to identify the selected item. Alternatively, if the item objects contain an\nid\nproperty,\nas shown in the example below, then this is used automatically and a\nkey\nprop is not required.\nfunction\nExample\n(\n)\n{\nlet\nitems\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'New'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Open'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Close'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Save'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Duplicate'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Rename'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Move'\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Actions\"\nitems\n=\n{\nitems\n}\nonAction\n=\n{\nalert\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\nitems\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'New'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Open'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Close'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Save'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Duplicate'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Rename'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Move'\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Actions\"\nitems\n=\n{\nitems\n}\nonAction\n=\n{\nalert\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\nitems\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'New'\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Open'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Close'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'Save'\n}\n,\n{\nid\n:\n5\n,\nname\n:\n'Duplicate'\n}\n,\n{\nid\n:\n6\n,\nname\n:\n'Rename'\n}\n,\n{\nid\n:\n7\n,\nname\n:\n'Move'\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Actions\"\nitems\n=\n{\nitems\n}\nonAction\n=\n{\nalert\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nSelection\n#\nMenu supports multiple selection modes. By default, selection is disabled, however this can be changed using the\nselectionMode\nprop.\nUse\ndefaultSelectedKeys\nto provide a default set of selected items (uncontrolled) and\nselectedKeys\nto set the selected items (controlled). The value of the selected keys must match the\nkey\nprop of the items.\nSee the\nreact-stately\nSelection docs\nfor more details.\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'sidebar'\n,\n'console'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"sidebar\"\n>\nSidebar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"searchbar\"\n>\nSearchbar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tools\"\n>\nTools\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"console\"\n>\nConsole\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\np\n>\nCurrent selection (controlled):\n{\n' '\n}\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'sidebar'\n,\n'console'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"sidebar\"\n>\nSidebar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"searchbar\"\n>\nSearchbar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tools\"\n>\nTools\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"console\"\n>\nConsole\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\np\n>\nCurrent selection (controlled):\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n'sidebar'\n,\n'console'\n]\n)\n)\n;\nreturn\n(\n<\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n<\nItem\nkey\n=\n\"sidebar\"\n>\nSidebar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"searchbar\"\n>\nSearchbar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"tools\"\n>\nTools\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"console\"\n>\nConsole\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\np\n>\nCurrent selection\n        (controlled):\n{\n' '\n}\n{\nselected\n===\n'all'\n?\n'all'\n:\n[\n...\nselected\n]\n.\njoin\n(\n', '\n)\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nSections\n#\nMenu supports sections with separators and headings in order to group options. Sections can be used by wrapping groups of Items in a\nSection\ncomponent. Each\nSection\ntakes a\ntitle\nand\nkey\nprop.\nTo implement sections, implement the\nListBoxSection\ncomponent referenced above\nusing the\nuseMenuSection\nhook. It will include four extra elements:\nan\n<li>\nbetween the sections to represent the separator, an\n<li>\nto contain the heading\n<span>\nelement, and a\n<ul>\nto contain the child items. This structure is necessary to ensure HTML\nsemantics are correct.\nimport\n{\nuseMenuSection\n,\nuseSeparator\n}\nfrom\n'react-aria'\n;\nfunction\nMenuSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseMenuSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\nlet\n{\nseparatorProps\n}\n=\nuseSeparator\n(\n{\nelementType\n:\n'li'\n}\n)\n;\n// If the section is not the first, add a separator element.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\n{\n...\nseparatorProps\n}\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nMenuItem\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nimport\n{\nuseMenuSection\n,\nuseSeparator\n}\nfrom\n'react-aria'\n;\nfunction\nMenuSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseMenuSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\nlet\n{\nseparatorProps\n}\n=\nuseSeparator\n(\n{\nelementType\n:\n'li'\n}\n)\n;\n// If the section is not the first, add a separator element.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\n{\n...\nseparatorProps\n}\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nMenuItem\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nimport\n{\nuseMenuSection\n,\nuseSeparator\n}\nfrom\n'react-aria'\n;\nfunction\nMenuSection\n(\n{\nsection\n,\nstate\n}\n)\n{\nlet\n{\nitemProps\n,\nheadingProps\n,\ngroupProps\n}\n=\nuseMenuSection\n(\n{\nheading\n:\nsection\n.\nrendered\n,\n'aria-label'\n:\nsection\n[\n'aria-label'\n]\n}\n)\n;\nlet\n{\nseparatorProps\n}\n=\nuseSeparator\n(\n{\nelementType\n:\n'li'\n}\n)\n;\n// If the section is not the first, add a separator element.\n// The heading is rendered inside an <li> element, which contains\n// a <ul> with the child items.\nreturn\n(\n<\n>\n{\nsection\n.\nkey\n!==\nstate\n.\ncollection\n.\ngetFirstKey\n(\n)\n&&\n(\n<\nli\n{\n...\nseparatorProps\n}\nstyle\n=\n{\n{\nborderTop\n:\n'1px solid gray'\n,\nmargin\n:\n'2px 5px'\n}\n}\n/\n>\n)\n}\n<\nli\n{\n...\nitemProps\n}\n>\n{\nsection\n.\nrendered\n&&\n(\n<\nspan\n{\n...\nheadingProps\n}\nstyle\n=\n{\n{\nfontWeight\n:\n'bold'\n,\nfontSize\n:\n'1.1em'\n,\npadding\n:\n'2px 5px'\n}\n}\n>\n{\nsection\n.\nrendered\n}\n<\n/\nspan\n>\n)\n}\n<\nul\n{\n...\ngroupProps\n}\nstyle\n=\n{\n{\npadding\n:\n0\n,\nlistStyle\n:\n'none'\n}\n}\n>\n{\n[\n...\nsection\n.\nchildNodes\n]\n.\nmap\n(\n(\nnode\n)\n=>\n(\n<\nMenuItem\nkey\n=\n{\nnode\n.\nkey\n}\nitem\n=\n{\nnode\n}\nstate\n=\n{\nstate\n}\n/\n>\n)\n)\n}\n<\n/\nul\n>\n<\n/\nli\n>\n<\n/\n>\n)\n;\n}\nStatic items\n#\nWith this in place, we can now render a static menu with multiple sections:\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nSection\ntitle\n=\n\"Styles\"\n>\n<\nItem\nkey\n=\n\"bold\"\n>\nBold\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"underline\"\n>\nUnderline\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Align\"\n>\n<\nItem\nkey\n=\n\"left\"\n>\nLeft\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"middle\"\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"right\"\n>\nRight\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nMenuButton\n>\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nSection\ntitle\n=\n\"Styles\"\n>\n<\nItem\nkey\n=\n\"bold\"\n>\nBold\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"underline\"\n>\nUnderline\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Align\"\n>\n<\nItem\nkey\n=\n\"left\"\n>\nLeft\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"middle\"\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"right\"\n>\nRight\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nMenuButton\n>\nimport\n{\nSection\n}\nfrom\n'react-stately'\n;\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nSection\ntitle\n=\n\"Styles\"\n>\n<\nItem\nkey\n=\n\"bold\"\n>\nBold\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"underline\"\n>\nUnderline\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\nSection\ntitle\n=\n\"Align\"\n>\n<\nItem\nkey\n=\n\"left\"\n>\nLeft\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"middle\"\n>\nMiddle\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"right\"\n>\nRight\n<\n/\nItem\n>\n<\n/\nSection\n>\n<\n/\nMenuButton\n>\nDynamic items\n#\nThe above example shows sections with static items. Sections can also be populated from a hierarchical data structure.\nSimilarly to the props on Menu,\n<Section>\ntakes an array of data using the\nitems\nprop.\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n1\n,\n3\n]\n)\n)\n;\nlet\nopenWindows\n=\n[\n{\nname\n:\n'Left Panel'\n,\nid\n:\n'left'\n,\nchildren\n:\n[\n{\nid\n:\n1\n,\nname\n:\n'Final Copy (1)'\n}\n]\n}\n,\n{\nname\n:\n'Right Panel'\n,\nid\n:\n'right'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'index.ts'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'package.json'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'license.txt'\n}\n]\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Window\"\nitems\n=\n{\nopenWindows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\nitem\n=>\n(\n<\nSection\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\nitem\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n1\n,\n3\n]\n)\n)\n;\nlet\nopenWindows\n=\n[\n{\nname\n:\n'Left Panel'\n,\nid\n:\n'left'\n,\nchildren\n:\n[\n{\nid\n:\n1\n,\nname\n:\n'Final Copy (1)'\n}\n]\n}\n,\n{\nname\n:\n'Right Panel'\n,\nid\n:\n'right'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'index.ts'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'package.json'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'license.txt'\n}\n]\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Window\"\nitems\n=\n{\nopenWindows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nSection\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\n(\nitem\n)\n=>\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nimport\ntype\n{\nSelection\n}\nfrom\n'react-stately'\n;\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nReact\n.\nuseState\n<\nSelection\n>\n(\nnew\nSet\n(\n[\n1\n,\n3\n]\n)\n)\n;\nlet\nopenWindows\n=\n[\n{\nname\n:\n'Left Panel'\n,\nid\n:\n'left'\n,\nchildren\n:\n[\n{\nid\n:\n1\n,\nname\n:\n'Final Copy (1)'\n}\n]\n}\n,\n{\nname\n:\n'Right Panel'\n,\nid\n:\n'right'\n,\nchildren\n:\n[\n{\nid\n:\n2\n,\nname\n:\n'index.ts'\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'package.json'\n}\n,\n{\nid\n:\n4\n,\nname\n:\n'license.txt'\n}\n]\n}\n]\n;\nreturn\n(\n<\nMenuButton\nlabel\n=\n\"Window\"\nitems\n=\n{\nopenWindows\n}\nselectionMode\n=\n\"multiple\"\nselectedKeys\n=\n{\nselected\n}\nonSelectionChange\n=\n{\nsetSelected\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nSection\nitems\n=\n{\nitem\n.\nchildren\n}\ntitle\n=\n{\nitem\n.\nname\n}\n>\n{\n(\nitem\n)\n=>\n(\n<\nItem\n>\n{\nitem\n.\nname\n}\n<\n/\nItem\n>\n)\n}\n<\n/\nSection\n>\n)\n}\n<\n/\nMenuButton\n>\n)\n;\n}\nAccessibility\n#\nSections without a\ntitle\nmust provide an\naria-label\nfor accessibility.\nComplex menu items\n#\nBy default, menu items that only contain text will be labeled by the contents of the item.\nFor items that have more complex content (e.g. icons, multiple lines of text, keyboard shortcuts, etc.),\nuse\nlabelProps\n,\ndescriptionProps\n, and\nkeyboardShortcutProps\nfrom\nuseMenuItem\nas needed to apply to the main text element of the menu item, its description, and keyboard\nshortcut text. This improves screen reader announcement.\nNOTE: menu items cannot contain interactive content (e.g. buttons, checkboxes, etc.).\nTo implement this, we'll update the\nMenuItem\ncomponent to apply the ARIA properties\nreturned by\nuseMenuItem\nto the appropriate\nelements. In this example, we'll pull them out of\nprops.children\nand use\nReact.cloneElement\nto apply the props, but you may want to use a more robust approach (e.g. context).\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nlabelProps\n,\ndescriptionProps\n,\nkeyboardShortcutProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Pull out the three expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n,\nshortcut\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\ndiv\n>\n{\nReact\n.\ncloneElement\n(\nshortcut\n,\nkeyboardShortcutProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\ntextValue\n=\n\"Copy\"\nkey\n=\n\"copy\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCopy\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCopy the selected text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098C\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Cut\"\nkey\n=\n\"cut\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCut\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCut the selected text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098X\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Paste\"\nkey\n=\n\"paste\"\n>\n<\ndiv\n>\n<\nstrong\n>\nPaste\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nPaste the copied text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098V\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nlabelProps\n,\ndescriptionProps\n,\nkeyboardShortcutProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Pull out the three expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n,\nshortcut\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\ndiv\n>\n{\nReact\n.\ncloneElement\n(\nshortcut\n,\nkeyboardShortcutProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\ntextValue\n=\n\"Copy\"\nkey\n=\n\"copy\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCopy\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCopy the selected text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098C\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Cut\"\nkey\n=\n\"cut\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCut\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCut the selected text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098X\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Paste\"\nkey\n=\n\"paste\"\n>\n<\ndiv\n>\n<\nstrong\n>\nPaste\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nPaste the copied text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098V\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n,\nlabelProps\n,\ndescriptionProps\n,\nkeyboardShortcutProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\n// Pull out the three expected children. We will clone them\n// and add the necessary props for accessibility.\nlet\n[\ntitle\n,\ndescription\n,\nshortcut\n]\n=\nitem\n.\nrendered\n;\nreturn\n(\n<\nli\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n<\ndiv\n>\n{\nReact\n.\ncloneElement\n(\ntitle\n,\nlabelProps\n)\n}\n{\nReact\n.\ncloneElement\n(\ndescription\n,\ndescriptionProps\n)\n}\n<\n/\ndiv\n>\n{\nReact\n.\ncloneElement\n(\nshortcut\n,\nkeyboardShortcutProps\n)\n}\n<\n/\nli\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\n>\n<\nItem\ntextValue\n=\n\"Copy\"\nkey\n=\n\"copy\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCopy\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCopy the selected\n      text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098C\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Cut\"\nkey\n=\n\"cut\"\n>\n<\ndiv\n>\n<\nstrong\n>\nCut\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nCut the selected\n      text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098X\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\nItem\ntextValue\n=\n\"Paste\"\nkey\n=\n\"paste\"\n>\n<\ndiv\n>\n<\nstrong\n>\nPaste\n<\n/\nstrong\n>\n<\n/\ndiv\n>\n<\ndiv\n>\nPaste the copied\n      text\n<\n/\ndiv\n>\n<\nkbd\n>\n\u00e2\u008c\u0098V\n<\n/\nkbd\n>\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nDisabled items\n#\nuseMenu\nsupports marking items as disabled using the\ndisabledKeys\nprop. Each key in this list\ncorresponds with the\nkey\nprop passed to the\nItem\ncomponent, or automatically derived from the values passed\nto the\nitems\nprop. See\nCollections\nfor more details.\nDisabled items are not focusable or keyboard navigable, and do not trigger\nonAction\nor\nonSelectionChange\n.\nThe\nisDisabled\nproperty returned by\nuseMenuItem\ncan be used to style the item appropriately.\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\ndisabledKeys\n=\n{\n[\n'paste'\n]\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\ndisabledKeys\n=\n{\n[\n'paste'\n]\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\nMenuButton\nlabel\n=\n\"Actions\"\nonAction\n=\n{\nalert\n}\ndisabledKeys\n=\n{\n[\n'paste'\n]\n}\n>\n<\nItem\nkey\n=\n\"copy\"\n>\nCopy\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"cut\"\n>\nCut\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"paste\"\n>\nPaste\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nLinks\n#\nBy default, interacting with an item in a Menu triggers\nonAction\nand optionally\nonSelectionChange\ndepending on the\nselectionMode\n. Alternatively, items may be links to another page or website. This can be achieved by passing the\nhref\nprop to the\n<Item>\ncomponent. Link items in a menu are not selectable.\nThis example shows how to update the\nMenuItem\ncomponent with support for rendering an\n<a>\nelement if an\nhref\nprop is passed to the item. Note that you'll also need to render the\nMenu\nas a\n<div>\ninstead of a\n<ul>\n, since an\n<a>\ninside a\n<ul>\nis not valid HTML.\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nfunction\nMenuItem\n(\n{\nitem\n,\nstate\n}\n)\n{\n// Get props for the menu item element and child elements\nlet\nref\n=\nReact\n.\nuseRef\n(\nnull\n)\n;\nlet\n{\nmenuItemProps\n}\n=\nuseMenuItem\n(\n{\nkey\n:\nitem\n.\nkey\n}\n,\nstate\n,\nref\n)\n;\nlet\nElementType\n:\nReact\n.\nElementType\n=\nitem\n.\nprops\n.\nhref\n?\n'a'\n:\n'div'\n;\nreturn\n(\n<\nElementType\n{\n...\nmenuItemProps\n}\nref\n=\n{\nref\n}\n>\n{\nitem\n.\nrendered\n}\n<\n/\nElementType\n>\n)\n;\n}\n<\nMenuButton\nlabel\n=\n\"Links\"\n>\n<\nItem\nhref\n=\n\"https://adobe.com/\"\ntarget\n=\n\"_blank\"\n>\nAdobe\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://apple.com/\"\ntarget\n=\n\"_blank\"\n>\nApple\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://google.com/\"\ntarget\n=\n\"_blank\"\n>\nGoogle\n<\n/\nItem\n>\n<\nItem\nhref\n=\n\"https://microsoft.com/\"\ntarget\n=\n\"_blank\"\n>\nMicrosoft\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\nClient side routing\n#\nThe\n<Item>\ncomponent works with frameworks and client side routers like\nNext.js\nand\nReact Router\n. As with other React Aria components that support links, this works via the\nRouterProvider\ncomponent at the root of your app. See the\nframework setup guide\nto learn how to set this up.\nControlled open state\n#\nThe open state of the menu can be controlled via the\ndefaultOpen\nand\nisOpen\nprops\nfunction\nExample\n(\n)\n{\nlet\n[\nopen\n,\nsetOpen\n]\n=\nReact\n.\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\np\n>\nMenu is\n{\nopen\n?\n'open'\n:\n'closed'\n}\n<\n/\np\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nisOpen\n=\n{\nopen\n}\nonOpenChange\n=\n{\nsetOpen\n}\n>\n<\nItem\nkey\n=\n\"side\"\n>\nSide bar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"options\"\n>\nPage options\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"edit\"\n>\nEdit Panel\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\n/\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\nopen\n,\nsetOpen\n]\n=\nReact\n.\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\np\n>\nMenu is\n{\nopen\n?\n'open'\n:\n'closed'\n}\n<\n/\np\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nisOpen\n=\n{\nopen\n}\nonOpenChange\n=\n{\nsetOpen\n}\n>\n<\nItem\nkey\n=\n\"side\"\n>\nSide bar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"options\"\n>\nPage options\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"edit\"\n>\nEdit Panel\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\n/\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\nopen\n,\nsetOpen\n]\n=\nReact\n.\nuseState\n(\nfalse\n)\n;\nreturn\n(\n<\n>\n<\np\n>\nMenu is\n{\nopen\n?\n'open'\n:\n'closed'\n}\n<\n/\np\n>\n<\nMenuButton\nlabel\n=\n\"View\"\nisOpen\n=\n{\nopen\n}\nonOpenChange\n=\n{\nsetOpen\n}\n>\n<\nItem\nkey\n=\n\"side\"\n>\nSide bar\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"options\"\n>\nPage options\n<\n/\nItem\n>\n<\nItem\nkey\n=\n\"edit\"\n>\nEdit Panel\n<\n/\nItem\n>\n<\n/\nMenuButton\n>\n<\n/\n>\n)\n;\n}\nInternationalization\n#\nuseMenu\nhandles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\nIntl.Collator\nfor internationalized string matching. You are responsible for localizing all menu item labels for\ncontent that is passed into the menu.\nRTL\n#\nIn right-to-left languages, the menu button should be mirrored. The arrow should be on the left,\nand the label should be on the right. In addition, the content of menu items should\nflip. Ensure that your CSS accounts for this.\nName\nType\nDescription\ntype\n'menu'\n|\u00c2\n'listbox'\nThe type of menu that the menu trigger opens.\nisDisabled\nboolean\nWhether menu trigger is disabled.\ntrigger\nMenuTriggerType\nHow menu is triggered.\n'press'\n|\u00c2\n'longPress'\nProperties\nName\nType\nDescription\nfocusStrategy\nFocusStrategy\n|\u00c2\nnull\nControls which item will be auto focused when the menu opens.\nisOpen\nboolean\nWhether the overlay is currently open.\nMethods\nMethod\nDescription\nopen\n(\n(\nfocusStrategy\n?\n:\nFocusStrategy\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nvoid\nOpens the menu.\ntoggle\n(\n(\nfocusStrategy\n?\n:\nFocusStrategy\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nvoid\nToggles the menu.\nsetOpen\n(\n(\nisOpen\n:\nboolean\n)\n)\n:\nvoid\nSets whether the overlay is open.\nclose\n(\n)\n:\nvoid\nCloses the overlay.\n'first'\n|\u00c2\n'last'\nName\nType\nDescription\ncurrent\nT\nName\nType\nDescription\nmenuTriggerProps\nAriaButtonProps\nProps for the menu trigger element.\nmenuProps\nAriaMenuOptions\n<\nT\n>\nProps for the menu.\nName\nType\nDefault\nDescription\nisDisabled\nboolean\n\u00e2\u0080\u0094\nWhether the button is disabled.\nchildren\nReactNode\n\u00e2\u0080\u0094\nThe content to display in the button.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element should receive focus on render.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nhref\nstring\n\u00e2\u0080\u0094\nA URL to link to if elementType=\"a\".\ntarget\nstring\n\u00e2\u0080\u0094\nThe target window for the link.\nrel\nstring\n\u00e2\u0080\u0094\nThe relationship between the linked resource and the current page. See\nMDN\n.\nelementType\nElementType\n|\u00c2\nJSXElementConstructor\n<\nany\n>\n'button'\nThe HTML element or React element used to render the button, e.g. 'div', 'a', or\nRouterLink\n.\naria-disabled\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element is disabled to users of assistive technology.\naria-expanded\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element, or another grouping element it controls, is currently expanded or collapsed.\naria-haspopup\nboolean\n|\u00c2\n'menu'\n|\u00c2\n'listbox'\n|\u00c2\n'tree'\n|\u00c2\n'grid'\n|\u00c2\n'dialog'\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) whose contents or presence are controlled by the current element.\naria-pressed\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'mixed'\n\u00e2\u0080\u0094\nIndicates the current \"pressed\" state of toggle buttons.\naria-current\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'page'\n|\u00c2\n'step'\n|\u00c2\n'location'\n|\u00c2\n'date'\n|\u00c2\n'time'\n\u00e2\u0080\u0094\nIndicates whether this element represents the current item within a container or set of related elements.\ntype\n'button'\n|\u00c2\n'submit'\n|\u00c2\n'reset'\n'button'\nThe behavior of the button when used in an HTML form.\npreventFocusOnPress\nboolean\n\u00e2\u0080\u0094\nWhether to prevent focus from moving to the button when pressing it.\nCaution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided,\nsuch as ComboBox's MenuTrigger or a NumberField's increment/decrement control.\nform\nstring\n\u00e2\u0080\u0094\nThe\n<form>\nelement to associate the button with.\nThe value of this attribute must be the id of a\n<form>\nin the same document.\nSee\nMDN\n.\nformAction\nstring\n\u00e2\u0080\u0094\nThe URL that processes the information submitted by the button.\nOverrides the action attribute of the button's form owner.\nformEncType\nstring\n\u00e2\u0080\u0094\nIndicates how to encode the form data that is submitted.\nformMethod\nstring\n\u00e2\u0080\u0094\nIndicates the HTTP method used to submit the form.\nformNoValidate\nboolean\n\u00e2\u0080\u0094\nIndicates that the form is not to be validated when it is submitted.\nformTarget\nstring\n\u00e2\u0080\u0094\nOverrides the target attribute of the button's form owner.\nname\nstring\n\u00e2\u0080\u0094\nSubmitted as a pair with the button's value as part of the form data.\nvalue\nstring\n\u00e2\u0080\u0094\nThe value associated with the button's name when it's submitted with the form data.\nexcludeFromTabOrder\nboolean\n\u00e2\u0080\u0094\nWhether to exclude the element from the sequential tab order. If true,\nthe element will not be focusable via the keyboard by tabbing. This should\nbe avoided except in rare scenarios where an alternative means of accessing\nthe element or its functionality via the keyboard is available.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nBaseEvent\n<\nReactKeyboardEvent\n<\nany\n>\n>\nSyntheticEvent\n&\u00c2\n{\nstopPropagation\n:\n(\n)\n=>\nvoid\n,\ncontinuePropagation\n:\n(\n)\n=>\nvoid\n}\nName\nType\nDefault\nDescription\nisVirtualized\nboolean\n\u00e2\u0080\u0094\nWhether the menu uses virtual scrolling.\nkeyboardDelegate\nKeyboardDelegate\n\u00e2\u0080\u0094\nAn optional keyboard delegate implementation for type to select,\nto override the default.\nshouldUseVirtualFocus\nboolean\n\u00e2\u0080\u0094\nWhether the menu items should use virtual focus instead of being focused directly.\nescapeKeyBehavior\n'clearSelection'\n|\u00c2\n'none'\n'clearSelection'\nWhether pressing the escape key should clear selection in the menu or not.\nMost experiences should not modify this option as it eliminates a keyboard user's ability to\neasily clear selection. Only use if the escape key is being handled externally or should not\ntrigger selection clearing contextually.\nautoFocus\nboolean\n|\u00c2\nFocusStrategy\n\u00e2\u0080\u0094\nWhere the focus should be set.\nshouldFocusWrap\nboolean\n\u00e2\u0080\u0094\nWhether keyboard navigation is circular.\nonAction\n(\n(\nkey\n:\nKey\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when an item is selected.\nonClose\n(\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the menu should close after selecting an item.\nitems\nIterable\n<\nT\n>\n\u00e2\u0080\u0094\nItem objects in the collection.\ndisabledKeys\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\nselectionMode\nSelectionMode\n\u00e2\u0080\u0094\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\n\u00e2\u0080\u0094\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\n\u00e2\u0080\u0094\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the selection changes.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nMethod\nDescription\ngetKeyBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually below the given one, or\nnull\nfor none.\ngetKeyAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually above the given one, or\nnull\nfor none.\ngetKeyLeftOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the left of the given one, or\nnull\nfor none.\ngetKeyRightOf\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually to the right of the given one, or\nnull\nfor none.\ngetKeyPageBelow\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page below the given one, or\nnull\nfor none.\ngetKeyPageAbove\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the key visually one page above the given one, or\nnull\nfor none.\ngetFirstKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the first key, or\nnull\nfor none.\ngetLastKey\n(\n(\nkey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nglobal\n?\n:\nboolean\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the last key, or\nnull\nfor none.\ngetKeyForSearch\n(\n(\nsearch\n:\nstring\n,\n,\nfromKey\n?\n:\nKey\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nKey\n|\u00c2\nnull\nReturns the next key after\nfromKey\nthat matches the given search string, or\nnull\nfor none.\nstring\n|\u00c2\nnumber\n'none'\n|\u00c2\n'single'\n|\u00c2\n'multiple'\n'all'\n|\u00c2\nSet\n<\nKey\n>\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA collection of items in the tree.\ndisabledKeys\nSet\n<\nKey\n>\nA set of keys for items that are disabled.\nexpandedKeys\nSet\n<\nKey\n>\nA set of keys for items that are expanded.\nselectionManager\nSelectionManager\nA selection manager to read and update multiple selection state.\nMethods\nMethod\nDescription\ntoggleKey\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles the expanded state for an item by its key.\nsetExpandedKeys\n(\n(\nkeys\n:\nSet\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the set of expanded keys.\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\nExtends\n:\nIterable\nProperties\nName\nType\nDescription\nsize\nnumber\nThe number of items in the collection.\nMethods\nMethod\nDescription\ngetKeys\n(\n)\n:\nIterable\n<\nKey\n>\nIterate over all keys in the collection.\ngetItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by its key.\nat\n(\n(\nidx\n:\nnumber\n)\n)\n:\nT\n|\u00c2\nnull\nGet an item by the index of its key.\ngetKeyBefore\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes before the given key in the collection.\ngetKeyAfter\n(\n(\nkey\n:\nKey\n)\n)\n:\nKey\n|\u00c2\nnull\nGet the key that comes after the given key in the collection.\ngetFirstKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the first key in the collection.\ngetLastKey\n(\n)\n:\nKey\n|\u00c2\nnull\nGet the last key in the collection.\ngetChildren\n(\n(\nkey\n:\nKey\n)\n)\n:\nIterable\n<\nT\n>\nIterate over the child items of the given key.\ngetTextValue\n(\n(\nkey\n:\nKey\n)\n)\n:\nstring\nReturns a string representation of the item's contents.\nfilter\n(\n(\nfilterFn\n:\n(\n(\nnodeValue\n:\nstring\n,\n,\nnode\n:\nT\n)\n)\n=>\nboolean\n)\n)\n:\nCollection\n<\nT\n>\nFilters the collection using the given function.\nName\nType\nDescription\ntype\nstring\nThe type of item this node represents.\nkey\nKey\nA unique key for the node.\nvalue\nT\n|\u00c2\nnull\nThe object value the node was created from.\nlevel\nnumber\nThe level of depth this node is at in the hierarchy.\nhasChildNodes\nboolean\nWhether this item has children, even if not loaded yet.\nrendered\nReactNode\nThe rendered contents of this node (e.g. JSX).\ntextValue\nstring\nA string value for this node, used for features like typeahead.\nindex\nnumber\nThe index of this node within its parent.\naria-label\nstring\nAn accessibility label for this node.\nwrapper\n(\n(\nelement\n:\nReactElement\n)\n)\n=>\nReactElement\nA function that should be called to wrap the rendered node.\nparentKey\nKey\n|\u00c2\nnull\nThe key of the parent node.\nprevKey\nKey\n|\u00c2\nnull\nThe key of the node before this node.\nnextKey\nKey\n|\u00c2\nnull\nThe key of the node after this node.\nprops\nany\nAdditional properties specific to a particular node type.\nrender\n(\n(\nnode\n:\nNode\n<\nany\n>\n)\n)\n=>\nReactElement\nA function that renders this node to a React Element in the DOM.\nAn interface for reading and updating multiple selection state.\nProperties\nName\nType\nDescription\ncollection\nCollection\n<\nNode\n<\nunknown\n>\n>\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nselectedKeys\nSet\n<\nKey\n>\nThe currently selected keys in the collection.\nrawSelection\nSelection\nThe raw selection value for the collection.\nEither 'all' for select all, or a set of keys.\nisEmpty\nboolean\nWhether the selection is empty.\nisSelectAll\nboolean\nWhether all items in the collection are selected.\nfirstSelectedKey\nKey\n|\u00c2\nnull\nlastSelectedKey\nKey\n|\u00c2\nnull\ndisabledKeys\nSet\n<\nKey\n>\ndisabledBehavior\nDisabledBehavior\nMethods\nMethod\nDescription\nconstructor\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n,\nstate\n:\nMultipleSelectionState\n,\noptions\n?\n:\nSelectionManagerOptions\n)\n:\nvoid\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchildFocusStrategy\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key.\nisSelected\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nReturns whether a key is selected.\nextendSelection\n(\n(\ntoKey\n:\nKey\n)\n)\n:\nvoid\nExtends the selection to the given key.\ntoggleSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nToggles whether the given key is selected.\nreplaceSelection\n(\n(\nkey\n:\nKey\n)\n)\n:\nvoid\nReplaces the selection with only the given key.\nsetSelectedKeys\n(\n(\nkeys\n:\nIterable\n<\nKey\n>\n)\n)\n:\nvoid\nReplaces the selection with the given keys.\nselectAll\n(\n)\n:\nvoid\nSelects all items in the collection.\nclearSelection\n(\n)\n:\nvoid\nRemoves all keys from the selection.\ntoggleSelectAll\n(\n)\n:\nvoid\nToggles between select all and an empty selection.\nselect\n(\n(\nkey\n:\nKey\n,\n,\ne\n?\n:\nPressEvent\n|\u00c2\nLongPressEvent\n|\u00c2\nPointerEvent\n)\n)\n:\nvoid\nisSelectionEqual\n(\n(\nselection\n:\nSet\n<\nKey\n>\n)\n)\n:\nboolean\nReturns whether the current selection is equal to the given selection.\ncanSelectItem\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisDisabled\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\nisLink\n(\n(\nkey\n:\nKey\n)\n)\n:\nboolean\ngetItemProps\n(\n(\nkey\n:\nKey\n)\n)\n:\nany\nwithCollection\n(\n(\ncollection\n:\nCollection\n<\nNode\n<\nunknown\n>\n>\n)\n)\n:\nSelectionManager\nProperties\nName\nType\nDescription\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\nselectionBehavior\nSelectionBehavior\nThe selection behavior for the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\nSelection\nThe currently selected keys in the collection.\ndisabledKeys\nSet\n<\nKey\n>\nThe currently disabled keys in the collection.\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to selection, actions, or both.\nisFocused\nboolean\nWhether the collection is currently focused.\nfocusedKey\nKey\n|\u00c2\nnull\nThe current focused key in the collection.\nchildFocusStrategy\nFocusStrategy\n|\u00c2\nnull\nWhether the first or last child of the focused key should receive focus.\nMethods\nMethod\nDescription\nsetSelectionBehavior\n(\n(\nselectionBehavior\n:\nSelectionBehavior\n)\n)\n:\nvoid\nSets the selection behavior for the collection.\nsetSelectedKeys\n(\n(\nkeys\n:\nSelection\n)\n)\n:\nvoid\nSets the selected keys in the collection.\nsetFocused\n(\n(\nisFocused\n:\nboolean\n)\n)\n:\nvoid\nSets whether the collection is focused.\nsetFocusedKey\n(\n(\nkey\n:\nKey\n|\u00c2\n|\u00c2\nnull\n,\n,\nchild\n?\n:\nFocusStrategy\n)\n)\n:\nvoid\nSets the focused key, and optionally, whether the first or last child of that key should receive focus.\n'toggle'\n|\u00c2\n'replace'\n'selection'\n|\u00c2\n'all'\nA LayoutDelegate provides layout information for collection items.\nMethod\nDescription\ngetItemRect\n(\n(\nkey\n:\nKey\n)\n)\n:\nRect\n|\u00c2\nnull\nReturns a rectangle for the item with the given key.\ngetVisibleRect\n(\n)\n:\nRect\nReturns the visible rectangle of the collection.\ngetContentSize\n(\n)\n:\nSize\nReturns the size of the scrollable content in the collection.\ngetKeyRange\n(\n(\nfrom\n:\nKey\n,\n,\nto\n:\nKey\n)\n)\n:\nKey\n[]\nReturns a list of keys between\nfrom\nand\nto\n.\nName\nType\nDescription\nx\nnumber\ny\nnumber\nwidth\nnumber\nheight\nnumber\nName\nType\nDescription\nwidth\nnumber\nheight\nnumber\nName\nType\nDescription\nallowsCellSelection\nboolean\nlayoutDelegate\nLayoutDelegate\nName\nType\nDescription\ntype\n'longpressstart'\n|\u00c2\n'longpressend'\n|\u00c2\n'longpress'\nThe type of long press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nName\nType\nDescription\nmenuProps\nDOMAttributes\nProps for the menu element.\nAll DOM attributes supported across both HTML and SVG elements.\nExtends\n:\nAriaAttributes\n,\nReactDOMAttributes\nName\nType\nDescription\nid\nstring\n|\u00c2\nundefined\nrole\nAriaRole\n|\u00c2\nundefined\ntabIndex\nnumber\n|\u00c2\nundefined\nstyle\nCSSProperties\n|\u00c2\nundefined\nclassName\nstring\n|\u00c2\nundefined\nName\nType\nDefault\nDescription\nkey\nKey\n\u00e2\u0080\u0094\nThe unique key for the menu item.\naria-label\nstring\n\u00e2\u0080\u0094\nA screen reader only label for the menu item.\ncloseOnSelect\nboolean\ntrue\nWhether the menu should close when the menu item is selected.\nisVirtualized\nboolean\n\u00e2\u0080\u0094\nWhether the menu item is contained in a virtual scrolling menu.\naria-haspopup\n'menu'\n|\u00c2\n'dialog'\n\u00e2\u0080\u0094\nWhat kind of popup the item opens.\naria-expanded\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the menu item's popup element is expanded or collapsed.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the menu item's popup element whose contents or presence is controlled by the menu item.\nselectionManager\nSelectionManager\n\u00e2\u0080\u0094\nOverride of the selection manager. By default,\nstate.selectionManager\nis used.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\nonHoverStart\n(\n(\ne\n:\nHoverEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a hover interaction starts.\nonHoverEnd\n(\n(\ne\n:\nHoverEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a hover interaction ends.\nonHoverChange\n(\n(\nisHovering\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the hover state changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nName\nType\nDescription\ntype\n'hoverstart'\n|\u00c2\n'hoverend'\nThe type of hover event being fired.\npointerType\n'mouse'\n|\u00c2\n'pen'\nThe pointer type that triggered the hover event.\ntarget\nHTMLElement\nThe target element of the hover event.\nName\nType\nDescription\nmenuItemProps\nDOMAttributes\nProps for the menu item element.\nlabelProps\nDOMAttributes\nProps for the main text element inside the menu item.\ndescriptionProps\nDOMAttributes\nProps for the description text element inside the menu item, if any.\nkeyboardShortcutProps\nDOMAttributes\nProps for the keyboard shortcut text element inside the item, if any.\nisFocused\nboolean\nWhether the item is currently focused.\nisFocusVisible\nboolean\nWhether the item is keyboard focused.\nisSelected\nboolean\nWhether the item is currently selected.\nisPressed\nboolean\nWhether the item is currently in a pressed state.\nisDisabled\nboolean\nWhether the item is disabled.\nName\nType\nDescription\nheading\nReactNode\nThe heading for the section.\naria-label\nstring\nAn accessibility label for the section. Required if\nheading\nis not present.\nName\nType\nDescription\nitemProps\nDOMAttributes\nProps for the wrapper list item.\nheadingProps\nDOMAttributes\nProps for the heading element, if any.\ngroupProps\nDOMAttributes\nProps for the group element.\nManages state for a menu trigger. Tracks whether the menu is currently open,\nand controls which item will receive focus when it opens. Also tracks the open submenus within\nthe menu tree via their trigger keys.\nuseMenuTriggerState\n(\n(\nprops\n:\nMenuTriggerProps\n)\n)\n:\nRootMenuTriggerState\nName\nType\nDefault\nDescription\ntrigger\nMenuTriggerType\n'press'\nHow the menu is triggered.\nisOpen\nboolean\n\u00e2\u0080\u0094\nWhether the overlay is open by default (controlled).\ndefaultOpen\nboolean\n\u00e2\u0080\u0094\nWhether the overlay is open by default (uncontrolled).\nonOpenChange\n(\n(\nisOpen\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the overlay's open state changes.\nProperties\nName\nType\nDescription\nopenSubmenu\n(\n(\ntriggerKey\n:\nKey\n,\n,\nlevel\n:\nnumber\n)\n)\n=>\nvoid\nOpens a specific submenu tied to a specific menu item at a specific level.\ncloseSubmenu\n(\n(\ntriggerKey\n:\nKey\n,\n,\nlevel\n:\nnumber\n)\n)\n=>\nvoid\nCloses a specific submenu tied to a specific menu item at a specific level.\nexpandedKeysStack\nKey\n[]\nAn array of open submenu trigger keys within the menu tree.\nThe index of key within array matches the submenu level in the tree.\nclose\n(\n)\n=>\nvoid\nCloses the menu and all submenus in the menu tree.\nfocusStrategy\nFocusStrategy\n|\u00c2\nnull\nControls which item will be auto focused when the menu opens.\nisOpen\nboolean\nWhether the overlay is currently open.\nMethods\nMethod\nDescription\nopen\n(\n(\nfocusStrategy\n?\n:\nFocusStrategy\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nvoid\nOpens the menu.\ntoggle\n(\n(\nfocusStrategy\n?\n:\nFocusStrategy\n|\u00c2\n|\u00c2\nnull\n)\n)\n:\nvoid\nToggles the menu.\nsetOpen\n(\n(\nisOpen\n:\nboolean\n)\n)\n:\nvoid\nSets whether the overlay is open.\nProvides state management for tree-like components. Handles building a collection\nof items from props, item expanded state, and manages multiple selection state.\nuseTreeState\n<\nT\nextends\nobject\n>\n(\n(\nprops\n:\nTreeProps\n<\nT\n>\n)\n)\n:\nTreeState\n<\nT\n>\nName\nType\nDescription\ndisabledBehavior\nDisabledBehavior\nWhether\ndisabledKeys\napplies to all interactions, or only selection.\ncollection\nCollection\n<\nNode\n<\nT\n>\n>\nA pre-constructed collection to use instead of building one from items and children.\nexpandedKeys\nIterable\n<\nKey\n>\nThe currently expanded keys in the collection (controlled).\ndefaultExpandedKeys\nIterable\n<\nKey\n>\nThe initial expanded keys in the collection (uncontrolled).\nonExpandedChange\n(\n(\nkeys\n:\nSet\n<\nKey\n>\n)\n)\n=>\nany\nHandler that is called when items are expanded or collapsed.\nselectionMode\nSelectionMode\nThe type of selection that is allowed in the collection.\ndisallowEmptySelection\nboolean\nWhether the collection allows empty selection.\nselectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe currently selected keys in the collection (controlled).\ndefaultSelectedKeys\n'all'\n|\u00c2\nIterable\n<\nKey\n>\nThe initial selected keys in the collection (uncontrolled).\nonSelectionChange\n(\n(\nkeys\n:\nSelection\n)\n)\n=>\nvoid\nHandler that is called when the selection changes.\ndisabledKeys\nIterable\n<\nKey\n>\nThe currently disabled keys in the collection (controlled).\nProvides the behavior and accessibility implementation for a menu trigger.\nuseMenuTrigger\n<\nT\n>\n(\nprops\n:\nAriaMenuTriggerProps\n,\nstate\n:\nMenuTriggerState\n,\nref\n:\nRefObject\n<\nElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuTriggerAria\n<\nT\n>\nProvides the behavior and accessibility implementation for a menu component.\nA menu displays a list of actions or options that a user can choose.\nuseMenu\n<\nT\n>\n(\nprops\n:\nAriaMenuOptions\n<\nT\n>\n,\nstate\n:\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nHTMLElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuAria\nProvides the behavior and accessibility implementation for an item in a menu.\nSee\nuseMenu\nfor more details about menus.\nuseMenuItem\n<\nT\n>\n(\nprops\n:\nAriaMenuItemProps\n,\nstate\n:\nTreeState\n<\nT\n>\n,\nref\n:\nRefObject\n<\nFocusableElement\n|\u00c2\n|\u00c2\nnull\n>\n)\n:\nMenuItemAria\nProvides the behavior and accessibility implementation for a section in a menu.\nSee\nuseMenu\nfor more details about menus.\nuseMenuSection\n(\n(\nprops\n:\nAriaMenuSectionProps\n)\n)\n:\nMenuSectionAria\nA RouterProvider accepts a\nnavigate\nfunction from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\nName\nType\nDescription\nnavigate\n(\n(\npath\n:\nHref\n,\n,\nrouterOptions\n:\nRouterOptions\n|\u00c2\n|\u00c2\nundefined\n)\n)\n=>\nvoid\nchildren\nReactNode\nuseHref\n(\n(\nhref\n:\nHref\n)\n)\n=>\nstring\nRouterConfig\nextends\n{\nhref\n:\nany\n}\n?\nH\n:\nstring\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with\nhref\nand\nrouterOptions\nproperties to configure your router.\nRouterConfig\nextends\n{\nrouterOptions\n:\nany\n}\n?\nO\n:\nnever",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../Menu).\n\n# useMenu\n\nProvides the behavior and accessibility implementation for a menu component.\nA menu displays a list of actions or options that a user can choose.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useMenuTrigger, useMenu, useMenuItem, useMenuSection} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/menu/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/menu \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/menu \"View package\")\n\n## API[#](#api)\n\n---\n\n`useMenuTrigger<T>(\nprops: AriaMenuTriggerProps,\nstate: MenuTriggerState,\nref: RefObject<Element\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuTriggerAria<T>`\n`useMenu<T>(\nprops: AriaMenuOptions<T>,\nstate: TreeState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuAria`\n`useMenuItem<T>(\nprops: AriaMenuItemProps,\nstate: TreeState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuItemAria`\n`useMenuSection(\n(props: AriaMenuSectionProps\n)): MenuSectionAria`\n\n## Features[#](#features)\n\n---\n\nThere is no native element to implement a menu in HTML that is widely supported. `useMenuTrigger` and `useMenu`\nhelp achieve accessible menu components that can be styled as needed.\n\n- Exposed to assistive technology as a button with a `menu` using ARIA\n- Support for single, multiple, or no selection\n- Support for disabled items\n- Support for sections\n- Complex item labeling support for accessibility\n- Keyboard navigation support including arrow keys, home/end, page up/down\n- Automatic scrolling support during keyboard navigation\n- Keyboard support for opening the menu using the arrow keys, including automatically focusing\n  the first or last item accordingly\n- Typeahead to allow focusing items by typing text\n- Support for use with virtualized lists\n\n## Anatomy[#](#anatomy)\n\n---\n\nA menu trigger consists of a button or other trigger element combined with a popup menu,\nwith a list of menu items or groups inside. `useMenuTrigger`, `useMenu`, `useMenuItem`,\nand `useMenuSection` handle exposing this to assistive technology using ARIA, along with\nhandling keyboard, mouse, and interactions to support selection and focus behavior.\n\n`useMenuTrigger` returns props that you should spread onto the appropriate element:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuTriggerProps` | `AriaButtonProps` | Props for the menu trigger element. |\n| `menuProps` | `AriaMenuOptions<T>` | Props for the menu. |\n\n`useMenu` returns props that you should spread onto the menu container element:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuProps` | `DOMAttributes` | Props for the menu element. |\n\n`useMenuItem` returns props for an individual item and its children:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuItemProps` | `DOMAttributes` | Props for the menu item element. |\n| `labelProps` | `DOMAttributes` | Props for the main text element inside the menu item. |\n| `descriptionProps` | `DOMAttributes` | Props for the description text element inside the menu item, if any. |\n| `keyboardShortcutProps` | `DOMAttributes` | Props for the keyboard shortcut text element inside the item, if any. |\n| `isFocused` | `boolean` | Whether the item is currently focused. |\n| `isFocusVisible` | `boolean` | Whether the item is keyboard focused. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isDisabled` | `boolean` | Whether the item is disabled. |\n\n`useMenuSection` returns props for a section:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `itemProps` | `DOMAttributes` | Props for the wrapper list item. |\n| `headingProps` | `DOMAttributes` | Props for the heading element, if any. |\n| `groupProps` | `DOMAttributes` | Props for the group element. |\n\nState for the trigger is managed by the `useMenuTriggerState`\nhook from `@react-stately/menu`. State for the menu itself is managed by the `useTreeState`\nhook from `@react-stately/tree`. These state objects should be passed to the appropriate React Aria hooks.\n\nIf a menu, menu item, or group does not have a visible label, an `aria-label` or `aria-labelledby`\nprop must be passed instead to identify the element to assistive technology.\n\n## Example[#](#example)\n\n---\n\nA menu consists of several components: a menu button to toggle the menu popup, and the menu itself, which contains\nitems or sections of items. We'll go through each component one by one.\n\n### MenuButton[#](#menubutton)\n\nWe'll start with the `MenuButton` component, which is what will trigger our menu to appear. This uses\nthe `useMenuTrigger` and `useMenuTriggerState` hooks.\nThe `Popover` and `Button` components used in this example are independent, and can be shared by many other components.\nThe code is available below, and documentation is available on the corresponding pages.\n\n```\nimport type {MenuTriggerProps} from 'react-stately';\nimport {useMenuTrigger} from 'react-aria';\nimport {Item, useMenuTriggerState} from 'react-stately';\n\n// Reuse the Popover, and Button from your component library. See below for details.\nimport {Button, Popover} from 'your-component-library';\n\ninterface MenuButtonProps<T> extends AriaMenuProps<T>, MenuTriggerProps {\n  label?: string;\n}\n\nfunction MenuButton<T extends object>(props: MenuButtonProps<T>) {\n  // Create state based on the incoming props\n  let state = useMenuTriggerState(props);\n\n  // Get props for the button and menu elements\n  let ref = React.useRef(null);\n  let { menuTriggerProps, menuProps } = useMenuTrigger<T>({}, state, ref);\n\n  return (\n    <>\n      <Button\n        {...menuTriggerProps}\n        buttonRef={ref}\n        style={{ height: 30, fontSize: 14 }}\n      >\n        {props.label}\n        <span aria-hidden=\"true\" style={{ paddingLeft: 5 }}>\u00e2\u0096\u00bc</span>\n      </Button>\n      {state.isOpen &&\n        (\n          <Popover state={state} triggerRef={ref} placement=\"bottom start\">\n            <Menu\n              {...props}\n              {...menuProps}\n            />\n          </Popover>\n        )}\n    </>\n  );\n}\n```\n\n```\nimport type {MenuTriggerProps} from 'react-stately';\nimport {useMenuTrigger} from 'react-aria';\nimport {Item, useMenuTriggerState} from 'react-stately';\n\n// Reuse the Popover, and Button from your component library. See below for details.\nimport {Button, Popover} from 'your-component-library';\n\ninterface MenuButtonProps<T>\n  extends AriaMenuProps<T>, MenuTriggerProps {\n  label?: string;\n}\n\nfunction MenuButton<T extends object>(\n  props: MenuButtonProps<T>\n) {\n  // Create state based on the incoming props\n  let state = useMenuTriggerState(props);\n\n  // Get props for the button and menu elements\n  let ref = React.useRef(null);\n  let { menuTriggerProps, menuProps } = useMenuTrigger<T>(\n    {},\n    state,\n    ref\n  );\n\n  return (\n    <>\n      <Button\n        {...menuTriggerProps}\n        buttonRef={ref}\n        style={{ height: 30, fontSize: 14 }}\n      >\n        {props.label}\n        <span aria-hidden=\"true\" style={{ paddingLeft: 5 }}>\n          \u00e2\u0096\u00bc\n        </span>\n      </Button>\n      {state.isOpen &&\n        (\n          <Popover\n            state={state}\n            triggerRef={ref}\n            placement=\"bottom start\"\n          >\n            <Menu\n              {...props}\n              {...menuProps}\n            />\n          </Popover>\n        )}\n    </>\n  );\n}\n```\n\n```\nimport type {MenuTriggerProps} from 'react-stately';\nimport {useMenuTrigger} from 'react-aria';\nimport {\n  Item,\n  useMenuTriggerState\n} from 'react-stately';\n\n// Reuse the Popover, and Button from your component library. See below for details.\nimport {\n  Button,\n  Popover\n} from 'your-component-library';\n\ninterface MenuButtonProps<\n  T\n> extends\n  AriaMenuProps<T>,\n  MenuTriggerProps {\n  label?: string;\n}\n\nfunction MenuButton<\n  T extends object\n>(\n  props: MenuButtonProps<\n    T\n  >\n) {\n  // Create state based on the incoming props\n  let state =\n    useMenuTriggerState(\n      props\n    );\n\n  // Get props for the button and menu elements\n  let ref = React.useRef(\n    null\n  );\n  let {\n    menuTriggerProps,\n    menuProps\n  } = useMenuTrigger<T>(\n    {},\n    state,\n    ref\n  );\n\n  return (\n    <>\n      <Button\n        {...menuTriggerProps}\n        buttonRef={ref}\n        style={{\n          height: 30,\n          fontSize: 14\n        }}\n      >\n        {props.label}\n        <span\n          aria-hidden=\"true\"\n          style={{\n            paddingLeft:\n              5\n          }}\n        >\n          \u00e2\u0096\u00bc\n        </span>\n      </Button>\n      {state.isOpen &&\n        (\n          <Popover\n            state={state}\n            triggerRef={ref}\n            placement=\"bottom start\"\n          >\n            <Menu\n              {...props}\n              {...menuProps}\n            />\n          </Popover>\n        )}\n    </>\n  );\n}\n```\n\n### Menu[#](#menu)\n\nNext, let's implement the `Menu` component. This will appear inside the `Popover` when the user presses the button.\nIt is built using the `useMenu` and `useTreeState` hooks.\nFor each item in the collection in state, we render either a `MenuItem` or `MenuSection` (defined [below](#sections)) according to the item's `type` property.\n\n```\nimport type {AriaMenuProps} from 'react-aria';\nimport {useTreeState} from 'react-stately';\nimport {useMenu} from 'react-aria';\n\nfunction Menu<T extends object>(props: AriaMenuProps<T>) {\n  // Create menu state based on the incoming props\n  let state = useTreeState(props);\n\n  // Get props for the menu element\n  let ref = React.useRef(null);\n  let { menuProps } = useMenu(props, state, ref);\n\n  return (\n    <ul {...menuProps} ref={ref}>\n      {[...state.collection].map((item) => (\n        item.type === 'section'\n          ? <MenuSection key={item.key} section={item} state={state} />\n          : <MenuItem key={item.key} item={item} state={state} />\n      ))}\n    </ul>\n  );\n}\n```\n\n```\nimport type {AriaMenuProps} from 'react-aria';\nimport {useTreeState} from 'react-stately';\nimport {useMenu} from 'react-aria';\n\nfunction Menu<T extends object>(props: AriaMenuProps<T>) {\n  // Create menu state based on the incoming props\n  let state = useTreeState(props);\n\n  // Get props for the menu element\n  let ref = React.useRef(null);\n  let { menuProps } = useMenu(props, state, ref);\n\n  return (\n    <ul {...menuProps} ref={ref}>\n      {[...state.collection].map((item) => (\n        item.type === 'section'\n          ? (\n            <MenuSection\n              key={item.key}\n              section={item}\n              state={state}\n            />\n          )\n          : (\n            <MenuItem\n              key={item.key}\n              item={item}\n              state={state}\n            />\n          )\n      ))}\n    </ul>\n  );\n}\n```\n\n```\nimport type {AriaMenuProps} from 'react-aria';\nimport {useTreeState} from 'react-stately';\nimport {useMenu} from 'react-aria';\n\nfunction Menu<\n  T extends object\n>(\n  props: AriaMenuProps<T>\n) {\n  // Create menu state based on the incoming props\n  let state =\n    useTreeState(props);\n\n  // Get props for the menu element\n  let ref = React.useRef(\n    null\n  );\n  let { menuProps } =\n    useMenu(\n      props,\n      state,\n      ref\n    );\n\n  return (\n    <ul\n      {...menuProps}\n      ref={ref}\n    >\n      {[\n        ...state\n          .collection\n      ].map((item) => (\n        item.type ===\n            'section'\n          ? (\n            <MenuSection\n              key={item\n                .key}\n              section={item}\n              state={state}\n            />\n          )\n          : (\n            <MenuItem\n              key={item\n                .key}\n              item={item}\n              state={state}\n            />\n          )\n      ))}\n    </ul>\n  );\n}\n```\n\n### MenuItem[#](#menuitem)\n\nNow let's implement `MenuItem`. This is built using `useMenuItem`,\nand the `state` object passed via props from `Menu`.\n\n```\nimport {useMenuItem} from 'react-aria';\n\nfunction MenuItem({ item, state }) {\n  // Get props for the menu item element\n  let ref = React.useRef(null);\n  let { menuItemProps, isSelected } = useMenuItem(\n    { key: item.key },\n    state,\n    ref\n  );\n\n  return (\n    <li {...menuItemProps} ref={ref}>\n      {item.rendered}\n      {isSelected && <span aria-hidden=\"true\">\u00e2\u009c\u0085</span>}\n    </li>\n  );\n}\n```\n\n```\nimport {useMenuItem} from 'react-aria';\n\nfunction MenuItem({ item, state }) {\n  // Get props for the menu item element\n  let ref = React.useRef(null);\n  let { menuItemProps, isSelected } = useMenuItem(\n    { key: item.key },\n    state,\n    ref\n  );\n\n  return (\n    <li {...menuItemProps} ref={ref}>\n      {item.rendered}\n      {isSelected && <span aria-hidden=\"true\">\u00e2\u009c\u0085</span>}\n    </li>\n  );\n}\n```\n\n```\nimport {useMenuItem} from 'react-aria';\n\nfunction MenuItem(\n  { item, state }\n) {\n  // Get props for the menu item element\n  let ref = React.useRef(\n    null\n  );\n  let {\n    menuItemProps,\n    isSelected\n  } = useMenuItem(\n    { key: item.key },\n    state,\n    ref\n  );\n\n  return (\n    <li\n      {...menuItemProps}\n      ref={ref}\n    >\n      {item.rendered}\n      {isSelected && (\n        <span aria-hidden=\"true\">\n          \u00e2\u009c\u0085\n        </span>\n      )}\n    </li>\n  );\n}\n```\n\nNow we can render a simple menu with actionable items:\n\n```\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Item key=\"copy\">Copy</Item>\n  <Item key=\"cut\">Cut</Item>\n  <Item key=\"paste\">Paste</Item>\n</MenuButton>\n```\n\n```\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Item key=\"copy\">Copy</Item>\n  <Item key=\"cut\">Cut</Item>\n  <Item key=\"paste\">Paste</Item>\n</MenuButton>\n```\n\n```\n<MenuButton\n  label=\"Actions\"\n  onAction={alert}\n>\n  <Item key=\"copy\">\n    Copy\n  </Item>\n  <Item key=\"cut\">\n    Cut\n  </Item>\n  <Item key=\"paste\">\n    Paste\n  </Item>\n</MenuButton>\n```\n\n Show CSS\n\n```\n[role=menu] {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  width: 200px;\n}\n\n[role=menuitem],\n[role=menuitemradio],\n[role=menuitemcheckbox] {\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  display: flex;\n  justify-content: space-between;\n  color: black;\n\n  &:focus {\n    background: gray;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: gray;\n  }\n}\n```\n\n```\n[role=menu] {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  width: 200px;\n}\n\n[role=menuitem],\n[role=menuitemradio],\n[role=menuitemcheckbox] {\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  display: flex;\n  justify-content: space-between;\n  color: black;\n\n  &:focus {\n    background: gray;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: gray;\n  }\n}\n```\n\n```\n[role=menu] {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  width: 200px;\n}\n\n[role=menuitem],\n[role=menuitemradio],\n[role=menuitemcheckbox] {\n  padding: 2px 5px;\n  outline: none;\n  cursor: default;\n  display: flex;\n  justify-content: space-between;\n  color: black;\n\n  &:focus {\n    background: gray;\n    color: white;\n  }\n\n  &[aria-disabled] {\n    color: gray;\n  }\n}\n```\n\n### Popover[#](#popover)\n\nThe `Popover` component is used to contain the menu.\nIt can be shared between many other components, including [ComboBox](../ComboBox/useComboBox.html),\n[Select](../Select/useSelect.html), and others.\nSee [usePopover](../Popover/usePopover.html) for more examples of popovers.\n\n Show code\n\n```\nimport {DismissButton, Overlay, usePopover} from 'react-aria';\nimport type {AriaPopoverProps} from 'react-aria';\nimport type {OverlayTriggerState} from 'react-stately';\n\ninterface PopoverProps extends Omit<AriaPopoverProps, 'popoverRef'> {\n  children: React.ReactNode;\n  state: OverlayTriggerState;\n}\n\nfunction Popover({ children, state, ...props }: PopoverProps) {\n  let popoverRef = React.useRef(null);\n  let { popoverProps, underlayProps } = usePopover({\n    ...props,\n    popoverRef\n  }, state);\n\n  return (\n    <Overlay>\n      <div {...underlayProps} style={{ position: 'fixed', inset: 0 }} />\n      <div\n        {...popoverProps}\n        ref={popoverRef}\n        style={{\n          ...popoverProps.style,\n          background: 'lightgray',\n          border: '1px solid gray'\n        }}\n      >\n        <DismissButton onDismiss={state.close} />\n        {children}\n        <DismissButton onDismiss={state.close} />\n      </div>\n    </Overlay>\n  );\n}\n```\n\n```\nimport {\n  DismissButton,\n  Overlay,\n  usePopover\n} from 'react-aria';\nimport type {AriaPopoverProps} from 'react-aria';\nimport type {OverlayTriggerState} from 'react-stately';\n\ninterface PopoverProps\n  extends Omit<AriaPopoverProps, 'popoverRef'> {\n  children: React.ReactNode;\n  state: OverlayTriggerState;\n}\n\nfunction Popover(\n  { children, state, ...props }: PopoverProps\n) {\n  let popoverRef = React.useRef(null);\n  let { popoverProps, underlayProps } = usePopover({\n    ...props,\n    popoverRef\n  }, state);\n\n  return (\n    <Overlay>\n      <div\n        {...underlayProps}\n        style={{ position: 'fixed', inset: 0 }}\n      />\n      <div\n        {...popoverProps}\n        ref={popoverRef}\n        style={{\n          ...popoverProps.style,\n          background: 'lightgray',\n          border: '1px solid gray'\n        }}\n      >\n        <DismissButton onDismiss={state.close} />\n        {children}\n        <DismissButton onDismiss={state.close} />\n      </div>\n    </Overlay>\n  );\n}\n```\n\n```\nimport {\n  DismissButton,\n  Overlay,\n  usePopover\n} from 'react-aria';\nimport type {AriaPopoverProps} from 'react-aria';\nimport type {OverlayTriggerState} from 'react-stately';\n\ninterface PopoverProps\n  extends\n    Omit<\n      AriaPopoverProps,\n      'popoverRef'\n    > {\n  children:\n    React.ReactNode;\n  state:\n    OverlayTriggerState;\n}\n\nfunction Popover(\n  {\n    children,\n    state,\n    ...props\n  }: PopoverProps\n) {\n  let popoverRef = React\n    .useRef(null);\n  let {\n    popoverProps,\n    underlayProps\n  } = usePopover({\n    ...props,\n    popoverRef\n  }, state);\n\n  return (\n    <Overlay>\n      <div\n        {...underlayProps}\n        style={{\n          position:\n            'fixed',\n          inset: 0\n        }}\n      />\n      <div\n        {...popoverProps}\n        ref={popoverRef}\n        style={{\n          ...popoverProps\n            .style,\n          background:\n            'lightgray',\n          border:\n            '1px solid gray'\n        }}\n      >\n        <DismissButton\n          onDismiss={state\n            .close}\n        />\n        {children}\n        <DismissButton\n          onDismiss={state\n            .close}\n        />\n      </div>\n    </Overlay>\n  );\n}\n```\n\n### Button[#](#button)\n\nThe `Button` component is used in the above example to toggle the menu. It is built using the [useButton](../Button/useButton.html) hook, and can be shared with many other components.\n\n Show code\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = props.buttonRef;\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button {...buttonProps} ref={ref} style={props.style}>\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref = props.buttonRef;\n  let { buttonProps } = useButton(props, ref);\n  return (\n    <button {...buttonProps} ref={ref} style={props.style}>\n      {props.children}\n    </button>\n  );\n}\n```\n\n```\nimport {useButton} from 'react-aria';\n\nfunction Button(props) {\n  let ref =\n    props.buttonRef;\n  let { buttonProps } =\n    useButton(\n      props,\n      ref\n    );\n  return (\n    <button\n      {...buttonProps}\n      ref={ref}\n      style={props.style}\n    >\n      {props.children}\n    </button>\n  );\n}\n```\n\n## Styled examples[#](#styled-examples)\n\n---\n\n[![](/tailwind.05c39dc7.png)\n\nTailwind CSS\n\nAn example of styling a Menu with Tailwind.](https://codesandbox.io/s/awesome-boyd-c0gbv5?file=/src/Menu.tsx)\n\n## Dynamic collections[#](#dynamic-collections)\n\n---\n\n`Menu` follows the [Collection Components API](https://react-spectrum.adobe.com/v3/collections.html), accepting both static and dynamic collections.\nThe examples above show static collections, which can be used when the full list of options is known ahead of time. Dynamic collections,\nas shown below, can be used when the options come from an external data source such as an API call, or update over time.\n\nAs seen below, an iterable list of options is passed to the ComboBox using the `items` prop. Each item accepts a `key` prop, which\nis passed to the `onSelectionChange` handler to identify the selected item. Alternatively, if the item objects contain an `id` property,\nas shown in the example below, then this is used automatically and a `key` prop is not required.\n\n```\nfunction Example() {\n  let items = [\n    {id: 1, name: 'New'},\n    {id: 2, name: 'Open'},\n    {id: 3, name: 'Close'},\n    {id: 4, name: 'Save'},\n    {id: 5, name: 'Duplicate'},\n    {id: 6, name: 'Rename'},\n    {id: 7, name: 'Move'}\n  ];\n\n  return (\n    <MenuButton label=\"Actions\" items={items} onAction={alert}>\n      {(item) => <Item>{item.name}</Item>}\n    </MenuButton>\n  );\n}\n```\n\n```\nfunction Example() {\n  let items = [\n    { id: 1, name: 'New' },\n    { id: 2, name: 'Open' },\n    { id: 3, name: 'Close' },\n    { id: 4, name: 'Save' },\n    { id: 5, name: 'Duplicate' },\n    { id: 6, name: 'Rename' },\n    { id: 7, name: 'Move' }\n  ];\n\n  return (\n    <MenuButton\n      label=\"Actions\"\n      items={items}\n      onAction={alert}\n    >\n      {(item) => <Item>{item.name}</Item>}\n    </MenuButton>\n  );\n}\n```\n\n```\nfunction Example() {\n  let items = [\n    {\n      id: 1,\n      name: 'New'\n    },\n    {\n      id: 2,\n      name: 'Open'\n    },\n    {\n      id: 3,\n      name: 'Close'\n    },\n    {\n      id: 4,\n      name: 'Save'\n    },\n    {\n      id: 5,\n      name: 'Duplicate'\n    },\n    {\n      id: 6,\n      name: 'Rename'\n    },\n    {\n      id: 7,\n      name: 'Move'\n    }\n  ];\n\n  return (\n    <MenuButton\n      label=\"Actions\"\n      items={items}\n      onAction={alert}\n    >\n      {(item) => (\n        <Item>\n          {item.name}\n        </Item>\n      )}\n    </MenuButton>\n  );\n}\n```\n\n## Selection[#](#selection)\n\n---\n\nMenu supports multiple selection modes. By default, selection is disabled, however this can be changed using the `selectionMode` prop.\nUse `defaultSelectedKeys` to provide a default set of selected items (uncontrolled) and `selectedKeys` to set the selected items (controlled). The value of the selected keys must match the `key` prop of the items.\nSee the `react-stately` [Selection docs](https://react-spectrum.adobe.com/v3/selection.html) for more details.\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(\n    new Set(['sidebar', 'console'])\n  );\n\n  return (\n    <>\n      <MenuButton\n        label=\"View\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"sidebar\">Sidebar</Item>\n        <Item key=\"searchbar\">Searchbar</Item>\n        <Item key=\"tools\">Tools</Item>\n        <Item key=\"console\">Console</Item>\n      </MenuButton>\n      <p>\n        Current selection (controlled):{' '}\n        {selected === 'all' ? 'all' : [...selected].join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(\n    new Set(['sidebar', 'console'])\n  );\n\n  return (\n    <>\n      <MenuButton\n        label=\"View\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"sidebar\">Sidebar</Item>\n        <Item key=\"searchbar\">Searchbar</Item>\n        <Item key=\"tools\">Tools</Item>\n        <Item key=\"console\">Console</Item>\n      </MenuButton>\n      <p>\n        Current selection (controlled): {selected === 'all'\n          ? 'all'\n          : [...selected].join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [\n    selected,\n    setSelected\n  ] = React.useState<\n    Selection\n  >(\n    new Set([\n      'sidebar',\n      'console'\n    ])\n  );\n\n  return (\n    <>\n      <MenuButton\n        label=\"View\"\n        selectionMode=\"multiple\"\n        selectedKeys={selected}\n        onSelectionChange={setSelected}\n      >\n        <Item key=\"sidebar\">\n          Sidebar\n        </Item>\n        <Item key=\"searchbar\">\n          Searchbar\n        </Item>\n        <Item key=\"tools\">\n          Tools\n        </Item>\n        <Item key=\"console\">\n          Console\n        </Item>\n      </MenuButton>\n      <p>\n        Current selection\n        (controlled):\n        {' '}\n        {selected ===\n            'all'\n          ? 'all'\n          : [...selected]\n            .join(', ')}\n      </p>\n    </>\n  );\n}\n```\n\n## Sections[#](#sections)\n\n---\n\nMenu supports sections with separators and headings in order to group options. Sections can be used by wrapping groups of Items in a `Section` component. Each `Section` takes a `title` and `key` prop.\nTo implement sections, implement the `ListBoxSection` component referenced above\nusing the `useMenuSection` hook. It will include four extra elements:\nan `<li>` between the sections to represent the separator, an `<li>` to contain the heading `<span>` element, and a\n`<ul>` to contain the child items. This structure is necessary to ensure HTML\nsemantics are correct.\n\n```\nimport {useMenuSection, useSeparator} from 'react-aria';\n\nfunction MenuSection({ section, state }) {\n  let { itemProps, headingProps, groupProps } = useMenuSection({\n    heading: section.rendered,\n    'aria-label': section['aria-label']\n  });\n\n  let { separatorProps } = useSeparator({\n    elementType: 'li'\n  });\n\n  // If the section is not the first, add a separator element.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() &&\n        (\n          <li\n            {...separatorProps}\n            style={{\n              borderTop: '1px solid gray',\n              margin: '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section.rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight: 'bold',\n                fontSize: '1.1em',\n                padding: '2px 5px'\n              }}\n            >\n              {section.rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle: 'none'\n          }}\n        >\n          {[...section.childNodes].map((node) => (\n            <MenuItem\n              key={node.key}\n              item={node}\n              state={state}\n            />\n          ))}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n```\nimport {useMenuSection, useSeparator} from 'react-aria';\n\nfunction MenuSection({ section, state }) {\n  let { itemProps, headingProps, groupProps } =\n    useMenuSection({\n      heading: section.rendered,\n      'aria-label': section['aria-label']\n    });\n\n  let { separatorProps } = useSeparator({\n    elementType: 'li'\n  });\n\n  // If the section is not the first, add a separator element.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !== state.collection.getFirstKey() &&\n        (\n          <li\n            {...separatorProps}\n            style={{\n              borderTop: '1px solid gray',\n              margin: '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section.rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight: 'bold',\n                fontSize: '1.1em',\n                padding: '2px 5px'\n              }}\n            >\n              {section.rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle: 'none'\n          }}\n        >\n          {[...section.childNodes].map((node) => (\n            <MenuItem\n              key={node.key}\n              item={node}\n              state={state}\n            />\n          ))}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n```\nimport {\n  useMenuSection,\n  useSeparator\n} from 'react-aria';\n\nfunction MenuSection(\n  { section, state }\n) {\n  let {\n    itemProps,\n    headingProps,\n    groupProps\n  } = useMenuSection({\n    heading:\n      section.rendered,\n    'aria-label':\n      section[\n        'aria-label'\n      ]\n  });\n\n  let {\n    separatorProps\n  } = useSeparator({\n    elementType: 'li'\n  });\n\n  // If the section is not the first, add a separator element.\n  // The heading is rendered inside an <li> element, which contains\n  // a <ul> with the child items.\n  return (\n    <>\n      {section.key !==\n          state\n            .collection\n            .getFirstKey() &&\n        (\n          <li\n            {...separatorProps}\n            style={{\n              borderTop:\n                '1px solid gray',\n              margin:\n                '2px 5px'\n            }}\n          />\n        )}\n      <li {...itemProps}>\n        {section\n          .rendered &&\n          (\n            <span\n              {...headingProps}\n              style={{\n                fontWeight:\n                  'bold',\n                fontSize:\n                  '1.1em',\n                padding:\n                  '2px 5px'\n              }}\n            >\n              {section\n                .rendered}\n            </span>\n          )}\n        <ul\n          {...groupProps}\n          style={{\n            padding: 0,\n            listStyle:\n              'none'\n          }}\n        >\n          {[\n            ...section\n              .childNodes\n          ].map(\n            (node) => (\n              <MenuItem\n                key={node\n                  .key}\n                item={node}\n                state={state}\n              />\n            )\n          )}\n        </ul>\n      </li>\n    </>\n  );\n}\n```\n\n### Static items[#](#static-items)\n\nWith this in place, we can now render a static menu with multiple sections:\n\n```\nimport {Section} from 'react-stately';\n\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Section title=\"Styles\">\n    <Item key=\"bold\">Bold</Item>\n    <Item key=\"underline\">Underline</Item>\n  </Section>\n  <Section title=\"Align\">\n    <Item key=\"left\">Left</Item>\n    <Item key=\"middle\">Middle</Item>\n    <Item key=\"right\">Right</Item>\n  </Section>\n</MenuButton>\n```\n\n```\nimport {Section} from 'react-stately';\n\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Section title=\"Styles\">\n    <Item key=\"bold\">Bold</Item>\n    <Item key=\"underline\">Underline</Item>\n  </Section>\n  <Section title=\"Align\">\n    <Item key=\"left\">Left</Item>\n    <Item key=\"middle\">Middle</Item>\n    <Item key=\"right\">Right</Item>\n  </Section>\n</MenuButton>\n```\n\n```\nimport {Section} from 'react-stately';\n\n<MenuButton\n  label=\"Actions\"\n  onAction={alert}\n>\n  <Section title=\"Styles\">\n    <Item key=\"bold\">\n      Bold\n    </Item>\n    <Item key=\"underline\">\n      Underline\n    </Item>\n  </Section>\n  <Section title=\"Align\">\n    <Item key=\"left\">\n      Left\n    </Item>\n    <Item key=\"middle\">\n      Middle\n    </Item>\n    <Item key=\"right\">\n      Right\n    </Item>\n  </Section>\n</MenuButton>\n```\n\n### Dynamic items[#](#dynamic-items)\n\nThe above example shows sections with static items. Sections can also be populated from a hierarchical data structure.\nSimilarly to the props on Menu, `<Section>` takes an array of data using the `items` prop.\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(new Set([1,3]));\n  let openWindows = [\n    {\n      name: 'Left Panel',\n      id: 'left',\n      children: [\n        {id: 1, name: 'Final Copy (1)'}\n      ]\n    },\n    {\n      name: 'Right Panel',\n      id: 'right',\n      children: [\n        {id: 2, name: 'index.ts'},\n        {id: 3, name: 'package.json'},\n        {id: 4, name: 'license.txt'}\n      ]\n    }\n  ];\n\n  return (\n    <MenuButton\n      label=\"Window\"\n      items={openWindows}\n      selectionMode=\"multiple\"\n      selectedKeys={selected}\n      onSelectionChange={setSelected}>\n      {item => (\n        <Section items={item.children} title={item.name}>\n          {item => <Item>{item.name}</Item>}\n        </Section>\n      )}\n    </MenuButton>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [selected, setSelected] = React.useState<Selection>(\n    new Set([1, 3])\n  );\n  let openWindows = [\n    {\n      name: 'Left Panel',\n      id: 'left',\n      children: [\n        { id: 1, name: 'Final Copy (1)' }\n      ]\n    },\n    {\n      name: 'Right Panel',\n      id: 'right',\n      children: [\n        { id: 2, name: 'index.ts' },\n        { id: 3, name: 'package.json' },\n        { id: 4, name: 'license.txt' }\n      ]\n    }\n  ];\n\n  return (\n    <MenuButton\n      label=\"Window\"\n      items={openWindows}\n      selectionMode=\"multiple\"\n      selectedKeys={selected}\n      onSelectionChange={setSelected}\n    >\n      {(item) => (\n        <Section items={item.children} title={item.name}>\n          {(item) => <Item>{item.name}</Item>}\n        </Section>\n      )}\n    </MenuButton>\n  );\n}\n```\n\n```\nimport type {Selection} from 'react-stately';\n\nfunction Example() {\n  let [\n    selected,\n    setSelected\n  ] = React.useState<\n    Selection\n  >(new Set([1, 3]));\n  let openWindows = [\n    {\n      name: 'Left Panel',\n      id: 'left',\n      children: [\n        {\n          id: 1,\n          name:\n            'Final Copy (1)'\n        }\n      ]\n    },\n    {\n      name:\n        'Right Panel',\n      id: 'right',\n      children: [\n        {\n          id: 2,\n          name:\n            'index.ts'\n        },\n        {\n          id: 3,\n          name:\n            'package.json'\n        },\n        {\n          id: 4,\n          name:\n            'license.txt'\n        }\n      ]\n    }\n  ];\n\n  return (\n    <MenuButton\n      label=\"Window\"\n      items={openWindows}\n      selectionMode=\"multiple\"\n      selectedKeys={selected}\n      onSelectionChange={setSelected}\n    >\n      {(item) => (\n        <Section\n          items={item\n            .children}\n          title={item\n            .name}\n        >\n          {(item) => (\n            <Item>\n              {item.name}\n            </Item>\n          )}\n        </Section>\n      )}\n    </MenuButton>\n  );\n}\n```\n\n### Accessibility[#](#accessibility)\n\nSections without a `title` must provide an `aria-label` for accessibility.\n\n## Complex menu items[#](#complex-menu-items)\n\n---\n\nBy default, menu items that only contain text will be labeled by the contents of the item.\nFor items that have more complex content (e.g. icons, multiple lines of text, keyboard shortcuts, etc.),\nuse `labelProps`, `descriptionProps`, and `keyboardShortcutProps`\nfrom `useMenuItem`\nas needed to apply to the main text element of the menu item, its description, and keyboard\nshortcut text. This improves screen reader announcement.\n\n**NOTE: menu items cannot contain interactive content (e.g. buttons, checkboxes, etc.).**\n\nTo implement this, we'll update the `MenuItem` component to apply the ARIA properties\nreturned by `useMenuItem` to the appropriate\nelements. In this example, we'll pull them out of `props.children` and use `React.cloneElement`\nto apply the props, but you may want to use a more robust approach (e.g. context).\n\n```\nfunction MenuItem({item, state}) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(null);\n  let {\n    menuItemProps,\n    labelProps,\n    descriptionProps,\n    keyboardShortcutProps\n  } = useMenuItem({key: item.key}, state, ref);\n\n  // Pull out the three expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [title, description, shortcut] = item.rendered;\n\n  return (\n    <li {...menuItemProps} ref={ref}>\n      <div>\n        {React.cloneElement(title, labelProps)}\n        {React.cloneElement(description, descriptionProps)}\n      </div>\n      {React.cloneElement(shortcut, keyboardShortcutProps)}\n    </li>\n  );\n}\n\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Item textValue=\"Copy\" key=\"copy\">\n    <div><strong>Copy</strong></div>\n    <div>Copy the selected text</div>\n    <kbd>\u00e2\u008c\u0098C</kbd>\n  </Item>\n  <Item textValue=\"Cut\" key=\"cut\">\n    <div><strong>Cut</strong></div>\n    <div>Cut the selected text</div>\n    <kbd>\u00e2\u008c\u0098X</kbd>\n  </Item>\n  <Item textValue=\"Paste\" key=\"paste\">\n    <div><strong>Paste</strong></div>\n    <div>Paste the copied text</div>\n    <kbd>\u00e2\u008c\u0098V</kbd>\n  </Item>\n</MenuButton>\n```\n\n```\nfunction MenuItem({ item, state }) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(null);\n  let {\n    menuItemProps,\n    labelProps,\n    descriptionProps,\n    keyboardShortcutProps\n  } = useMenuItem({ key: item.key }, state, ref);\n\n  // Pull out the three expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [title, description, shortcut] = item.rendered;\n\n  return (\n    <li {...menuItemProps} ref={ref}>\n      <div>\n        {React.cloneElement(title, labelProps)}\n        {React.cloneElement(description, descriptionProps)}\n      </div>\n      {React.cloneElement(shortcut, keyboardShortcutProps)}\n    </li>\n  );\n}\n\n<MenuButton label=\"Actions\" onAction={alert}>\n  <Item textValue=\"Copy\" key=\"copy\">\n    <div>\n      <strong>Copy</strong>\n    </div>\n    <div>Copy the selected text</div>\n    <kbd>\u00e2\u008c\u0098C</kbd>\n  </Item>\n  <Item textValue=\"Cut\" key=\"cut\">\n    <div>\n      <strong>Cut</strong>\n    </div>\n    <div>Cut the selected text</div>\n    <kbd>\u00e2\u008c\u0098X</kbd>\n  </Item>\n  <Item textValue=\"Paste\" key=\"paste\">\n    <div>\n      <strong>Paste</strong>\n    </div>\n    <div>Paste the copied text</div>\n    <kbd>\u00e2\u008c\u0098V</kbd>\n  </Item>\n</MenuButton>\n```\n\n```\nfunction MenuItem(\n  { item, state }\n) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(\n    null\n  );\n  let {\n    menuItemProps,\n    labelProps,\n    descriptionProps,\n    keyboardShortcutProps\n  } = useMenuItem(\n    { key: item.key },\n    state,\n    ref\n  );\n\n  // Pull out the three expected children. We will clone them\n  // and add the necessary props for accessibility.\n  let [\n    title,\n    description,\n    shortcut\n  ] = item.rendered;\n\n  return (\n    <li\n      {...menuItemProps}\n      ref={ref}\n    >\n      <div>\n        {React\n          .cloneElement(\n            title,\n            labelProps\n          )}\n        {React\n          .cloneElement(\n            description,\n            descriptionProps\n          )}\n      </div>\n      {React\n        .cloneElement(\n          shortcut,\n          keyboardShortcutProps\n        )}\n    </li>\n  );\n}\n\n<MenuButton\n  label=\"Actions\"\n  onAction={alert}\n>\n  <Item\n    textValue=\"Copy\"\n    key=\"copy\"\n  >\n    <div>\n      <strong>\n        Copy\n      </strong>\n    </div>\n    <div>\n      Copy the selected\n      text\n    </div>\n    <kbd>\u00e2\u008c\u0098C</kbd>\n  </Item>\n  <Item\n    textValue=\"Cut\"\n    key=\"cut\"\n  >\n    <div>\n      <strong>\n        Cut\n      </strong>\n    </div>\n    <div>\n      Cut the selected\n      text\n    </div>\n    <kbd>\u00e2\u008c\u0098X</kbd>\n  </Item>\n  <Item\n    textValue=\"Paste\"\n    key=\"paste\"\n  >\n    <div>\n      <strong>\n        Paste\n      </strong>\n    </div>\n    <div>\n      Paste the copied\n      text\n    </div>\n    <kbd>\u00e2\u008c\u0098V</kbd>\n  </Item>\n</MenuButton>\n```\n\n## Disabled items[#](#disabled-items)\n\n---\n\n`useMenu` supports marking items as disabled using the `disabledKeys` prop. Each key in this list\ncorresponds with the `key` prop passed to the `Item` component, or automatically derived from the values passed\nto the `items` prop. See [Collections](https://react-spectrum.adobe.com/v3/collections.html) for more details.\n\nDisabled items are not focusable or keyboard navigable, and do not trigger `onAction` or `onSelectionChange`.\nThe `isDisabled` property returned by `useMenuItem` can be used to style the item appropriately.\n\n```\n<MenuButton label=\"Actions\" onAction={alert} disabledKeys={['paste']}>\n  <Item key=\"copy\">Copy</Item>\n  <Item key=\"cut\">Cut</Item>\n  <Item key=\"paste\">Paste</Item>\n</MenuButton>\n```\n\n```\n<MenuButton\n  label=\"Actions\"\n  onAction={alert}\n  disabledKeys={['paste']}\n>\n  <Item key=\"copy\">Copy</Item>\n  <Item key=\"cut\">Cut</Item>\n  <Item key=\"paste\">Paste</Item>\n</MenuButton>\n```\n\n```\n<MenuButton\n  label=\"Actions\"\n  onAction={alert}\n  disabledKeys={[\n    'paste'\n  ]}\n>\n  <Item key=\"copy\">\n    Copy\n  </Item>\n  <Item key=\"cut\">\n    Cut\n  </Item>\n  <Item key=\"paste\">\n    Paste\n  </Item>\n</MenuButton>\n```\n\n## Links[#](#links)\n\n---\n\nBy default, interacting with an item in a Menu triggers `onAction` and optionally `onSelectionChange` depending on the `selectionMode`. Alternatively, items may be links to another page or website. This can be achieved by passing the `href` prop to the `<Item>` component. Link items in a menu are not selectable.\n\nThis example shows how to update the `MenuItem` component with support for rendering an `<a>` element if an `href` prop is passed to the item. Note that you'll also need to render the `Menu` as a `<div>` instead of a `<ul>`, since an `<a>` inside a `<ul>` is not valid HTML.\n\n```\nfunction MenuItem({item, state}) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(null);\n  let {menuItemProps} = useMenuItem({key: item.key}, state, ref);\n  let ElementType: React.ElementType = item.props.href ? 'a' : 'div';\n  return (\n    <ElementType {...menuItemProps} ref={ref}>\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<MenuButton label=\"Links\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">Adobe</Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">Apple</Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">Google</Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">Microsoft</Item>\n</MenuButton>\n```\n\n```\nfunction MenuItem({ item, state }) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(null);\n  let { menuItemProps } = useMenuItem(\n    { key: item.key },\n    state,\n    ref\n  );\n  let ElementType: React.ElementType = item.props.href\n    ? 'a'\n    : 'div';\n  return (\n    <ElementType {...menuItemProps} ref={ref}>\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<MenuButton label=\"Links\">\n  <Item href=\"https://adobe.com/\" target=\"_blank\">\n    Adobe\n  </Item>\n  <Item href=\"https://apple.com/\" target=\"_blank\">\n    Apple\n  </Item>\n  <Item href=\"https://google.com/\" target=\"_blank\">\n    Google\n  </Item>\n  <Item href=\"https://microsoft.com/\" target=\"_blank\">\n    Microsoft\n  </Item>\n</MenuButton>\n```\n\n```\nfunction MenuItem(\n  { item, state }\n) {\n  // Get props for the menu item element and child elements\n  let ref = React.useRef(\n    null\n  );\n  let { menuItemProps } =\n    useMenuItem(\n      { key: item.key },\n      state,\n      ref\n    );\n  let ElementType:\n    React.ElementType =\n      item.props.href\n        ? 'a'\n        : 'div';\n  return (\n    <ElementType\n      {...menuItemProps}\n      ref={ref}\n    >\n      {item.rendered}\n    </ElementType>\n  );\n}\n\n<MenuButton label=\"Links\">\n  <Item\n    href=\"https://adobe.com/\"\n    target=\"_blank\"\n  >\n    Adobe\n  </Item>\n  <Item\n    href=\"https://apple.com/\"\n    target=\"_blank\"\n  >\n    Apple\n  </Item>\n  <Item\n    href=\"https://google.com/\"\n    target=\"_blank\"\n  >\n    Google\n  </Item>\n  <Item\n    href=\"https://microsoft.com/\"\n    target=\"_blank\"\n  >\n    Microsoft\n  </Item>\n</MenuButton>\n```\n\n### Client side routing[#](#client-side-routing)\n\nThe `<Item>` component works with frameworks and client side routers like [Next.js](https://nextjs.org/) and [React Router](https://reactrouter.com/en/main). As with other React Aria components that support links, this works via the `RouterProvider` component at the root of your app. See the [framework setup guide](../frameworks) to learn how to set this up.\n\n## Controlled open state[#](#controlled-open-state)\n\n---\n\nThe open state of the menu can be controlled via the `defaultOpen` and `isOpen` props\n\n```\nfunction Example() {\n  let [open, setOpen] = React.useState(false);\n\n  return (\n    <>\n      <p>Menu is {open ? 'open' : 'closed'}</p>\n      <MenuButton\n        label=\"View\"\n        isOpen={open}\n        onOpenChange={setOpen}>\n        <Item key=\"side\">Side bar</Item>\n        <Item key=\"options\">Page options</Item>\n        <Item key=\"edit\">Edit Panel</Item>\n      </MenuButton>\n    </>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [open, setOpen] = React.useState(false);\n\n  return (\n    <>\n      <p>Menu is {open ? 'open' : 'closed'}</p>\n      <MenuButton\n        label=\"View\"\n        isOpen={open}\n        onOpenChange={setOpen}>\n        <Item key=\"side\">Side bar</Item>\n        <Item key=\"options\">Page options</Item>\n        <Item key=\"edit\">Edit Panel</Item>\n      </MenuButton>\n    </>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [open, setOpen] =\n    React.useState(\n      false\n    );\n\n  return (\n    <>\n      <p>\n        Menu is {open\n          ? 'open'\n          : 'closed'}\n      </p>\n      <MenuButton\n        label=\"View\"\n        isOpen={open}\n        onOpenChange={setOpen}\n      >\n        <Item key=\"side\">\n          Side bar\n        </Item>\n        <Item key=\"options\">\n          Page options\n        </Item>\n        <Item key=\"edit\">\n          Edit Panel\n        </Item>\n      </MenuButton>\n    </>\n  );\n}\n```\n\n## Internationalization[#](#internationalization)\n\n---\n\n`useMenu` handles some aspects of internationalization automatically.\nFor example, type to select is implemented with an\n[Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator)\nfor internationalized string matching. You are responsible for localizing all menu item labels for\ncontent that is passed into the menu.\n\n### RTL[#](#rtl)\n\nIn right-to-left languages, the menu button should be mirrored. The arrow should be on the left,\nand the label should be on the right. In addition, the content of menu items should\nflip. Ensure that your CSS accounts for this.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'menu' |\u00c2\u00a0'listbox'` | The type of menu that the menu trigger opens. |\n| `isDisabled` | `boolean` | Whether menu trigger is disabled. |\n| `trigger` | `MenuTriggerType` | How menu is triggered. |\n\n`'press' |\u00c2\u00a0'longPress'`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `focusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Controls which item will be auto focused when the menu opens. |\n| `isOpen` | `boolean` | Whether the overlay is currently open. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `open( (focusStrategy?: FocusStrategy |\u00c2\u00a0 |\u00c2\u00a0null )): void` | Opens the menu. |\n| `toggle( (focusStrategy?: FocusStrategy |\u00c2\u00a0 |\u00c2\u00a0null )): void` | Toggles the menu. |\n| `setOpen( (isOpen: boolean )): void` | Sets whether the overlay is open. |\n| `close(): void` | Closes the overlay. |\n\n`'first' |\u00c2\u00a0'last'`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `current` | `T` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuTriggerProps` | `AriaButtonProps` | Props for the menu trigger element. |\n| `menuProps` | `AriaMenuOptions<T>` | Props for the menu. |\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isDisabled` | `boolean` | \u00e2\u0080\u0094 | Whether the button is disabled. |\n| `children` | `ReactNode` | \u00e2\u0080\u0094 | The content to display in the button. |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element should receive focus on render. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `href` | `string` | \u00e2\u0080\u0094 | A URL to link to if elementType=\"a\". |\n| `target` | `string` | \u00e2\u0080\u0094 | The target window for the link. |\n| `rel` | `string` | \u00e2\u0080\u0094 | The relationship between the linked resource and the current page. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel). |\n| `elementType` | `ElementType |\u00c2\u00a0JSXElementConstructor<any>` | `'button'` | The HTML element or React element used to render the button, e.g. 'div', 'a', or `RouterLink`. |\n| `aria-disabled` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element is disabled to users of assistive technology. |\n| `aria-expanded` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed. |\n| `aria-haspopup` | `boolean |\u00c2\u00a0'menu' |\u00c2\u00a0'listbox' |\u00c2\u00a0'tree' |\u00c2\u00a0'grid' |\u00c2\u00a0'dialog' |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) whose contents or presence are controlled by the current element. |\n| `aria-pressed` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'mixed'` | \u00e2\u0080\u0094 | Indicates the current \"pressed\" state of toggle buttons. |\n| `aria-current` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'page' |\u00c2\u00a0'step' |\u00c2\u00a0'location' |\u00c2\u00a0'date' |\u00c2\u00a0'time'` | \u00e2\u0080\u0094 | Indicates whether this element represents the current item within a container or set of related elements. |\n| `type` | `'button' |\u00c2\u00a0'submit' |\u00c2\u00a0'reset'` | `'button'` | The behavior of the button when used in an HTML form. |\n| `preventFocusOnPress` | `boolean` | \u00e2\u0080\u0094 | Whether to prevent focus from moving to the button when pressing it.  Caution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided, such as ComboBox's MenuTrigger or a NumberField's increment/decrement control. |\n| `form` | `string` | \u00e2\u0080\u0094 | The `<form>` element to associate the button with. The value of this attribute must be the id of a `<form>` in the same document. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/button#form). |\n| `formAction` | `string` | \u00e2\u0080\u0094 | The URL that processes the information submitted by the button. Overrides the action attribute of the button's form owner. |\n| `formEncType` | `string` | \u00e2\u0080\u0094 | Indicates how to encode the form data that is submitted. |\n| `formMethod` | `string` | \u00e2\u0080\u0094 | Indicates the HTTP method used to submit the form. |\n| `formNoValidate` | `boolean` | \u00e2\u0080\u0094 | Indicates that the form is not to be validated when it is submitted. |\n| `formTarget` | `string` | \u00e2\u0080\u0094 | Overrides the target attribute of the button's form owner. |\n| `name` | `string` | \u00e2\u0080\u0094 | Submitted as a pair with the button's value as part of the form data. |\n| `value` | `string` | \u00e2\u0080\u0094 | The value associated with the button's name when it's submitted with the form data. |\n| `excludeFromTabOrder` | `boolean` | \u00e2\u0080\u0094 | Whether to exclude the element from the sequential tab order. If true, the element will not be focusable via the keyboard by tabbing. This should be avoided except in rare scenarios where an alternative means of accessing the element or its functionality via the keyboard is available. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n`BaseEvent<ReactKeyboardEvent<any>>`\n\n`SyntheticEvent &\u00c2\u00a0{\n\nstopPropagation: () => void,\n\ncontinuePropagation: () => void\n\n}`\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isVirtualized` | `boolean` | \u00e2\u0080\u0094 | Whether the menu uses virtual scrolling. |\n| `keyboardDelegate` | `KeyboardDelegate` | \u00e2\u0080\u0094 | An optional keyboard delegate implementation for type to select, to override the default. |\n| `shouldUseVirtualFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the menu items should use virtual focus instead of being focused directly. |\n| `escapeKeyBehavior` | `'clearSelection' |\u00c2\u00a0'none'` | `'clearSelection'` | Whether pressing the escape key should clear selection in the menu or not.  Most experiences should not modify this option as it eliminates a keyboard user's ability to easily clear selection. Only use if the escape key is being handled externally or should not trigger selection clearing contextually. |\n| `autoFocus` | `boolean |\u00c2\u00a0FocusStrategy` | \u00e2\u0080\u0094 | Where the focus should be set. |\n| `shouldFocusWrap` | `boolean` | \u00e2\u0080\u0094 | Whether keyboard navigation is circular. |\n| `onAction` | `( (key: Key )) => void` | \u00e2\u0080\u0094 | Handler that is called when an item is selected. |\n| `onClose` | `() => void` | \u00e2\u0080\u0094 | Handler that is called when the menu should close after selecting an item. |\n| `items` | `Iterable<T>` | \u00e2\u0080\u0094 | Item objects in the collection. |\n| `disabledKeys` | `Iterable<Key>` | \u00e2\u0080\u0094 | The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with. |\n| `selectionMode` | `SelectionMode` | \u00e2\u0080\u0094 | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | \u00e2\u0080\u0094 | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | \u00e2\u0080\u0094 | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | \u00e2\u0080\u0094 | Handler that is called when the selection changes. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n\n| Method | Description |\n| --- | --- |\n| `getKeyBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually below the given one, or `null` for none. |\n| `getKeyAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually above the given one, or `null` for none. |\n| `getKeyLeftOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the left of the given one, or `null` for none. |\n| `getKeyRightOf( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually to the right of the given one, or `null` for none. |\n| `getKeyPageBelow( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page below the given one, or `null` for none. |\n| `getKeyPageAbove( (key: Key )): Key |\u00c2\u00a0null` | Returns the key visually one page above the given one, or `null` for none. |\n| `getFirstKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the first key, or `null` for none. |\n| `getLastKey( (key?: Key |\u00c2\u00a0 |\u00c2\u00a0null, , global?: boolean )): Key |\u00c2\u00a0null` | Returns the last key, or `null` for none. |\n| `getKeyForSearch( (search: string, , fromKey?: Key |\u00c2\u00a0 |\u00c2\u00a0null )): Key |\u00c2\u00a0null` | Returns the next key after `fromKey` that matches the given search string, or `null` for none. |\n\n`string |\u00c2\u00a0number`\n\n`'none'\n|\u00c2\u00a0'single'\n|\u00c2\u00a0'multiple'`\n\n`'all' |\u00c2\u00a0Set<Key>`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<T>>` | A collection of items in the tree. |\n| `disabledKeys` | `Set<Key>` | A set of keys for items that are disabled. |\n| `expandedKeys` | `Set<Key>` | A set of keys for items that are expanded. |\n| `selectionManager` | `SelectionManager` | A selection manager to read and update multiple selection state. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `toggleKey( (key: Key )): void` | Toggles the expanded state for an item by its key. |\n| `setExpandedKeys( (keys: Set<Key> )): void` | Replaces the set of expanded keys. |\n\nA generic interface to access a readonly sequential\ncollection of unique keyed items.\n\n**Extends**: `Iterable`\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `size` | `number` | The number of items in the collection. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `getKeys(): Iterable<Key>` | Iterate over all keys in the collection. |\n| `getItem( (key: Key )): T |\u00c2\u00a0null` | Get an item by its key. |\n| `at( (idx: number )): T |\u00c2\u00a0null` | Get an item by the index of its key. |\n| `getKeyBefore( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes before the given key in the collection. |\n| `getKeyAfter( (key: Key )): Key |\u00c2\u00a0null` | Get the key that comes after the given key in the collection. |\n| `getFirstKey(): Key |\u00c2\u00a0null` | Get the first key in the collection. |\n| `getLastKey(): Key |\u00c2\u00a0null` | Get the last key in the collection. |\n| `getChildren( (key: Key )): Iterable<T>` | Iterate over the child items of the given key. |\n| `getTextValue( (key: Key )): string` | Returns a string representation of the item's contents. |\n| `filter( (filterFn: ( (nodeValue: string, , node: T )) => boolean )): Collection<T>` | Filters the collection using the given function. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `string` | The type of item this node represents. |\n| `key` | `Key` | A unique key for the node. |\n| `value` | `T |\u00c2\u00a0null` | The object value the node was created from. |\n| `level` | `number` | The level of depth this node is at in the hierarchy. |\n| `hasChildNodes` | `boolean` | Whether this item has children, even if not loaded yet. |\n| `rendered` | `ReactNode` | The rendered contents of this node (e.g. JSX). |\n| `textValue` | `string` | A string value for this node, used for features like typeahead. |\n| `index` | `number` | The index of this node within its parent. |\n| `aria-label` | `string` | An accessibility label for this node. |\n| `wrapper` | `( (element: ReactElement )) => ReactElement` | A function that should be called to wrap the rendered node. |\n| `parentKey` | `Key |\u00c2\u00a0null` | The key of the parent node. |\n| `prevKey` | `Key |\u00c2\u00a0null` | The key of the node before this node. |\n| `nextKey` | `Key |\u00c2\u00a0null` | The key of the node after this node. |\n| `props` | `any` | Additional properties specific to a particular node type. |\n| `render` | `( (node: Node<any> )) => ReactElement` | A function that renders this node to a React Element in the DOM. |\n\nAn interface for reading and updating multiple selection state.\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `collection` | `Collection<Node<unknown>>` |  |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n| `selectedKeys` | `Set<Key>` | The currently selected keys in the collection. |\n| `rawSelection` | `Selection` | The raw selection value for the collection. Either 'all' for select all, or a set of keys. |\n| `isEmpty` | `boolean` | Whether the selection is empty. |\n| `isSelectAll` | `boolean` | Whether all items in the collection are selected. |\n| `firstSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `lastSelectedKey` | `Key |\u00c2\u00a0null` |  |\n| `disabledKeys` | `Set<Key>` |  |\n| `disabledBehavior` | `DisabledBehavior` |  |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `constructor( collection: Collection<Node<unknown>>, state: MultipleSelectionState, options?: SelectionManagerOptions ): void` |  |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , childFocusStrategy?: FocusStrategy )): void` | Sets the focused key. |\n| `isSelected( (key: Key )): boolean` | Returns whether a key is selected. |\n| `extendSelection( (toKey: Key )): void` | Extends the selection to the given key. |\n| `toggleSelection( (key: Key )): void` | Toggles whether the given key is selected. |\n| `replaceSelection( (key: Key )): void` | Replaces the selection with only the given key. |\n| `setSelectedKeys( (keys: Iterable<Key> )): void` | Replaces the selection with the given keys. |\n| `selectAll(): void` | Selects all items in the collection. |\n| `clearSelection(): void` | Removes all keys from the selection. |\n| `toggleSelectAll(): void` | Toggles between select all and an empty selection. |\n| `select( (key: Key, , e?: PressEvent |\u00c2\u00a0LongPressEvent |\u00c2\u00a0PointerEvent )): void` |  |\n| `isSelectionEqual( (selection: Set<Key> )): boolean` | Returns whether the current selection is equal to the given selection. |\n| `canSelectItem( (key: Key )): boolean` |  |\n| `isDisabled( (key: Key )): boolean` |  |\n| `isLink( (key: Key )): boolean` |  |\n| `getItemProps( (key: Key )): any` |  |\n| `withCollection( (collection: Collection<Node<unknown>> )): SelectionManager` |  |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `selectionBehavior` | `SelectionBehavior` | The selection behavior for the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `Selection` | The currently selected keys in the collection. |\n| `disabledKeys` | `Set<Key>` | The currently disabled keys in the collection. |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to selection, actions, or both. |\n| `isFocused` | `boolean` | Whether the collection is currently focused. |\n| `focusedKey` | `Key |\u00c2\u00a0null` | The current focused key in the collection. |\n| `childFocusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Whether the first or last child of the focused key should receive focus. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `setSelectionBehavior( (selectionBehavior: SelectionBehavior )): void` | Sets the selection behavior for the collection. |\n| `setSelectedKeys( (keys: Selection )): void` | Sets the selected keys in the collection. |\n| `setFocused( (isFocused: boolean )): void` | Sets whether the collection is focused. |\n| `setFocusedKey( (key: Key |\u00c2\u00a0 |\u00c2\u00a0null, , child?: FocusStrategy )): void` | Sets the focused key, and optionally, whether the first or last child of that key should receive focus. |\n\n`'toggle' |\u00c2\u00a0'replace'`\n\n`'selection' |\u00c2\u00a0'all'`\n\nA LayoutDelegate provides layout information for collection items.\n\n| Method | Description |\n| --- | --- |\n| `getItemRect( (key: Key )): Rect |\u00c2\u00a0null` | Returns a rectangle for the item with the given key. |\n| `getVisibleRect(): Rect` | Returns the visible rectangle of the collection. |\n| `getContentSize(): Size` | Returns the size of the scrollable content in the collection. |\n| `getKeyRange( (from: Key, , to: Key )): Key[]` | Returns a list of keys between `from` and `to`. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `x` | `number` |  |\n| `y` | `number` |  |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `width` | `number` |  |\n| `height` | `number` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `allowsCellSelection` | `boolean` |  |\n| `layoutDelegate` | `LayoutDelegate` |  |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'longpressstart' |\u00c2\u00a0'longpressend' |\u00c2\u00a0'longpress'` | The type of long press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuProps` | `DOMAttributes` | Props for the menu element. |\n\nAll DOM attributes supported across both HTML and SVG elements.\n\n**Extends**: `AriaAttributes, ReactDOMAttributes`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `id` | `string |\u00c2\u00a0undefined` |  |\n| `role` | `AriaRole |\u00c2\u00a0undefined` |  |\n| `tabIndex` | `number |\u00c2\u00a0undefined` |  |\n| `style` | `CSSProperties |\u00c2\u00a0undefined` |  |\n| `className` | `string |\u00c2\u00a0undefined` |  |\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `key` | `Key` | \u00e2\u0080\u0094 | The unique key for the menu item. |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | A screen reader only label for the menu item. |\n| `closeOnSelect` | `boolean` | `true` | Whether the menu should close when the menu item is selected. |\n| `isVirtualized` | `boolean` | \u00e2\u0080\u0094 | Whether the menu item is contained in a virtual scrolling menu. |\n| `aria-haspopup` | `'menu' |\u00c2\u00a0'dialog'` | \u00e2\u0080\u0094 | What kind of popup the item opens. |\n| `aria-expanded` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the menu item's popup element is expanded or collapsed. |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the menu item's popup element whose contents or presence is controlled by the menu item. |\n| `selectionManager` | `SelectionManager` | \u00e2\u0080\u0094 | Override of the selection manager. By default, `state.selectionManager` is used. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n| `onHoverStart` | `( (e: HoverEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a hover interaction starts. |\n| `onHoverEnd` | `( (e: HoverEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a hover interaction ends. |\n| `onHoverChange` | `( (isHovering: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the hover state changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'hoverstart' |\u00c2\u00a0'hoverend'` | The type of hover event being fired. |\n| `pointerType` | `'mouse' |\u00c2\u00a0'pen'` | The pointer type that triggered the hover event. |\n| `target` | `HTMLElement` | The target element of the hover event. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `menuItemProps` | `DOMAttributes` | Props for the menu item element. |\n| `labelProps` | `DOMAttributes` | Props for the main text element inside the menu item. |\n| `descriptionProps` | `DOMAttributes` | Props for the description text element inside the menu item, if any. |\n| `keyboardShortcutProps` | `DOMAttributes` | Props for the keyboard shortcut text element inside the item, if any. |\n| `isFocused` | `boolean` | Whether the item is currently focused. |\n| `isFocusVisible` | `boolean` | Whether the item is keyboard focused. |\n| `isSelected` | `boolean` | Whether the item is currently selected. |\n| `isPressed` | `boolean` | Whether the item is currently in a pressed state. |\n| `isDisabled` | `boolean` | Whether the item is disabled. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `heading` | `ReactNode` | The heading for the section. |\n| `aria-label` | `string` | An accessibility label for the section. Required if `heading` is not present. |\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `itemProps` | `DOMAttributes` | Props for the wrapper list item. |\n| `headingProps` | `DOMAttributes` | Props for the heading element, if any. |\n| `groupProps` | `DOMAttributes` | Props for the group element. |\n\nManages state for a menu trigger. Tracks whether the menu is currently open,\nand controls which item will receive focus when it opens. Also tracks the open submenus within\nthe menu tree via their trigger keys.\n\n`useMenuTriggerState(\n(props: MenuTriggerProps\n)): RootMenuTriggerState`\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `trigger` | `MenuTriggerType` | `'press'` | How the menu is triggered. |\n| `isOpen` | `boolean` | \u00e2\u0080\u0094 | Whether the overlay is open by default (controlled). |\n| `defaultOpen` | `boolean` | \u00e2\u0080\u0094 | Whether the overlay is open by default (uncontrolled). |\n| `onOpenChange` | `( (isOpen: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the overlay's open state changes. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `openSubmenu` | `( (triggerKey: Key, , level: number )) => void` | Opens a specific submenu tied to a specific menu item at a specific level. |\n| `closeSubmenu` | `( (triggerKey: Key, , level: number )) => void` | Closes a specific submenu tied to a specific menu item at a specific level. |\n| `expandedKeysStack` | `Key[]` | An array of open submenu trigger keys within the menu tree. The index of key within array matches the submenu level in the tree. |\n| `close` | `() => void` | Closes the menu and all submenus in the menu tree. |\n| `focusStrategy` | `FocusStrategy |\u00c2\u00a0null` | Controls which item will be auto focused when the menu opens. |\n| `isOpen` | `boolean` | Whether the overlay is currently open. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `open( (focusStrategy?: FocusStrategy |\u00c2\u00a0 |\u00c2\u00a0null )): void` | Opens the menu. |\n| `toggle( (focusStrategy?: FocusStrategy |\u00c2\u00a0 |\u00c2\u00a0null )): void` | Toggles the menu. |\n| `setOpen( (isOpen: boolean )): void` | Sets whether the overlay is open. |\n\nProvides state management for tree-like components. Handles building a collection\nof items from props, item expanded state, and manages multiple selection state.\n\n`useTreeState<T extends object>(\n(props: TreeProps<T>\n)): TreeState<T>`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `disabledBehavior` | `DisabledBehavior` | Whether `disabledKeys` applies to all interactions, or only selection. |\n| `collection` | `Collection<Node<T>>` | A pre-constructed collection to use instead of building one from items and children. |\n| `expandedKeys` | `Iterable<Key>` | The currently expanded keys in the collection (controlled). |\n| `defaultExpandedKeys` | `Iterable<Key>` | The initial expanded keys in the collection (uncontrolled). |\n| `onExpandedChange` | `( (keys: Set<Key> )) => any` | Handler that is called when items are expanded or collapsed. |\n| `selectionMode` | `SelectionMode` | The type of selection that is allowed in the collection. |\n| `disallowEmptySelection` | `boolean` | Whether the collection allows empty selection. |\n| `selectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The currently selected keys in the collection (controlled). |\n| `defaultSelectedKeys` | `'all' |\u00c2\u00a0Iterable<Key>` | The initial selected keys in the collection (uncontrolled). |\n| `onSelectionChange` | `( (keys: Selection )) => void` | Handler that is called when the selection changes. |\n| `disabledKeys` | `Iterable<Key>` | The currently disabled keys in the collection (controlled). |\n\nProvides the behavior and accessibility implementation for a menu trigger.\n\n`useMenuTrigger<T>(\nprops: AriaMenuTriggerProps,\nstate: MenuTriggerState,\nref: RefObject<Element\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuTriggerAria<T>`\n\nProvides the behavior and accessibility implementation for a menu component.\nA menu displays a list of actions or options that a user can choose.\n\n`useMenu<T>(\nprops: AriaMenuOptions<T>,\nstate: TreeState<T>,\nref: RefObject<HTMLElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuAria`\n\nProvides the behavior and accessibility implementation for an item in a menu.\nSee `useMenu` for more details about menus.\n\n`useMenuItem<T>(\nprops: AriaMenuItemProps,\nstate: TreeState<T>,\nref: RefObject<FocusableElement\n|\u00c2\u00a0 |\u00c2\u00a0null>\n): MenuItemAria`\n\nProvides the behavior and accessibility implementation for a section in a menu.\nSee `useMenu` for more details about menus.\n\n`useMenuSection(\n(props: AriaMenuSectionProps\n)): MenuSectionAria`\n\nA RouterProvider accepts a `navigate` function from a framework or client side router,\nand provides it to all nested React Aria links to enable client side navigation.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `navigate` | `( (path: Href, , routerOptions: RouterOptions |\u00c2\u00a0 |\u00c2\u00a0undefined )) => void` |  |\n| `children` | `ReactNode` |  |\n| `useHref` | `( (href: Href )) => string` |  |\n\n`RouterConfig extends {\n\nhref: any\n\n} ? H : string`\n\nThis type allows configuring link props with router options and type-safe URLs via TS module augmentation.\nBy default, this is an empty type. Extend with `href` and `routerOptions` properties to configure your router.\n\n`RouterConfig extends {\n\nrouterOptions: any\n\n} ? O : never`",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:38:08.422635+00:00",
  "content_length": 67152,
  "content_hash": "1c0a766c00747f90"
}