{
  "id": "react-aria__react-aria_useDrop_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useDrop.html",
  "title": "useDrop",
  "content": "useDrop\nHandles drop interactions for an element, with support for traditional mouse and touch\nbased drag and drop, in addition to full parity for keyboard and screen reader users.\nIntroduction\nReact Aria supports traditional mouse and touch based drag and drop, but also implements keyboard and screen reader friendly interactions. Users can press\nEnter\non a draggable element to enter drag and drop mode. Then, they can press\nTab\nto navigate between drop targets, and\nEnter\nto drop or\nEscape\nto cancel. Touch screen reader users can also drag by double tapping to activate drag and drop mode, swiping between drop targets, and double tapping again to drop.\nSee the\ndrag and drop guide\nto learn more.\nExample\nThis example shows how to make a simple drop target that accepts plain text data. In order to support keyboard and screen reader drag interactions, the element must be focusable and have an ARIA role (in this case,\nbutton\n). While a drag is hovered over it, a blue outline is rendered by applying an additional CSS class.\nDrag me\nDrop here\nExample\nDraggable.tsx\nuseDragExample.css\nExample\nDraggable.tsx\nuseDragExample.css\nimport\nReact\nfrom\n'react'\n;\nimport\ntype\n{TextDropItem}\nfrom\n'react-aria'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\n{Draggable}\nfrom\n'./Draggable'\n;\nimport\n'./useDragExample.css'\n;\nimport\n'./theme.css'\n;\nfunction\nDropTarget() {\nlet\n[\ndropped\n,\nsetDropped\n] = React.\nuseState\n<string | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\nlet\nitems\n=\nawait\nPromise.\nall\n(\ne\n.\nitems\n.\nfilter\n((\nitem\n):\nitem\nis TextDropItem =>\nitem\n.\nkind\n===\n'text'\n&&\nitem\n.\ntypes\n.\nhas\n(\n'text/plain'\n))\n          .\nmap\n((\nitem\n) =>\nitem\n.\ngetText\n(\n'text/plain'\n))\n      );\nsetDropped\n(\nitems\n.\njoin\n(\n'\\n'\n));\n    }\n  });\nreturn\n(\n    <\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}>\n      {\ndropped\n||\n'Drop here'\n}\n    </\ndiv\n>\n  );\n}\n\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDrop data\nuseDrop\nallows users to drop one or more\ndrag items\n, each of which contains data to be transferred from the drag source to drop target. There are three kinds of drag items:\ntext\n\u00e2\u0080\u0093 represents data inline as a string in one or more formats\nfile\n\u00e2\u0080\u0093 references a file on the user's device\ndirectory\n\u00e2\u0080\u0093 references the contents of a directory\nText\nA\nTextDropItem\nrepresents textual data in one or more different formats. These may be either standard\nmime types\nor custom app-specific formats. Representing data in multiple formats allows drop targets both within and outside an application to choose data in a format that they understand. For example, a complex object may be serialized in a custom format for use within an application, with fallbacks in plain text and/or rich HTML that can be used when a user drops data from an external application.\nThe example below finds the first available item that includes a custom app-specific type. The same draggable component as used in the above example is used here, but rather than displaying the plain text representation, the custom format is used instead.\nDrag me\nDrop here\nimport\nReact\nfrom\n'react'\n;\nimport\ntype\n{TextDropItem}\nfrom\n'react-aria'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\n{Draggable}\nfrom\n'./Draggable'\n;\nfunction\nDropTarget() {\nlet\n[\ndropped\n,\nsetDropped\n] = React.\nuseState\n<string | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\nlet\nitem\n=\ne\n.\nitems\n.\nfind\n(\nitem\n=>\nitem\n.\nkind\n===\n'text'\n&&\nitem\n.\ntypes\n.\nhas\n(\n'my-app-custom-type'\n))\nas\nTextDropItem;\nif\n(\nitem\n) {\nsetDropped\n(\nawait\nitem\n.\ngetText\n(\n'my-app-custom-type'\n));\n      }\n    }\n});\n// ...\nreturn\n(\n);\n<\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}>\n      {\ndropped\n||\n'Drop here'\n}\n    </\ndiv\n>\n  );\n}\n<\ndiv\n>\n</\ndiv\n>\n<\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nFiles\nA\nFileDropItem\nreferences a file on the user's device. It includes the name and mime type of the file, and methods to read the contents as plain text, or retrieve a native\nFile\nobject which can be attached to form data for uploading.\nThis example accepts JPEG and PNG image files, and renders them by creating a local\nobject URL\n.\nDrop image here\nimport\nReact\nfrom\n'react'\n;\nimport\ntype\n{FileDropItem}\nfrom\n'react-aria'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nfunction\nDropTarget() {\nlet\n[\nfile\n,\nsetFile\n] = React.\nuseState\n<string | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\nlet\nitem\n=\ne\n.\nitems\n.\nfind\n(\nitem\n=>\nitem\n.\nkind\n===\n'file'\n&& (\nitem\n.\ntype\n===\n'image/jpeg'\n||\nitem\n.\ntype\n===\n'image/png'\n))\nas\nFileDropItem;\nif\n(\nitem\n) {\nsetFile\n(URL.\ncreateObjectURL\n(\nawait\nitem\n.\ngetFile\n()));\n      }\n    }\n});\nreturn\n(\n    <\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}>\n      {\nfile\n? <\nimg\nsrc\n={\nfile\n}\nstyle\n={{\nwidth\n:\n'100%'\n,\nheight\n:\n'100%'\n,\nobjectFit\n:\n'contain'\n}} /> :\n'Drop image here'\n}\n    </\ndiv\n>\n  );\n}\nExpand code\nDirectories\nA\nDirectoryDropItem\nreferences the contents of a directory on the user's device. It includes the name of the directory, as well as a method to iterate through the files and folders within the directory. The contents of any folders within the directory can be accessed recursively.\nThe\ngetEntries\nmethod returns an\nasync iterable\nobject, which can be used in a\nfor await...of\nloop. This provides each item in the directory as either a\nFileDropItem\nor\nDirectoryDropItem\n, and you can access the contents of each file as discussed above.\nThis example renders the file names within a dropped directory in a grid.\nDrop directory here\nExample\nuseClipboardGrid.css\nExample\nuseClipboardGrid.css\nimport\nReact\nfrom\n'react'\n;\nimport\ntype\n{DirectoryDropItem}\nfrom\n'react-aria'\n;\nimport\nFile\nfrom\n'@react-spectrum/s2/icons/File'\n;\nimport\nFolder\nfrom\n'@react-spectrum/s2/icons/Folder'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\n'./useClipboardGrid.css'\n;\nfunction\nDropTarget() {\nlet\n[\nfiles\n,\nsetFiles\n] = React.\nuseState\n<Array<{\nname\n: string,\nkind\n:\n'file'\n|\n'directory'\n}> | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\n// Find the first dropped item that is a directory.\nlet\ndir\n=\ne\n.\nitems\n.\nfind\n(\nitem\n=>\nitem\n.\nkind\n===\n'directory'\n)\nas\nDirectoryDropItem;\nif\n(\ndir\n) {\n// Read entries in directory and update state with relevant info.\nlet\nfiles\n: Array<{\nname\n: string,\nkind\n:\n'file'\n|\n'directory'\n}> = [];\nfor\nawait\n(\nlet\nentry\nof\ndir\n.\ngetEntries\n()) {\nfiles\n.\npush\n({\nname\n:\nentry\n.\nname\n,\nkind\n:\nentry\n.\nkind\n});\n        }\nsetFiles\n(\nfiles\n);\n      }\n    }\n});\nlet\ncontents\n= <>Drop directory here</>;\nif\n(\nfiles\n) {\ncontents\n= (\n      <\nul\n>\n        {\nfiles\n.\nmap\n(\nf\n=> (\n          <\nli\nkey\n={\nf\n.\nname\n}>\n            {\nf\n.\nkind\n===\n'directory'\n? <\nFolder\n/> : <\nFile\n/>}\n            <\nspan\n>{\nf\n.\nname\n}</\nspan\n>\n          </\nli\n>\n        ))}\n      </\nul\n>\n    );\n  }\nreturn\n(\n    <\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable grid ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}\nstyle\n={{\noverflow\n:\n'auto'\n}}>\n      {\ncontents\n}\n    </\ndiv\n>\n  );\n}\nExpand code\nDrop operations\nA\nDropOperation\nis an indication of what will happen when dragged data is dropped on a particular drop target. These are:\nmove\n\u00e2\u0080\u0093 indicates that the dragged data will be moved from its source location to the target location.\ncopy\n\u00e2\u0080\u0093 indicates that the dragged data will be copied to the target destination.\nlink\n\u00e2\u0080\u0093 indicates that there will be a relationship established between the source and target locations.\ncancel\n\u00e2\u0080\u0093 indicates that the drag and drop operation will be canceled, resulting in no changes made to the source or target.\nMany operating systems display these in the form of a cursor change, e.g. a plus sign to indicate a copy operation. The user may also be able to use a modifier key to choose which drop operation to perform, such as\nOption\nor\nAlt\nto switch from move to copy.\nThe drag source can specify which drop operations are allowed for the dragged data (see the\nuseDrag docs\nfor how to customize this). By default, the first allowed operation is allowed by drop targets, meaning that the drop target accepts data of any type and operation.\ngetDropOperation\nThe\ngetDropOperation\nfunction passed to\nuseDrop\ncan be used to provide appropriate feedback to the user when a drag hovers over the drop target. If a drop target only supports data of specific types (e.g. images, videos, text, etc.), then it should implement\ngetDropOperation\nand return\n'cancel'\nfor types that aren't supported. This will prevent visual feedback indicating that the drop target accepts the dragged data when this is not true.\nWhen the data is supported, either return one of the drop operations in\nallowedOperation\nor a specific drop operation if only that drop operation is supported. If the returned operation is not in\nallowedOperations\n, then the drop target will act as if\n'cancel'\nwas returned.\nIn the below example, the drop target only supports dropping PNG images. If a PNG is dragged over the target, it will be highlighted and the operating system displays a copy cursor. If another type is dragged over the target, then there is no visual feedback, indicating that a drop is not accepted there. If the user holds a modifier key such as\nControl\nwhile dragging over the drop target in order to change the drop operation, then the drop target does not accept the drop.\nDrop image here\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\ntype\n{FileDropItem}\nfrom\n'react-aria'\n;\nfunction\nDropTarget() {\nlet\n[\nfile\n,\nsetFile\n] = React.\nuseState\n<string | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\ngetDropOperation\n(\ntypes\n,\nallowedOperations\n) {\nreturn\ntypes\n.\nhas\n(\n'image/png'\n) ?\n'copy'\n:\n'cancel'\n;\n    },\nasync\nonDrop\n(\ne\n) {\nlet\nitem\n=\ne\n.\nitems\n.\nfind\n(\nitem\n=>\nitem\n.\nkind\n===\n'file'\n&&\nitem\n.\ntype\n===\n'image/png'\n)\nas\nFileDropItem;\nif\n(\nitem\n) {\nsetFile\n(URL.\ncreateObjectURL\n(\nawait\nitem\n.\ngetFile\n()));\n      }\n    }\n  });\n// ...\nreturn\n(\n);\n<\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}>\n      {\nfile\n? <\nimg\nsrc\n={\nfile\n}\nstyle\n={{\nwidth\n:\n'100%'\n,\nheight\n:\n'100%'\n,\nobjectFit\n:\n'contain'\n}} /> :\n'Drop image here'\n}\n    </\ndiv\n>\n  );\n}\nExpand code\nonDrop\nThe\nonDrop\nevent also includes the\ndropOperation\n. This can be used to perform different actions accordingly, for example, when communicating with a backend API.\nfunction\nDropTarget(\nprops\n) {\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\nlet\nitem\n=\ne\n.\nitems\n.\nfind\n(\nitem\n=>\nitem\n.\nkind\n===\n'text'\n&&\nitem\n.\ntypes\n.\nhas\n(\n'my-app-file'\n))\nas\nTextDropItem;\nif\n(!\nitem\n) {\nreturn\n;\n}\nlet\ndata\n= JSON.\nparse\n(\nawait\nitem\n.\ngetText\n(\n'my-app-file'\n));\nswitch\n(\ne\n.\ndropOperation\n) {\ncase\n'move'\n:\n          MyAppFileService.\nmove\n(\ndata\n.\nfilePath\n,\nprops\n.\nfilePath\n);\nbreak\n;\ncase\n'copy'\n:\n          MyAppFileService.\ncopy\n(\ndata\n.\nfilePath\n,\nprops\n.\nfilePath\n);\nbreak\n;\ncase\n'link'\n:\n          MyAppFileService.\nlink\n(\ndata\n.\nfilePath\n,\nprops\n.\nfilePath\n);\nbreak\n;\n      }\n}\n  });\n// ...\n}\nEvents\nDrop targets receive a number of events during a drag session. These are:\nName\nType\ny\nnumber\nThe y coordinate of the event, relative to the target element.\nx\nnumber\nThe x coordinate of the event, relative to the target element.\nitems\nDropItem\n[]\nThe dropped items.\ndropOperation\nDropOperation\nThe drop operation that should occur.\ntype\n'drop'\nThe event type.\nThis example logs all events that occur within the drop target:\nDrag me\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\n{Draggable}\nfrom\n'./Draggable'\n;\nfunction\nDropTarget() {\nlet\n[\nevents\n,\nsetEvents\n] = React.\nuseState\n<string[]>([]);\nlet\nonEvent\n=\ne\n=>\nsetEvents\n(\nevents\n=> [JSON.\nstringify\n(\ne\n), ...\nevents\n]);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nonDropEnter\n:\nonEvent\n,\nonDropMove\n:\nonEvent\n,\nonDropExit\n:\nonEvent\n,\nonDrop\n:\nonEvent\n});\nreturn\n(\n    <\nul\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}\nstyle\n={{\ndisplay\n:\n'block'\n,\nwidth\n:\n'auto'\n,\noverflow\n:\n'auto'\n}}\naria-label\n=\n\"Drop events\"\n>\n      {\nevents\n.\nmap\n((\ne\n,\ni\n) => <\nli\nkey\n={\ni\n}>{\ne\n}</\nli\n>)}\n    </\nul\n>\n  );\n}\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDisabling dropping\nIf you need to temporarily disable dropping, you can pass the\nisDisabled\noption to\nuseDrop\n. This will prevent the drop target from accepting any drops until it is re-enabled.\nDrag me\nDrop here\nimport\nReact\nfrom\n'react'\n;\nimport\ntype\n{TextDropItem}\nfrom\n'react-aria'\n;\nimport\n{\nuseDrop\n}\nfrom\n'react-aria'\n;\nimport\n{Draggable}\nfrom\n'./Draggable'\n;\nfunction\nDropTarget() {\nlet\n[\ndropped\n,\nsetDropped\n] = React.\nuseState\n<string | null>(null);\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{dropProps, isDropTarget} =\nuseDrop\n({\n    ref,\nasync\nonDrop\n(\ne\n) {\nlet\nitems\n=\nawait\nPromise.\nall\n(\ne\n.\nitems\n.\nfilter\n((\nitem\n):\nitem\nis TextDropItem =>\nitem\n.\nkind\n===\n'text'\n&&\nitem\n.\ntypes\n.\nhas\n(\n'text/plain'\n))\n          .\nmap\n((\nitem\n) =>\nitem\n.\ngetText\n(\n'text/plain'\n))\n);\nsetDropped\n(\nitems\n.\njoin\n(\n'\\n'\n));\n    },\nisDisabled\n: true\n});\nreturn\n(\n    <\ndiv\n{...\ndropProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nref\n={\nref\n}\nclassName\n={\n`droppable ${\nisDropTarget\n?\n'target'\n:\n''\n}`\n}>\n      {\ndropped\n||\n'Drop here'\n}\n    </\ndiv\n>\n  );\n}\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nAPI\nuseDrop\n(\noptions\n:\nDropOptions\n)\n:\nDropResult\nDropOptions\nName\nType\nref\nRefObject\n<\nFocusableElement\n|\u00c2\nnull\n>\nA ref for the droppable element.\nisDisabled\nboolean\nWhether the drop target is disabled. If true, the drop target will not accept any drops.\nhasDropButton\nboolean\nWhether the item has an explicit focusable drop affordance to initiate accessible drag and drop mode.\nIf true, the dropProps will omit these event handlers, and they will be applied to dropButtonProps instead.\nonDrop\n(\ne\n:\nDropEvent\n)\n=>\nvoid\nHandler that is called when a valid drag is dropped on the drop target.\nonDropExit\n(\ne\n:\nDropExitEvent\n)\n=>\nvoid\nHandler that is called when a valid drag exits the drop target.\nonDropActivate\n(\ne\n:\nDropActivateEvent\n)\n=>\nvoid\nHandler that is called after a valid drag is held over the drop target for a period of time.\nThis typically opens the item so that the user can drop within it.\nonDropMove\n(\ne\n:\nDropMoveEvent\n)\n=>\nvoid\nHandler that is called when a valid drag is moved within the drop target.\nonDropEnter\n(\ne\n:\nDropEnterEvent\n)\n=>\nvoid\nHandler that is called when a valid drag enters the drop target.\ngetDropOperationForPoint\n(\ntypes\n:\nDragTypes\n,\nallowedOperations\n:\nDropOperation\n[]\n,\nx\n:\nnumber\n,\ny\n:\nnumber\n)\n=>\nDropOperation\nA function that returns the drop operation for a specific point within the target.\ngetDropOperation\n(\ntypes\n:\nDragTypes\n,\nallowedOperations\n:\nDropOperation\n[]\n)\n=>\nDropOperation\nA function returning the drop operation to be performed when items matching the given types are dropped\non the drop target.\nDropResult\nName\nType\nisDropTarget\nboolean\nWhether the drop target is currently focused or hovered.\ndropProps\nDOMAttributes\nProps for the droppable element.\ndropButtonProps\nAriaButtonProps\nProps for the explicit drop button affordance, if any.",
  "content_markdown": "# useDrop\n\nHandles drop interactions for an element, with support for traditional mouse and touch\nbased drag and drop, in addition to full parity for keyboard and screen reader users.\n\n## Introduction\n\nReact Aria supports traditional mouse and touch based drag and drop, but also implements keyboard and screen reader friendly interactions. Users can press `Enter` on a draggable element to enter drag and drop mode. Then, they can press `Tab` to navigate between drop targets, and `Enter` to drop or `Escape` to cancel. Touch screen reader users can also drag by double tapping to activate drag and drop mode, swiping between drop targets, and double tapping again to drop.\n\nSee the [drag and drop guide](dnd) to learn more.\n\n## Example\n\nThis example shows how to make a simple drop target that accepts plain text data. In order to support keyboard and screen reader drag interactions, the element must be focusable and have an ARIA role (in this case, `button`). While a drag is hovered over it, a blue outline is rendered by applying an additional CSS class.\n\nDrag me\n\nDrop here\n\nExample\n\nDraggable.tsx\n\nuseDragExample.css\n\nExample\n\nDraggable.tsx\n\nuseDragExample.css\n\nExample\n\nDraggable.tsx\n\nuseDragExample.css\n\n```\nimport React from 'react';\nimport type {TextDropItem} from 'react-aria';\nimport {useDrop} from 'react-aria';\nimport {Draggable} from './Draggable';\nimport './useDragExample.css';\nimport './theme.css';\n\nfunction DropTarget() {\n  let [dropped, setDropped] = React.useState<string | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      let items = await Promise.all(\n        e.items\n          .filter((item): item is TextDropItem => item.kind === 'text' && item.types.has('text/plain'))\n          .map((item) => item.getText('text/plain'))\n      );\n      setDropped(items.join('\\n'));\n    }\n  });\n\n  return (\n    <div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`}>\n      {dropped || 'Drop here'}\n    </div>\n  );\n}\n\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Drop data\n\n`useDrop` allows users to drop one or more **drag items**, each of which contains data to be transferred from the drag source to drop target. There are three kinds of drag items:\n\n- `text` \u00e2\u0080\u0093 represents data inline as a string in one or more formats\n- `file` \u00e2\u0080\u0093 references a file on the user's device\n- `directory` \u00e2\u0080\u0093 references the contents of a directory\n\n### Text\n\nA TextDropItem represents textual data in one or more different formats. These may be either standard [mime types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) or custom app-specific formats. Representing data in multiple formats allows drop targets both within and outside an application to choose data in a format that they understand. For example, a complex object may be serialized in a custom format for use within an application, with fallbacks in plain text and/or rich HTML that can be used when a user drops data from an external application.\n\nThe example below finds the first available item that includes a custom app-specific type. The same draggable component as used in the above example is used here, but rather than displaying the plain text representation, the custom format is used instead.\n\nDrag me\n\nDrop here\n\n```\nimport React from 'react';\nimport type {TextDropItem} from 'react-aria';\nimport {useDrop} from 'react-aria';\nimport {Draggable} from './Draggable';\n\nfunction DropTarget() {\n  let [dropped, setDropped] = React.useState<string | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      let item = e.items.find(item => item.kind === 'text' && item.types.has('my-app-custom-type')) as TextDropItem;\n      if (item) {\n        setDropped(await item.getText('my-app-custom-type'));\n      }\n    }\n  });\n  // ...\n\nreturn ();\n\n<div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`}>\n      {dropped || 'Drop here'}\n    </div>\n  );\n\n}\n\n<div></div>\n\n<Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n### Files\n\nA FileDropItem references a file on the user's device. It includes the name and mime type of the file, and methods to read the contents as plain text, or retrieve a native [File](https://developer.mozilla.org/en-US/docs/Web/API/File) object which can be attached to form data for uploading.\n\nThis example accepts JPEG and PNG image files, and renders them by creating a local [object URL](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL).\n\nDrop image here\n\n```\nimport React from 'react';\nimport type {FileDropItem} from 'react-aria';\nimport {useDrop} from 'react-aria';\nfunction DropTarget() {\n  let [file, setFile] = React.useState<string | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      let item = e.items.find(item => item.kind === 'file' && (item.type === 'image/jpeg' || item.type === 'image/png')) as FileDropItem;\n      if (item) {\n        setFile(URL.createObjectURL(await item.getFile()));\n      }\n    }\n  });\n  return (\n    <div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`}>\n      {file ? <img src={file} style={{width: '100%', height: '100%', objectFit: 'contain'}} /> : 'Drop image here'}\n    </div>\n  );\n}\n```\n\nExpand code\n\n### Directories\n\nA DirectoryDropItem references the contents of a directory on the user's device. It includes the name of the directory, as well as a method to iterate through the files and folders within the directory. The contents of any folders within the directory can be accessed recursively.\nThe `getEntries` method returns an [async iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) object, which can be used in a `for await...of` loop. This provides each item in the directory as either a FileDropItem or DirectoryDropItem, and you can access the contents of each file as discussed above.\n\nThis example renders the file names within a dropped directory in a grid.\n\nDrop directory here\n\nExample\n\nuseClipboardGrid.css\n\nExample\n\nuseClipboardGrid.css\n\nExample\n\nuseClipboardGrid.css\n\n```\nimport React from 'react';\nimport type {DirectoryDropItem} from 'react-aria';\nimport File from '@react-spectrum/s2/icons/File';\nimport Folder from '@react-spectrum/s2/icons/Folder';\nimport {useDrop} from 'react-aria';\nimport './useClipboardGrid.css';\n\nfunction DropTarget() {\n  let [files, setFiles] = React.useState<Array<{name: string, kind: 'file' | 'directory'}> | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      // Find the first dropped item that is a directory.\n      let dir = e.items.find(item => item.kind === 'directory') as DirectoryDropItem;\n      if (dir) {\n        // Read entries in directory and update state with relevant info.\n        let files: Array<{name: string, kind: 'file' | 'directory'}> = [];\n        for await (let entry of dir.getEntries()) {\n          files.push({\n            name: entry.name,\n            kind: entry.kind\n          });\n        }\n        setFiles(files);\n      }\n    }\n  });\n  let contents = <>Drop directory here</>;\n  if (files) {\n    contents = (\n      <ul>\n        {files.map(f => (\n          <li key={f.name}>\n            {f.kind === 'directory' ? <Folder /> : <File />}\n            <span>{f.name}</span>\n          </li>\n        ))}\n      </ul>\n    );\n  }\n  return (\n    <div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable grid ${isDropTarget ? 'target' : ''}`} style={{overflow: 'auto'}}>\n      {contents}\n    </div>\n  );\n}\n```\n\nExpand code\n\n## Drop operations\n\nA DropOperation is an indication of what will happen when dragged data is dropped on a particular drop target. These are:\n\n- `move` \u00e2\u0080\u0093 indicates that the dragged data will be moved from its source location to the target location.\n- `copy` \u00e2\u0080\u0093 indicates that the dragged data will be copied to the target destination.\n- `link` \u00e2\u0080\u0093 indicates that there will be a relationship established between the source and target locations.\n- `cancel` \u00e2\u0080\u0093 indicates that the drag and drop operation will be canceled, resulting in no changes made to the source or target.\n\nMany operating systems display these in the form of a cursor change, e.g. a plus sign to indicate a copy operation. The user may also be able to use a modifier key to choose which drop operation to perform, such as `Option` or `Alt` to switch from move to copy.\nThe drag source can specify which drop operations are allowed for the dragged data (see the [useDrag docs](useDrag) for how to customize this). By default, the first allowed operation is allowed by drop targets, meaning that the drop target accepts data of any type and operation.\n\n### getDropOperation\n\nThe `getDropOperation` function passed to `useDrop` can be used to provide appropriate feedback to the user when a drag hovers over the drop target. If a drop target only supports data of specific types (e.g. images, videos, text, etc.), then it should implement `getDropOperation` and return `'cancel'` for types that aren't supported. This will prevent visual feedback indicating that the drop target accepts the dragged data when this is not true.\nWhen the data is supported, either return one of the drop operations in `allowedOperation` or a specific drop operation if only that drop operation is supported. If the returned operation is not in `allowedOperations`, then the drop target will act as if `'cancel'` was returned.\n\nIn the below example, the drop target only supports dropping PNG images. If a PNG is dragged over the target, it will be highlighted and the operating system displays a copy cursor. If another type is dragged over the target, then there is no visual feedback, indicating that a drop is not accepted there. If the user holds a modifier key such as `Control` while dragging over the drop target in order to change the drop operation, then the drop target does not accept the drop.\n\nDrop image here\n\n```\nimport React from 'react';\nimport {useDrop} from 'react-aria';\nimport type {FileDropItem} from 'react-aria';\nfunction DropTarget() {\n  let [file, setFile] = React.useState<string | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    getDropOperation(types, allowedOperations) {\n      return types.has('image/png') ? 'copy' : 'cancel';\n    },\n    async onDrop(e) {\n      let item = e.items.find(item => item.kind === 'file' && item.type === 'image/png') as FileDropItem;\n      if (item) {\n        setFile(URL.createObjectURL(await item.getFile()));\n      }\n    }\n  });\n  // ...\n\nreturn ();\n\n<div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`}>\n      {file ? <img src={file} style={{width: '100%', height: '100%', objectFit: 'contain'}} /> : 'Drop image here'}\n    </div>\n  );\n\n}\n```\n\nExpand code\n\n### onDrop\n\nThe `onDrop` event also includes the `dropOperation`. This can be used to perform different actions accordingly, for example, when communicating with a backend API.\n\n```\nfunction DropTarget(props) {\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      let item = e.items.find(item => item.kind === 'text' && item.types.has('my-app-file')) as TextDropItem;\n      if (!item) {\n        return;\n      }\n      let data = JSON.parse(await item.getText('my-app-file'));\n      switch (e.dropOperation) {\n        case 'move':\n          MyAppFileService.move(data.filePath, props.filePath);\n          break;\n        case 'copy':\n          MyAppFileService.copy(data.filePath, props.filePath);\n          break;\n        case 'link':\n          MyAppFileService.link(data.filePath, props.filePath);\n          break;\n      }\n    }\n  });\n  // ...\n}\n```\n\n## Events\n\nDrop targets receive a number of events during a drag session. These are:\n\n| Name | Type |\n| --- | --- |\n| `y` | `number` |\n| The y coordinate of the event, relative to the target element. | | |\n| `x` | `number` |\n| The x coordinate of the event, relative to the target element. | | |\n| `items` | `DropItem[]` |\n| The dropped items. | | |\n| `dropOperation` | `DropOperation` |\n| The drop operation that should occur. | | |\n| `type` | `'drop'` |\n| The event type. | | |\n\nThis example logs all events that occur within the drop target:\n\nDrag me\n\n```\nimport React from 'react';\nimport {useDrop} from 'react-aria';\nimport {Draggable} from './Draggable';\n\nfunction DropTarget() {\n  let [events, setEvents] = React.useState<string[]>([]);\n  let onEvent = e => setEvents(events => [JSON.stringify(e), ...events]);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    onDropEnter: onEvent,\n    onDropMove: onEvent,\n    onDropExit: onEvent,\n    onDrop: onEvent\n  });\n  return (\n    <ul {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`} style={{display: 'block', width: 'auto', overflow: 'auto'}} aria-label=\"Drop events\">\n      {events.map((e, i) => <li key={i}>{e}</li>)}\n    </ul>\n  );\n}\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Disabling dropping\n\nIf you need to temporarily disable dropping, you can pass the `isDisabled` option to `useDrop`. This will prevent the drop target from accepting any drops until it is re-enabled.\n\nDrag me\n\nDrop here\n\n```\nimport React from 'react';\nimport type {TextDropItem} from 'react-aria';\nimport {useDrop} from 'react-aria';\nimport {Draggable} from './Draggable';\n\nfunction DropTarget() {\n  let [dropped, setDropped] = React.useState<string | null>(null);\n  let ref = React.useRef(null);\n  let {dropProps, isDropTarget} = useDrop({\n    ref,\n    async onDrop(e) {\n      let items = await Promise.all(\n        e.items\n          .filter((item): item is TextDropItem => item.kind === 'text' && item.types.has('text/plain'))\n          .map((item) => item.getText('text/plain'))\n      );\n      setDropped(items.join('\\n'));\n    },\n    isDisabled: true\n  });\n  return (\n    <div {...dropProps} role=\"button\" tabIndex={0} ref={ref} className={`droppable ${isDropTarget ? 'target' : ''}`}>\n      {dropped || 'Drop here'}\n    </div>\n  );\n}\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## API\n\n`useDrop(options: DropOptions): DropResult`\n\n### DropOptions\n\n| Name | Type |\n| --- | --- |\n| `ref` | `RefObject<FocusableElement |\u00c2\u00a0null>` |\n| A ref for the droppable element. | | |\n| `isDisabled` | `boolean` |\n| Whether the drop target is disabled. If true, the drop target will not accept any drops. | | |\n| `hasDropButton` | `boolean` |\n| Whether the item has an explicit focusable drop affordance to initiate accessible drag and drop mode. If true, the dropProps will omit these event handlers, and they will be applied to dropButtonProps instead. | | |\n| `onDrop` | `(e: DropEvent) => void` |\n| Handler that is called when a valid drag is dropped on the drop target. | | |\n| `onDropExit` | `(e: DropExitEvent) => void` |\n| Handler that is called when a valid drag exits the drop target. | | |\n| `onDropActivate` | `(e: DropActivateEvent) => void` |\n| Handler that is called after a valid drag is held over the drop target for a period of time. This typically opens the item so that the user can drop within it. | | |\n| `onDropMove` | `(e: DropMoveEvent) => void` |\n| Handler that is called when a valid drag is moved within the drop target. | | |\n| `onDropEnter` | `(e: DropEnterEvent) => void` |\n| Handler that is called when a valid drag enters the drop target. | | |\n| `getDropOperationForPoint` | `( types: DragTypes, allowedOperations: DropOperation[], x: number, y: number ) => DropOperation` |\n| A function that returns the drop operation for a specific point within the target. | | |\n| `getDropOperation` | `(types: DragTypes, allowedOperations: DropOperation[]) => DropOperation` |\n| A function returning the drop operation to be performed when items matching the given types are dropped on the drop target. | | |\n\n### DropResult\n\n| Name | Type |\n| --- | --- |\n| `isDropTarget` | `boolean` |\n| Whether the drop target is currently focused or hovered. | | |\n| `dropProps` | `DOMAttributes` |\n| Props for the droppable element. | | |\n| `dropButtonProps` | `AriaButtonProps` |\n| Props for the explicit drop button affordance, if any. | | |",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:39:17.107201+00:00",
  "content_length": 15732,
  "content_hash": "d0341e4350c2ca12"
}