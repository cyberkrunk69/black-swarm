{
  "id": "react-aria__react-aria_useButton_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useButton.html",
  "title": "useButton",
  "content": "Migration in progress\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs\nhere\n.\nuseButton\nProvides the behavior and accessibility implementation for a button component. Handles mouse, keyboard, and touch interactions,\nfocus behavior, and ARIA props for both native button elements and custom element types.\ninstall\nyarn add react-aria\nversion\n3.45.0\nusage\nimport\n{useButton}\nfrom\n'react-aria'\nView ARIA pattern\nW3C\nView repository\nGitHub\nView package\nNPM\nAPI\n#\nuseButton\n(\n(\nprops\n:\nAriaButtonOptions\n<\nElementType\n>\n,\n,\nref\n:\nRefObject\n<\nany\n>\n)\n)\n:\nButtonAria\n<\nHTMLAttributes\n<\nany\n>\n>\nFeatures\n#\nOn the surface, building a custom styled button seems simple. However, there are many\ncross browser inconsistencies in interactions and accessibility features to consider.\nuseButton\nhandles all of these interactions for you, so you can focus on the styling.\nNative HTML\n<button>\nsupport\n<a>\nand custom element type support via ARIA\nMouse and touch event handling, and press state management\nKeyboard focus management and cross browser normalization\nKeyboard event support for\nSpace\nand\nEnter\nkeys\nRead our\nblog post\nabout the complexities of building buttons that work well across devices and interaction methods.\nAnatomy\n#\nButtons consist of a clickable area usually containing a textual label or an icon\nthat users can click to perform an action. In addition, keyboard users may activate\nbuttons using the\nSpace\nor\nEnter\nkeys.\nIf a visual label is not provided (e.g. an icon only button), then an\naria-label\nor\naria-labelledby\nprop must be passed to identify the button to assistive technology.\nExample\n#\nBy default,\nuseButton\nassumes that you are using it with a native\n<button>\nelement.\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nlet\n{\nchildren\n}\n=\nprops\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nlet\n{\nchildren\n}\n=\nprops\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nimport\n{\nuseButton\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseRef\n}\nfrom\n'react'\n;\nfunction\nButton\n(\nprops\n)\n{\nlet\nref\n=\nuseRef\n<\n|\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n}\n=\nuseButton\n(\nprops\n,\nref\n)\n;\nlet\n{\nchildren\n}\n=\nprops\n;\nreturn\n(\n<\nbutton\n{\n...\nbuttonProps\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nbutton\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nCustom element type\n#\nSometimes you might need to use an element other than a native\n<button>\n.\nuseButton\nsupports\nthis via the\nelementType\nprop. When used with an element other than a native button,\nuseButton\nautomatically applies the necessary ARIA roles and attributes to ensure that the element is exposed\nto assistive technology as a button.\nIn addition, this example shows usage of the\nisPressed\nvalue returned by\nuseButton\nto properly\nstyle the button's active state. You could use the CSS\n:active\npseudo class for this, but\nisPressed\nproperly handles when the user drags their pointer off of the button, along with keyboard support and better\ntouch screen support.\nfunction\nButton\n(\nprops\n)\n{\nlet\n{\nchildren\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n,\nisPressed\n}\n=\nuseButton\n(\n{\n...\nprops\n,\nelementType\n:\n'span'\n}\n,\nref\n)\n;\nreturn\n(\n<\nspan\n{\n...\nbuttonProps\n}\nstyle\n=\n{\n{\nbackground\n:\nisPressed\n?\n'darkgreen'\n:\n'green'\n,\ncolor\n:\n'white'\n,\npadding\n:\n10\n,\ncursor\n:\n'pointer'\n,\nuserSelect\n:\n'none'\n,\nWebkitUserSelect\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nspan\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nfunction\nButton\n(\nprops\n)\n{\nlet\n{\nchildren\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n,\nisPressed\n}\n=\nuseButton\n(\n{\n...\nprops\n,\nelementType\n:\n'span'\n}\n,\nref\n)\n;\nreturn\n(\n<\nspan\n{\n...\nbuttonProps\n}\nstyle\n=\n{\n{\nbackground\n:\nisPressed\n?\n'darkgreen'\n:\n'green'\n,\ncolor\n:\n'white'\n,\npadding\n:\n10\n,\ncursor\n:\n'pointer'\n,\nuserSelect\n:\n'none'\n,\nWebkitUserSelect\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nspan\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nfunction\nButton\n(\nprops\n)\n{\nlet\n{\nchildren\n}\n=\nprops\n;\nlet\nref\n=\nuseRef\n<\n|\nHTMLButtonElement\n|\nnull\n>\n(\nnull\n)\n;\nlet\n{\nbuttonProps\n,\nisPressed\n}\n=\nuseButton\n(\n{\n...\nprops\n,\nelementType\n:\n'span'\n}\n,\nref\n)\n;\nreturn\n(\n<\nspan\n{\n...\nbuttonProps\n}\nstyle\n=\n{\n{\nbackground\n:\nisPressed\n?\n'darkgreen'\n:\n'green'\n,\ncolor\n:\n'white'\n,\npadding\n:\n10\n,\ncursor\n:\n'pointer'\n,\nuserSelect\n:\n'none'\n,\nWebkitUserSelect\n:\n'none'\n}\n}\nref\n=\n{\nref\n}\n>\n{\nchildren\n}\n<\n/\nspan\n>\n)\n;\n}\n<\nButton\nonPress\n=\n{\n(\n)\n=>\nalert\n(\n'Button pressed!'\n)\n}\n>\nTest\n<\n/\nButton\n>\nUsage\n#\nThe following examples show how to use the\nButton\ncomponent created in the above example.\nEvents\n#\nuseButton\nsupports user interactions via mouse, keyboard, and touch. You can handle all of these via the\nonPress\nprop. This is similar to the standard\nonClick\nevent, but normalized to support all interaction methods equally. In addition, the\nonPressStart\n,\nonPressEnd\n, and\nonPressChange\nevents are fired as the user interacts with the button.\nEach of these handlers receives a\nPressEvent\n, which exposes information about the target and the type of event that triggered the interaction. See\nusePress\nfor more details.\nfunction\nExample\n(\n)\n{\nlet\n[\npointerType\n,\nsetPointerType\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\n>\n<\nButton\nonPressStart\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\ne\n.\npointerType\n)\n}\nonPressEnd\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\nnull\n)\n}\n>\nPress me\n<\n/\nButton\n>\n<\np\n>\n{\npointerType\n?\n`You are pressing the button with a\n${\npointerType\n}\n!`\n:\n'Ready to be pressed.'\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\npointerType\n,\nsetPointerType\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\n>\n<\nButton\nonPressStart\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\ne\n.\npointerType\n)\n}\nonPressEnd\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\nnull\n)\n}\n>\nPress me\n<\n/\nButton\n>\n<\np\n>\n{\npointerType\n?\n`You are pressing the button with a\n${\npointerType\n}\n!`\n:\n'Ready to be pressed.'\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nfunction\nExample\n(\n)\n{\nlet\n[\npointerType\n,\nsetPointerType\n]\n=\nReact\n.\nuseState\n(\nnull\n)\n;\nreturn\n(\n<\n>\n<\nButton\nonPressStart\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\ne\n.\npointerType\n)\n}\nonPressEnd\n=\n{\n(\ne\n)\n=>\nsetPointerType\n(\nnull\n)\n}\n>\nPress me\n<\n/\nButton\n>\n<\np\n>\n{\npointerType\n?\n`You are pressing the button with a\n${\npointerType\n}\n!`\n:\n'Ready to be pressed.'\n}\n<\n/\np\n>\n<\n/\n>\n)\n;\n}\nDisabled\n#\nA\nButton\ncan be disabled using the\nisDisabled\nprop.\n<\nButton\nisDisabled\n>\nPin\n<\n/\nButton\n>\n<\nButton\nisDisabled\n>\nPin\n<\n/\nButton\n>\n<\nButton\nisDisabled\n>\nPin\n<\n/\nButton\n>\nName\nType\nDefault\nDescription\nisDisabled\nboolean\n\u00e2\u0080\u0094\nWhether the button is disabled.\nonPress\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press is released over the target.\nonPressStart\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction starts.\nonPressEnd\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press interaction ends, either\nover the target or when the pointer leaves the target.\nonPressChange\n(\n(\nisPressed\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the press state changes.\nonPressUp\n(\n(\ne\n:\nPressEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a press is released over the target, regardless of\nwhether it started on the target or not.\nonClick\n(\n(\ne\n:\nMouseEvent\n<\nFocusableElement\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nNot recommended \u00e2\u0080\u0093 use\nonPress\ninstead.\nonClick\nis an alias for\nonPress\nprovided for compatibility with other libraries.\nonPress\nprovides \nadditional event details for non-mouse interactions.\nautoFocus\nboolean\n\u00e2\u0080\u0094\nWhether the element should receive focus on render.\nonFocus\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element receives focus.\nonBlur\n(\n(\ne\n:\nFocusEvent\n<\nTarget\n>\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element loses focus.\nonFocusChange\n(\n(\nisFocused\n:\nboolean\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when the element's focus status changes.\nonKeyDown\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is pressed.\nonKeyUp\n(\n(\ne\n:\nKeyboardEvent\n)\n)\n=>\nvoid\n\u00e2\u0080\u0094\nHandler that is called when a key is released.\nhref\nstring\n\u00e2\u0080\u0094\nA URL to link to if elementType=\"a\".\ntarget\nstring\n\u00e2\u0080\u0094\nThe target window for the link.\nrel\nstring\n\u00e2\u0080\u0094\nThe relationship between the linked resource and the current page. See\nMDN\n.\nelementType\nElementType\n|\u00c2\nJSXElementConstructor\n<\nany\n>\n'button'\nThe HTML element or React element used to render the button, e.g. 'div', 'a', or\nRouterLink\n.\naria-disabled\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element is disabled to users of assistive technology.\naria-expanded\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates whether the element, or another grouping element it controls, is currently expanded or collapsed.\naria-haspopup\nboolean\n|\u00c2\n'menu'\n|\u00c2\n'listbox'\n|\u00c2\n'tree'\n|\u00c2\n'grid'\n|\u00c2\n'dialog'\n|\u00c2\n'true'\n|\u00c2\n'false'\n\u00e2\u0080\u0094\nIndicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element.\naria-controls\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) whose contents or presence are controlled by the current element.\naria-pressed\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'mixed'\n\u00e2\u0080\u0094\nIndicates the current \"pressed\" state of toggle buttons.\naria-current\nboolean\n|\u00c2\n'true'\n|\u00c2\n'false'\n|\u00c2\n'page'\n|\u00c2\n'step'\n|\u00c2\n'location'\n|\u00c2\n'date'\n|\u00c2\n'time'\n\u00e2\u0080\u0094\nIndicates whether this element represents the current item within a container or set of related elements.\ntype\n'button'\n|\u00c2\n'submit'\n|\u00c2\n'reset'\n'button'\nThe behavior of the button when used in an HTML form.\npreventFocusOnPress\nboolean\n\u00e2\u0080\u0094\nWhether to prevent focus from moving to the button when pressing it.\nCaution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided,\nsuch as ComboBox's MenuTrigger or a NumberField's increment/decrement control.\nform\nstring\n\u00e2\u0080\u0094\nThe\n<form>\nelement to associate the button with.\nThe value of this attribute must be the id of a\n<form>\nin the same document.\nSee\nMDN\n.\nformAction\nstring\n\u00e2\u0080\u0094\nThe URL that processes the information submitted by the button.\nOverrides the action attribute of the button's form owner.\nformEncType\nstring\n\u00e2\u0080\u0094\nIndicates how to encode the form data that is submitted.\nformMethod\nstring\n\u00e2\u0080\u0094\nIndicates the HTTP method used to submit the form.\nformNoValidate\nboolean\n\u00e2\u0080\u0094\nIndicates that the form is not to be validated when it is submitted.\nformTarget\nstring\n\u00e2\u0080\u0094\nOverrides the target attribute of the button's form owner.\nname\nstring\n\u00e2\u0080\u0094\nSubmitted as a pair with the button's value as part of the form data.\nvalue\nstring\n\u00e2\u0080\u0094\nThe value associated with the button's name when it's submitted with the form data.\nexcludeFromTabOrder\nboolean\n\u00e2\u0080\u0094\nWhether to exclude the element from the sequential tab order. If true,\nthe element will not be focusable via the keyboard by tabbing. This should\nbe avoided except in rare scenarios where an alternative means of accessing\nthe element or its functionality via the keyboard is available.\nid\nstring\n\u00e2\u0080\u0094\nThe element's unique identifier. See\nMDN\n.\naria-label\nstring\n\u00e2\u0080\u0094\nDefines a string value that labels the current element.\naria-labelledby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that labels the current element.\naria-describedby\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that describes the object.\naria-details\nstring\n\u00e2\u0080\u0094\nIdentifies the element (or elements) that provide a detailed, extended description for the object.\nProperties\nName\nType\nDescription\ntype\n'pressstart'\n|\u00c2\n'pressend'\n|\u00c2\n'pressup'\n|\u00c2\n'press'\nThe type of press event being fired.\npointerType\nPointerType\nThe pointer type that triggered the press event.\ntarget\nElement\nThe target element of the press event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the press event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the press event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the press event.\naltKey\nboolean\nWhether the alt keyboard modifier was held during the press event.\nx\nnumber\nX position relative to the target.\ny\nnumber\nY position relative to the target.\nMethods\nMethod\nDescription\ncontinuePropagation\n(\n)\n:\nvoid\nBy default, press events stop propagation to parent elements.\nIn cases where a handler decides not to handle a specific event,\nit can call\ncontinuePropagation()\nto allow a parent to handle it.\n'mouse'\n|\u00c2\n'pen'\n|\u00c2\n'touch'\n|\u00c2\n'keyboard'\n|\u00c2\n'virtual'\nAny focusable element, including both HTML and SVG elements.\nExtends\n:\nElement\n,\nHTMLOrSVGElement\nBaseEvent\n<\nReactKeyboardEvent\n<\nany\n>\n>\nSyntheticEvent\n&\u00c2\n{\nstopPropagation\n:\n(\n)\n=>\nvoid\n,\ncontinuePropagation\n:\n(\n)\n=>\nvoid\n}\nName\nType\nDescription\nbuttonProps\nT\nProps for the button element.\nisPressed\nboolean\nWhether the button is currently pressed.",
  "content_markdown": "### Migration in progress\n\nThis page is still being migrated to our new website. In the meantime, you can explore the new React Aria Components docs [here](../Button).\n\n# useButton\n\nProvides the behavior and accessibility implementation for a button component. Handles mouse, keyboard, and touch interactions,\nfocus behavior, and ARIA props for both native button elements and custom element types.\n\n|  |  |\n| --- | --- |\n| install | `yarn add react-aria` |\n| version | 3.45.0 |\n| usage | `import {useButton} from 'react-aria'` |\n\n[View ARIA pattern\n\nW3C](https://www.w3.org/WAI/ARIA/apg/patterns/button/ \"View ARIA pattern\")[View repository\n\nGitHub](https://github.com/adobe/react-spectrum/tree/main/packages/@react-aria/button \"View repository\")[View package\n\nNPM](https://www.npmjs.com/package/@react-aria/button \"View package\")\n\n## API[#](#api)\n\n---\n\n`useButton(\n(props: AriaButtonOptions<ElementType>,\n, ref: RefObject<any>\n)): ButtonAria<HTMLAttributes<any>>`\n\n## Features[#](#features)\n\n---\n\nOn the surface, building a custom styled button seems simple. However, there are many\ncross browser inconsistencies in interactions and accessibility features to consider.\n`useButton` handles all of these interactions for you, so you can focus on the styling.\n\n- Native HTML `<button>` support\n- `<a>` and custom element type support via ARIA\n- Mouse and touch event handling, and press state management\n- Keyboard focus management and cross browser normalization\n- Keyboard event support for `Space` and `Enter` keys\n\nRead our [blog post](../blog/building-a-button-part-1) about the complexities of building buttons that work well across devices and interaction methods.\n\n## Anatomy[#](#anatomy)\n\n---\n\nButtons consist of a clickable area usually containing a textual label or an icon\nthat users can click to perform an action. In addition, keyboard users may activate\nbuttons using the `Space` or `Enter` keys.\n\nIf a visual label is not provided (e.g. an icon only button), then an `aria-label` or\n`aria-labelledby` prop must be passed to identify the button to assistive technology.\n\n## Example[#](#example)\n\n---\n\nBy default, `useButton` assumes that you are using it with a native `<button>` element.\n\n```\nimport {useButton} from 'react-aria';\nimport {useRef} from 'react';\n\nfunction Button(props) {\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { buttonProps } = useButton(props, ref);\n  let { children } = props;\n\n  return (\n    <button {...buttonProps} ref={ref}>\n      {children}\n    </button>\n  );\n}\n\n<Button onPress={() => alert('Button pressed!')}>Test</Button>\n```\n\n```\nimport {useButton} from 'react-aria';\nimport {useRef} from 'react';\n\nfunction Button(props) {\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { buttonProps } = useButton(props, ref);\n  let { children } = props;\n\n  return (\n    <button {...buttonProps} ref={ref}>\n      {children}\n    </button>\n  );\n}\n\n<Button onPress={() => alert('Button pressed!')}>\n  Test\n</Button>\n```\n\n```\nimport {useButton} from 'react-aria';\nimport {useRef} from 'react';\n\nfunction Button(props) {\n  let ref = useRef<\n    | HTMLButtonElement\n    | null\n  >(null);\n  let { buttonProps } =\n    useButton(\n      props,\n      ref\n    );\n  let { children } =\n    props;\n\n  return (\n    <button\n      {...buttonProps}\n      ref={ref}\n    >\n      {children}\n    </button>\n  );\n}\n\n<Button\n  onPress={() =>\n    alert(\n      'Button pressed!'\n    )}\n>\n  Test\n</Button>\n```\n\n## Custom element type[#](#custom-element-type)\n\n---\n\nSometimes you might need to use an element other than a native `<button>`. `useButton` supports\nthis via the `elementType` prop. When used with an element other than a native button, `useButton`\nautomatically applies the necessary ARIA roles and attributes to ensure that the element is exposed\nto assistive technology as a button.\n\nIn addition, this example shows usage of the `isPressed` value returned by `useButton` to properly\nstyle the button's active state. You could use the CSS `:active` pseudo class for this, but `isPressed`\nproperly handles when the user drags their pointer off of the button, along with keyboard support and better\ntouch screen support.\n\n```\nfunction Button(props) {\n  let { children } = props;\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { buttonProps, isPressed } = useButton({\n    ...props,\n    elementType: 'span'\n  }, ref);\n\n  return (\n    <span\n      {...buttonProps}\n      style={{\n        background: isPressed ? 'darkgreen' : 'green',\n        color: 'white',\n        padding: 10,\n        cursor: 'pointer',\n        userSelect: 'none',\n        WebkitUserSelect: 'none'\n      }}\n      ref={ref}\n    >\n      {children}\n    </span>\n  );\n}\n\n<Button onPress={() => alert('Button pressed!')}>Test</Button>\n```\n\n```\nfunction Button(props) {\n  let { children } = props;\n  let ref = useRef<HTMLButtonElement | null>(null);\n  let { buttonProps, isPressed } = useButton({\n    ...props,\n    elementType: 'span'\n  }, ref);\n\n  return (\n    <span\n      {...buttonProps}\n      style={{\n        background: isPressed ? 'darkgreen' : 'green',\n        color: 'white',\n        padding: 10,\n        cursor: 'pointer',\n        userSelect: 'none',\n        WebkitUserSelect: 'none'\n      }}\n      ref={ref}\n    >\n      {children}\n    </span>\n  );\n}\n\n<Button onPress={() => alert('Button pressed!')}>\n  Test\n</Button>\n```\n\n```\nfunction Button(props) {\n  let { children } =\n    props;\n  let ref = useRef<\n    | HTMLButtonElement\n    | null\n  >(null);\n  let {\n    buttonProps,\n    isPressed\n  } = useButton({\n    ...props,\n    elementType: 'span'\n  }, ref);\n\n  return (\n    <span\n      {...buttonProps}\n      style={{\n        background:\n          isPressed\n            ? 'darkgreen'\n            : 'green',\n        color: 'white',\n        padding: 10,\n        cursor:\n          'pointer',\n        userSelect:\n          'none',\n        WebkitUserSelect:\n          'none'\n      }}\n      ref={ref}\n    >\n      {children}\n    </span>\n  );\n}\n\n<Button\n  onPress={() =>\n    alert(\n      'Button pressed!'\n    )}\n>\n  Test\n</Button>\n```\n\n## Usage[#](#usage)\n\n---\n\nThe following examples show how to use the `Button` component created in the above example.\n\n### Events[#](#events)\n\n`useButton` supports user interactions via mouse, keyboard, and touch. You can handle all of these via the `onPress` prop. This is similar to the standard `onClick` event, but normalized to support all interaction methods equally. In addition, the `onPressStart`, `onPressEnd`, and `onPressChange` events are fired as the user interacts with the button.\n\nEach of these handlers receives a `PressEvent`, which exposes information about the target and the type of event that triggered the interaction. See [usePress](../usePress) for more details.\n\n```\nfunction Example() {\n  let [pointerType, setPointerType] = React.useState(null);\n\n  return (\n    <>\n      <Button\n        onPressStart={(e) => setPointerType(e.pointerType)}\n        onPressEnd={(e) => setPointerType(null)}\n      >\n        Press me\n      </Button>\n      <p>\n        {pointerType\n          ? `You are pressing the button with a ${pointerType}!`\n          : 'Ready to be pressed.'}\n      </p>\n    </>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [pointerType, setPointerType] = React.useState(null);\n\n  return (\n    <>\n      <Button\n        onPressStart={(e) => setPointerType(e.pointerType)}\n        onPressEnd={(e) => setPointerType(null)}\n      >\n        Press me\n      </Button>\n      <p>\n        {pointerType\n          ? `You are pressing the button with a ${pointerType}!`\n          : 'Ready to be pressed.'}\n      </p>\n    </>\n  );\n}\n```\n\n```\nfunction Example() {\n  let [\n    pointerType,\n    setPointerType\n  ] = React.useState(\n    null\n  );\n\n  return (\n    <>\n      <Button\n        onPressStart={(e) =>\n          setPointerType(\n            e.pointerType\n          )}\n        onPressEnd={(e) =>\n          setPointerType(\n            null\n          )}\n      >\n        Press me\n      </Button>\n      <p>\n        {pointerType\n          ? `You are pressing the button with a ${pointerType}!`\n          : 'Ready to be pressed.'}\n      </p>\n    </>\n  );\n}\n```\n\n### Disabled[#](#disabled)\n\nA `Button` can be disabled using the `isDisabled` prop.\n\n```\n<Button isDisabled>Pin</Button>\n```\n\n```\n<Button isDisabled>Pin</Button>\n```\n\n```\n<Button isDisabled>\n  Pin\n</Button>\n```\n\n| Name | Type | Default | Description |\n| --- | --- | --- | --- |\n| `isDisabled` | `boolean` | \u00e2\u0080\u0094 | Whether the button is disabled. |\n| `onPress` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press is released over the target. |\n| `onPressStart` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction starts. |\n| `onPressEnd` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press interaction ends, either over the target or when the pointer leaves the target. |\n| `onPressChange` | `( (isPressed: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the press state changes. |\n| `onPressUp` | `( (e: PressEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a press is released over the target, regardless of whether it started on the target or not. |\n| `onClick` | `( (e: MouseEvent<FocusableElement> )) => void` | \u00e2\u0080\u0094 | **Not recommended \u00e2\u0080\u0093 use `onPress` instead.** `onClick` is an alias for `onPress` provided for compatibility with other libraries. `onPress` provides additional event details for non-mouse interactions. |\n| `autoFocus` | `boolean` | \u00e2\u0080\u0094 | Whether the element should receive focus on render. |\n| `onFocus` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element receives focus. |\n| `onBlur` | `( (e: FocusEvent<Target> )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element loses focus. |\n| `onFocusChange` | `( (isFocused: boolean )) => void` | \u00e2\u0080\u0094 | Handler that is called when the element's focus status changes. |\n| `onKeyDown` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is pressed. |\n| `onKeyUp` | `( (e: KeyboardEvent )) => void` | \u00e2\u0080\u0094 | Handler that is called when a key is released. |\n| `href` | `string` | \u00e2\u0080\u0094 | A URL to link to if elementType=\"a\". |\n| `target` | `string` | \u00e2\u0080\u0094 | The target window for the link. |\n| `rel` | `string` | \u00e2\u0080\u0094 | The relationship between the linked resource and the current page. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel). |\n| `elementType` | `ElementType |\u00c2\u00a0JSXElementConstructor<any>` | `'button'` | The HTML element or React element used to render the button, e.g. 'div', 'a', or `RouterLink`. |\n| `aria-disabled` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element is disabled to users of assistive technology. |\n| `aria-expanded` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed. |\n| `aria-haspopup` | `boolean |\u00c2\u00a0'menu' |\u00c2\u00a0'listbox' |\u00c2\u00a0'tree' |\u00c2\u00a0'grid' |\u00c2\u00a0'dialog' |\u00c2\u00a0'true' |\u00c2\u00a0'false'` | \u00e2\u0080\u0094 | Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. |\n| `aria-controls` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) whose contents or presence are controlled by the current element. |\n| `aria-pressed` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'mixed'` | \u00e2\u0080\u0094 | Indicates the current \"pressed\" state of toggle buttons. |\n| `aria-current` | `boolean |\u00c2\u00a0'true' |\u00c2\u00a0'false' |\u00c2\u00a0'page' |\u00c2\u00a0'step' |\u00c2\u00a0'location' |\u00c2\u00a0'date' |\u00c2\u00a0'time'` | \u00e2\u0080\u0094 | Indicates whether this element represents the current item within a container or set of related elements. |\n| `type` | `'button' |\u00c2\u00a0'submit' |\u00c2\u00a0'reset'` | `'button'` | The behavior of the button when used in an HTML form. |\n| `preventFocusOnPress` | `boolean` | \u00e2\u0080\u0094 | Whether to prevent focus from moving to the button when pressing it.  Caution, this can make the button inaccessible and should only be used when alternative keyboard interaction is provided, such as ComboBox's MenuTrigger or a NumberField's increment/decrement control. |\n| `form` | `string` | \u00e2\u0080\u0094 | The `<form>` element to associate the button with. The value of this attribute must be the id of a `<form>` in the same document. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/button#form). |\n| `formAction` | `string` | \u00e2\u0080\u0094 | The URL that processes the information submitted by the button. Overrides the action attribute of the button's form owner. |\n| `formEncType` | `string` | \u00e2\u0080\u0094 | Indicates how to encode the form data that is submitted. |\n| `formMethod` | `string` | \u00e2\u0080\u0094 | Indicates the HTTP method used to submit the form. |\n| `formNoValidate` | `boolean` | \u00e2\u0080\u0094 | Indicates that the form is not to be validated when it is submitted. |\n| `formTarget` | `string` | \u00e2\u0080\u0094 | Overrides the target attribute of the button's form owner. |\n| `name` | `string` | \u00e2\u0080\u0094 | Submitted as a pair with the button's value as part of the form data. |\n| `value` | `string` | \u00e2\u0080\u0094 | The value associated with the button's name when it's submitted with the form data. |\n| `excludeFromTabOrder` | `boolean` | \u00e2\u0080\u0094 | Whether to exclude the element from the sequential tab order. If true, the element will not be focusable via the keyboard by tabbing. This should be avoided except in rare scenarios where an alternative means of accessing the element or its functionality via the keyboard is available. |\n| `id` | `string` | \u00e2\u0080\u0094 | The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id). |\n| `aria-label` | `string` | \u00e2\u0080\u0094 | Defines a string value that labels the current element. |\n| `aria-labelledby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that labels the current element. |\n| `aria-describedby` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that describes the object. |\n| `aria-details` | `string` | \u00e2\u0080\u0094 | Identifies the element (or elements) that provide a detailed, extended description for the object. |\n\n### Properties\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `type` | `'pressstart' |\u00c2\u00a0'pressend' |\u00c2\u00a0'pressup' |\u00c2\u00a0'press'` | The type of press event being fired. |\n| `pointerType` | `PointerType` | The pointer type that triggered the press event. |\n| `target` | `Element` | The target element of the press event. |\n| `shiftKey` | `boolean` | Whether the shift keyboard modifier was held during the press event. |\n| `ctrlKey` | `boolean` | Whether the ctrl keyboard modifier was held during the press event. |\n| `metaKey` | `boolean` | Whether the meta keyboard modifier was held during the press event. |\n| `altKey` | `boolean` | Whether the alt keyboard modifier was held during the press event. |\n| `x` | `number` | X position relative to the target. |\n| `y` | `number` | Y position relative to the target. |\n\n### Methods\n\n| Method | Description |\n| --- | --- |\n| `continuePropagation(): void` | By default, press events stop propagation to parent elements. In cases where a handler decides not to handle a specific event, it can call `continuePropagation()` to allow a parent to handle it. |\n\n`'mouse'\n|\u00c2\u00a0'pen'\n|\u00c2\u00a0'touch'\n|\u00c2\u00a0'keyboard'\n|\u00c2\u00a0'virtual'`\n\nAny focusable element, including both HTML and SVG elements.\n\n**Extends**: `Element, HTMLOrSVGElement`\n\n`BaseEvent<ReactKeyboardEvent<any>>`\n\n`SyntheticEvent &\u00c2\u00a0{\n\nstopPropagation: () => void,\n\ncontinuePropagation: () => void\n\n}`\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `buttonProps` | `T` | Props for the button element. |\n| `isPressed` | `boolean` | Whether the button is currently pressed. |",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:37:39.251553+00:00",
  "content_length": 13373,
  "content_hash": "11fa1984502b8eb6"
}