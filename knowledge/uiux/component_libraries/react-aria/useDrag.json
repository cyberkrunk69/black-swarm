{
  "id": "react-aria__react-aria_useDrag_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useDrag.html",
  "title": "useDrag",
  "content": "useDrag\nHandles drag interactions for an element, with support for traditional mouse and touch\nbased drag and drop, in addition to full parity for keyboard and screen reader users.\nIntroduction\nReact Aria supports traditional mouse and touch based drag and drop, but also implements keyboard and screen reader friendly interactions. Users can press\nEnter\non a draggable element to enter drag and drop mode. Then, they can press\nTab\nto navigate between drop targets, and\nEnter\nto drop or\nEscape\nto cancel. Touch screen reader users can also drag by double tapping to activate drag and drop mode, swiping between drop targets, and double tapping again to drop.\nSee the\ndrag and drop guide\nto learn more.\nExample\nThis example shows how to make a simple draggable element that provides data as plain text. In order to support keyboard and screen reader drag interactions, the element must be focusable and have an ARIA role (in this case,\nbutton\n). While it is being dragged, it is displayed with a dimmed appearance by applying an additional CSS class.\nDrag me\n'Drop here'\nExample\nDropTarget.tsx\nuseDragExample.css\nExample\nDropTarget.tsx\nuseDragExample.css\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nimport\n'./useDragExample.css'\n;\nimport\n'./theme.css'\n;\nfunction\nDraggable() {\nlet\n{dragProps, isDragging} =\nuseDrag\n({\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n    }\n  });\nreturn\n(\n    <\ndiv\n{...\ndragProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\n      Drag me\n    </\ndiv\n>\n  );\n}\n\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDrag data\nData for a draggable element can be provided in multiple formats at once. This allows drop targets to choose data in a format that they understand. For example, you could serialize a complex object as JSON in a custom format for use within your own application, and also provide plain text and/or rich HTML fallbacks that can be used when a user drops data in an external application (e.g. an email message).\nThis can be done by returning multiple keys for an item from the\ngetItems\nfunction. Types can either be a standard\nmime type\nfor interoperability with external applications, or a custom string for use within your own app.\nIn addition to providing items in multiple formats, you can also return multiple drag items from\ngetItems\nto transfer multiple objects in a single drag operation.\nThis example drags two items, each of which contains representations as plain text, HTML, and a custom app-specific data format. Dropping on the drop targets in this page will use the custom data format to render formatted items. If you drop in an external application supporting rich text, the HTML representation will be used. Dropping in a text editor will use the plain text format.\nDrag me\n'Drop here'\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nfunction\nDraggable() {\nlet\n{dragProps, isDragging} =\nuseDrag\n({\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n,\n'text/html'\n:\n'<strong>hello world</strong>'\n,\n'my-app-custom-type'\n: JSON.\nstringify\n({\nmessage\n:\n'hello world'\n,\nstyle\n:\n'bold'\n})\n      }, {\n'text/plain'\n:\n'foo bar'\n,\n'text/html'\n:\n'<em>foo bar</em>'\n,\n'my-app-custom-type'\n: JSON.\nstringify\n({\nmessage\n:\n'foo bar'\n,\nstyle\n:\n'italic'\n})\n      }];\n    }\n  });\nreturn\n(\n);\n<\ndiv\n{...\ndragProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\n      Drag me\n    </\ndiv\n>\n  );\n}\n<\ndiv\n>\n</\ndiv\n>\n<\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDrag previews\nBy default, the drag preview shown under the user's pointer or finger is a copy of the original element that started the drag. A custom preview can be rendered using the\n<DragPreview>\ncomponent. This accepts a function as a child which receives the dragged data that was returned by\ngetItems\n, and returns a rendered preview for those items. The\nDragPreview\nis linked with\nuseDrag\nvia a ref, passed to the\npreview\nproperty. The\nDragPreview\nshould be placed in the component hierarchy appropriately, so that it receives any React context or inherited styles that it needs to render correctly.\nThis example renders a custom drag preview which shows the text of the first drag item.\nDrag me\n'Drop here'\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nimport\n{DragPreview}\nfrom\n'react-aria'\n;\nfunction\nDraggable() {\nlet\npreview\n= React.\nuseRef\n(null);\nlet\n{dragProps, isDragging} =\nuseDrag\n({\n    preview,\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n    }\n  });\nreturn\n(\n    <>\n      <\ndiv\n{...\ndragProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\nDrag me\n      </\ndiv\n>\n<\nDragPreview\nref\n={\npreview\n}>\n        {\nitems\n=> <\ndiv\nstyle\n={{\nbackground\n:\n'green'\n,\ncolor\n:\n'white'\n}}>{\nitems\n[\n0\n][\n'text/plain'\n]}</\ndiv\n>}\n      </\nDragPreview\n>\n</>\n  );\n}\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDrop operations\nA\nDropOperation\nis an indication of what will happen when dragged data is dropped on a particular drop target. These are:\nmove\n\u00e2\u0080\u0093 indicates that the dragged data will be moved from its source location to the target location.\ncopy\n\u00e2\u0080\u0093 indicates that the dragged data will be copied to the target destination.\nlink\n\u00e2\u0080\u0093 indicates that there will be a relationship established between the source and target locations.\ncancel\n\u00e2\u0080\u0093 indicates that the drag and drop operation will be canceled, resulting in no changes made to the source or target.\nMany operating systems display these in the form of a cursor change, e.g. a plus sign to indicate a copy operation. The user may also be able to use a modifier key to choose which drop operation to perform, such as\nOption\nor\nAlt\nto switch from move to copy.\nThe\nonDragEnd\nevent allows the drag source to respond when a drag that it initiated ends, either because it was dropped or because it was canceled by the user. The\ndropOperation\nproperty of the event object indicates the operation that was performed. For example, when data is moved, the UI could be updated to reflect this change by removing the original dragged element.\nThis example removes the draggable element from the UI when a move operation is completed. Try holding the\nOption\nor\nAlt\nkeys to change the operation to copy, and see how the behavior changes.\nDrag me\n'Drop here'\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nfunction\nDraggable() {\nlet\n[\nmoved\n,\nsetMoved\n] = React.\nuseState\n(false);\nlet\n{dragProps, isDragging} =\nuseDrag\n({\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n},\nonDragEnd\n(\ne\n) {\nif\n(\ne\n.\ndropOperation\n===\n'move'\n) {\nsetMoved\n(true);\n      }\n    }\n});\nif\n(\nmoved\n) {\nreturn\nnull;\n  }\n// ...\nreturn\n(\n);\n<\ndiv\n{...\ndragProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\n      Drag me\n    </\ndiv\n>\n  );\n}\n<\ndiv\n>\n</\ndiv\n>\n<\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nThe drag source can also control which drop operations are allowed for the data. For example, if moving data is not allowed, and only copying is supported, the\ngetAllowedDropOperations\nfunction could be implemented to indicate this. When you drag the element below, the cursor now shows the copy affordance by default, and pressing a modifier to switch drop operations results in the drop being canceled.\nDrag me\n'Drop here'\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nfunction\nDraggable() {\nlet\n{dragProps, isDragging} =\nuseDrag\n({\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n    },\ngetAllowedDropOperations\n() {\nreturn\n[\n'copy'\n];\n    }\n});\n// ...\nreturn\n(\n);\n<\ndiv\n{...\ndragProps\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\n      Drag me\n    </\ndiv\n>\n  );\n}\n<\ndiv\n>\n</\ndiv\n>\n<\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDrag button\nIn cases where a draggable element has other interactions that conflict with accessible drag and drop (e.g.\nEnter\nkey), or if the element is not focusable, an explicit drag affordance can be added. This acts as a button that keyboard and screen reader users can use to activate drag and drop.\nWhen the\nhasDragButton\noption is enabled, the keyboard interactions are moved from the returned\ndragProps\nto the\ndragButtonProps\nso that they can be applied to a separate element, while the mouse and touch dragging interactions remain in\ndragProps\n.\n\u00e2\u0089\u00a1\nSome text\nAction\n'Drop here'\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nimport\n{\nuseButton\n}\nfrom\n'@react-aria/button'\n;\nimport\n{DropTarget}\nfrom\n'./DropTarget'\n;\nfunction\nDraggable() {\nlet\n{dragProps, dragButtonProps, isDragging} =\nuseDrag\n({\nhasDragButton\n: true,\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n    }\n  });\nlet\nref\n= React.\nuseRef\n(null);\nlet\n{buttonProps} =\nuseButton\n({...\ndragButtonProps\n,\nelementType\n:\n'div'\n},\nref\n);\nreturn\n(\n    <\ndiv\n{...\ndragProps\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}\nstyle\n={{\ndisplay\n:\n'inline-flex'\n,\nalignItems\n:\n'center'\n,\ngap\n:\n5\n}}>\n<\nspan\n{...\nbuttonProps\n}\naria-label\n=\n\"Drag\"\nref\n={\nref\n}\nstyle\n={{\nfontSize\n:\n18\n}}>\u00e2\u0089\u00a1</\nspan\n>\n<\nspan\n>Some text</\nspan\n>\n      <\nbutton\nonClick\n={() =>\nalert\n(\n'action'\n)}>Action</\nbutton\n>\n    </\ndiv\n>\n  );\n}\n\n<\ndiv\n>\n  <\nDraggable\n/>\n  <\nDropTarget\n/>\n</\ndiv\n>\nExpand code\nDisabling dragging\nIf you need to temporarily disable dragging, you can pass the\nisDisabled\noption to\nuseDrag\n. This will prevent dragging an element until it is re-enabled.\nDrag me\nimport\n{\nuseDrag\n}\nfrom\n'react-aria'\n;\nfunction\nDraggable() {\nlet\n{dragProps, isDragging} =\nuseDrag\n({\ngetItems\n() {\nreturn\n[{\n'text/plain'\n:\n'hello world'\n}];\n    },\nisDisabled\n: true\n});\nreturn\n(\n    <\ndiv\n{...\ndragProps\n}\nrole\n=\n\"button\"\ntabIndex\n={\n0\n}\nclassName\n={\n`draggable ${\nisDragging\n?\n'dragging'\n:\n''\n}`\n}>\n      Drag me\n    </\ndiv\n>\n  );\n}\n<\nDraggable\n/>\nExpand code\nAPI\nuseDrag\n(\noptions\n:\nDragOptions\n)\n:\nDragResult\nDragOptions\nName\nType\ngetItems\n(\n)\n=>\nDragItem\n[]\nA function that returns the items being dragged.\nisDisabled\nboolean\nWhether the drag operation is disabled. If true, the element will not be draggable.\nhasDragButton\nboolean\nWhether the item has an explicit focusable drag affordance to initiate accessible drag and drop mode.\nIf true, the dragProps will omit these event handlers, and they will be applied to dragButtonProps instead.\ngetAllowedDropOperations\n(\n)\n=>\nDropOperation\n[]\nFunction that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed.\npreview\nRefObject\n<\nDragPreviewRenderer\n|\u00c2\nnull\n>\nThe ref of the element that will be rendered as the drag preview while dragging.\nonDragEnd\n(\ne\n:\nDragEndEvent\n)\n=>\nvoid\nHandler that is called when the drag operation is ended, either as a result of a drop or a cancellation.\nonDragMove\n(\ne\n:\nDragMoveEvent\n)\n=>\nvoid\nHandler that is called when the drag is moved.\nonDragStart\n(\ne\n:\nDragStartEvent\n)\n=>\nvoid\nHandler that is called when a drag operation is started.\nDragResult\nName\nType\nisDragging\nboolean\nWhether the element is currently being dragged.\ndragButtonProps\nAriaButtonProps\nProps for the explicit drag button affordance, if any.\ndragProps\nHTMLAttributes\n<\nHTMLElement\n>\nProps for the draggable element.",
  "content_markdown": "# useDrag\n\nHandles drag interactions for an element, with support for traditional mouse and touch\nbased drag and drop, in addition to full parity for keyboard and screen reader users.\n\n## Introduction\n\nReact Aria supports traditional mouse and touch based drag and drop, but also implements keyboard and screen reader friendly interactions. Users can press `Enter` on a draggable element to enter drag and drop mode. Then, they can press `Tab` to navigate between drop targets, and `Enter` to drop or `Escape` to cancel. Touch screen reader users can also drag by double tapping to activate drag and drop mode, swiping between drop targets, and double tapping again to drop.\n\nSee the [drag and drop guide](dnd) to learn more.\n\n## Example\n\nThis example shows how to make a simple draggable element that provides data as plain text. In order to support keyboard and screen reader drag interactions, the element must be focusable and have an ARIA role (in this case, `button`). While it is being dragged, it is displayed with a dimmed appearance by applying an additional CSS class.\n\nDrag me\n\n'Drop here'\n\nExample\n\nDropTarget.tsx\n\nuseDragExample.css\n\nExample\n\nDropTarget.tsx\n\nuseDragExample.css\n\nExample\n\nDropTarget.tsx\n\nuseDragExample.css\n\n```\nimport {useDrag} from 'react-aria';\nimport {DropTarget} from './DropTarget';\nimport './useDragExample.css';\nimport './theme.css';\n\nfunction Draggable() {\n  let {dragProps, isDragging} = useDrag({\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    }\n  });\n\n  return (\n    <div {...dragProps} role=\"button\" tabIndex={0} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n      Drag me\n    </div>\n  );\n}\n\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Drag data\n\nData for a draggable element can be provided in multiple formats at once. This allows drop targets to choose data in a format that they understand. For example, you could serialize a complex object as JSON in a custom format for use within your own application, and also provide plain text and/or rich HTML fallbacks that can be used when a user drops data in an external application (e.g. an email message).\nThis can be done by returning multiple keys for an item from the `getItems` function. Types can either be a standard [mime type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types) for interoperability with external applications, or a custom string for use within your own app.\nIn addition to providing items in multiple formats, you can also return multiple drag items from `getItems` to transfer multiple objects in a single drag operation.\nThis example drags two items, each of which contains representations as plain text, HTML, and a custom app-specific data format. Dropping on the drop targets in this page will use the custom data format to render formatted items. If you drop in an external application supporting rich text, the HTML representation will be used. Dropping in a text editor will use the plain text format.\n\nDrag me\n\n'Drop here'\n\n```\nimport {useDrag} from 'react-aria';\nimport {DropTarget} from './DropTarget';\n\nfunction Draggable() {\n  let {dragProps, isDragging} = useDrag({\n    getItems() {\n      return [{\n        'text/plain': 'hello world',\n        'text/html': '<strong>hello world</strong>',\n        'my-app-custom-type': JSON.stringify({\n          message: 'hello world',\n          style: 'bold'\n        })\n      }, {\n        'text/plain': 'foo bar',\n        'text/html': '<em>foo bar</em>',\n        'my-app-custom-type': JSON.stringify({\n          message: 'foo bar',\n          style: 'italic'\n        })\n      }];\n    }\n  });\n\nreturn ();\n\n<div {...dragProps} role=\"button\" tabIndex={0} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n      Drag me\n    </div>\n  );\n\n}\n\n<div></div>\n\n<Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Drag previews\n\nBy default, the drag preview shown under the user's pointer or finger is a copy of the original element that started the drag. A custom preview can be rendered using the `<DragPreview>` component. This accepts a function as a child which receives the dragged data that was returned by `getItems`, and returns a rendered preview for those items. The `DragPreview` is linked with `useDrag` via a ref, passed to the `preview` property. The `DragPreview` should be placed in the component hierarchy appropriately, so that it receives any React context or inherited styles that it needs to render correctly.\nThis example renders a custom drag preview which shows the text of the first drag item.\n\nDrag me\n\n'Drop here'\n\n```\nimport React from 'react';\nimport {useDrag} from 'react-aria';\nimport {DropTarget} from './DropTarget';\nimport {DragPreview} from 'react-aria';\n\nfunction Draggable() {\n  let preview = React.useRef(null);\n  let {dragProps, isDragging} = useDrag({\n    preview,\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    }\n  });\n  return (\n    <>\n      <div {...dragProps} role=\"button\" tabIndex={0} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n        Drag me\n      </div>\n      <DragPreview ref={preview}>\n        {items => <div style={{background: 'green', color: 'white'}}>{items[0]['text/plain']}</div>}\n      </DragPreview>\n    </>\n  );\n}\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Drop operations\n\nA DropOperation is an indication of what will happen when dragged data is dropped on a particular drop target. These are:\n\n- `move` \u00e2\u0080\u0093 indicates that the dragged data will be moved from its source location to the target location.\n- `copy` \u00e2\u0080\u0093 indicates that the dragged data will be copied to the target destination.\n- `link` \u00e2\u0080\u0093 indicates that there will be a relationship established between the source and target locations.\n- `cancel` \u00e2\u0080\u0093 indicates that the drag and drop operation will be canceled, resulting in no changes made to the source or target.\n\nMany operating systems display these in the form of a cursor change, e.g. a plus sign to indicate a copy operation. The user may also be able to use a modifier key to choose which drop operation to perform, such as `Option` or `Alt` to switch from move to copy.\nThe `onDragEnd` event allows the drag source to respond when a drag that it initiated ends, either because it was dropped or because it was canceled by the user. The `dropOperation` property of the event object indicates the operation that was performed. For example, when data is moved, the UI could be updated to reflect this change by removing the original dragged element.\nThis example removes the draggable element from the UI when a move operation is completed. Try holding the `Option` or `Alt` keys to change the operation to copy, and see how the behavior changes.\n\nDrag me\n\n'Drop here'\n\n```\nimport React from 'react';\nimport {useDrag} from 'react-aria';\nimport {DropTarget} from './DropTarget';\n\nfunction Draggable() {\n  let [moved, setMoved] = React.useState(false);\n  let {dragProps, isDragging} = useDrag({\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    },\n    onDragEnd(e) {\n      if (e.dropOperation === 'move') {\n        setMoved(true);\n      }\n    }\n  });\n  if (moved) {\n    return null;\n  }\n  // ...\n\nreturn ();\n\n<div {...dragProps} role=\"button\" tabIndex={0} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n      Drag me\n    </div>\n  );\n\n}\n\n<div></div>\n\n<Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\nThe drag source can also control which drop operations are allowed for the data. For example, if moving data is not allowed, and only copying is supported, the `getAllowedDropOperations` function could be implemented to indicate this. When you drag the element below, the cursor now shows the copy affordance by default, and pressing a modifier to switch drop operations results in the drop being canceled.\n\nDrag me\n\n'Drop here'\n\n```\nimport {useDrag} from 'react-aria';\nimport {DropTarget} from './DropTarget';\n\nfunction Draggable() {\n  let {dragProps, isDragging} = useDrag({\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    },\n    getAllowedDropOperations() {\n      return ['copy'];\n    }\n  });\n  // ...\n\nreturn ();\n\n<div {...dragProps} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n      Drag me\n    </div>\n  );\n\n}\n\n<div></div>\n\n<Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Drag button\n\nIn cases where a draggable element has other interactions that conflict with accessible drag and drop (e.g. `Enter` key), or if the element is not focusable, an explicit drag affordance can be added. This acts as a button that keyboard and screen reader users can use to activate drag and drop.\nWhen the `hasDragButton` option is enabled, the keyboard interactions are moved from the returned `dragProps` to the `dragButtonProps` so that they can be applied to a separate element, while the mouse and touch dragging interactions remain in `dragProps`.\n\n\u00e2\u0089\u00a1Some textAction\n\n'Drop here'\n\n```\nimport React from 'react';\nimport {useDrag} from 'react-aria';\nimport {useButton} from '@react-aria/button';\nimport {DropTarget} from './DropTarget';\n\nfunction Draggable() {\n  let {dragProps, dragButtonProps, isDragging} = useDrag({\n    hasDragButton: true,\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    }\n  });\n  let ref = React.useRef(null);\n  let {buttonProps} = useButton({...dragButtonProps, elementType: 'div'}, ref);\n  return (\n    <div {...dragProps} className={`draggable ${isDragging ? 'dragging' : ''}`} style={{display: 'inline-flex', alignItems: 'center', gap: 5}}>\n      <span {...buttonProps} aria-label=\"Drag\" ref={ref} style={{fontSize: 18}}>\u00e2\u0089\u00a1</span>\n      <span>Some text</span>\n      <button onClick={() => alert('action')}>Action</button>\n    </div>\n  );\n}\n\n<div>\n  <Draggable />\n  <DropTarget />\n</div>\n```\n\nExpand code\n\n## Disabling dragging\n\nIf you need to temporarily disable dragging, you can pass the `isDisabled` option to `useDrag`. This will prevent dragging an element until it is re-enabled.\n\nDrag me\n\n```\nimport {useDrag} from 'react-aria';\nfunction Draggable() {\n  let {dragProps, isDragging} = useDrag({\n    getItems() {\n      return [{\n        'text/plain': 'hello world'\n      }];\n    },\n    isDisabled: true\n  });\n  return (\n    <div {...dragProps} role=\"button\" tabIndex={0} className={`draggable ${isDragging ? 'dragging' : ''}`}>\n      Drag me\n    </div>\n  );\n}\n<Draggable />\n```\n\nExpand code\n\n## API\n\n`useDrag(options: DragOptions): DragResult`\n\n### DragOptions\n\n| Name | Type |\n| --- | --- |\n| `getItems` | `() => DragItem[]` |\n| A function that returns the items being dragged. | | |\n| `isDisabled` | `boolean` |\n| Whether the drag operation is disabled. If true, the element will not be draggable. | | |\n| `hasDragButton` | `boolean` |\n| Whether the item has an explicit focusable drag affordance to initiate accessible drag and drop mode. If true, the dragProps will omit these event handlers, and they will be applied to dragButtonProps instead. | | |\n| `getAllowedDropOperations` | `() => DropOperation[]` |\n| Function that returns the drop operations that are allowed for the dragged items. If not provided, all drop operations are allowed. | | |\n| `preview` | `RefObject<DragPreviewRenderer |\u00c2\u00a0null>` |\n| The ref of the element that will be rendered as the drag preview while dragging. | | |\n| `onDragEnd` | `(e: DragEndEvent) => void` |\n| Handler that is called when the drag operation is ended, either as a result of a drop or a cancellation. | | |\n| `onDragMove` | `(e: DragMoveEvent) => void` |\n| Handler that is called when the drag is moved. | | |\n| `onDragStart` | `(e: DragStartEvent) => void` |\n| Handler that is called when a drag operation is started. | | |\n\n### DragResult\n\n| Name | Type |\n| --- | --- |\n| `isDragging` | `boolean` |\n| Whether the element is currently being dragged. | | |\n| `dragButtonProps` | `AriaButtonProps` |\n| Props for the explicit drag button affordance, if any. | | |\n| `dragProps` | `HTMLAttributes<HTMLElement>` |\n| Props for the draggable element. | | |",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:39:14.837577+00:00",
  "content_length": 11438,
  "content_hash": "27ff6321f8407e4e"
}