{
  "id": "react-aria__react-aria_useMove_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/useMove.html",
  "title": "useMove",
  "content": "useMove\nHandles move interactions across mouse, touch, and keyboard, including dragging with\nthe mouse or touch, and using the arrow keys. Normalizes behavior across browsers and\nplatforms, and ignores emulated mouse events on touch devices.\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseMove\n}\nfrom\n'react-aria'\n;\nfunction\nExample() {\nconst\nCONTAINER_SIZE =\n200\n;\nconst\nBALL_SIZE =\n30\n;\nlet\n[\nevents\n,\nsetEvents\n] = React.\nuseState\n<string[]>([]);\nlet\n[\ncolor\n,\nsetColor\n] = React.\nuseState\n(\n'black'\n);\nlet\n[\nposition\n,\nsetPosition\n] = React.\nuseState\n({\nx\n:\n0\n,\ny\n:\n0\n});\nlet\nclamp\n=\npos\n=> Math.\nmin\n(Math.\nmax\n(\npos\n,\n0\n), CONTAINER_SIZE - BALL_SIZE);\nlet\n{moveProps} =\nuseMove\n({\nonMoveStart\n(\ne\n) {\nsetColor\n(\n'red'\n);\nsetEvents\n(\nevents\n=> [\n`move start with pointerType = ${\ne\n.\npointerType\n}`\n, ...\nevents\n]);\n    },\nonMove\n(\ne\n) {\nsetPosition\n(({x, y}) => {\n// Normally, we want to allow the user to continue\n// dragging outside the box such that they need to\n// drag back over the ball again before it moves.\n// This is handled below by clamping during render.\n// If using the keyboard, however, we need to clamp\n// here so that dragging outside the container and\n// then using the arrow keys works as expected.\nif\n(\ne\n.\npointerType\n===\n'keyboard'\n) {\nx\n=\nclamp\n(\nx\n);\ny\n=\nclamp\n(\ny\n);\n        }\nx\n+=\ne\n.\ndeltaX\n;\ny\n+=\ne\n.\ndeltaY\n;\nreturn\n{x, y};\n      });\nsetEvents\n(\nevents\n=> [\n`move with pointerType = ${\ne\n.\npointerType\n}, deltaX = ${\ne\n.\ndeltaX\n}, deltaY = ${\ne\n.\ndeltaY\n}`\n, ...\nevents\n]);\n    },\nonMoveEnd\n(\ne\n) {\nsetPosition\n(({x, y}) => {\n// Clamp position on mouse up\nx\n=\nclamp\n(\nx\n);\ny\n=\nclamp\n(\ny\n);\nreturn\n{x, y};\n      });\nsetColor\n(\n'black'\n);\nsetEvents\n(\nevents\n=> [\n`move end with pointerType = ${\ne\n.\npointerType\n}`\n, ...\nevents\n]);\n    }\n  });\nreturn\n(\n    <>\n      <\ndiv\nstyle\n={{\nwidth\n: CONTAINER_SIZE,\nheight\n: CONTAINER_SIZE,\nbackground\n:\n'white'\n,\nborder\n:\n'1px solid black'\n,\nposition\n:\n'relative'\n,\ntouchAction\n:\n'none'\n}}>\n        <\ndiv\n{...\nmoveProps\n}\ntabIndex\n={\n0\n}\nstyle\n={{\nwidth\n: BALL_SIZE,\nheight\n: BALL_SIZE,\nborderRadius\n:\n'100%'\n,\nposition\n:\n'absolute'\n,\nleft\n:\nclamp\n(\nposition\n.\nx\n),\ntop\n:\nclamp\n(\nposition\n.\ny\n),\nbackground\n:\ncolor\n}} />\n      </\ndiv\n>\n      <\nul\nstyle\n={{\nmaxHeight\n:\n'200px'\n,\noverflow\n:\n'auto'\n}}>\n        {\nevents\n.\nmap\n((\ne\n,\ni\n) => <\nli\nkey\n={\ni\n}>{\ne\n}</\nli\n>)}\n      </\nul\n>\n    </>\n  );\n}\nExpand code\nFeatures\nMove events are emitted after the user presses down and then drags the pointer around. They specify the distance that the pointer traveled since the last event. In addition, after a user focuses the target element, move events are fired when the user presses the arrow keys.\nHandles mouse and touch events\nHandles arrow key presses\nDisables text selection while the user drags\nAPI\nuseMove\n(\nprops\n:\nMoveEvents\n)\n:\nMoveResult\nMoveEvents\nName\nType\nonMoveEnd\n(\ne\n:\nMoveEndEvent\n)\n=>\nvoid\nHandler that is called when a move interaction ends.\nonMove\n(\ne\n:\nMoveMoveEvent\n)\n=>\nvoid\nHandler that is called when the element is moved.\nonMoveStart\n(\ne\n:\nMoveStartEvent\n)\n=>\nvoid\nHandler that is called when a move interaction starts.\nMoveResult\nName\nType\nmoveProps\nDOMAttributes\nProps to spread on the target element.\nMoveEvent\nName\nType\naltKey\nboolean\nWhether the alt keyboard modifier was held during the move event.\nmetaKey\nboolean\nWhether the meta keyboard modifier was held during the move event.\nctrlKey\nboolean\nWhether the ctrl keyboard modifier was held during the move event.\nshiftKey\nboolean\nWhether the shift keyboard modifier was held during the move event.\npointerType\nPointerType\nThe pointer type that triggered the move event.\ndeltaY\nnumber\nThe amount moved in the Y direction since the last event.\ndeltaX\nnumber\nThe amount moved in the X direction since the last event.\ntype\n'move'\nThe type of move event being fired.",
  "content_markdown": "# useMove\n\nHandles move interactions across mouse, touch, and keyboard, including dragging with\nthe mouse or touch, and using the arrow keys. Normalizes behavior across browsers and\nplatforms, and ignores emulated mouse events on touch devices.\n\n```\nimport React from 'react';\nimport {useMove} from 'react-aria';\n\nfunction Example() {\n  const CONTAINER_SIZE = 200;\n  const BALL_SIZE = 30;\n\n  let [events, setEvents] = React.useState<string[]>([]);\n  let [color, setColor] = React.useState('black');\n  let [position, setPosition] = React.useState({\n    x: 0,\n    y: 0\n  });\n\n  let clamp = pos => Math.min(Math.max(pos, 0), CONTAINER_SIZE - BALL_SIZE);\n  let {moveProps} = useMove({\n    onMoveStart(e) {\n      setColor('red');\n      setEvents(events => [`move start with pointerType = ${e.pointerType}`, ...events]);\n    },\n    onMove(e) {\n      setPosition(({x, y}) => {\n        // Normally, we want to allow the user to continue\n        // dragging outside the box such that they need to\n        // drag back over the ball again before it moves.\n        // This is handled below by clamping during render.\n        // If using the keyboard, however, we need to clamp\n        // here so that dragging outside the container and\n        // then using the arrow keys works as expected.\n        if (e.pointerType === 'keyboard') {\n          x = clamp(x);\n          y = clamp(y);\n        }\n\n        x += e.deltaX;\n        y += e.deltaY;\n        return {x, y};\n      });\n\n      setEvents(events => [`move with pointerType = ${e.pointerType}, deltaX = ${e.deltaX}, deltaY = ${e.deltaY}`, ...events]);\n    },\n    onMoveEnd(e) {\n      setPosition(({x, y}) => {\n        // Clamp position on mouse up\n        x = clamp(x);\n        y = clamp(y);\n        return {x, y};\n      });\n      setColor('black');\n      setEvents(events => [`move end with pointerType = ${e.pointerType}`, ...events]);\n    }\n  });\n\n  return (\n    <>\n      <div\n        style={{\n          width: CONTAINER_SIZE,\n          height: CONTAINER_SIZE,\n          background: 'white',\n          border: '1px solid black',\n          position: 'relative',\n          touchAction: 'none'\n        }}>\n        <div\n          {...moveProps}\n          tabIndex={0}\n          style={{\n            width: BALL_SIZE,\n            height: BALL_SIZE,\n            borderRadius: '100%',\n            position: 'absolute',\n            left: clamp(position.x),\n            top: clamp(position.y),\n            background: color\n          }} />\n      </div>\n      <ul\n        style={{\n          maxHeight: '200px',\n          overflow: 'auto'\n        }}>\n        {events.map((e, i) => <li key={i}>{e}</li>)}\n      </ul>\n    </>\n  );\n}\n```\n\nExpand code\n\n## Features\n\nMove events are emitted after the user presses down and then drags the pointer around. They specify the distance that the pointer traveled since the last event. In addition, after a user focuses the target element, move events are fired when the user presses the arrow keys.\n\n- Handles mouse and touch events\n- Handles arrow key presses\n- Disables text selection while the user drags\n\n## API\n\n`useMove(props: MoveEvents): MoveResult`\n\n### MoveEvents\n\n| Name | Type |\n| --- | --- |\n| `onMoveEnd` | `(e: MoveEndEvent) => void` |\n| Handler that is called when a move interaction ends. | | |\n| `onMove` | `(e: MoveMoveEvent) => void` |\n| Handler that is called when the element is moved. | | |\n| `onMoveStart` | `(e: MoveStartEvent) => void` |\n| Handler that is called when a move interaction starts. | | |\n\n### MoveResult\n\n| Name | Type |\n| --- | --- |\n| `moveProps` | `DOMAttributes` |\n| Props to spread on the target element. | | |\n\n### MoveEvent\n\n| Name | Type |\n| --- | --- |\n| `altKey` | `boolean` |\n| Whether the alt keyboard modifier was held during the move event. | | |\n| `metaKey` | `boolean` |\n| Whether the meta keyboard modifier was held during the move event. | | |\n| `ctrlKey` | `boolean` |\n| Whether the ctrl keyboard modifier was held during the move event. | | |\n| `shiftKey` | `boolean` |\n| Whether the shift keyboard modifier was held during the move event. | | |\n| `pointerType` | `PointerType` |\n| The pointer type that triggered the move event. | | |\n| `deltaY` | `number` |\n| The amount moved in the Y direction since the last event. | | |\n| `deltaX` | `number` |\n| The amount moved in the X direction since the last event. | | |\n| `type` | `'move'` |\n| The type of move event being fired. | | |",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:39:10.354008+00:00",
  "content_length": 3808,
  "content_hash": "b23158214c369f76"
}