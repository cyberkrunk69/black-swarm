{
  "id": "react-aria__react-aria_advanced_html",
  "source_id": "react-aria",
  "source_name": "React Aria",
  "category": "component_libraries",
  "url": "https://react-spectrum.adobe.com/react-aria/advanced.html",
  "title": "Customization",
  "content": "Customization\nReact Aria is built using a flexible and composable API. Learn how to use contexts and slots to create custom component patterns, or mix and match with the lower level Hook-based API for even more control over rendering and behavior.\nContexts\nThe React Aria Components API is designed around composition. Components are reused between patterns to build larger composite components. For example, there is no dedicated\nNumberFieldIncrementButton\nor\nSelectPopover\ncomponent. Instead, the standalone\nButton\nand\nPopover\ncomponents are reused within\nNumberField\nand\nSelect\n. This reduces the amount of duplicate styling code you need to write and maintain, and provides powerful composition capabilities you can use in your own components.\n<\nNumberField\n>\n  <\nLabel\n>Width</\nLabel\n>\n  <\nGroup\n>\n    <\nInput\n/>\n    <\nButton\nslot\n=\n\"increment\"\n>+</\nButton\n>\n    <\nButton\nslot\n=\n\"decrement\"\n>-</\nButton\n>\n  </\nGroup\n>\n</\nNumberField\n>\nReact Aria Components automatically provide behavior to their children by passing event handlers and other attributes via context. For example, the increment and decrement buttons in a\nNumberField\nreceive\nonPress\nhandlers that update the value. Keeping each element of a component separate enables full styling, layout, and DOM structure control, and contexts ensure that accessibility and behavior are taken care of on your behalf.\nThis architecture also enables you to reuse React Aria Components in your own custom patterns, or even replace one part of a component with your own custom implementation without rebuilding the whole pattern from scratch.\nCustom patterns\nEach React Aria Component exports a corresponding context that you can use to build your own compositional APIs similar to the built-in components. These accept the component's props as a value. The local component props are merged with the ones passed via context, with the local props taking precedence (see\nmergeProps\n).\nThis example shows a\nFieldGroup\ncomponent that renders a group of text fields. The entire group can be marked as disabled via the\nisDisabled\nprop, which is passed to all child text fields via the\nTextFieldContext\nprovider.\nimport\n{TextFieldContext}\nfrom\n'react-aria-components'\n;\ninterface\nFieldGroupProps {\nchildren\n?: React.ReactNode,\nisDisabled\n?: boolean\n}\nfunction\nFieldGroup({children, isDisabled}: FieldGroupProps) {\nreturn\n(\n<TextFieldContext.Provider\nvalue\n={{isDisabled}}>\n{\nchildren\n}\n    </TextFieldContext.Provider>\n  );\n}\nAny\nTextField\ncomponent you place inside a\nFieldGroup\nwill automatically receive the\nisDisabled\nprop from the group, including those that are deeply nested inside other components.\n<\nFieldGroup\nisDisabled\n={\nisSubmitting\n}>\n  <\nMyTextField\nlabel\n=\n\"Name\"\n/>\n  <\nMyTextField\nlabel\n=\n\"Email\"\n/>\n  <\nCreditCardFields\n/>\n</\nFieldGroup\n>\nSlots\nSome patterns include multiple instances of the same component, which are distinguished by the\nslot\nprop. Slots are named children within a component that have separate behaviors and\nstyles\n. Separate props can be sent to slots by providing an object with keys for each slot name to the component's context provider.\nThis example shows a\nStepper\ncomponent with slots for its increment and decrement buttons.\nfunction\nStepper({children}) {\nlet\n[\nvalue\n,\nsetValue\n] = React.\nuseState\n(\n0\n);\nreturn\n(\n    <ButtonContext.Provider\nvalue\n={{\nslots\n: {\nincrement\n: {\nonPress\n: () =>\nsetValue\n(\nvalue\n+\n1\n)\n          },\ndecrement\n: {\nonPress\n: () =>\nsetValue\n(\nvalue\n-\n1\n)\n          }\n        }\n      }}>\n      {\nchildren\n}\n    </ButtonContext.Provider>\n  );\n}\n\n<\nStepper\n>\n  <\nButton\nslot\n=\n\"increment\"\n>\u00e2\u00ac\u0086</\nButton\n>\n  <\nButton\nslot\n=\n\"decrement\"\n>\u00e2\u00ac\u0087</\nButton\n>\n</\nStepper\n>\nDefault slot\nThe default slot is used to provide props to a component without specifying a slot name. This is used by children without a\nslot\nprop. This example passes a specific class name to a standard button child and to a button child with a slot named \"end\".\nimport\n{Button, ButtonContext, DEFAULT_SLOT}\nfrom\n'react-aria-components'\n;\nfunction\nMyCustomComponent({children}) {\nreturn\n(\n    <ButtonContext.Provider\nvalue\n={{\nslots\n: {\n          [DEFAULT_SLOT]: {\nclassName\n:\n\"default-button\"\n},\nend\n: {\nclassName\n:\n\"end-button\"\n}\n        }\n      }}>\n      {\nchildren\n}\n    </ButtonContext.Provider>\n  );\n}\n\n<\nMyCustomComponent\n>\n  {\n/* Consumes the props passed to the default slot */\n}\n  <\nButton\n>Click me</\nButton\n>\n  {\n/* Consumes the props passed to the \"end\" slot */\n}\n  <\nButton\nslot\n=\n\"end\"\n>Click me</\nButton\n>\n</\nMyCustomComponent\n>\nProvider\nThe\nProvider\ncomponent is a utility that makes it easier to provide multiple React contexts without manually nesting them. This can be achieved by passing pairs of contexts and values as an array to the\nvalues\nprop.\nimport\n{Provider, ButtonContext, InputContext}\nfrom\n'react-aria-components'\n;\n<\nProvider\nvalues\n={[\n    [ButtonContext, {\n/* ... */\n}],\n    [InputContext, {\n/* ... */\n}]\n  ]}>\n  {\n/* ... */\n}\n</\nProvider\n>\nThis is equivalent to:\n<ButtonContext.Provider\nvalue\n={{\n/* ... */\n}}>\n  <InputContext.Provider\nvalue\n={{\n/* ... */\n}}>\n    {\n/* ... */\n}\n  </InputContext.Provider>\n</ButtonContext.Provider>\nConsuming contexts\nYou can also consume from contexts provided by React Aria Components in your own custom components. This allows you to replace a component used as part of a larger pattern with a custom implementation. For example, you could consume from\nLabelContext\nin a custom label component to make it compatible with React Aria Components.\nuseContextProps\nThe\nuseContextProps\nhook merges the local props with the ones provided via context by a parent component. The local props always take precedence over the context values (see\nmergeProps\n).\nuseContextProps\nsupports the\nslot\nprop to indicate which value to consume from context.\nimport\ntype\n{LabelProps}\nfrom\n'react-aria-components'\n;\nimport\n{LabelContext,\nuseContextProps\n}\nfrom\n'react-aria-components'\n;\nconst\nMyCustomLabel = React.\nforwardRef\n(\n  (\nprops\n: LabelProps,\nref\n: React.ForwardedRef<HTMLLabelElement>) => {\n// Merge the local props and ref with the ones provided via context.\nlet\n[\nmergedProps\n,\nmergedRef\n] =\nuseContextProps\n(\nprops\n,\nref\n, LabelContext);\n// ... your existing Label component\nreturn\n<\nlabel\n{...\nmergedProps\n}\nref\n={\nmergedRef\n} />;\n  }\n);\nSince it consumes from\nLabelContext\n,\nMyCustomLabel\ncan be used within any React Aria component instead of the built-in\nLabel\n.\n<\nTextField\n>\n<\nMyCustomLabel\n>Name</\nMyCustomLabel\n>\n<\nInput\n/>\n</\nTextField\n>\nuseSlottedContext\nTo consume a context without merging with existing props, use the\nuseSlottedContext\nhook. This works like React's\nuseContext\n, and also accepts an optional slot argument to identify which slot name to consume.\nimport\n{\nuseSlottedContext\n}\nfrom\n'react-aria-components'\n;\n// Consume the un-slotted value.\nlet\nbuttonContext\n=\nuseSlottedContext\n(ButtonContext);\n// Consume the value for a specific slot name.\nlet\nincrementButtonContext\n=\nuseSlottedContext\n(ButtonContext,\n'increment'\n);\nAccessing state\nMost React Aria components compose other components in their children to build larger patterns. However, some components are made up of more tightly coupled children. For example,\nCalendar\nincludes children such as\nCalendarGrid\nand\nCalendarCell\nthat cannot be used standalone. These components access the state from their parent via context.\nYou can access the state from a parent component via the same contexts in order to build your own custom children. This example shows a\nCalendarValue\ncomponent that displays the currently selected date from a calendar as a formatted string.\nimport\n{CalendarStateContext}\nfrom\n'react-aria-components'\n;\nimport\n{\nuseDateFormatter\n}\nfrom\n'react-aria'\n;\nimport\n{\ngetLocalTimeZone\n}\nfrom\n'@internationalized/date'\n;\nfunction\nCalendarValue() {\nlet\nstate\n= React.\nuseContext\n(CalendarStateContext)!;\nlet\ndate\n=\nstate\n.\nvalue\n?.\ntoDate\n(\ngetLocalTimeZone\n());\nlet\n{format} =\nuseDateFormatter\n();\nlet\nformatted\n=\ndate\n?\nformat\n(\ndate\n) :\n'None'\n;\nreturn\n`Selected date: ${\nformatted\n}`\n;\n}\nThis enables a\n<CalendarValue>\nto be placed inside a\n<Calendar>\nto display the current value.\n<\nCalendar\n>\n  {\n/* ... */\n}\n<\nCalendarValue\n/>\n</\nCalendar\n>\nHooks\nIf you need to customize things even further, such as overriding behavior, intercepting events, or customizing DOM structure, you can drop down to the lower level Hook-based API. Hooks only provide behavior and leave all rendering to you. This gives you more control and flexibility, but requires additional glue code to set up.\nReact Aria Components and Hooks can be used together, allowing you to mix and match depending on the level of customization you require. We recommend starting with the component API by default, and only dropping down to hooks when you need to customize something that the component API does not allow.\nSome potential use cases for Hooks are:\nOverriding which DOM element a component renders\nIntercepting a DOM event to apply conditional logic\nOverriding internal state management behavior\nCustomizing overlay positioning\nRemoving unused features to reduce bundle size\nSetup\nAs described\nabove\n, each React Aria component exports a corresponding context. You can build a custom implementation of a component using Hooks by consuming from the relevant context with\nuseContextProps\n.\nThis example shows how a custom checkbox could be set up using\nCheckboxContext\nfrom\nreact-aria-components\nand the\nuseCheckbox\nhook from\nreact-aria\n.\nimport\ntype\n{CheckboxProps}\nfrom\n'react-aria-components'\n;\nimport\n{CheckboxContext,\nuseContextProps\n}\nfrom\n'react-aria-components'\n;\nimport\n{\nuseToggleState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseCheckbox\n}\nfrom\n'react-aria'\n;\nconst\nMyCheckbox = React.\nforwardRef\n((\nprops\n: CheckboxProps,\nref\n: React.ForwardedRef<HTMLInputElement>) => {\n// Merge the local props and ref with the ones provided via context.\nlet\n[\nmergedProps\n,\nmergedRef\n] =\nuseContextProps\n(\nprops\n,\nref\n, CheckboxContext);\n// Follow the hook docs and implement your customizations...\nlet\nstate\n=\nuseToggleState\n(\nmergedProps\n);\nlet\n{inputProps} =\nuseCheckbox\n(\nmergedProps\n,\nstate\n,\nmergedRef\n);\nreturn\n<\ninput\n{...\ninputProps\n}\nref\n={\nmergedRef\n} />;\n});\nSince\nMyCheckbox\nconsumes from\nCheckboxContext\nit can be used within other React Aria Components in place of the built-in\nCheckbox\n, such as within a\nTable\nor\nGridList\n. This lets you provide a custom checkbox implementation without rewriting all other React Aria Components you might use it in.\n<\nGridList\n>\n  <\nGridListItem\n>\n<\nMyCheckbox\nslot\n=\n\"selection\"\n/>\n{\n/* ... */\n}\n  </\nGridListItem\n>\n</\nGridList\n>\nReusing children\nYou can also provide values for React Aria Components from a Hook-based implementation. This allows you to customize the parent component of a larger pattern, while reusing the existing implementations of the child elements from React Aria Components.\nThis example shows how a custom number field could be set up. First, follow the docs for\nuseNumberField\n, and then use\nProvider\nto send values returned by the hook to each of the child elements via their corresponding contexts.\nimport\ntype\n{NumberFieldProps}\nfrom\n'react-aria-components'\n;\nimport\n{Provider, GroupContext, InputContext, LabelContext, ButtonContext}\nfrom\n'react-aria-components'\n;\nimport\n{\nuseNumberFieldState\n}\nfrom\n'react-stately'\n;\nimport\n{\nuseNumberField\n,\nuseLocale\n}\nfrom\n'react-aria'\n;\nfunction\nCustomNumberField(\nprops\n: NumberFieldProps) {\n// Follow the hook docs...\nlet\n{locale} =\nuseLocale\n();\nlet\nstate\n=\nuseNumberFieldState\n({...\nprops\n, locale});\nlet\nref\n=\nuseRef\n<HTMLInputElement>(null);\nlet\n{\n    labelProps,\n    groupProps,\n    inputProps,\n    incrementButtonProps,\n    decrementButtonProps\n  } =\nuseNumberField\n(\nprops\n,\nstate\n,\nref\n);\n// Provide values for the child components via context.\nreturn\n(\n<\nProvider\nvalues\n={[\n        [GroupContext,\ngroupProps\n],\n        [InputContext, {...\ninputProps\n, ref}],\n        [LabelContext,\nlabelProps\n],\n        [ButtonContext, {\nslots\n: {\nincrement\n:\nincrementButtonProps\n,\ndecrement\n:\ndecrementButtonProps\n}\n        }]\n      ]}>\n      {\nprops\n.\nchildren\n}\n    </\nProvider\n>\n);\n}\nBecause\nCustomNumberField\nprovides values for the\nGroup\n,\nInput\n,\nLabel\n, and\nButton\ncomponents via context, the implementations from React Aria Components can be reused.\n<\nCustomNumberField\n>\n  <\nLabel\n>Width</\nLabel\n>\n  <\nGroup\n>\n    <\nInput\n/>\n    <\nButton\nslot\n=\n\"increment\"\n>+</\nButton\n>\n    <\nButton\nslot\n=\n\"decrement\"\n>-</\nButton\n>\n  </\nGroup\n>\n</\nCustomNumberField\n>",
  "content_markdown": "# Customization\n\nReact Aria is built using a flexible and composable API. Learn how to use contexts and slots to create custom component patterns, or mix and match with the lower level Hook-based API for even more control over rendering and behavior.\n\n## Contexts\n\nThe React Aria Components API is designed around composition. Components are reused between patterns to build larger composite components. For example, there is no dedicated `NumberFieldIncrementButton` or `SelectPopover` component. Instead, the standalone <Button> and <Popover> components are reused within <NumberField> and <Select>. This reduces the amount of duplicate styling code you need to write and maintain, and provides powerful composition capabilities you can use in your own components.\n\n```\n<NumberField>\n  <Label>Width</Label>\n  <Group>\n    <Input />\n    <Button slot=\"increment\">+</Button>\n    <Button slot=\"decrement\">-</Button>\n  </Group>\n</NumberField>\n```\n\nReact Aria Components automatically provide behavior to their children by passing event handlers and other attributes via context. For example, the increment and decrement buttons in a `NumberField` receive `onPress` handlers that update the value. Keeping each element of a component separate enables full styling, layout, and DOM structure control, and contexts ensure that accessibility and behavior are taken care of on your behalf.\n\nThis architecture also enables you to reuse React Aria Components in your own custom patterns, or even replace one part of a component with your own custom implementation without rebuilding the whole pattern from scratch.\n\n### Custom patterns\n\nEach React Aria Component exports a corresponding context that you can use to build your own compositional APIs similar to the built-in components. These accept the component's props as a value. The local component props are merged with the ones passed via context, with the local props taking precedence (see <mergeProps>).\n\nThis example shows a `FieldGroup` component that renders a group of text fields. The entire group can be marked as disabled via the `isDisabled` prop, which is passed to all child text fields via the `TextFieldContext` provider.\n\n```\nimport {TextFieldContext} from 'react-aria-components';\n\ninterface FieldGroupProps {\n  children?: React.ReactNode,\n  isDisabled?: boolean\n}\n\nfunction FieldGroup({children, isDisabled}: FieldGroupProps) {\n  return (\n    <TextFieldContext.Provider value={{isDisabled}}>\n      {children}\n    </TextFieldContext.Provider>\n  );\n}\n```\n\nAny `TextField` component you place inside a `FieldGroup` will automatically receive the `isDisabled` prop from the group, including those that are deeply nested inside other components.\n\n```\n<FieldGroup isDisabled={isSubmitting}>\n  <MyTextField label=\"Name\" />\n  <MyTextField label=\"Email\" />\n  <CreditCardFields />\n</FieldGroup>\n```\n\n### Slots\n\nSome patterns include multiple instances of the same component, which are distinguished by the `slot` prop. Slots are named children within a component that have separate behaviors and [styles](styling#slots). Separate props can be sent to slots by providing an object with keys for each slot name to the component's context provider.\n\nThis example shows a `Stepper` component with slots for its increment and decrement buttons.\n\n```\nfunction Stepper({children}) {\n  let [value, setValue] = React.useState(0);\n\n  return (\n    <ButtonContext.Provider\n      value={{\n        slots: {\n          increment: {\n            onPress: () => setValue(value + 1)\n          },\n          decrement: {\n            onPress: () => setValue(value - 1)\n          }\n        }\n      }}>\n      {children}\n    </ButtonContext.Provider>\n  );\n}\n\n<Stepper>\n  <Button slot=\"increment\">\u00e2\u00ac\u0086</Button>\n  <Button slot=\"decrement\">\u00e2\u00ac\u0087</Button>\n</Stepper>\n```\n\n#### Default slot\n\nThe default slot is used to provide props to a component without specifying a slot name. This is used by children without a `slot` prop. This example passes a specific class name to a standard button child and to a button child with a slot named \"end\".\n\n```\nimport {Button, ButtonContext, DEFAULT_SLOT} from 'react-aria-components';\n\nfunction MyCustomComponent({children}) {\n  return (\n    <ButtonContext.Provider\n      value={{\n        slots: {\n          [DEFAULT_SLOT]: {\n            className: \"default-button\"\n          },\n          end: {\n            className: \"end-button\"\n          }\n        }\n      }}>\n      {children}\n    </ButtonContext.Provider>\n  );\n}\n\n<MyCustomComponent>\n  {/* Consumes the props passed to the default slot */}\n  <Button>Click me</Button>\n  {/* Consumes the props passed to the \"end\" slot */}\n  <Button slot=\"end\">Click me</Button>\n</MyCustomComponent>\n```\n\n### Provider\n\nThe `Provider` component is a utility that makes it easier to provide multiple React contexts without manually nesting them. This can be achieved by passing pairs of contexts and values as an array to the `values` prop.\n\n```\nimport {Provider, ButtonContext, InputContext} from 'react-aria-components';\n\n<Provider\n  values={[\n    [ButtonContext, {/* ... */}],\n    [InputContext, {/* ... */}]\n  ]}>\n  {/* ... */}\n</Provider>\n```\n\nThis is equivalent to:\n\n```\n<ButtonContext.Provider value={{/* ... */}}>\n  <InputContext.Provider value={{/* ... */}}>\n    {/* ... */}\n  </InputContext.Provider>\n</ButtonContext.Provider>\n```\n\n### Consuming contexts\n\nYou can also consume from contexts provided by React Aria Components in your own custom components. This allows you to replace a component used as part of a larger pattern with a custom implementation. For example, you could consume from `LabelContext` in a custom label component to make it compatible with React Aria Components.\n\n#### useContextProps\n\nThe useContextProps hook merges the local props with the ones provided via context by a parent component. The local props always take precedence over the context values (see <mergeProps>). `useContextProps` supports the [slot](#slots) prop to indicate which value to consume from context.\n\n```\nimport type {LabelProps} from 'react-aria-components';\nimport {LabelContext, useContextProps} from 'react-aria-components';\n\nconst MyCustomLabel = React.forwardRef(\n  (props: LabelProps, ref: React.ForwardedRef<HTMLLabelElement>) => {\n    // Merge the local props and ref with the ones provided via context.\n    let [mergedProps, mergedRef] = useContextProps(props, ref, LabelContext);\n\n    // ... your existing Label component\n    return <label {...mergedProps} ref={mergedRef} />;\n  }\n);\n```\n\nSince it consumes from `LabelContext`, `MyCustomLabel` can be used within any React Aria component instead of the built-in `Label`.\n\n```\n<TextField>\n  <MyCustomLabel>Name</MyCustomLabel>\n  <Input />\n</TextField>\n```\n\n#### useSlottedContext\n\nTo consume a context without merging with existing props, use the useSlottedContext hook. This works like React's `useContext`, and also accepts an optional slot argument to identify which slot name to consume.\n\n```\nimport {useSlottedContext} from 'react-aria-components';\n\n// Consume the un-slotted value.\nlet buttonContext = useSlottedContext(ButtonContext);\n\n// Consume the value for a specific slot name.\nlet incrementButtonContext = useSlottedContext(ButtonContext, 'increment');\n```\n\n### Accessing state\n\nMost React Aria components compose other components in their children to build larger patterns. However, some components are made up of more tightly coupled children. For example, <Calendar> includes children such as `CalendarGrid` and `CalendarCell` that cannot be used standalone. These components access the state from their parent via context.\n\nYou can access the state from a parent component via the same contexts in order to build your own custom children. This example shows a `CalendarValue` component that displays the currently selected date from a calendar as a formatted string.\n\n```\nimport {CalendarStateContext} from 'react-aria-components';\nimport {useDateFormatter} from 'react-aria';\nimport {getLocalTimeZone} from '@internationalized/date';\n\nfunction CalendarValue() {\n  let state = React.useContext(CalendarStateContext)!;\n  let date = state.value?.toDate(getLocalTimeZone());\n  let {format} = useDateFormatter();\n  let formatted = date ? format(date) : 'None';\n  return `Selected date: ${formatted}`;\n}\n```\n\nThis enables a `<CalendarValue>` to be placed inside a `<Calendar>` to display the current value.\n\n```\n<Calendar>\n  {/* ... */}\n  <CalendarValue />\n</Calendar>\n```\n\n## Hooks\n\nIf you need to customize things even further, such as overriding behavior, intercepting events, or customizing DOM structure, you can drop down to the lower level Hook-based API. Hooks only provide behavior and leave all rendering to you. This gives you more control and flexibility, but requires additional glue code to set up.\n\nReact Aria Components and Hooks can be used together, allowing you to mix and match depending on the level of customization you require. We recommend starting with the component API by default, and only dropping down to hooks when you need to customize something that the component API does not allow.\n\nSome potential use cases for Hooks are:\n\n- Overriding which DOM element a component renders\n- Intercepting a DOM event to apply conditional logic\n- Overriding internal state management behavior\n- Customizing overlay positioning\n- Removing unused features to reduce bundle size\n\n### Setup\n\nAs described [above](#contexts), each React Aria component exports a corresponding context. You can build a custom implementation of a component using Hooks by consuming from the relevant context with useContextProps.\n\nThis example shows how a custom checkbox could be set up using `CheckboxContext` from `react-aria-components` and the [useCheckbox](Checkbox/useCheckbox.html) hook from `react-aria`.\n\n```\nimport type {CheckboxProps} from 'react-aria-components';\nimport {CheckboxContext, useContextProps} from 'react-aria-components';\nimport {useToggleState} from 'react-stately';\nimport {useCheckbox} from 'react-aria';\n\nconst MyCheckbox = React.forwardRef((props: CheckboxProps, ref: React.ForwardedRef<HTMLInputElement>) => {\n  // Merge the local props and ref with the ones provided via context.\n  let [mergedProps, mergedRef] = useContextProps(props, ref, CheckboxContext);\n\n  // Follow the hook docs and implement your customizations...\n  let state = useToggleState(mergedProps);\n  let {inputProps} = useCheckbox(mergedProps, state, mergedRef);\n  return <input {...inputProps} ref={mergedRef} />;\n});\n```\n\nSince `MyCheckbox` consumes from `CheckboxContext` it can be used within other React Aria Components in place of the built-in `Checkbox`, such as within a <Table> or <GridList>. This lets you provide a custom checkbox implementation without rewriting all other React Aria Components you might use it in.\n\n```\n<GridList>\n  <GridListItem>\n    <MyCheckbox slot=\"selection\" />\n    {/* ... */}\n  </GridListItem>\n</GridList>\n```\n\n### Reusing children\n\nYou can also provide values for React Aria Components from a Hook-based implementation. This allows you to customize the parent component of a larger pattern, while reusing the existing implementations of the child elements from React Aria Components.\n\nThis example shows how a custom number field could be set up. First, follow the docs for [useNumberField](NumberField/useNumberField.html), and then use [Provider](#provider) to send values returned by the hook to each of the child elements via their corresponding contexts.\n\n```\nimport type {NumberFieldProps} from 'react-aria-components';\nimport {Provider, GroupContext, InputContext, LabelContext, ButtonContext} from 'react-aria-components';\nimport {useNumberFieldState} from 'react-stately';\nimport {useNumberField, useLocale} from 'react-aria';\n\nfunction CustomNumberField(props: NumberFieldProps) {\n  // Follow the hook docs...\n  let {locale} = useLocale();\n  let state = useNumberFieldState({...props, locale});\n  let ref = useRef<HTMLInputElement>(null);\n  let {\n    labelProps,\n    groupProps,\n    inputProps,\n    incrementButtonProps,\n    decrementButtonProps\n  } = useNumberField(props, state, ref);\n\n  // Provide values for the child components via context.\n  return (\n    <Provider\n      values={[\n        [GroupContext, groupProps],\n        [InputContext, {...inputProps, ref}],\n        [LabelContext, labelProps],\n        [ButtonContext, {\n          slots: {\n            increment: incrementButtonProps,\n            decrement: decrementButtonProps\n          }\n        }]\n      ]}>\n      {props.children}\n    </Provider>\n  );\n}\n```\n\nBecause `CustomNumberField` provides values for the `Group`, `Input`, `Label`, and `Button` components via context, the implementations from React Aria Components can be reused.\n\n```\n<CustomNumberField>\n  <Label>Width</Label>\n  <Group>\n    <Input />\n    <Button slot=\"increment\">+</Button>\n    <Button slot=\"decrement\">-</Button>\n  </Group>\n</CustomNumberField>\n```",
  "tags": [
    "adobe",
    "react-aria",
    "hooks",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:37:37.354142+00:00",
  "content_length": 12484,
  "content_hash": "f7d329e0af6c5d84"
}