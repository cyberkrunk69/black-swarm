{
  "id": "mantine__styles_responsive_",
  "source_id": "mantine",
  "source_name": "Mantine",
  "category": "component_libraries",
  "url": "https://mantine.dev/styles/responsive/",
  "title": "Responsive styles",
  "content": "Responsive styles\nMedia queries\nDemo\nDemo.module.css\nDemo.tsx\n.demo {\n  background-color: var(--mantine-color-blue-filled);\n  color: var(--mantine-color-white);\n  padding: var(--mantine-spacing-md);\n  text-align: center;\n\n  @media (min-width: em(750px)) {\n    background-color: var(--mantine-color-red-filled);\n  }\n}\nExpand code\nConfigure breakpoints\ntheme.breakpoints\nare used in all responsive Mantine components. Breakpoints are expected to be set in\nem\nunits.\nYou can configure these values with\nMantineProvider\n:\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  breakpoints: {\n    xs: '30em',\n    sm: '48em',\n    md: '64em',\n    lg: '74em',\n    xl: '90em',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\nExpand code\nDefault\ntheme.breakpoints\nvalues:\nBreakpoint\nViewport width\nValue in px\nxs\n36em\n576px\nsm\n48em\n768px\nmd\n62em\n992px\nlg\n75em\n1200px\nxl\n88em\n1408px\nBreakpoints variables in CSS modules\nIt is not possible to use CSS variables inside media queries \u2013 these values cannot be dynamically\ngenerated by\nMantineProvider\n. To use Mantine theme breakpoints\nin your\n.css\nfiles, you will need\npostcss-simple-vars\npackage:\nyarn\nnpm\nyarn add --dev postcss-simple-vars\nExpand code\nnpm install --save-dev postcss-simple-vars\nExpand code\nAdd it to your\nPostCSS config\nin\npostcss.config.cjs\n:\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\nExpand code\nThen you will be able to access these variables in your\n.css\nfiles:\n.demo {\n  @media (max-width: $mantine-breakpoint-xs) {\n    background-color: red;\n  }\n}\nExpand code\nWill be transformed to:\n@media (max-width: 36em) {\n  .demo {\n    background-color: red;\n  }\n}\nExpand code\nDynamic breakpoints are not supported\nValues that are defined in\npostcss-simple-vars\nconfig are static and\nare not connected to the\ntheme\n\u2013 if values change,\nyou will need to update them manually in both theme override and postcss config.\nhiddenFrom and visibleFrom props\nAll Mantine components that have a root element support\nhiddenFrom\nand\nvisibleFrom\nprops.\nThese props accept breakpoint (\nxs\n,\nsm\n,\nmd\n,\nlg\n,\nxl\n) and hide the component when\nviewport width is less than or greater than the specified breakpoint:\nHidden from sm\nVisible from sm\nVisible from md\nDemo.tsx\nimport { Button, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group justify=\"center\">\n      <Button hiddenFrom=\"sm\" color=\"orange\">\n        Hidden from sm\n      </Button>\n      <Button visibleFrom=\"sm\" color=\"cyan\">\n        Visible from sm\n      </Button>\n      <Button visibleFrom=\"md\" color=\"pink\">\n        Visible from md\n      </Button>\n    </Group>\n  );\n}\nExpand code\nHidden and visible from as classes\nIf you are building a custom component and want to use the same logic as in\nhiddenFrom\nand\nvisibleFrom\nprops\nbut you do not want to use Mantine components, you can use\nmantine-hidden-from-{x}\nand\nmantine-visible-from-{x}\nclasses.\nfunction CustomComponent() {\n  return (\n    <>\n      <div className=\"mantine-hidden-from-md\">Hidden from md</div>\n      <div className=\"mantine-visible-from-xl\">Visible from xl</div>\n    </>\n  );\n}\nExpand code\nComponent size based on media query\nSome components support\nsize\nprop, which changes various aspects of component appearance.\nsize\nprop is not responsive \u2013 it is not possible to define different component sizes for different\nscreen sizes. Instead, you can render multiple components with different sizes and show/hide them\nbased on media query with\nclassName\nor\nhiddenFrom\n/\nvisibleFrom\nprops:\nMy input\nMy input\nDemo.tsx\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <TextInput size=\"xs\" hiddenFrom=\"sm\" label=\"My input\" placeholder=\"My input\" />\n      <TextInput size=\"xl\" visibleFrom=\"sm\" label=\"My input\" placeholder=\"My input\" />\n    </>\n  );\n}\nExpand code\nuse-media-query hook\nYou can use\nuse-media-query hook\nto change some of component props\nbased on media query. Note that this approach is not recommended for most of the cases if you have\nssr in your application (you use Next.js, React Router, Gatsby or any other framework that includes ssr)\nas it may cause hydration mismatch. If you do not have ssr in your application (for example, if you use Vite),\nthen you can safely use this hook to change props of components or conditionally render components\nbased on hook return value.\nuse-media-query hook\ncan be safely used to change props of components that are not rendered\non server side (modals, tooltips, etc.). In the following example, it is safe to use\nuseMediaQuery\nhook to\nchange\nTooltip\nprops as it is not rendered on server side:\nHover me\nDemo.tsx\nimport { Tooltip, Button, em } from '@mantine/core';\nimport { useMediaQuery } from '@mantine/hooks';\n\nfunction Demo() {\n  const isMobile = useMediaQuery(`(max-width: ${em(750)})`);\n\n  return (\n    <Tooltip label={isMobile ? 'Mobile' : 'Desktop'}>\n      <Button>Hover me</Button>\n    </Tooltip>\n  );\n}\nExpand code\nuse-matches hook\nuse-matches\nhook exported from\n@mantine/core\nis an alternative to\nuse-media-query\nif you need to match multiple media queries and values. It accepts an object with media queries as keys and\nvalues at given breakpoint as values.\nNote that\nuse-matches\nhook uses the same logic as\nuse-media-query\nunder the hood,\nit is not recommended to be used as a primary source of responsive styles, especially if you have ssr in your application.\nIn the following example:\nStarting from\ntheme.breakpoints.lg\n, color will be\nred.9\nBetween\ntheme.breakpoints.sm\nand\ntheme.breakpoints.lg\n, color will be\norange.9\nBelow\ntheme.breakpoints.sm\n, color will be\nblue.9\nBox with color that changes based on screen size\nDemo.tsx\nimport { Box, useMatches } from '@mantine/core';\n\nfunction Demo() {\n  const color = useMatches({\n    base: 'blue.9',\n    sm: 'orange.9',\n    lg: 'red.9',\n  });\n\n  return (\n    <Box bg={color} c=\"white\" p=\"xl\">\n      Box with color that changes based on screen size\n    </Box>\n  );\n}\nExpand code\nContainer queries\nContainer queries\nenable you to apply styles to an element based on the size of the element's container.\nIf, for example, a container has less space available in the surrounding context,\nyou can hide certain elements or use smaller fonts. Container queries are supported\nin\nall modern browsers\n.\nYou can use\nrem\nand\nem\nfunctions from\npostcss-preset-mantine\nin container queries. Note that CSS variables do not work in container queries and because of that\nrem scaling\nfeature is not available. If you rely on this feature,\nit is better to define breakpoints in\npx\nunits.\nResize parent element to see container query in action\nDemo.module.css\nDemo.tsx\n.root {\n  min-width: 200px;\n  max-width: 100%;\n  min-height: 120px;\n  container-type: inline-size;\n  overflow: auto;\n  resize: horizontal;\n}\n\n.child {\n  background-color: var(--mantine-color-dimmed);\n  color: var(--mantine-color-white);\n  padding: var(--mantine-spacing-md);\n\n  @container (max-width: 500px) {\n    background-color: var(--mantine-color-blue-filled);\n  }\n\n  @container (max-width: 300px) {\n    background-color: var(--mantine-color-red-filled);\n  }\n}\nExpand code\nResponsive style props\nYou can use object syntax to add responsive styles with\nstyle props\n.\nNote that responsive style props are\nless performant\nthan regular style props,\nit is not recommended to use them in large lists of elements.\nBox with responsive style props\nDemo.tsx\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      w={{ base: 200, sm: 400, lg: 500 }}\n      py={{ base: 'xs', sm: 'md', lg: 'xl' }}\n      bg={{ base: 'blue.7', sm: 'red.7', lg: 'green.7' }}\n      c=\"#fff\"\n      ta=\"center\"\n      mx=\"auto\"\n    >\n      Box with responsive style props\n    </Box>\n  );\n}\nExpand code\nResponsive values are calculated the following way:\nbase\nvalue is used when none of breakpoint values are applied\nxs\n,\nsm\n,\nmd\n,\nlg\n,\nxl\nvalues are used when the viewport width is larger that the value of corresponding breakpoint specified in\ntheme.breakpoints\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box w={{ base: 320, sm: 480, lg: 640 }} />;\n}\nExpand code\nIn this case the element will have the following styles:\n/* Base styles added to element and then get overwritten with responsive values */\n.element {\n  width: 20rem;\n}\n\n/* 48em is theme.breakpoints.sm by default */\n@media (min-width: 48em) {\n  .element {\n    width: 30rem;\n  }\n}\n\n/* 75em is theme.breakpoints.lg by default */\n@media (min-width: 75em) {\n  .element {\n    width: 40rem;\n  }\n}\nExpand code\nstyle prop\nStyles API",
  "content_markdown": "# Responsive styles\n\n## [Media queries](#media-queries)\n\nDemo\n\nDemo.module.cssDemo.tsx\n\n```\n.demo {\n  background-color: var(--mantine-color-blue-filled);\n  color: var(--mantine-color-white);\n  padding: var(--mantine-spacing-md);\n  text-align: center;\n\n  @media (min-width: em(750px)) {\n    background-color: var(--mantine-color-red-filled);\n  }\n}\n```\n\nExpand code\n\n## [Configure breakpoints](#configure-breakpoints)\n\n`theme.breakpoints` are used in all responsive Mantine components. Breakpoints are expected to be set in `em` units.\nYou can configure these values with [MantineProvider](/theming/mantine-provider/):\n\n```\nimport { createTheme, MantineProvider } from '@mantine/core';\n\nconst theme = createTheme({\n  breakpoints: {\n    xs: '30em',\n    sm: '48em',\n    md: '64em',\n    lg: '74em',\n    xl: '90em',\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\nExpand code\n\nDefault `theme.breakpoints` values:\n\n| Breakpoint | Viewport width | Value in px |\n| --- | --- | --- |\n| xs | 36em | 576px |\n| sm | 48em | 768px |\n| md | 62em | 992px |\n| lg | 75em | 1200px |\n| xl | 88em | 1408px |\n\n## [Breakpoints variables in CSS modules](#breakpoints-variables-in-css-modules)\n\nIt is not possible to use CSS variables inside media queries \u2013 these values cannot be dynamically\ngenerated by [MantineProvider](/theming/mantine-provider/). To use Mantine theme breakpoints\nin your `.css` files, you will need `postcss-simple-vars` package:\n\nyarn\n\nnpm\n\n```\nyarn add --dev postcss-simple-vars\n```\n\nExpand code\n\n```\nnpm install --save-dev postcss-simple-vars\n```\n\nExpand code\n\nAdd it to your [PostCSS config](/styles/postcss-preset/) in `postcss.config.cjs`:\n\n```\nmodule.exports = {\n  plugins: {\n    'postcss-preset-mantine': {},\n    'postcss-simple-vars': {\n      variables: {\n        'mantine-breakpoint-xs': '36em',\n        'mantine-breakpoint-sm': '48em',\n        'mantine-breakpoint-md': '62em',\n        'mantine-breakpoint-lg': '75em',\n        'mantine-breakpoint-xl': '88em',\n      },\n    },\n  },\n};\n```\n\nExpand code\n\nThen you will be able to access these variables in your `.css` files:\n\n```\n.demo {\n  @media (max-width: $mantine-breakpoint-xs) {\n    background-color: red;\n  }\n}\n```\n\nExpand code\n\nWill be transformed to:\n\n```\n@media (max-width: 36em) {\n  .demo {\n    background-color: red;\n  }\n}\n```\n\nExpand code\n\n> **Dynamic breakpoints are not supported**\n>\n> Values that are defined in `postcss-simple-vars` config are static and\n> are not connected to the [theme](/theming/theme-object/) \u2013 if values change,\n> you will need to update them manually in both theme override and postcss config.\n\n## [hiddenFrom and visibleFrom props](#hiddenfrom-and-visiblefrom-props)\n\nAll Mantine components that have a root element support `hiddenFrom` and `visibleFrom` props.\nThese props accept breakpoint (`xs`, `sm`, `md`, `lg`, `xl`) and hide the component when\nviewport width is less than or greater than the specified breakpoint:\n\nHidden from smVisible from smVisible from md\n\nDemo.tsx\n\n```\nimport { Button, Group } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Group justify=\"center\">\n      <Button hiddenFrom=\"sm\" color=\"orange\">\n        Hidden from sm\n      </Button>\n      <Button visibleFrom=\"sm\" color=\"cyan\">\n        Visible from sm\n      </Button>\n      <Button visibleFrom=\"md\" color=\"pink\">\n        Visible from md\n      </Button>\n    </Group>\n  );\n}\n```\n\nExpand code\n\n## [Hidden and visible from as classes](#hidden-and-visible-from-as-classes)\n\nIf you are building a custom component and want to use the same logic as in `hiddenFrom` and `visibleFrom` props\nbut you do not want to use Mantine components, you can use `mantine-hidden-from-{x}` and `mantine-visible-from-{x}`\nclasses.\n\n```\nfunction CustomComponent() {\n  return (\n    <>\n      <div className=\"mantine-hidden-from-md\">Hidden from md</div>\n      <div className=\"mantine-visible-from-xl\">Visible from xl</div>\n    </>\n  );\n}\n```\n\nExpand code\n\n## [Component size based on media query](#component-size-based-on-media-query)\n\nSome components support `size` prop, which changes various aspects of component appearance.\n`size` prop is not responsive \u2013 it is not possible to define different component sizes for different\nscreen sizes. Instead, you can render multiple components with different sizes and show/hide them\nbased on media query with `className` or `hiddenFrom`/`visibleFrom` props:\n\nMy input\n\nMy input\n\nDemo.tsx\n\n```\nimport { TextInput } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <>\n      <TextInput size=\"xs\" hiddenFrom=\"sm\" label=\"My input\" placeholder=\"My input\" />\n      <TextInput size=\"xl\" visibleFrom=\"sm\" label=\"My input\" placeholder=\"My input\" />\n    </>\n  );\n}\n```\n\nExpand code\n\n## [use-media-query hook](#use-media-query-hook)\n\nYou can use [use-media-query hook](/hooks/use-media-query/) to change some of component props\nbased on media query. Note that this approach is not recommended for most of the cases if you have\nssr in your application (you use Next.js, React Router, Gatsby or any other framework that includes ssr)\nas it may cause hydration mismatch. If you do not have ssr in your application (for example, if you use Vite),\nthen you can safely use this hook to change props of components or conditionally render components\nbased on hook return value.\n\n[use-media-query hook](/hooks/use-media-query/) can be safely used to change props of components that are not rendered\non server side (modals, tooltips, etc.). In the following example, it is safe to use `useMediaQuery` hook to\nchange [Tooltip](/core/tooltip/) props as it is not rendered on server side:\n\nHover me\n\nDemo.tsx\n\n```\nimport { Tooltip, Button, em } from '@mantine/core';\nimport { useMediaQuery } from '@mantine/hooks';\n\nfunction Demo() {\n  const isMobile = useMediaQuery(`(max-width: ${em(750)})`);\n\n  return (\n    <Tooltip label={isMobile ? 'Mobile' : 'Desktop'}>\n      <Button>Hover me</Button>\n    </Tooltip>\n  );\n}\n```\n\nExpand code\n\n## [use-matches hook](#use-matches-hook)\n\n`use-matches` hook exported from `@mantine/core` is an alternative to [use-media-query](/hooks/use-media-query/)\nif you need to match multiple media queries and values. It accepts an object with media queries as keys and\nvalues at given breakpoint as values.\n\nNote that `use-matches` hook uses the same logic as [use-media-query](/hooks/use-media-query/) under the hood,\nit is not recommended to be used as a primary source of responsive styles, especially if you have ssr in your application.\n\nIn the following example:\n\n- Starting from `theme.breakpoints.lg`, color will be `red.9`\n- Between `theme.breakpoints.sm` and `theme.breakpoints.lg`, color will be `orange.9`\n- Below `theme.breakpoints.sm`, color will be `blue.9`\n\nBox with color that changes based on screen size\n\nDemo.tsx\n\n```\nimport { Box, useMatches } from '@mantine/core';\n\nfunction Demo() {\n  const color = useMatches({\n    base: 'blue.9',\n    sm: 'orange.9',\n    lg: 'red.9',\n  });\n\n  return (\n    <Box bg={color} c=\"white\" p=\"xl\">\n      Box with color that changes based on screen size\n    </Box>\n  );\n}\n```\n\nExpand code\n\n## [Container queries](#container-queries)\n\n[Container queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_container_queries)\nenable you to apply styles to an element based on the size of the element's container.\nIf, for example, a container has less space available in the surrounding context,\nyou can hide certain elements or use smaller fonts. Container queries are supported\nin [all modern browsers](https://caniuse.com/css-container-queries).\n\nYou can use `rem` and `em` functions from [postcss-preset-mantine](/styles/postcss-preset/#remem-functions)\nin container queries. Note that CSS variables do not work in container queries and because of that\n[rem scaling](/styles/rem/#rem-units-scaling) feature is not available. If you rely on this feature,\nit is better to define breakpoints in `px` units.\n\nResize parent element to see container query in action\n\nDemo.module.cssDemo.tsx\n\n```\n.root {\n  min-width: 200px;\n  max-width: 100%;\n  min-height: 120px;\n  container-type: inline-size;\n  overflow: auto;\n  resize: horizontal;\n}\n\n.child {\n  background-color: var(--mantine-color-dimmed);\n  color: var(--mantine-color-white);\n  padding: var(--mantine-spacing-md);\n\n  @container (max-width: 500px) {\n    background-color: var(--mantine-color-blue-filled);\n  }\n\n  @container (max-width: 300px) {\n    background-color: var(--mantine-color-red-filled);\n  }\n}\n```\n\nExpand code\n\n## [Responsive style props](#responsive-style-props)\n\nYou can use object syntax to add responsive styles with [style props](/styles/style-props/).\nNote that responsive style props are [less performant](/styles/styles-performance/) than regular style props,\nit is not recommended to use them in large lists of elements.\n\nBox with responsive style props\n\nDemo.tsx\n\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Box\n      w={{ base: 200, sm: 400, lg: 500 }}\n      py={{ base: 'xs', sm: 'md', lg: 'xl' }}\n      bg={{ base: 'blue.7', sm: 'red.7', lg: 'green.7' }}\n      c=\"#fff\"\n      ta=\"center\"\n      mx=\"auto\"\n    >\n      Box with responsive style props\n    </Box>\n  );\n}\n```\n\nExpand code\n\nResponsive values are calculated the following way:\n\n- `base` value is used when none of breakpoint values are applied\n- `xs`, `sm`, `md`, `lg`, `xl` values are used when the viewport width is larger that the value of corresponding breakpoint specified in [theme.breakpoints](/styles/responsive/)\n\n```\nimport { Box } from '@mantine/core';\n\nfunction Demo() {\n  return <Box w={{ base: 320, sm: 480, lg: 640 }} />;\n}\n```\n\nExpand code\n\nIn this case the element will have the following styles:\n\n```\n/* Base styles added to element and then get overwritten with responsive values */\n.element {\n  width: 20rem;\n}\n\n/* 48em is theme.breakpoints.sm by default */\n@media (min-width: 48em) {\n  .element {\n    width: 30rem;\n  }\n}\n\n/* 75em is theme.breakpoints.lg by default */\n@media (min-width: 75em) {\n  .element {\n    width: 40rem;\n  }\n}\n```\n\nExpand code\n\n[style prop](/styles/style/)[Styles API](/styles/styles-api/)",
  "tags": [
    "mantine",
    "react",
    "hooks",
    "components"
  ],
  "extracted_at": "2026-02-03T12:39:55.843408+00:00",
  "content_length": 8903,
  "content_hash": "c58620b91f56f9b0"
}