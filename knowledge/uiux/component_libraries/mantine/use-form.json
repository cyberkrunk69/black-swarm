{
  "id": "mantine__form_use-form_",
  "source_id": "mantine",
  "source_name": "Mantine",
  "category": "component_libraries",
  "url": "https://mantine.dev/form/use-form/",
  "title": "use-form",
  "content": "use-form\nManage form state\nSource\nView source code\nDocs\nEdit this page\nPackage\n@mantine/form\nLicense\nMIT\nInstallation\n@mantine/form\npackage does not depend on any other libraries, you can use it with or without\n@mantine/core\ninputs:\nyarn\nnpm\nyarn add @mantine/form\nExpand code\nnpm install @mantine/form\nExpand code\nUsage\nEmail\n*\nI agree to sell my privacy\nSubmit\nDemo.tsx\nimport { Button, Checkbox, Group, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      email: '',\n      termsOfService: false,\n    },\n\n    validate: {\n      email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),\n    },\n  });\n\n  return (\n    <form onSubmit={form.onSubmit((values) => console.log(values))}>\n      <TextInput\n        withAsterisk\n        label=\"Email\"\n        placeholder=\"your@email.com\"\n        key={form.key('email')}\n        {...form.getInputProps('email')}\n      />\n\n      <Checkbox\n        mt=\"md\"\n        label=\"I agree to sell my privacy\"\n        key={form.key('termsOfService')}\n        {...form.getInputProps('termsOfService', { type: 'checkbox' })}\n      />\n\n      <Group justify=\"flex-end\" mt=\"md\">\n        <Button type=\"submit\">Submit</Button>\n      </Group>\n    </form>\n  );\n}\nExpand code\nAPI overview\nAll examples below use the following example use-form hook.\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    path: '',\n    path2: '',\n    user: {\n      firstName: 'John',\n      lastName: 'Doe',\n    },\n    fruits: [\n      { name: 'Banana', available: true },\n      { name: 'Orange', available: false },\n    ],\n    accepted: false,\n  },\n});\nExpand code\nValues\nForm values guide\n// get current form values\nform.getValues();\n\n// Set all form values\nform.setValues(values);\n\n// Set all form values using the previous state\nform.setValues((prev) => ({ ...prev, ...values }));\n\n// Set value of single field\nform.setFieldValue('path', value);\n\n// Set value of nested field\nform.setFieldValue('user.firstName', 'Jane');\n\n// Resets form values to `initialValues`,\n// clears all validation errors,\n// resets touched and dirty state\nform.reset();\n\n// Reset field at `path` to its initial value\nform.resetField('path');\n\n// Sets initial values, used when form is reset\nform.setInitialValues({ values: 'object' });\nExpand code\nList items\nNested fields guide\n// Inserts given list item at the specified path\nform.insertListItem('fruits', { name: 'Apple', available: true });\n\n// An optional index may be provided to specify the position in a nested field.\n// If the index is provided, item will be inserted at the given position.\n// If the index is larger than the current list, the element is inserted at the last position.\nform.insertListItem('fruits', { name: 'Orange', available: true }, 1);\n\n// Removes the list item at the specified path and index.\nform.removeListItem('fruits', 1);\n\n// Replaces the list item at the specified path and index with the given item.\nform.replaceListItem('fruits', 1, { name: 'Apple', available: true });\n\n// Swaps two items of the list at the specified path.\n// You should make sure that there are elements at at the `from` and `to` index.\nform.reorderListItem('fruits', { from: 1, to: 0 });\nExpand code\nValidation\nForm validation guide\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    email: '',\n    user: {\n      firstName: '',\n      lastName: '',\n    },\n  },\n  validate: {\n    email: (value) => (value.length < 2 ? 'Invalid email' : null),\n    user: {\n      firstName: (value) =>\n        value.length < 2\n          ? 'First name must have at least 2 letters'\n          : null,\n    },\n  },\n});\n\n// Validates all fields with specified `validate` function or schema, sets form.errors\nform.validate();\n\n// Validates single field at specified path, sets form.errors\nform.validateField('user.firstName');\n\n// Works the same way as form.validate but does not set form.errors\nform.isValid();\nform.isValid('user.firstName');\nExpand code\nErrors\nForm errors guide\nValidation errors occur when defined validation rules were violated,\ninitialErrors\nwere specified in useForm properties\nor validation errors were set manually.\n// get current errors state\nform.errors;\n\n// Set all errors\nform.setErrors({ path: 'Error message', path2: 'Another error' });\n\n// Set error message at specified path\nform.setFieldError('user.lastName', 'No special characters allowed');\n\n// Clears all errors\nform.clearErrors();\n\n// Clears error of field at specified path\nform.clearFieldError('path');\nExpand code\nonReset and onSubmit\nWrapper function for form\nonSubmit\nand\nonReset\nevent handler.\nonSubmit\nhandler accepts as second argument a function\nthat will be called with errors object when validation fails.\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({ mode: 'uncontrolled' });\n\n  const handleSubmit = (values: typeof form.values) => {\n    console.log(values);\n  };\n\n  return (\n    <>\n      {/* Supply handle submit as a single argument to receive validated values */}\n      <form onSubmit={form.onSubmit(handleSubmit)} />\n\n      {/* Supply second argument to handle errors */}\n      <form\n        onSubmit={form.onSubmit(\n          (values, event) => {\n            console.log(\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          },\n          (validationErrors, values, event) => {\n            console.log(\n              validationErrors, // <- form.errors at the moment of submit\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          }\n        )}\n      />\n\n      {/* form.onReset calls form.reset */}\n      <form onReset={form.onReset}></form>\n    </>\n  );\n}\nExpand code\nonSubmitPreventDefault option\nBy default,\nevent.preventDefault()\nis called on the form\nonSubmit\nhandler.\nIf you want to change this behavior, you can pass\nonSubmitPreventDefault\noption\nto\nuseForm\nhook. It can have the following values:\nalways\n(default) - always call\nevent.preventDefault()\nnever\n- never call\nevent.preventDefault()\nvalidation-failed\n- call\nevent.preventDefault()\nonly if validation failed\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  onSubmitPreventDefault: 'never',\n});\nExpand code\nTouched and dirty\nTouched & dirty guide\n// Returns true if user interacted with any field inside form in any way\nform.isTouched();\n\n// Returns true if user interacted with field at specified path\nform.isTouched('path');\n\n// Set all touched values\nform.setTouched({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears touched status of all fields\nform.resetTouched();\n\n// Returns true if form values are not deep equal to initialValues\nform.isDirty();\n\n// Returns true if field value is not deep equal to initialValues\nform.isDirty('path');\n\n// Sets dirty status of all fields\nform.setDirty({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears dirty status of all fields, saves form.values snapshot\n// After form.resetDirty is called, form.isDirty will compare\n// form.getValues() to snapshot instead of initialValues\nform.resetDirty();\nExpand code\nUseFormReturnType\nUseFormReturnType\ncan be used when you want to pass\nform\nas a prop to another component:\nimport { TextInput } from '@mantine/core';\nimport { useForm, UseFormReturnType } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  occupation: string;\n}\n\nfunction NameInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('name')}\n      {...form.getInputProps('name')}\n    />\n  );\n}\n\nfunction OccupationInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('occupation')}\n      {...form.getInputProps('occupation')}\n    />\n  );\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    mode: 'uncontrolled',\n    initialValues: { name: '', occupation: '' },\n  });\n  return (\n    <>\n      <NameInput form={form} />\n      <OccupationInput form={form} />\n    </>\n  );\n}\nExpand code\nGet started\nuse-field",
  "content_markdown": "# use-form\n\nManage form state\n\nSource\n\n[View source code](https://github.com/mantinedev/mantine/blob/master/packages/@mantine/form/src)\n\nDocs\n\n[Edit this page](https://github.com/mantinedev/mantine/blob/master/apps/mantine.dev/src/pages/form/use-form.mdx)\n\nPackage\n\n[@mantine/form](https://www.npmjs.com/package/@mantine/form)\n\nLicense\n\n[MIT](https://github.com/mantinedev/mantine/blob/master/LICENSE)\n\n## [Installation](#installation)\n\n`@mantine/form` package does not depend on any other libraries, you can use it with or without `@mantine/core` inputs:\n\nyarn\n\nnpm\n\n```\nyarn add @mantine/form\n```\n\nExpand code\n\n```\nnpm install @mantine/form\n```\n\nExpand code\n\n## [Usage](#usage)\n\nEmail \\*\n\nI agree to sell my privacy\n\nSubmit\n\nDemo.tsx\n\n```\nimport { Button, Checkbox, Group, TextInput } from '@mantine/core';\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({\n    mode: 'uncontrolled',\n    initialValues: {\n      email: '',\n      termsOfService: false,\n    },\n\n    validate: {\n      email: (value) => (/^\\S+@\\S+$/.test(value) ? null : 'Invalid email'),\n    },\n  });\n\n  return (\n    <form onSubmit={form.onSubmit((values) => console.log(values))}>\n      <TextInput\n        withAsterisk\n        label=\"Email\"\n        placeholder=\"your@email.com\"\n        key={form.key('email')}\n        {...form.getInputProps('email')}\n      />\n\n      <Checkbox\n        mt=\"md\"\n        label=\"I agree to sell my privacy\"\n        key={form.key('termsOfService')}\n        {...form.getInputProps('termsOfService', { type: 'checkbox' })}\n      />\n\n      <Group justify=\"flex-end\" mt=\"md\">\n        <Button type=\"submit\">Submit</Button>\n      </Group>\n    </form>\n  );\n}\n```\n\nExpand code\n\n## [API overview](#api-overview)\n\nAll examples below use the following example use-form hook.\n\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    path: '',\n    path2: '',\n    user: {\n      firstName: 'John',\n      lastName: 'Doe',\n    },\n    fruits: [\n      { name: 'Banana', available: true },\n      { name: 'Orange', available: false },\n    ],\n    accepted: false,\n  },\n});\n```\n\nExpand code\n\n### [Values](#values)\n\n[Form values guide](/form/values/)\n\n```\n// get current form values\nform.getValues();\n\n// Set all form values\nform.setValues(values);\n\n// Set all form values using the previous state\nform.setValues((prev) => ({ ...prev, ...values }));\n\n// Set value of single field\nform.setFieldValue('path', value);\n\n// Set value of nested field\nform.setFieldValue('user.firstName', 'Jane');\n\n// Resets form values to `initialValues`,\n// clears all validation errors,\n// resets touched and dirty state\nform.reset();\n\n// Reset field at `path` to its initial value\nform.resetField('path');\n\n// Sets initial values, used when form is reset\nform.setInitialValues({ values: 'object' });\n```\n\nExpand code\n\n### [List items](#list-items)\n\n[Nested fields guide](/form/nested/)\n\n```\n// Inserts given list item at the specified path\nform.insertListItem('fruits', { name: 'Apple', available: true });\n\n// An optional index may be provided to specify the position in a nested field.\n// If the index is provided, item will be inserted at the given position.\n// If the index is larger than the current list, the element is inserted at the last position.\nform.insertListItem('fruits', { name: 'Orange', available: true }, 1);\n\n// Removes the list item at the specified path and index.\nform.removeListItem('fruits', 1);\n\n// Replaces the list item at the specified path and index with the given item.\nform.replaceListItem('fruits', 1, { name: 'Apple', available: true });\n\n// Swaps two items of the list at the specified path.\n// You should make sure that there are elements at at the `from` and `to` index.\nform.reorderListItem('fruits', { from: 1, to: 0 });\n```\n\nExpand code\n\n### [Validation](#validation)\n\n[Form validation guide](/form/validation/)\n\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  initialValues: {\n    email: '',\n    user: {\n      firstName: '',\n      lastName: '',\n    },\n  },\n  validate: {\n    email: (value) => (value.length < 2 ? 'Invalid email' : null),\n    user: {\n      firstName: (value) =>\n        value.length < 2\n          ? 'First name must have at least 2 letters'\n          : null,\n    },\n  },\n});\n\n// Validates all fields with specified `validate` function or schema, sets form.errors\nform.validate();\n\n// Validates single field at specified path, sets form.errors\nform.validateField('user.firstName');\n\n// Works the same way as form.validate but does not set form.errors\nform.isValid();\nform.isValid('user.firstName');\n```\n\nExpand code\n\n### [Errors](#errors)\n\n[Form errors guide](/form/errors/)\n\nValidation errors occur when defined validation rules were violated, `initialErrors` were specified in useForm properties\nor validation errors were set manually.\n\n```\n// get current errors state\nform.errors;\n\n// Set all errors\nform.setErrors({ path: 'Error message', path2: 'Another error' });\n\n// Set error message at specified path\nform.setFieldError('user.lastName', 'No special characters allowed');\n\n// Clears all errors\nform.clearErrors();\n\n// Clears error of field at specified path\nform.clearFieldError('path');\n```\n\nExpand code\n\n### [onReset and onSubmit](#onreset-and-onsubmit)\n\nWrapper function for form `onSubmit` and `onReset` event handler. `onSubmit` handler accepts as second argument a function\nthat will be called with errors object when validation fails.\n\n```\nimport { useForm } from '@mantine/form';\n\nfunction Demo() {\n  const form = useForm({ mode: 'uncontrolled' });\n\n  const handleSubmit = (values: typeof form.values) => {\n    console.log(values);\n  };\n\n  return (\n    <>\n      {/* Supply handle submit as a single argument to receive validated values */}\n      <form onSubmit={form.onSubmit(handleSubmit)} />\n\n      {/* Supply second argument to handle errors */}\n      <form\n        onSubmit={form.onSubmit(\n          (values, event) => {\n            console.log(\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          },\n          (validationErrors, values, event) => {\n            console.log(\n              validationErrors, // <- form.errors at the moment of submit\n              values, // <- form.getValues() at the moment of submit\n              event // <- form element submit event\n            );\n          }\n        )}\n      />\n\n      {/* form.onReset calls form.reset */}\n      <form onReset={form.onReset}></form>\n    </>\n  );\n}\n```\n\nExpand code\n\n### [onSubmitPreventDefault option](#onsubmitpreventdefault-option)\n\nBy default, `event.preventDefault()` is called on the form `onSubmit` handler.\nIf you want to change this behavior, you can pass `onSubmitPreventDefault` option\nto `useForm` hook. It can have the following values:\n\n- `always` (default) - always call `event.preventDefault()`\n- `never` - never call `event.preventDefault()`\n- `validation-failed` - call `event.preventDefault()` only if validation failed\n\n```\nimport { useForm } from '@mantine/form';\n\nconst form = useForm({\n  mode: 'uncontrolled',\n  onSubmitPreventDefault: 'never',\n});\n```\n\nExpand code\n\n### [Touched and dirty](#touched-and-dirty)\n\n[Touched & dirty guide](/form/status/)\n\n```\n// Returns true if user interacted with any field inside form in any way\nform.isTouched();\n\n// Returns true if user interacted with field at specified path\nform.isTouched('path');\n\n// Set all touched values\nform.setTouched({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears touched status of all fields\nform.resetTouched();\n\n// Returns true if form values are not deep equal to initialValues\nform.isDirty();\n\n// Returns true if field value is not deep equal to initialValues\nform.isDirty('path');\n\n// Sets dirty status of all fields\nform.setDirty({ 'user.firstName': true, 'user.lastName': false });\n\n// Clears dirty status of all fields, saves form.values snapshot\n// After form.resetDirty is called, form.isDirty will compare\n// form.getValues() to snapshot instead of initialValues\nform.resetDirty();\n```\n\nExpand code\n\n## [UseFormReturnType](#useformreturntype)\n\n`UseFormReturnType` can be used when you want to pass `form` as a prop to another component:\n\n```\nimport { TextInput } from '@mantine/core';\nimport { useForm, UseFormReturnType } from '@mantine/form';\n\ninterface FormValues {\n  name: string;\n  occupation: string;\n}\n\nfunction NameInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('name')}\n      {...form.getInputProps('name')}\n    />\n  );\n}\n\nfunction OccupationInput({\n  form,\n}: {\n  form: UseFormReturnType<FormValues>;\n}) {\n  return (\n    <TextInput\n      key={form.key('occupation')}\n      {...form.getInputProps('occupation')}\n    />\n  );\n}\n\nfunction Demo() {\n  const form = useForm<FormValues>({\n    mode: 'uncontrolled',\n    initialValues: { name: '', occupation: '' },\n  });\n  return (\n    <>\n      <NameInput form={form} />\n      <OccupationInput form={form} />\n    </>\n  );\n}\n```\n\nExpand code\n\n[Get started](/form/package/)[use-field](/form/use-field/)",
  "tags": [
    "mantine",
    "react",
    "hooks",
    "components"
  ],
  "extracted_at": "2026-02-03T12:40:18.977553+00:00",
  "content_length": 8307,
  "content_hash": "44ada76d5129c417"
}