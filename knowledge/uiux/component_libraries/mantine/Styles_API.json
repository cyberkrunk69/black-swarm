{
  "id": "mantine__styles_styles-api_",
  "source_id": "mantine",
  "source_name": "Mantine",
  "category": "component_libraries",
  "url": "https://mantine.dev/styles/styles-api/",
  "title": "Styles API",
  "content": "Styles API\nWhat is Styles API\nThe styles API is a set of props and techniques that allows you to customize the style of any element\ninside a Mantine component \u2013 inline or using the\ntheme object\n. All Mantine components that\nhave styles support Styles API.\nStyles API selectors\nEvery Mantine component that supports the styles API has a set of element names that can be used to\napply styles to inner elements inside the component. For simplicity, these elements names are called\nselectors in Mantine documentation. You can find selectors information under the\nStyles API\ntab\nin a component's documentation.\nExample of\nButton\ncomponent selectors:\nSelector\nStatic selector\nDescription\nroot\n.mantine-\nButton\n-\nroot\nRoot element\nloader\n.mantine-\nButton\n-\nloader\nLoader component, displayed only when\nloading\nprop is set\ninner\n.mantine-\nButton\n-\ninner\nContains all other elements, child of the\nroot\nelement\nsection\n.mantine-\nButton\n-\nsection\nLeft and right sections of the button\nlabel\n.mantine-\nButton\n-\nlabel\nButton children\nYou can use these selectors in\nclassNames\nand\nstyles\nin, both, component props and\ntheme.components\n:\nimport { Button, createTheme, MantineProvider } from '@mantine/core';\n\nfunction ClassNamesDemo() {\n  return (\n    <Button\n      classNames={{\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\nfunction StylesDemo() {\n  return (\n    <Button\n      styles={{\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      classNames: {\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      },\n      styles: {\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      },\n    }),\n  },\n});\n\nfunction ProviderDemo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Button>Button</Button>\n    </MantineProvider>\n  );\n}\nExpand code\nclassNames prop\nWith the\nclassNames\nprop you can add classes to inner elements of Mantine components. It accepts\nan object with element names as keys and classes as values:\nFloating label input\nDemo.tsx\nDemo.module.css\nimport { useState } from 'react';\nimport { TextInput } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  const [focused, setFocused] = useState(false);\n  const floating = focused || value.length > 0 || undefined;\n\n  return (\n    <TextInput\n      label=\"Floating label input\"\n      labelProps={{ 'data-floating': floating }}\n      classNames={{\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      }}\n      onFocus={() => setFocused(true)}\n      onBlur={() => setFocused(false)}\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\nExpand code\nclassNames in theme.components\nYou can also define\nclassNames\nin\ntheme.components\nto apply them to all\ncomponents of a specific type:\nimport { useState } from 'react';\nimport {\n  createTheme,\n  MantineProvider,\n  TextInput,\n} from '@mantine/core';\n// Styles are the same as in previous example\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: {\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\nExpand code\nComponents CSS variables\nMost of Mantine components use CSS variables to define colors, sizes, paddings and other\nproperties. You can override these values using a custom CSS variables resolver function\nin\ntheme.components\nor by passing it to the\nvars\nprop.\nYou can find CSS variables information under the\nStyles API\ntab in a component's documentation.\nExample of\nButton\ncomponent CSS variables:\nSelector\nVariable\nDescription\nroot\n--button-bg\nControls\nbackground\n--button-bd\nControl\nborder\n--button-hover\nControls\nbackground\nwhen hovered\n--button-color\nControl text\ncolor\n--button-hover-color\nControl text\ncolor\nwhen hovered\n--button-radius\nControls\nborder-radius\n--button-height\nControls\nheight\nof the button\n--button-padding-x\nControls horizontal\npadding\nof the button\n--button-fz\nControls\nfont-size\nof the button\n--button-justify\nControls\njustify-content\nof\ninner\nelement\nExample of a custom CSS variables resolver function used to add more sizes to the\nButton\ncomponent:\nXXL Button\nXXS Button\nMantineProvider.tsx\nInline.tsx\nimport { Button, Group, MantineProvider, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      vars: (theme, props) => {\n        if (props.size === 'xxl') {\n          return {\n            root: {\n              '--button-height': '60px',\n              '--button-padding-x': '30px',\n              '--button-fz': '24px',\n            },\n          };\n        }\n\n        if (props.size === 'xxs') {\n          return {\n            root: {\n              '--button-height': '24px',\n              '--button-padding-x': '10px',\n              '--button-fz': '10px',\n            },\n          };\n        }\n\n        return { root: {} };\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Group>\n        <Button size=\"xxl\">XXL Button</Button>\n        <Button size=\"xxs\">XXS Button</Button>\n      </Group>\n    </MantineProvider>\n  );\n}\nExpand code\nstyles prop\nThe\nstyles\nprop works the same way as\nclassNames\n, but applies inline styles. Note that inline\nstyles have higher specificity than classes, so you will not be able to override them with classes\nwithout using\n!important\n. You cannot use pseudo-classes (for example,\n:hover\n,\n:first-of-type\n)\nand media queries inside the\nstyles\nprop.\nGradient button\nDemo.tsx\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  const gradient =\n    'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';\n\n  return (\n    <Button\n      radius=\"md\"\n      styles={{\n        root: {\n          padding: 2,\n          border: 0,\n          backgroundImage: gradient,\n        },\n\n        inner: {\n          background: 'var(--mantine-color-body)',\n          color: 'var(--mantine-color-text)',\n          borderRadius: 'calc(var(--button-radius) - 2px)',\n          paddingLeft: 'var(--mantine-spacing-md)',\n          paddingRight: 'var(--mantine-spacing-md)',\n        },\n\n        label: {\n          backgroundImage: gradient,\n          WebkitBackgroundClip: 'text',\n          WebkitTextFillColor: 'transparent',\n        },\n      }}\n    >\n      Gradient button\n    </Button>\n  );\n}\nExpand code\nstyles prop usage\nSome examples and demos in the documentation use the\nstyles\nprop for convenience, but it is not\nrecommended to use the\nstyles\nprop as the primary means of styling components, as the\nclassNames\nprop is more flexible and has\nbetter performance\n.\nStyles API based on component props\nYou can also pass a callback function to\nclassNames\nand\nstyles\n. This function will receive\ntheme\nas first argument and component props as second. It should return\nan object of classes (for\nclassNames\n) or styles (for\nstyles\n).\nYou can use this feature to conditionally apply styles based on component props. For example,\nyou can change the\nTextInput\nlabel color if the input is required or change the input\nbackground color if the input is wrong:\nRequired input\n*\nInput with error\nDemo.tsx\nDemo.module.css\nimport cx from 'clsx';\nimport { MantineProvider, createTheme, TextInput } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: (_theme, props) => ({\n        label: cx({ [classes.labelRequired]: props.required }),\n        input: cx({ [classes.inputError]: props.error }),\n      }),\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <TextInput required label=\"Required input\" placeholder=\"Required input\" />\n      <TextInput error label=\"Input with error\" placeholder=\"Input with error\" mt=\"md\" />\n    </MantineProvider>\n  );\n}\nExpand code\nStatic classes\nEvery component that supports Styles API also includes static classes that can be used to style\ncomponent without using\nclassNames\nor\nstyles\nprops. By default, static classes have\n.mantine-{ComponentName}-{selector}\nformat. For example,\nroot\nselector of\nButton\ncomponent will have\n.mantine-Button-root\nclass.\nYou can use static classes to style a component with CSS or\nany other styling solution\n:\n.mantine-Button-root {\n  background-color: red;\n}\nExpand code\nThe prefix of static classes can be changed with\nclassNamesPrefix\nof\nMantineProvider\n.\nComponents classes\nClasses of each component are available in the\nComponent.classes\nobject. For example, you can\nfind the classes of\nButton\nin\nButton.classes\n:\nKey\nClass\nroot\nm_77c9d27d\ninner\nm_80f1301b\nlabel\nm_811560b9\nsection\nm_a74036a\nloader\nm_a25b86ee\ngroup\nm_80d6d844\ngroupSection\nm_70be2a01\nYou can use these classes to create components with the same styles as Mantine components:\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return <button type=\"button\" className={Button.classes.root} />;\n}\nExpand code\nAttributes\nYou can pass attributes to inner elements of Mantine components using the\nattributes\nprop.\nFor example, it can be used to add data attributes for testing purposes:\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      attributes={{\n        root: { 'data-test-id': 'root' },\n        label: { 'data-test-id': 'label' },\n        inner: { 'data-test-id': 'inner' },\n      }}\n    >\n      Button\n    </Button>\n  );\n}\nExpand code\nResponsive styles\ndata-* attributes",
  "content_markdown": "# Styles API\n\n## [What is Styles API](#what-is-styles-api)\n\nThe styles API is a set of props and techniques that allows you to customize the style of any element\ninside a Mantine component \u2013 inline or using the [theme object](/theming/theme-object/). All Mantine components that\nhave styles support Styles API.\n\n## [Styles API selectors](#styles-api-selectors)\n\nEvery Mantine component that supports the styles API has a set of element names that can be used to\napply styles to inner elements inside the component. For simplicity, these elements names are called\nselectors in Mantine documentation. You can find selectors information under the `Styles API` tab\nin a component's documentation.\n\nExample of [Button](/core/button/) component selectors:\n\n| Selector | Static selector | Description |\n| --- | --- | --- |\n| root | .mantine-Button-root | Root element |\n| loader | .mantine-Button-loader | Loader component, displayed only when `loading` prop is set |\n| inner | .mantine-Button-inner | Contains all other elements, child of the `root` element |\n| section | .mantine-Button-section | Left and right sections of the button |\n| label | .mantine-Button-label | Button children |\n\nYou can use these selectors in `classNames` and `styles` in, both, component props and `theme.components`:\n\n```\nimport { Button, createTheme, MantineProvider } from '@mantine/core';\n\nfunction ClassNamesDemo() {\n  return (\n    <Button\n      classNames={{\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\nfunction StylesDemo() {\n  return (\n    <Button\n      styles={{\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      classNames: {\n        root: 'my-root-class',\n        label: 'my-label-class',\n        inner: 'my-inner-class',\n      },\n      styles: {\n        root: { backgroundColor: 'red' },\n        label: { color: 'blue' },\n        inner: { fontSize: 20 },\n      },\n    }),\n  },\n});\n\nfunction ProviderDemo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Button>Button</Button>\n    </MantineProvider>\n  );\n}\n```\n\nExpand code\n\n## [classNames prop](#classnames-prop)\n\nWith the `classNames` prop you can add classes to inner elements of Mantine components. It accepts\nan object with element names as keys and classes as values:\n\nFloating label input\n\nDemo.tsxDemo.module.css\n\n```\nimport { useState } from 'react';\nimport { TextInput } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nfunction Demo() {\n  const [value, setValue] = useState('');\n  const [focused, setFocused] = useState(false);\n  const floating = focused || value.length > 0 || undefined;\n\n  return (\n    <TextInput\n      label=\"Floating label input\"\n      labelProps={{ 'data-floating': floating }}\n      classNames={{\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      }}\n      onFocus={() => setFocused(true)}\n      onBlur={() => setFocused(false)}\n      value={value}\n      onChange={(event) => setValue(event.currentTarget.value)}\n    />\n  );\n}\n```\n\nExpand code\n\n## [classNames in theme.components](#classnames-in-themecomponents)\n\nYou can also define `classNames` in [`theme.components`](/theming/theme-object/) to apply them to all\ncomponents of a specific type:\n\n```\nimport { useState } from 'react';\nimport {\n  createTheme,\n  MantineProvider,\n  TextInput,\n} from '@mantine/core';\n// Styles are the same as in previous example\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: {\n        root: classes.root,\n        input: classes.input,\n        label: classes.label,\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      {/* Your app here */}\n    </MantineProvider>\n  );\n}\n```\n\nExpand code\n\n## [Components CSS variables](#components-css-variables)\n\nMost of Mantine components use CSS variables to define colors, sizes, paddings and other\nproperties. You can override these values using a custom CSS variables resolver function\nin [theme.components](/theming/theme-object/) or by passing it to the `vars` prop.\n\nYou can find CSS variables information under the `Styles API` tab in a component's documentation.\nExample of [Button](/core/button/) component CSS variables:\n\n| Selector | Variable | Description |\n| --- | --- | --- |\n| root | --button-bg | Controls `background` |\n| --button-bd | Control `border` |\n| --button-hover | Controls `background` when hovered |\n| --button-color | Control text `color` |\n| --button-hover-color | Control text `color` when hovered |\n| --button-radius | Controls `border-radius` |\n| --button-height | Controls `height` of the button |\n| --button-padding-x | Controls horizontal `padding` of the button |\n| --button-fz | Controls `font-size` of the button |\n| --button-justify | Controls `justify-content` of `inner` element |\n\nExample of a custom CSS variables resolver function used to add more sizes to the [Button](/core/button/) component:\n\nXXL ButtonXXS Button\n\nMantineProvider.tsxInline.tsx\n\n```\nimport { Button, Group, MantineProvider, createTheme } from '@mantine/core';\n\nconst theme = createTheme({\n  components: {\n    Button: Button.extend({\n      vars: (theme, props) => {\n        if (props.size === 'xxl') {\n          return {\n            root: {\n              '--button-height': '60px',\n              '--button-padding-x': '30px',\n              '--button-fz': '24px',\n            },\n          };\n        }\n\n        if (props.size === 'xxs') {\n          return {\n            root: {\n              '--button-height': '24px',\n              '--button-padding-x': '10px',\n              '--button-fz': '10px',\n            },\n          };\n        }\n\n        return { root: {} };\n      },\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <Group>\n        <Button size=\"xxl\">XXL Button</Button>\n        <Button size=\"xxs\">XXS Button</Button>\n      </Group>\n    </MantineProvider>\n  );\n}\n```\n\nExpand code\n\n## [styles prop](#styles-prop)\n\nThe `styles` prop works the same way as `classNames`, but applies inline styles. Note that inline\nstyles have higher specificity than classes, so you will not be able to override them with classes\nwithout using `!important`. You cannot use pseudo-classes (for example, `:hover`, `:first-of-type`)\nand media queries inside the `styles` prop.\n\nGradient button\n\nDemo.tsx\n\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  const gradient =\n    'linear-gradient(45deg, var(--mantine-color-pink-filled) 0%, var(--mantine-color-orange-filled) 50%, var(--mantine-color-yellow-filled) 100%)';\n\n  return (\n    <Button\n      radius=\"md\"\n      styles={{\n        root: {\n          padding: 2,\n          border: 0,\n          backgroundImage: gradient,\n        },\n\n        inner: {\n          background: 'var(--mantine-color-body)',\n          color: 'var(--mantine-color-text)',\n          borderRadius: 'calc(var(--button-radius) - 2px)',\n          paddingLeft: 'var(--mantine-spacing-md)',\n          paddingRight: 'var(--mantine-spacing-md)',\n        },\n\n        label: {\n          backgroundImage: gradient,\n          WebkitBackgroundClip: 'text',\n          WebkitTextFillColor: 'transparent',\n        },\n      }}\n    >\n      Gradient button\n    </Button>\n  );\n}\n```\n\nExpand code\n\n> **styles prop usage**\n>\n> Some examples and demos in the documentation use the `styles` prop for convenience, but it is not\n> recommended to use the `styles` prop as the primary means of styling components, as the `classNames`\n> prop is more flexible and has [better performance](/styles/styles-performance/).\n\n## [Styles API based on component props](#styles-api-based-on-component-props)\n\nYou can also pass a callback function to `classNames` and `styles`. This function will receive\n[theme](/theming/theme-object/) as first argument and component props as second. It should return\nan object of classes (for `classNames`) or styles (for `styles`).\n\nYou can use this feature to conditionally apply styles based on component props. For example,\nyou can change the [TextInput](/core/text-input/) label color if the input is required or change the input\nbackground color if the input is wrong:\n\nRequired input \\*\n\nInput with error\n\nDemo.tsxDemo.module.css\n\n```\nimport cx from 'clsx';\nimport { MantineProvider, createTheme, TextInput } from '@mantine/core';\nimport classes from './Demo.module.css';\n\nconst theme = createTheme({\n  components: {\n    TextInput: TextInput.extend({\n      classNames: (_theme, props) => ({\n        label: cx({ [classes.labelRequired]: props.required }),\n        input: cx({ [classes.inputError]: props.error }),\n      }),\n    }),\n  },\n});\n\nfunction Demo() {\n  return (\n    <MantineProvider theme={theme}>\n      <TextInput required label=\"Required input\" placeholder=\"Required input\" />\n      <TextInput error label=\"Input with error\" placeholder=\"Input with error\" mt=\"md\" />\n    </MantineProvider>\n  );\n}\n```\n\nExpand code\n\n## [Static classes](#static-classes)\n\nEvery component that supports Styles API also includes static classes that can be used to style\ncomponent without using `classNames` or `styles` props. By default, static classes have\n`.mantine-{ComponentName}-{selector}` format. For example, `root` selector of [Button](/core/button/)\ncomponent will have `.mantine-Button-root` class.\n\nYou can use static classes to style a component with CSS or [any other styling solution](/styles/css-modules/#styling-mantine-components-without-css-modules):\n\n```\n.mantine-Button-root {\n  background-color: red;\n}\n```\n\nExpand code\n\nThe prefix of static classes can be changed with `classNamesPrefix` of [MantineProvider](/theming/mantine-provider/#classnamesprefix).\n\n## [Components classes](#components-classes)\n\nClasses of each component are available in the `Component.classes` object. For example, you can\nfind the classes of [Button](/core/button/) in `Button.classes`:\n\n| Key | Class |\n| --- | --- |\n| root | m\\_77c9d27d |\n| inner | m\\_80f1301b |\n| label | m\\_811560b9 |\n| section | m\\_a74036a |\n| loader | m\\_a25b86ee |\n| group | m\\_80d6d844 |\n| groupSection | m\\_70be2a01 |\n\nYou can use these classes to create components with the same styles as Mantine components:\n\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return <button type=\"button\" className={Button.classes.root} />;\n}\n```\n\nExpand code\n\n## [Attributes](#attributes)\n\nYou can pass attributes to inner elements of Mantine components using the `attributes` prop.\nFor example, it can be used to add data attributes for testing purposes:\n\n```\nimport { Button } from '@mantine/core';\n\nfunction Demo() {\n  return (\n    <Button\n      attributes={{\n        root: { 'data-test-id': 'root' },\n        label: { 'data-test-id': 'label' },\n        inner: { 'data-test-id': 'inner' },\n      }}\n    >\n      Button\n    </Button>\n  );\n}\n```\n\nExpand code\n\n[Responsive styles](/styles/responsive/)[data-\\* attributes](/styles/data-attributes/)",
  "tags": [
    "mantine",
    "react",
    "hooks",
    "components"
  ],
  "extracted_at": "2026-02-03T12:40:02.465551+00:00",
  "content_length": 10062,
  "content_hash": "a1e73ec134068c13"
}