{
  "id": "headless-ui__react_radio-group",
  "source_id": "headless-ui",
  "source_name": "Headless UI",
  "category": "component_libraries",
  "url": "https://headlessui.com/react/radio-group",
  "title": "Radio Group",
  "content": "React\nVue\nRadio Group\nRadio groups give you the same functionality as native HTML radio inputs, without any of the styling. They're perfect\nfor building out custom UIs for selectors.\nPreview\nCode\nInstallation\nTo get started, install Headless UI via npm:\nnpm\ninstall\n@headlessui/react\nBasic example\nRadio groups are built using the\nRadioGroup\n,\nRadio\n,\nField\n, and\nLabel\ncomponents.\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n'Startup'\n,\n'Business'\n,\n'Enterprise'\n]\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n}\nclassName\n=\n\"\nflex items-center gap-2\n\"\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\nclassName\n=\n\"\ngroup flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400\n\"\n>\n<\nspan\nclassName\n=\n\"\ninvisible size-2 rounded-full bg-white group-data-checked:visible\n\"\n/>\n</\nRadio\n>\n<\nLabel\n>\n{\nplan\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nStyling\nHeadless UI keeps track of a lot of state about each component, like which radio group option is currently checked,\nwhether a popover is open or closed, or which item in a menu is currently focused via the keyboard.\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your\nUI until you provide the styles you want for each state yourself.\nUsing data attributes\nThe easiest way to style the different states of a Headless UI component is using the\ndata-*\nattributes that each\ncomponent exposes.\nFor example, the\nRadio\ncomponent exposes a\ndata-checked\nattribute, which tells you if the radio is currently\nchecked, and a\ndata-disabled\nattribute, which tells you if the radio is currently disabled.\n<!-- Rendered `Radio` -->\n<\nspan\nrole\n=\n\"\nradio\n\"\ndata-checked\ndata-disabled\n>\n<!-- ... -->\n</\nspan\n>\nUse the\nCSS attribute selector\nto conditionally\napply styles based on the presence of these data attributes. If you're using Tailwind CSS, the\ndata attribute modifier\nmakes this easy:\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nname\n:\n'Startup'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Business'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Enterprise'\n,\navailable\n:\nfalse\n}\n,\n]\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n.\nname\n}\ndisabled\n=\n{\n!\nplan\n.\navailable\n}\nclassName\n=\n\"\nflex items-center gap-2\n\"\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\nclassName\n=\n\"\ngroup flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400 data-disabled:bg-gray-100\n\"\n>\n<\nspan\nclassName\n=\n\"\ninvisible size-2 rounded-full bg-white group-data-checked:visible\n\"\n/>\n</\nRadio\n>\n<\nLabel\nclassName\n=\n\"\ndata-disabled:opacity-50\n\"\n>\n{\nplan\n.\nname\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nUsing render props\nEach component also exposes information about its current state via\nrender props\nthat you can use to conditionally apply different styles or\nrender different content.\nFor example, the\nRadio\ncomponent exposes a\nchecked\nstate, which tells you if the radio is currently checked, and a\ndisabled\nstate, which tells you if the radio is currently disabled.\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\nclsx\nfrom\n'clsx'\nimport\n{\nFragment\n,\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nname\n:\n'Startup'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Business'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Enterprise'\n,\navailable\n:\nfalse\n}\n,\n]\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n.\nname\n}\ndisabled\n=\n{\n!\nplan\n.\navailable\n}\nclassName\n=\n\"\nflex items-center gap-2\n\"\n>\n<\nRadio\nas\n=\n{\nFragment\n}\nvalue\n=\n{\nplan\n}\n>\n{\n(\n{\nchecked\n,\ndisabled\n}\n)\n=>\n(\n<\nspan\nclassName\n=\n{\nclsx\n(\n'group flex size-5 items-center justify-center rounded-full border'\n,\nchecked\n?\n'bg-blue-400'\n:\n'bg-white'\n,\ndisabled\n&&\n'bg-gray-100'\n)\n}\n>\n{\nchecked\n&&\n<\nspan\nclassName\n=\n\"\nsize-2 rounded-full bg-white\n\"\n/>\n}\n</\nspan\n>\n)\n}\n</\nRadio\n>\n<\nLabel\nas\n=\n{\nFragment\n}\n>\n{\n(\n{\ndisabled\n}\n)\n=>\n<\nlabel\nclassName\n=\n{\ndisabled\n&&\n'opacity-50'\n}\n>\n{\nplan\n.\nname\n}\n</\nlabel\n>\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nSee the\ncomponent API\nfor a list of all the available render props.\nExamples\nAdding a description\nUse the\nDescription\ncomponent within a\nField\nto automatically associate it with a\nRadio\nusing the\naria-describedby\nattribute:\nimport\n{\nDescription\n,\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nname\n:\n'Startup'\n,\ndescription\n:\n'12GB, 6 CPUs, 256GB SSD disk'\n}\n,\n{\nname\n:\n'Business'\n,\ndescription\n:\n'16GB, 8 CPUs, 512GB SSD disk'\n}\n,\n{\nname\n:\n'Enterprise'\n,\ndescription\n:\n'32GB, 12 CPUs, 1TB SSD disk'\n}\n,\n]\nfunction\nExample\n(\n)\n{\nlet\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n}\nclassName\n=\n\"\nflex items-baseline gap-2\n\"\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\nclassName\n=\n\"\ngroup flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400\n\"\n>\n<\nspan\nclassName\n=\n\"\ninvisible size-2 rounded-full bg-white group-data-checked:visible\n\"\n/>\n</\nRadio\n>\n<\ndiv\n>\n<\nLabel\n>\n{\nplan\n.\nname\n}\n</\nLabel\n>\n<\nDescription\nclassName\n=\n\"\nopacity-50\n\"\n>\n{\nplan\n.\ndescription\n}\n</\nDescription\n>\n</\ndiv\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nUsing with HTML forms\nIf you add the\nname\nprop to your\nRadioGroup\n, a hidden\ninput\nelement will be rendered and kept in sync with the\nradio group state.\nimport\n{\nField\n,\nFieldset\n,\nLabel\n,\nLegend\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n'Startup'\n,\n'Business'\n,\n'Enterprise'\n]\nfunction\nExample\n(\n)\n{\nconst\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nform\naction\n=\n\"\n/plans\n\"\nmethod\n=\n\"\npost\n\"\n>\n<\nFieldset\n>\n<\nLegend\n>\nServer size\n</\nLegend\n>\n<\nRadioGroup\nname\n=\n\"\nplan\n\"\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n}\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\n/>\n<\nLabel\n>\n{\nplan\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n</\nFieldset\n>\n<\nbutton\n>\nSubmit\n</\nbutton\n>\n</\nform\n>\n)\n}\nThis lets you use a radio group inside a native HTML\n<form>\nand make traditional form submissions as if your radio\ngroup was a native HTML form control.\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like\nobjects will be encoded into multiple inputs using square bracket notation for the names.\n<!-- Rendered hidden input -->\n<\ninput\ntype\n=\n\"\nhidden\n\"\nname\n=\n\"\nplan\n\"\nvalue\n=\n\"\nstartup\n\"\n/>\nUsing as uncontrolled\nIf you omit the\nvalue\nprop, Headless UI will track its state internally for you, allowing you to use it as an\nuncontrolled component\n.\nWhen uncontrolled, use the\ndefaultValue\nprop to provide an initial value to the\nRadioGroup\n.\nimport\n{\nuseState\n}\nfrom\n'react'\nimport\n{\nRadioGroup\n,\nRadio\n,\nFieldset\n,\nLegend\n,\nField\n,\nLabel\n}\nfrom\n'@headlessui/react'\nconst\nplans\n=\n[\n'Startup'\n,\n'Business'\n,\n'Enterprise'\n]\nfunction\nExample\n(\n)\n{\nreturn\n(\n<\nform\naction\n=\n\"\n/plans\n\"\nmethod\n=\n\"\npost\n\"\n>\n<\nFieldset\n>\n<\nLegend\n>\nServer size\n</\nLegend\n>\n<\nRadioGroup\nname\n=\n\"\nplan\n\"\ndefaultValue\n=\n{\nplans\n[\n0\n]\n}\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n}\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\n/>\n<\nLabel\n>\n{\nplan\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n</\nFieldset\n>\n</\nform\n>\n)\n}\nThis can simplify your code when using the combobox\nwith HTML forms\nor with form APIs that\ncollect their state using\nFormData\ninstead of tracking it\nusing React state.\nAny\nonChange\nprop you provide will still be called when the component's value changes in case you need to run any side\neffects, but you won't need to use it to track the component's state yourself.\nBinding objects as values\nUnlike native HTML form controls, which only allow you to provide strings as values, Headless UI supports binding\ncomplex objects as well.\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Startup'\n,\navailable\n:\ntrue\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Business'\n,\navailable\n:\ntrue\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Enterprise'\n,\navailable\n:\nfalse\n}\n,\n]\nfunction\nExample\n(\n)\n{\nconst\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n.\nid\n}\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\ndisabled\n=\n{\n!\nplan\n.\navailable\n}\n/>\n<\nLabel\n>\n{\nplan\n.\nname\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nWhen binding objects as values, it's important to make sure that you use the\nsame instance\nof the object as both the\nvalue\nof the\nRadioGroup\nas well as the corresponding\nRadio\n, otherwise they will fail to be equal and cause the\nradio group to behave incorrectly.\nTo make it easier to work with different instances of the same object, you can use the\nby\nprop to compare the objects\nby a particular field instead of comparing by object identity.\nWhen you pass an object to the\nvalue\nprop,\nby\nwill default to\nid\nwhen present, but you can set it to any field you\nlike:\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nname\n:\n'Startup'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Business'\n,\navailable\n:\ntrue\n}\n,\n{\nname\n:\n'Enterprise'\n,\navailable\n:\nfalse\n}\n,\n]\nfunction\nExample\n(\n)\n{\nconst\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nby\n=\n\"\nname\n\"\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n.\nid\n}\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\ndisabled\n=\n{\n!\nplan\n.\navailable\n}\n/>\n<\nLabel\n>\n{\nplan\n.\nname\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nYou can also pass your own comparison function to the\nby\nprop if you'd like complete control over how objects are\ncompared:\nimport\n{\nField\n,\nLabel\n,\nRadio\n,\nRadioGroup\n}\nfrom\n'@headlessui/react'\nimport\n{\nuseState\n}\nfrom\n'react'\nconst\nplans\n=\n[\n{\nid\n:\n1\n,\nname\n:\n'Startup'\n,\navailable\n:\ntrue\n}\n,\n{\nid\n:\n2\n,\nname\n:\n'Business'\n,\navailable\n:\ntrue\n}\n,\n{\nid\n:\n3\n,\nname\n:\n'Enterprise'\n,\navailable\n:\nfalse\n}\n,\n]\nfunction\ncomparePlans\n(\na\n,\nb\n)\n{\nreturn\na\n.\nname\n.\ntoLowerCase\n(\n)\n===\nb\n.\nname\n.\ntoLowerCase\n(\n)\n}\nfunction\nExample\n(\n)\n{\nconst\n[\nselected\n,\nsetSelected\n]\n=\nuseState\n(\nplans\n[\n0\n]\n)\nreturn\n(\n<\nRadioGroup\nvalue\n=\n{\nselected\n}\nby\n=\n{\ncomparePlans\n}\nonChange\n=\n{\nsetSelected\n}\naria-label\n=\n\"\nServer size\n\"\n>\n{\nplans\n.\nmap\n(\n(\nplan\n)\n=>\n(\n<\nField\nkey\n=\n{\nplan\n.\nid\n}\n>\n<\nRadio\nvalue\n=\n{\nplan\n}\ndisabled\n=\n{\n!\nplan\n.\navailable\n}\n/>\n<\nLabel\n>\n{\nplan\n.\nname\n}\n</\nLabel\n>\n</\nField\n>\n)\n)\n}\n</\nRadioGroup\n>\n)\n}\nKeyboard interaction\nAll interactions apply when a\nRadio\ncomponent is focused.\nCommand\nDescription\nArrowDown\nor\nArrowUp\nor\nArrowLeft\nor\nArrowRight\nCycles through a\nRadioGroup\n's options\nSpace\nwhen no option is selected yet\nSelects the focused option\nEnter\nwhen in a form\nSubmits the form\nComponent API\nRadioGroup\nThe main radio group component.\nProp\nDefault\nDescription\nas\ndiv\nString | Component\nThe element or component the\nradio group\nshould render as.\nvalue\n\u2014\nT | undefined\nThe current selected value in the\nRadioGroup\n.\ndefaultValue\n\u2014\nT\nThe default value when using as an uncontrolled component.\nby\n\u2014\nkeyof T | ((a: T, z: T) => boolean)\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\nWhen you pass an object to the\nvalue\nprop,\nby\nwill default to\nid\nwhen present.\nonChange\n\u2014\n(value: T) => void\nThe function called to update the\nRadioGroup\nvalue.\ndisabled\nfalse\nboolean\nUse this to disable the radio group and all of its radios.\nname\n\u2014\nString\nThe name used when using the\nradio group\ninside a form.\nform\n\u2014\nString\nThe id of the form that the\nradio group\nbelongs to.\nIf\nname\nis provided but\nform\nis not, the\nradio group\nwill add its state to the nearest ancestor\nform\nelement.\nData Attribute\nRender Prop\nDescription\n\u2014\nvalue\nT\nThe selected value.\nRadio\nThe component for each selectable option.\nProp\nDefault\nDescription\nas\nspan\nString | Component\nThe element or component the\nradio\nshould render as.\nvalue\n\u2014\nT | undefined\nThe value of this\nRadio\n. The type should match the type of the\nvalue\nin the\nRadioGroup\ncomponent.\ndisabled\nfalse\nBoolean\nWhether or not the\nradio\nis disabled\n.\nautoFocus\nfalse\nBoolean\nWhether or not the\nradio\nshould receive focus when first rendered.\nData Attribute\nRender Prop\nDescription\ndata-\nchecked\nchecked\nBoolean\nWhether or not the\nradio\nis checked.\ndata-\ndisabled\ndisabled\nBoolean\nWhether or not the\nradio\nis disabled.\ndata-\nfocus\nfocus\nBoolean\nWhether or not the\nradio\nis focused.\ndata-\nhover\nhover\nBoolean\nWhether or not the\nradio\nis hovered.\ndata-\nautofocus\nautofocus\nBoolean\nWhether or not the\nautoFocus\nprop was set to\ntrue\n.\nStyled examples\nIf you're interested in predesigned\nTailwind CSS\nradio group\nexamples\nusing Headless UI\n, check out\nTailwind Plus\n\u2014 a collection of beautifully designed and expertly crafted components built by us.\nIt's a great way to support our work on open-source projects like this and makes it possible for us to improve them and keep them well-maintained.\nExplore\nmore predesigned\nexamples \u2192\nOn this page",
  "content_markdown": "React\n\n[Vue](/v1/vue/radio-group)\n\n# Radio Group\n\nRadio groups give you the same functionality as native HTML radio inputs, without any of the styling. They're perfect\nfor building out custom UIs for selectors.\n\nPreviewCode\n\n## Installation\n\nTo get started, install Headless UI via npm:\n\n```\nnpm install @headlessui/react\n```\n\n## Basic example\n\nRadio groups are built using the `RadioGroup`, `Radio`, `Field`, and `Label` components.\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = ['Startup', 'Business', 'Enterprise']\n\nfunction Example() {\n  let [selected, setSelected] = useState(plans[0])\n\n  return (\n    <RadioGroup value={selected} onChange={setSelected} aria-label=\"Server size\">\n      {plans.map((plan) => (\n        <Field key={plan} className=\"flex items-center gap-2\">\n          <Radio\n            value={plan}\n            className=\"group flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400\"\n          >\n            <span className=\"invisible size-2 rounded-full bg-white group-data-checked:visible\" />\n          </Radio>\n          <Label>{plan}</Label>\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\n## Styling\n\nHeadless UI keeps track of a lot of state about each component, like which radio group option is currently checked,\nwhether a popover is open or closed, or which item in a menu is currently focused via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your\nUI until you provide the styles you want for each state yourself.\n\n### Using data attributes\n\nThe easiest way to style the different states of a Headless UI component is using the `data-*` attributes that each\ncomponent exposes.\n\nFor example, the `Radio` component exposes a `data-checked` attribute, which tells you if the radio is currently\nchecked, and a `data-disabled` attribute, which tells you if the radio is currently disabled.\n\n```\n<!-- Rendered `Radio` -->\n<span role=\"radio\" data-checked data-disabled>\n  <!-- ... -->\n</span>\n```\n\nUse the [CSS attribute selector](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors) to conditionally\napply styles based on the presence of these data attributes. If you're using Tailwind CSS, the\n[data attribute modifier](https://tailwindcss.com/docs/hover-focus-and-other-states#data-attributes) makes this easy:\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = [\n  { name: 'Startup', available: true },\n  { name: 'Business', available: true },\n  { name: 'Enterprise', available: false },\n]\n\nfunction Example() {\n  let [selected, setSelected] = useState(plans[0])\n\n  return (\n    <RadioGroup value={selected} onChange={setSelected} aria-label=\"Server size\">\n      {plans.map((plan) => (\n        <Field key={plan.name} disabled={!plan.available} className=\"flex items-center gap-2\">\n          <Radio\n            value={plan}\n\nclassName=\"group flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400 data-disabled:bg-gray-100\"\n\n>\n\n<span className=\"invisible size-2 rounded-full bg-white group-data-checked:visible\" />\n\n          </Radio>\n\n<Label className=\"data-disabled:opacity-50\">{plan.name}</Label>\n\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\n### Using render props\n\nEach component also exposes information about its current state via\n[render props](https://reactjs.org/docs/render-props.html) that you can use to conditionally apply different styles or\nrender different content.\n\nFor example, the `Radio` component exposes a `checked` state, which tells you if the radio is currently checked, and a\n`disabled` state, which tells you if the radio is currently disabled.\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport clsx from 'clsx'\nimport { Fragment, useState } from 'react'\n\nconst plans = [\n  { name: 'Startup', available: true },\n  { name: 'Business', available: true },\n  { name: 'Enterprise', available: false },\n]\n\nfunction Example() {\n  let [selected, setSelected] = useState(plans[0])\n\n  return (\n    <RadioGroup value={selected} onChange={setSelected} aria-label=\"Server size\">\n      {plans.map((plan) => (\n        <Field key={plan.name} disabled={!plan.available} className=\"flex items-center gap-2\">\n\n<Radio as={Fragment} value={plan}>\n\n{({ checked, disabled }) => (\n\n<span\n                className={clsx(\n                  'group flex size-5 items-center justify-center rounded-full border',\n\nchecked ? 'bg-blue-400' : 'bg-white',\n\ndisabled && 'bg-gray-100'\n\n)}\n              >\n\n{checked && <span className=\"size-2 rounded-full bg-white\" />}\n\n              </span>\n            )}\n          </Radio>\n\n<Label as={Fragment}>\n\n{({ disabled }) => <label className={disabled && 'opacity-50'}>{plan.name}</label>}\n\n</Label>\n\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\nSee the [component API](#component-api) for a list of all the available render props.\n\n## Examples\n\n### Adding a description\n\nUse the `Description` component within a `Field` to automatically associate it with a `Radio` using the\n`aria-describedby` attribute:\n\n```\nimport { Description, Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = [\n\n{ name: 'Startup', description: '12GB, 6 CPUs, 256GB SSD disk' },\n\n{ name: 'Business', description: '16GB, 8 CPUs, 512GB SSD disk' },\n\n{ name: 'Enterprise', description: '32GB, 12 CPUs, 1TB SSD disk' },\n\n]\n\nfunction Example() {\n  let [selected, setSelected] = useState(plans[0])\n\n  return (\n    <RadioGroup value={selected} onChange={setSelected} aria-label=\"Server size\">\n      {plans.map((plan) => (\n        <Field key={plan} className=\"flex items-baseline gap-2\">\n          <Radio\n            value={plan}\n            className=\"group flex size-5 items-center justify-center rounded-full border bg-white data-checked:bg-blue-400\"\n          >\n            <span className=\"invisible size-2 rounded-full bg-white group-data-checked:visible\" />\n          </Radio>\n          <div>\n            <Label>{plan.name}</Label>\n\n<Description className=\"opacity-50\">{plan.description}</Description>\n\n          </div>\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\n### Using with HTML forms\n\nIf you add the `name` prop to your `RadioGroup`, a hidden `input` element will be rendered and kept in sync with the\nradio group state.\n\n```\nimport { Field, Fieldset, Label, Legend, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = ['Startup', 'Business', 'Enterprise']\n\nfunction Example() {\n  const [selected, setSelected] = useState(plans[0])\n\n  return (\n\n<form action=\"/plans\" method=\"post\">\n\n      <Fieldset>\n        <Legend>Server size</Legend>\n\n<RadioGroup name=\"plan\" value={selected} onChange={setSelected}>\n\n          {plans.map((plan) => (\n            <Field key={plan}>\n              <Radio value={plan} />\n              <Label>{plan}</Label>\n            </Field>\n          ))}\n        </RadioGroup>\n      </Fieldset>\n      <button>Submit</button>\n\n</form>\n\n)\n}\n```\n\nThis lets you use a radio group inside a native HTML `<form>` and make traditional form submissions as if your radio\ngroup was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like\nobjects will be encoded into multiple inputs using square bracket notation for the names.\n\n```\n<!-- Rendered hidden input -->\n<input type=\"hidden\" name=\"plan\" value=\"startup\" />\n```\n\n### Using as uncontrolled\n\nIf you omit the `value` prop, Headless UI will track its state internally for you, allowing you to use it as an\n[uncontrolled component](https://reactjs.org/docs/uncontrolled-components.html).\n\nWhen uncontrolled, use the `defaultValue` prop to provide an initial value to the `RadioGroup`.\n\n```\nimport { useState } from 'react'\nimport { RadioGroup, Radio, Fieldset, Legend, Field, Label } from '@headlessui/react'\n\nconst plans = ['Startup', 'Business', 'Enterprise']\n\nfunction Example() {\n  return (\n    <form action=\"/plans\" method=\"post\">\n      <Fieldset>\n        <Legend>Server size</Legend>\n\n<RadioGroup name=\"plan\" defaultValue={plans[0]}>\n\n          {plans.map((plan) => (\n            <Field key={plan}>\n              <Radio value={plan} />\n              <Label>{plan}</Label>\n            </Field>\n          ))}\n        </RadioGroup>\n      </Fieldset>\n    </form>\n  )\n}\n```\n\nThis can simplify your code when using the combobox [with HTML forms](#using-with-html-forms) or with form APIs that\ncollect their state using [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) instead of tracking it\nusing React state.\n\nAny `onChange` prop you provide will still be called when the component's value changes in case you need to run any side\neffects, but you won't need to use it to track the component's state yourself.\n\n### Binding objects as values\n\nUnlike native HTML form controls, which only allow you to provide strings as values, Headless UI supports binding\ncomplex objects as well.\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = [\n\n{ id: 1, name: 'Startup', available: true },\n\n{ id: 2, name: 'Business', available: true },\n\n{ id: 3, name: 'Enterprise', available: false },\n\n]\n\nfunction Example() {\n  const [selected, setSelected] = useState(plans[0])\n\n  return (\n\n<RadioGroup value={selected} onChange={setSelected} aria-label=\"Server size\">\n\n      {plans.map((plan) => (\n        <Field key={plan.id}>\n\n<Radio value={plan} disabled={!plan.available} />\n\n          <Label>{plan.name}</Label>\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\nWhen binding objects as values, it's important to make sure that you use the *same instance* of the object as both the\n`value` of the `RadioGroup` as well as the corresponding `Radio`, otherwise they will fail to be equal and cause the\nradio group to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the `by` prop to compare the objects\nby a particular field instead of comparing by object identity.\n\nWhen you pass an object to the `value` prop, `by` will default to `id` when present, but you can set it to any field you\nlike:\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = [\n  { name: 'Startup', available: true },\n  { name: 'Business', available: true },\n  { name: 'Enterprise', available: false },\n]\n\nfunction Example() {\n  const [selected, setSelected] = useState(plans[0])\n\n  return (\n\n<RadioGroup value={selected} by=\"name\" onChange={setSelected} aria-label=\"Server size\">\n\n      {plans.map((plan) => (\n        <Field key={plan.id}>\n          <Radio value={plan} disabled={!plan.available} />\n          <Label>{plan.name}</Label>\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\nYou can also pass your own comparison function to the `by` prop if you'd like complete control over how objects are\ncompared:\n\n```\nimport { Field, Label, Radio, RadioGroup } from '@headlessui/react'\nimport { useState } from 'react'\n\nconst plans = [\n\n{ id: 1, name: 'Startup', available: true },\n\n{ id: 2, name: 'Business', available: true },\n\n{ id: 3, name: 'Enterprise', available: false },\n\n]\n\nfunction comparePlans(a, b) {\n\nreturn a.name.toLowerCase() === b.name.toLowerCase()\n\n}\n\nfunction Example() {\n  const [selected, setSelected] = useState(plans[0])\n\n  return (\n\n<RadioGroup value={selected} by={comparePlans} onChange={setSelected} aria-label=\"Server size\">\n\n      {plans.map((plan) => (\n        <Field key={plan.id}>\n          <Radio value={plan} disabled={!plan.available} />\n          <Label>{plan.name}</Label>\n        </Field>\n      ))}\n    </RadioGroup>\n  )\n}\n```\n\n## Keyboard interaction\n\nAll interactions apply when a `Radio` component is focused.\n\n|  |  |\n| --- | --- |\n| Command | Description |\n| `ArrowDown` or `ArrowUp` or `ArrowLeft` or `ArrowRight` | Cycles through a `RadioGroup`'s options |\n| `Space`when no option is selected yet | Selects the focused option |\n| `Enter`when in a form | Submits the form |\n\n## Component API\n\n### RadioGroup\n\nThe main radio group component.\n\n|  |  |  |\n| --- | --- | --- |\n| Prop | Default | Description |\n| `as` | `div` | `String | Component`  The element or component the radio group should render as. |\n| `value` | \u2014 | `T | undefined`  The current selected value in the `RadioGroup`. |\n| `defaultValue` | \u2014 | `T`  The default value when using as an uncontrolled component. |\n| `by` | \u2014 | `keyof T | ((a: T, z: T) => boolean)`  Use this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.  When you pass an object to the `value` prop, `by` will default to`id` when present. |\n| `onChange` | \u2014 | `(value: T) => void`  The function called to update the `RadioGroup` value. |\n| `disabled` | `false` | `boolean`  Use this to disable the radio group and all of its radios. |\n| `name` | \u2014 | `String`  The name used when using the radio group inside a form. |\n| `form` | \u2014 | `String`  The id of the form that the radio group belongs to.  If `name` is provided but `form` is not, the radio group will add its state to the nearest ancestor `form` element. |\n\n|  |  |  |\n| --- | --- | --- |\n| Data Attribute | Render Prop | Description |\n| \u2014 | `value` | `T`  The selected value. |\n\n### Radio\n\nThe component for each selectable option.\n\n|  |  |  |\n| --- | --- | --- |\n| Prop | Default | Description |\n| `as` | `span` | `String | Component`  The element or component the radio should render as. |\n| `value` | \u2014 | `T | undefined`  The value of this `Radio`. The type should match the type of the `value` in the `RadioGroup` component. |\n| `disabled` | `false` | `Boolean`  Whether or not the radio is disabled. |\n| `autoFocus` | `false` | `Boolean`  Whether or not the radio should receive focus when first rendered. |\n\n|  |  |  |\n| --- | --- | --- |\n| Data Attribute | Render Prop | Description |\n| `data-checked` | `checked` | `Boolean`  Whether or not the radio is checked. |\n| `data-disabled` | `disabled` | `Boolean`  Whether or not the radio is disabled. |\n| `data-focus` | `focus` | `Boolean`  Whether or not the radio is focused. |\n| `data-hover` | `hover` | `Boolean`  Whether or not the radio is hovered. |\n| `data-autofocus` | `autofocus` | `Boolean`  Whether or not the `autoFocus` prop was set to `true`. |\n\n## Styled examples\n\nIf you're interested in predesigned [Tailwind CSS radio group examples](https://tailwindui.com/components/application-ui/forms/radio-groups) using Headless UI, check out **Tailwind Plus** \u2014 a collection of beautifully designed and expertly crafted components built by us.\n\nIt's a great way to support our work on open-source projects like this and makes it possible for us to improve them and keep them well-maintained.\n\n[Explore more predesigned examples \u2192](https://tailwindcss.com/plus)\n\n[![Various components from Tailwind UI](/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftailwind-plus.434a3ca6.png&w=3840&q=75)](https://tailwindcss.com/plus)\n\nOn this page",
  "tags": [
    "headless",
    "tailwind",
    "react",
    "vue",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T14:47:36.441798+00:00",
  "content_length": 13833,
  "content_hash": "20deb1932f5a53b8"
}