{
  "id": "floating-ui__docs_shift",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/shift",
  "title": "shift",
  "content": "shift\nShifts the floating element to keep it in view.\nVisibility Optimizer\nimport\n{\nshift\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nThis prevents the floating element from overflowing along its\naxis of alignment, thereby preserving the side it\u2019s placed on.\nScroll horizontally\nUsage\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nshift\n()\n],\n})\n;\nOptions\nThese are the options you can pass to\nshift\n()\n.\ninterface\nShiftOptions\nextends\nDetectOverflowOptions\n{\nmainAxis\n?:\nboolean\n;\ncrossAxis\n?:\nboolean\n;\nlimiter\n?:\n{\nfn\n:\n(\nstate\n:\nMiddlewareState\n)\n=>\nCoords\n;\noptions\n?:\nany\n;\n}\n;\n}\nmainAxis\ndefault:\ntrue\nThis is the main axis in which shifting is applied.\nx\n-axis for\n'\ntop\n'\nand\n'\nbottom\n'\nplacements\ny\n-axis for\n'\nleft\n'\nand\n'\nright\n'\nplacements\nshift\n({\nmainAxis\n:\nfalse\n,\n})\n;\nScroll horizontally\nA floating element that does not shift along the x-axis\ncrossAxis\ndefault:\nfalse\nThis is the cross axis in which shifting is applied, the opposite\naxis of\nmainAxis\n.\nEnabling this can lead to the floating element\noverlapping\nthe reference element, which may not be desired and is often\nreplaced by the\nflip\n()\nmiddleware.\nshift\n({\ncrossAxis\n:\ntrue\n,\n})\n;\nScroll down\nlimiter\ndefault: no-op\nThis accepts a function that\nlimits\nthe shifting done, in\norder to prevent detachment or \u201coverly-eager\u201d behavior. The\nbehavior is to stop shifting once the opposite edges of the\nelements are aligned.\nimport\n{\nshift\n,\nlimitShift\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nshift\n({\nlimiter\n:\nlimitShift\n()\n,\n})\n;\nThis function itself takes options.\nlimitShift.mainAxis\ndefault:\ntrue\nWhether to apply limiting on the main axis.\nshift\n({\nlimiter\n:\nlimitShift\n({\nmainAxis\n:\nfalse\n,\n})\n,\n})\n;\nlimitShift.crossAxis\ndefault:\ntrue\nWhether to apply limiting on the cross axis.\nshift\n({\nlimiter\n:\nlimitShift\n({\ncrossAxis\n:\nfalse\n,\n})\n,\n})\n;\nlimitShift.offset\ndefault:\n0\nThis will offset when the limiting starts. A positive number will\nstart limiting earlier, while negative later.\nshift\n({\nlimiter\n:\nlimitShift\n({\n// Start limiting 5px earlier\noffset\n:\n5\n,\n})\n,\n})\n;\nThis can also take a function, which provides the\nRect\ns of each element to read their dimensions:\nshift\n({\nlimiter\n:\nlimitShift\n({\n// Start limiting by the reference's width earlier\noffset\n:\n(\n{\nrects\n,\nplacement\n}\n)\n=>\nrects\n.\nreference\n.\nwidth\n,\n})\n,\n})\n;\nYou may also pass an object to configure both axes:\nshift\n({\nlimiter\n:\nlimitShift\n({\n// object\noffset\n:\n{\nmainAxis\n:\n10\n,\ncrossAxis\n:\n5\n,\n}\n,\n// or a function which returns one\noffset\n:\n(\n{\nrects\n,\nplacement\n}\n)\n=>\n({\nmainAxis\n:\nrects\n.\nreference\n.\nheight\n,\ncrossAxis\n:\nrects\n.\nfloating\n.\nwidth\n,\n})\n,\n})\n,\n})\n;\n\u2026detectOverflowOptions\nAll of\ndetectOverflow\n\u2019s options\ncan be passed. For instance:\nshift\n({\npadding\n:\n5\n,\n// 0 by default\n})\n;\nIf you find the padding does not get applied on the right side,\nsee\nHandling large content\n.\nDeriving options from state\nYou can derive the options from the\nmiddleware lifecycle state\n:\nshift\n((\nstate\n)\n=>\n({\npadding\n:\nstate\n.\nrects\n.\nreference\n.\nwidth\n,\n}))\n;\nData\nThe following data is available in\nmiddlewareData\n.\nshift\n:\ninterface\nData\n{\nx\n:\nnumber\n;\ny\n:\nnumber\n;\n}\nx\nand\ny\nrepresent how much the floating element\nhas been shifted along that axis. The values are offsets, and\ntherefore can be negative.",
  "content_markdown": "# shift\n\nShifts the floating element to keep it in view.\n\n*Visibility Optimizer*\n\n```\nimport {shift} from '@floating-ui/dom';\n```\n\nThis prevents the floating element from overflowing along its\naxis of alignment, thereby preserving the side it\u2019s placed on.\n\nScroll horizontally\n\n## [Usage](#usage)\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [shift()],\n});\n```\n\n## [Options](#options)\n\nThese are the options you can pass to `shift()`.\n\n```\ninterface ShiftOptions extends DetectOverflowOptions {\n  mainAxis?: boolean;\n  crossAxis?: boolean;\n  limiter?: {\n    fn: (state: MiddlewareState) => Coords;\n    options?: any;\n  };\n}\n```\n\n### [`mainAxis`](#mainaxis)\n\ndefault: `true`\n\nThis is the main axis in which shifting is applied.\n\n- `x`-axis for `'top'` and `'bottom'` placements\n- `y`-axis for `'left'` and `'right'` placements\n\n```\nshift({\n  mainAxis: false,\n});\n```\n\nScroll horizontally\n\nA floating element that does not shift along the x-axis\n\n### [`crossAxis`](#crossaxis)\n\ndefault: `false`\n\nThis is the cross axis in which shifting is applied, the opposite\naxis of `mainAxis`.\n\nEnabling this can lead to the floating element **overlapping**\nthe reference element, which may not be desired and is often\nreplaced by the `flip()` middleware.\n\n```\nshift({\n  crossAxis: true,\n});\n```\n\nScroll down\n\n### [`limiter`](#limiter)\n\ndefault: no-op\n\nThis accepts a function that **limits** the shifting done, in\norder to prevent detachment or \u201coverly-eager\u201d behavior. The\nbehavior is to stop shifting once the opposite edges of the\nelements are aligned.\n\n```\nimport {shift, limitShift} from '@floating-ui/dom';\n```\n\n```\nshift({\n  limiter: limitShift(),\n});\n```\n\nThis function itself takes options.\n\n#### [limitShift.mainAxis](#limitshiftmainaxis)\n\ndefault: `true`\n\nWhether to apply limiting on the main axis.\n\n```\nshift({\n  limiter: limitShift({\n    mainAxis: false,\n  }),\n});\n```\n\n#### [limitShift.crossAxis](#limitshiftcrossaxis)\n\ndefault: `true`\n\nWhether to apply limiting on the cross axis.\n\n```\nshift({\n  limiter: limitShift({\n    crossAxis: false,\n  }),\n});\n```\n\n#### [limitShift.offset](#limitshiftoffset)\n\ndefault: `0`\n\nThis will offset when the limiting starts. A positive number will\nstart limiting earlier, while negative later.\n\n```\nshift({\n  limiter: limitShift({\n    // Start limiting 5px earlier\n    offset: 5,\n  }),\n});\n```\n\nThis can also take a function, which provides the\n`Rect`s of each element to read their dimensions:\n\n```\nshift({\n  limiter: limitShift({\n    // Start limiting by the reference's width earlier\n    offset: ({rects, placement}) => rects.reference.width,\n  }),\n});\n```\n\nYou may also pass an object to configure both axes:\n\n```\nshift({\n  limiter: limitShift({\n    // object\n    offset: {\n      mainAxis: 10,\n      crossAxis: 5,\n    },\n    // or a function which returns one\n    offset: ({rects, placement}) => ({\n      mainAxis: rects.reference.height,\n      crossAxis: rects.floating.width,\n    }),\n  }),\n});\n```\n\n### [\u2026detectOverflowOptions](#detectoverflowoptions)\n\nAll of [`detectOverflow`](/docs/detectOverflow#options)\u2019s options\ncan be passed. For instance:\n\n```\nshift({\n  padding: 5, // 0 by default\n});\n```\n\nIf you find the padding does not get applied on the right side,\nsee [Handling large content](/docs/misc#handling-large-content).\n\n### [Deriving options from state](#deriving-options-from-state)\n\nYou can derive the options from the\n[middleware lifecycle state](/docs/middleware#middlewarestate):\n\n```\nshift((state) => ({\n  padding: state.rects.reference.width,\n}));\n```\n\n## [Data](#data)\n\nThe following data is available in `middlewareData.shift`:\n\n```\ninterface Data {\n  x: number;\n  y: number;\n}\n```\n\n`x` and `y` represent how much the floating element\nhas been shifted along that axis. The values are offsets, and\ntherefore can be negative.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:29.246529+00:00",
  "content_length": 3249,
  "content_hash": "05620876c6ec53af"
}