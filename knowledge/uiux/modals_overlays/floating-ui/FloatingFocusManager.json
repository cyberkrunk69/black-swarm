{
  "id": "floating-ui__docs_FloatingFocusManager",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/FloatingFocusManager",
  "title": "FloatingFocusManager",
  "content": "Floating\nFocus\nManager\nProvides flexible modal or non-modal focus management for a\nfloating element. Modal behavior is the default \u2014 focus is fully\ntrapped inside the floating element while it is rendered.\nimport\n{\nFloatingFocusManager\n}\nfrom\n'\n@floating-ui/react\n'\n;\nThis is necessary to ensure that focus is properly managed for\nkeyboard interaction.\nThis component should only be rendered when the floating element\nis open and directly wrap it.\nfunction\nApp\n()\n{\nconst\n{\ncontext\n}\n=\nuseFloating\n()\n;\nreturn\n(\n<>\n{\n/* reference element */\n}\n{\nisOpen\n&&\n(\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\n)\n}\n</>\n)\n;\n}\nProps\ninterface\nFloatingFocusManagerProps\n{\ncontext\n:\nFloatingContext\n;\ndisabled\n?:\nboolean\n;\ninitialFocus\n?:\n|\nnumber\n|\nReact\n.\nMutableRefObject\n<\nHTMLElement\n|\nnull\n>;\nreturnFocus\n?:\n|\nboolean\n|\nReact\n.\nMutableRefObject\n<\nHTMLElement\n|\nnull\n>;\nrestoreFocus\n?:\nboolean\n;\nguards\n?:\nboolean\n;\nmodal\n?:\nboolean\n;\nvisuallyHiddenDismiss\n?:\nboolean\n|\nstring\n;\ncloseOnFocusOut\n?:\nboolean\n;\noutsideElementsInert\n?:\nboolean\n;\ngetInsideElements\n?:\n()\n=>\nElement\n[];\norder\n?:\nArray\n<\n'\nreference\n'\n|\n'\nfloating\n'\n|\n'\ncontent\n'\n>;\n}\ncontext\nRequired\nThe\ncontext\nobject returned from\nuseFloating\n()\nor\nuseFloatingRootContext\n.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\ndisabled\ndefault:\nfalse\nDisables all focus management entirely. Useful to delay focus\nmanagement until after a transition completes or some other\nconditional state.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ndisabled\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\ninitialFocus\ndefault:\n0\nWhich element to initially focus. Can be either a number\n(tabbable index as specified by the\norder\n) or a ref.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ninitialFocus\n={\nelementRef\n}\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nNegative number\nYou can set this to a negative number to ignore the initial\nfocus. This is required to prevent conflicts if your floating\nelement has no tabbable content and is instead controlled by the\nuseListNavigation\n()\nHook which has its own focus\nmanagement.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ninitialFocus\n={-\n1\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nIf there is no list navigation, then\nmodal\nbehavior\u2019s focus trap will no longer work. To maintain the trap,\nyou can place the initial focus on the floating element:\nconst\n{\ncontext\n,\nrefs\n}\n=\nuseFloating\n()\n;\nreturn\n(\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ninitialFocus\n={\nrefs\n.\nfloating\n}\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\n)\n;\nreturnFocus\ndefault:\ntrue\nDetermines if focus should be returned to the reference element\n(or if that is not available, the previously focused element).\nThis prop is ignored if the floating element lost focus. It can\nbe also set to a ref to explicitly control the element to return\nfocus to.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nreturnFocus\n={\nfalse\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nrestoreFocus\ndefault:\nfalse\nDetermines if focus should be restored to the nearest tabbable\nelement if the currently focused element inside the floating\nelement was removed from the DOM (causing focus to be lost\notherwise).\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nrestoreFocus\n={\ntrue\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nguards\ndefault:\ntrue\nDetermines if the focus guards are rendered. If not, focus can\nescape into the address bar/console/browser UI, like in native\ndialogs.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nguards\n={\nfalse\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nmodal\ndefault:\ntrue\nDetermines if focus is \u201cmodal\u201d, meaning focus is fully trapped\ninside the floating element and outside content cannot be\naccessed. This includes screen reader virtual cursors.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nmodal\n={\nfalse\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nNon-modal behavior\nThe floating element should be rendered after the reference\nelement in the React tree. It can be portaled using\n<\nFloatingPortal\n>\n. Other portal solutions are not supported\nor accessible when using Floating UI\u2019s focus manager.\nModal behavior\nEnsure you have an explicit \u201cclose\u201d button. This can be either\nvisible to all users, or visually-hidden so it is only available\nto assistive tech (see\nvisuallyHiddenDismiss\n).\nTouch-based screen readers often will not have an\nesc\nkey\navailable to dismiss the element, so an explicit close button is\nrequired, otherwise the user will be trapped in the floating\nelement if they don\u2019t want to select anything (thus needing to\nreload the page).\nComboboxes\nWhen the reference element has a\ncombobox\nrole\npresent, the focus manager behavior changes.\nThe listbox part (floating element) of a combobox (input +\nlistbox popup) can be portaled and accessible to touch screen\nreaders when using modal focus management, but DOM focus does not\nbecome modal. Screen reader virtual cursors do become modal,\nallowing a touch screen reader to immediately access the portaled\nlistbox items.\nvisuallyHiddenDismiss\ndefault:\nfalse\nIf your focus management is modal and there is no explicit close\nbutton available, you can use this prop to render a\nvisually-hidden dismiss button at the start and end of the\nfloating element. This allows touch-based screen readers to\nescape the floating element due to lack of an\nesc\nkey.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nvisuallyHiddenDismiss\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nYou can pass a string which will be announced by the screen\nreader, e.g. for languages other than English. The default string\nwhen using\ntrue\nis\nDismiss\n.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\nvisuallyHiddenDismiss\n=\n\"\nDismiss popup\n\"\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\ncloseOnFocusOut\ndefault:\ntrue\nDetermines whether\nfocusout\nevent listeners that\ncontrol whether the floating element should be closed if the\nfocus moves outside of it are attached to the reference and\nfloating elements. This affects non-modal focus management.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ncloseOnFocusOut\n={\nfalse\n}>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\noutsideElementsInert\ndefault:\nfalse\nDetermines whether outside elements are\ninert\nwhen\nmodal\nis enabled. This enables pointer modality\nwithout a backdrop.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\noutsideElementsInert\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\ngetInsideElements\nDetermines which elements are considered inside the floating\nelement when it\u2019s rendered. Such elements will avoid being marked\nwith\naria-hidden\nand\ndata-floating-ui-inert\nattributes.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\ngetInsideElements\n={\n()\n=>\nArray\n.\nfrom\n(\ndocument\n.\nquerySelectorAll\n(\n'\n.inside\n'\n))\n}\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\norder\ndefault:\n[\n'\ncontent\n'\n]\nThe order in which focus cycles.\n<\nFloatingFocusManager\ncontext\n={\ncontext\n}\n// Initially focuses the floating element. Subsequent tabs\n// will cycle through the tabbable contents of the floating\n// element.\norder\n={[\n'\nfloating\n'\n,\n'\ncontent\n'\n]}\n// Keeps focus on the reference element. Subsequent tabs\n// will cycle through the tabbable contents of the floating\n// element.\norder\n={[\n'\nreference\n'\n,\n'\ncontent\n'\n]}\n>\n{\n/* floating element */\n}\n</\nFloatingFocusManager\n>\nTroubleshooting\nPage scrolls to top when opening the floating element\nThis can happen if you\u2019re placing the\nautoFocus\nprop\non an element inside the floating element. This is because the\nfloating element is initially rendered at the top-left of the\npage, and the browser scrolls to it when it receives focus.\nInstead, use the\ninitialFocus\nprop on\n<\nFloatingFocusManager\n>\nto focus the desired element, which\nwaits for the position to be ready first.\nUsage with\n<\nFloatingPortal\n>\nEnsure the focus manager is rendered as a child (can be a nested\ndescendant) of\n<\nFloatingPortal\n>\n.\nIf you\u2019re using non-modal focus management, you must use\n<\nFloatingPortal\n>\nand not another portal solution. This is\nbecause it tightly integrates with the focus manager to ensure\nthat focus is moved correctly when tabbing, including the\nVoiceOver virtual cursor.",
  "content_markdown": "# FloatingFocusManager\n\nProvides flexible modal or non-modal focus management for a\nfloating element. Modal behavior is the default \u2014 focus is fully\ntrapped inside the floating element while it is rendered.\n\n```\nimport {FloatingFocusManager} from '@floating-ui/react';\n```\n\nThis is necessary to ensure that focus is properly managed for\nkeyboard interaction.\n\nThis component should only be rendered when the floating element\nis open and directly wrap it.\n\n```\nfunction App() {\n  const {context} = useFloating();\n \n  return (\n    <>\n      {/* reference element */}\n      {isOpen && (\n        <FloatingFocusManager context={context}>\n          {/* floating element */}\n        </FloatingFocusManager>\n      )}\n    </>\n  );\n}\n```\n\n## [Props](#props)\n\n```\ninterface FloatingFocusManagerProps {\n  context: FloatingContext;\n  disabled?: boolean;\n  initialFocus?:\n    | number\n    | React.MutableRefObject<HTMLElement | null>;\n  returnFocus?:\n    | boolean\n    | React.MutableRefObject<HTMLElement | null>;\n  restoreFocus?: boolean;\n  guards?: boolean;\n  modal?: boolean;\n  visuallyHiddenDismiss?: boolean | string;\n  closeOnFocusOut?: boolean;\n  outsideElementsInert?: boolean;\n  getInsideElements?: () => Element[];\n  order?: Array<'reference' | 'floating' | 'content'>;\n}\n```\n\n### [`context`](#context)\n\nRequired\n\nThe `context` object returned from `useFloating()`\nor\n[`useFloatingRootContext`](/docs/useInteractions#external-reference).\n\n```\n<FloatingFocusManager context={context}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`disabled`](#disabled)\n\ndefault: `false`\n\nDisables all focus management entirely. Useful to delay focus\nmanagement until after a transition completes or some other\nconditional state.\n\n```\n<FloatingFocusManager context={context} disabled>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`initialFocus`](#initialfocus)\n\ndefault: `0`\n\nWhich element to initially focus. Can be either a number\n(tabbable index as specified by the `order`) or a ref.\n\n```\n<FloatingFocusManager\n  context={context}\n  initialFocus={elementRef}\n>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n#### [Negative number](#negative-number)\n\nYou can set this to a negative number to ignore the initial\nfocus. This is required to prevent conflicts if your floating\nelement has no tabbable content and is instead controlled by the\n`useListNavigation()` Hook which has its own focus\nmanagement.\n\n```\n<FloatingFocusManager context={context} initialFocus={-1}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\nIf there is no list navigation, then `modal`\nbehavior\u2019s focus trap will no longer work. To maintain the trap,\nyou can place the initial focus on the floating element:\n\n```\nconst {context, refs} = useFloating();\n \nreturn (\n  <FloatingFocusManager\n    context={context}\n    initialFocus={refs.floating}\n  >\n    {/* floating element */}\n  </FloatingFocusManager>\n);\n```\n\n### [`returnFocus`](#returnfocus)\n\ndefault: `true`\n\nDetermines if focus should be returned to the reference element\n(or if that is not available, the previously focused element).\nThis prop is ignored if the floating element lost focus. It can\nbe also set to a ref to explicitly control the element to return\nfocus to.\n\n```\n<FloatingFocusManager context={context} returnFocus={false}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`restoreFocus`](#restorefocus)\n\ndefault: `false`\n\nDetermines if focus should be restored to the nearest tabbable\nelement if the currently focused element inside the floating\nelement was removed from the DOM (causing focus to be lost\notherwise).\n\n```\n<FloatingFocusManager context={context} restoreFocus={true}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`guards`](#guards)\n\ndefault: `true`\n\nDetermines if the focus guards are rendered. If not, focus can\nescape into the address bar/console/browser UI, like in native\ndialogs.\n\n```\n<FloatingFocusManager context={context} guards={false}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`modal`](#modal)\n\ndefault: `true`\n\nDetermines if focus is \u201cmodal\u201d, meaning focus is fully trapped\ninside the floating element and outside content cannot be\naccessed. This includes screen reader virtual cursors.\n\n```\n<FloatingFocusManager context={context} modal={false}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n#### [Non-modal behavior](#non-modal-behavior)\n\nThe floating element should be rendered after the reference\nelement in the React tree. It can be portaled using\n`<FloatingPortal>`. Other portal solutions are not supported\nor accessible when using Floating UI\u2019s focus manager.\n\n#### [Modal behavior](#modal-behavior)\n\nEnsure you have an explicit \u201cclose\u201d button. This can be either\nvisible to all users, or visually-hidden so it is only available\nto assistive tech (see\n[`visuallyHiddenDismiss`](/docs/FloatingFocusManager#visuallyhiddendismiss)).\nTouch-based screen readers often will not have an `esc` key\navailable to dismiss the element, so an explicit close button is\nrequired, otherwise the user will be trapped in the floating\nelement if they don\u2019t want to select anything (thus needing to\nreload the page).\n\n#### [Comboboxes](#comboboxes)\n\nWhen the reference element has a `combobox`\n`role` present, the focus manager behavior changes.\n\nThe listbox part (floating element) of a combobox (input +\nlistbox popup) can be portaled and accessible to touch screen\nreaders when using modal focus management, but DOM focus does not\nbecome modal. Screen reader virtual cursors do become modal,\nallowing a touch screen reader to immediately access the portaled\nlistbox items.\n\n### [`visuallyHiddenDismiss`](#visuallyhiddendismiss)\n\ndefault: `false`\n\nIf your focus management is modal and there is no explicit close\nbutton available, you can use this prop to render a\nvisually-hidden dismiss button at the start and end of the\nfloating element. This allows touch-based screen readers to\nescape the floating element due to lack of an `esc` key.\n\n```\n<FloatingFocusManager context={context} visuallyHiddenDismiss>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\nYou can pass a string which will be announced by the screen\nreader, e.g. for languages other than English. The default string\nwhen using `true` is `Dismiss`.\n\n```\n<FloatingFocusManager\n  context={context}\n  visuallyHiddenDismiss=\"Dismiss popup\"\n>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`closeOnFocusOut`](#closeonfocusout)\n\ndefault: `true`\n\nDetermines whether `focusout` event listeners that\ncontrol whether the floating element should be closed if the\nfocus moves outside of it are attached to the reference and\nfloating elements. This affects non-modal focus management.\n\n```\n<FloatingFocusManager context={context} closeOnFocusOut={false}>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`outsideElementsInert`](#outsideelementsinert)\n\ndefault: `false`\n\nDetermines whether outside elements are `inert` when\n`modal` is enabled. This enables pointer modality\nwithout a backdrop.\n\n```\n<FloatingFocusManager context={context} outsideElementsInert>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`getInsideElements`](#getinsideelements)\n\nDetermines which elements are considered inside the floating\nelement when it\u2019s rendered. Such elements will avoid being marked\nwith `aria-hidden` and `data-floating-ui-inert` attributes.\n\n```\n<FloatingFocusManager\n  context={context}\n  getInsideElements={() =>\n    Array.from(document.querySelectorAll('.inside'))\n  }\n>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n### [`order`](#order)\n\ndefault: `['content']`\n\nThe order in which focus cycles.\n\n```\n<FloatingFocusManager\n  context={context}\n  // Initially focuses the floating element. Subsequent tabs\n  // will cycle through the tabbable contents of the floating\n  // element.\n  order={['floating', 'content']}\n  // Keeps focus on the reference element. Subsequent tabs\n  // will cycle through the tabbable contents of the floating\n  // element.\n  order={['reference', 'content']}\n>\n  {/* floating element */}\n</FloatingFocusManager>\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [Page scrolls to top when opening the floating element](#page-scrolls-to-top-when-opening-the-floating-element)\n\nThis can happen if you\u2019re placing the `autoFocus` prop\non an element inside the floating element. This is because the\nfloating element is initially rendered at the top-left of the\npage, and the browser scrolls to it when it receives focus.\n\nInstead, use the `initialFocus` prop on\n`<FloatingFocusManager>` to focus the desired element, which\nwaits for the position to be ready first.\n\n### [Usage with `<FloatingPortal>`](#usage-with-floatingportal)\n\nEnsure the focus manager is rendered as a child (can be a nested\ndescendant) of `<FloatingPortal>`.\n\nIf you\u2019re using non-modal focus management, you must use\n`<FloatingPortal>` and not another portal solution. This is\nbecause it tightly integrates with the focus manager to ensure\nthat focus is moved correctly when tabbing, including the\nVoiceOver virtual cursor.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:54:03.364289+00:00",
  "content_length": 8273,
  "content_hash": "989604f5dca3bb89"
}