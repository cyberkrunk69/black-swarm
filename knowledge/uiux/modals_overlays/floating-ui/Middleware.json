{
  "id": "floating-ui__docs_middleware",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/middleware",
  "title": "Middleware",
  "content": "Middleware\nObjects that change the positioning of the floating element,\nexecuted in order as a queue.\nMiddleware allow you to customize the behavior of the positioning\nand be as granular as you want, adding your own custom logic.\ncomputePosition\n()\nstarts with initial positioning via\nplacement\n\u2014 then middleware are executed as an\nin-between \u201cmiddle\u201d step of the initial placement computation and\neventual return of data for rendering.\nEach middleware is executed in order:\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nplacement\n:\n'\nright\n'\n,\nmiddleware\n:\n[],\n})\n;\nExample\nconst\nshiftByOnePixel\n=\n{\nname\n:\n'\nshiftByOnePixel\n'\n,\nfn\n(\n{\nx\n,\ny\n}\n)\n{\nreturn\n{\nx\n:\nx\n+\n1\n,\ny\n:\ny\n+\n1\n,\n}\n;\n}\n,\n}\n;\nThis (not particularly useful) middleware adds\n1\npixel to\nthe coordinates. To use this middleware, add it to your\nmiddleware\narray:\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nplacement\n:\n'\nright\n'\n,\nmiddleware\n:\n[\nshiftByOnePixel\n],\n})\n;\nHere,\ncomputePosition\n()\nwill compute coordinates that will\nplace the floating element to the\nright\ncenter of the\nreference element, lying flush with it.\nMiddleware are then executed, resulting in these coordinates\ngetting shifted by one pixel. Then that data is returned for\nrendering.\nShape\nA middleware is an object that has a\nname\nproperty and a\nfn\nproperty. The\nfn\nproperty provides\nthe logic of the middleware, which returns new positioning\ncoordinates or useful data.\nData\nAny data can be passed via an optional\ndata\nproperty of\nthe object that is returned from\nfn\n. This will be\naccessible to the consumer via the\nmiddlewareData\nproperty:\nconst\nshiftByOnePixel\n=\n{\nname\n:\n'\nshiftByOnePixel\n'\n,\nfn\n(\n{\nx\n,\ny\n}\n)\n{\nreturn\n{\nx\n:\nx\n+\n1\n,\ny\n:\ny\n+\n1\n,\ndata\n:\n{\namount\n:\n1\n,\n}\n,\n}\n;\n}\n,\n}\n;\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nshiftByOnePixel\n],\n})\n.\nthen\n((\n{\nmiddlewareData\n}\n)\n=>\n{\nconsole\n.\nlog\n(\nmiddlewareData\n.\nshiftByOnePixel\n)\n;\n})\n;\nFunction\nYou may notice that Floating UI\u2019s packaged middleware are\nactually functions. This is so you can pass options in, changing\nhow the middleware behaves:\nconst\nshiftByAmount\n=\n(\namount\n=\n0\n)\n=>\n({\nname\n:\n'\nshiftByAmount\n'\n,\noptions\n:\namount\n,\nfn\n:\n(\n{\nx\n,\ny\n}\n)\n=>\n({\nx\n:\nx\n+\namount\n,\ny\n:\ny\n+\namount\n,\n})\n,\n})\n;\nIt returns an object and uses a closure to pass the configured\nbehavior:\nconst\nmiddleware\n=\n[\nshiftByAmount\n(\n10\n)\n];\nThe\noptions\nkey on a middleware object holds the\ndependencies, allowing deep comparison reactivity.\nAlways return an object\nInside\nfn\nmake sure to return an object. It doesn\u2019t\nneed to contain properties, but to remind you that it should be\npure, you must return an object. Never mutate any values that get\npassed in from\nfn\n.\nMiddlewareState\nAn object is passed to\nfn\ncontaining useful data\nabout the middleware lifecycle being executed.\nIn the previous examples, we destructured\nx\nand\ny\nout of the\nfn\nparameter object. These\nare only two properties that get passed into middleware, but\nthere are many more.\nThe properties passed are below:\ninterface\nMiddlewareState\n{\nx\n:\nnumber\n;\ny\n:\nnumber\n;\ninitialPlacement\n:\nPlacement\n;\nplacement\n:\nPlacement\n;\nstrategy\n:\nStrategy\n;\nmiddlewareData\n:\nMiddlewareData\n;\nelements\n:\nElements\n;\nrects\n:\nElementRects\n;\nplatform\n:\nPlatform\n;\n}\nx\nThis is the x-axis coordinate to position the floating element\nto.\ny\nThis is the y-axis coordinate to position the floating element\nto.\nelements\nThis is an object containing the reference and floating elements.\nrects\nThis is an object containing the\nRect\ns of the\nreference and floating elements, an object of shape\n{width, height, x, y}\n.\nmiddlewareData\nThis is an object containing all the data of any middleware at\nthe current step in the lifecycle. The lifecycle loops over the\nmiddleware\narray, so later middleware have access to\ndata from any middleware run prior.\nstrategy\nThe positioning strategy.\ninitialPlacement\nThe initial (or preferred) placement passed in to\ncomputePosition\n()\n.\nplacement\nThe stateful resultant placement. Middleware like\nflip\nchange\ninitialPlacement\nto a new one.\nplatform\nAn object containing methods to make Floating UI work on the\ncurrent platform, e.g. DOM or React Native.\nOrdering\nThe order in which middleware are placed in the array matters, as\nmiddleware\nuse\nthe coordinates that were returned from\nprevious ones. This means they perform their work based on the\ncurrent positioning state.\nThree\nshiftByOnePixel\nin the middleware array means\nthe coordinates get shifted by 3 pixels in total:\nconst\nshiftByOnePixel\n=\n{\nname\n:\n'\nshiftByOnePixel\n'\n,\nfn\n:\n(\n{\nx\n,\ny\n}\n)\n=>\n({\nx\n:\nx\n+\n1\n,\ny\n:\ny\n+\n1\n})\n,\n}\n;\nconst\nmiddleware\n=\n[\nshiftByOnePixel\n,\nshiftByOnePixel\n,\nshiftByOnePixel\n,\n];\nIf the later\nshiftByOnePixel\nimplementations had a condition\nbased on the current value of\nx\nand\ny\n, the\ncondition can change based on their placement in the array.\nUnderstanding this can help in knowing which order to place\nmiddleware in, as placing a middleware before or after another\ncan produce a different result.\nIn general,\noffset\n()\nshould always go at the beginning of\nthe middleware array, while\narrow\n()\nand\nhide\n()\nat\nthe end. The other core middleware can be shifted around\ndepending on the desired behavior.\nconst\nmiddleware\n=\n[\noffset\n()\n,\n// ...\narrow\n({\nelement\n:\narrowElement\n})\n,\nhide\n()\n,\n];\nResetting the lifecycle\nThere are use cases for needing to reset the middleware lifecycle\nso that other middleware perform fresh logic.\nWhen\nflip\n()\nand\nautoPlacement\n()\nchange the\nplacement, they reset the lifecycle so that other middleware\nthat modify the coordinates based on the current\nplacement\ndo not perform stale logic.\nsize\n()\nresets the lifecycle with the newly applied\ndimensions, as many middleware read the dimensions to perform\ntheir logic.\ninline\n()\nresets the lifecycle when it changes the\nreference rect to a custom implementation, similar to a\nVirtual Element\n.\nIn order to do this, add a\nreset\nproperty to the\nreturned object from\nfn\n.\ntype\nReset\n=\n|\ntrue\n|\n{\nplacement\n?:\nPlacement\n;\n// `true` will compute the new `rects` if the\n// dimensions were mutated. Otherwise, you can\n// return your own new rects.\nrects\n?:\ntrue\n|\nElementRects\n;\n}\n;\nconst\nmiddleware\n=\n{\nname\n:\n'\nmiddleware\n'\n,\nfn\n()\n{\nif\n(\nsomeCondition\n)\n{\nreturn\n{\nreset\n:\n{\nplacement\n:\nnextPlacement\n,\n}\n,\n}\n;\n}\nreturn\n{}\n;\n}\n,\n}\n;\nData supplied to\nmiddlewareData\nis preserved by doing\nthis, so you can read it at any point after you\u2019ve reset the\nlifecycle.",
  "content_markdown": "# Middleware\n\nObjects that change the positioning of the floating element,\nexecuted in order as a queue.\n\nMiddleware allow you to customize the behavior of the positioning\nand be as granular as you want, adding your own custom logic.\n\n`computePosition()` starts with initial positioning via\n`placement` \u2014 then middleware are executed as an\nin-between \u201cmiddle\u201d step of the initial placement computation and\neventual return of data for rendering.\n\nEach middleware is executed in order:\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  placement: 'right',\n  middleware: [],\n});\n```\n\n## [Example](#example)\n\n```\nconst shiftByOnePixel = {\n  name: 'shiftByOnePixel',\n  fn({x, y}) {\n    return {\n      x: x + 1,\n      y: y + 1,\n    };\n  },\n};\n```\n\nThis (not particularly useful) middleware adds `1` pixel to\nthe coordinates. To use this middleware, add it to your\n`middleware` array:\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  placement: 'right',\n  middleware: [shiftByOnePixel],\n});\n```\n\nHere, `computePosition()` will compute coordinates that will\nplace the floating element to the `right` center of the\nreference element, lying flush with it.\n\nMiddleware are then executed, resulting in these coordinates\ngetting shifted by one pixel. Then that data is returned for\nrendering.\n\n### [Shape](#shape)\n\nA middleware is an object that has a `name` property and a\n`fn` property. The `fn` property provides\nthe logic of the middleware, which returns new positioning\ncoordinates or useful data.\n\n### [Data](#data)\n\nAny data can be passed via an optional `data` property of\nthe object that is returned from `fn`. This will be\naccessible to the consumer via the `middlewareData` property:\n\n```\nconst shiftByOnePixel = {\n  name: 'shiftByOnePixel',\n  fn({x, y}) {\n    return {\n      x: x + 1,\n      y: y + 1,\n      data: {\n        amount: 1,\n      },\n    };\n  },\n};\n```\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [shiftByOnePixel],\n}).then(({middlewareData}) => {\n  console.log(middlewareData.shiftByOnePixel);\n});\n```\n\n### [Function](#function)\n\nYou may notice that Floating UI\u2019s packaged middleware are\nactually functions. This is so you can pass options in, changing\nhow the middleware behaves:\n\n```\nconst shiftByAmount = (amount = 0) => ({\n  name: 'shiftByAmount',\n  options: amount,\n  fn: ({x, y}) => ({\n    x: x + amount,\n    y: y + amount,\n  }),\n});\n```\n\nIt returns an object and uses a closure to pass the configured\nbehavior:\n\n```\nconst middleware = [shiftByAmount(10)];\n```\n\nThe `options` key on a middleware object holds the\ndependencies, allowing deep comparison reactivity.\n\n### [Always return an object](#always-return-an-object)\n\nInside `fn` make sure to return an object. It doesn\u2019t\nneed to contain properties, but to remind you that it should be\npure, you must return an object. Never mutate any values that get\npassed in from `fn`.\n\n## [MiddlewareState](#middlewarestate)\n\nAn object is passed to `fn` containing useful data\nabout the middleware lifecycle being executed.\n\nIn the previous examples, we destructured `x` and\n`y` out of the `fn` parameter object. These\nare only two properties that get passed into middleware, but\nthere are many more.\n\nThe properties passed are below:\n\n```\ninterface MiddlewareState {\n  x: number;\n  y: number;\n  initialPlacement: Placement;\n  placement: Placement;\n  strategy: Strategy;\n  middlewareData: MiddlewareData;\n  elements: Elements;\n  rects: ElementRects;\n  platform: Platform;\n}\n```\n\n### [`x`](#x)\n\nThis is the x-axis coordinate to position the floating element\nto.\n\n### [`y`](#y)\n\nThis is the y-axis coordinate to position the floating element\nto.\n\n### [`elements`](#elements)\n\nThis is an object containing the reference and floating elements.\n\n### [`rects`](#rects)\n\nThis is an object containing the `Rect`s of the\nreference and floating elements, an object of shape\n`{width, height, x, y}`.\n\n### [`middlewareData`](#middlewaredata)\n\nThis is an object containing all the data of any middleware at\nthe current step in the lifecycle. The lifecycle loops over the\n`middleware` array, so later middleware have access to\ndata from any middleware run prior.\n\n### [`strategy`](#strategy)\n\nThe positioning strategy.\n\n### [`initialPlacement`](#initialplacement)\n\nThe initial (or preferred) placement passed in to\n`computePosition()`.\n\n### [`placement`](#placement)\n\nThe stateful resultant placement. Middleware like\n`flip` change `initialPlacement` to a new one.\n\n### [`platform`](#platform)\n\nAn object containing methods to make Floating UI work on the\ncurrent platform, e.g. DOM or React Native.\n\n## [Ordering](#ordering)\n\nThe order in which middleware are placed in the array matters, as\nmiddleware **use** the coordinates that were returned from\nprevious ones. This means they perform their work based on the\ncurrent positioning state.\n\nThree `shiftByOnePixel` in the middleware array means\nthe coordinates get shifted by 3 pixels in total:\n\n```\nconst shiftByOnePixel = {\n  name: 'shiftByOnePixel',\n  fn: ({x, y}) => ({x: x + 1, y: y + 1}),\n};\nconst middleware = [\n  shiftByOnePixel,\n  shiftByOnePixel,\n  shiftByOnePixel,\n];\n```\n\nIf the later `shiftByOnePixel` implementations had a condition\nbased on the current value of `x` and `y`, the\ncondition can change based on their placement in the array.\n\nUnderstanding this can help in knowing which order to place\nmiddleware in, as placing a middleware before or after another\ncan produce a different result.\n\nIn general, `offset()` should always go at the beginning of\nthe middleware array, while `arrow()` and `hide()` at\nthe end. The other core middleware can be shifted around\ndepending on the desired behavior.\n\n```\nconst middleware = [\n  offset(),\n  // ...\n  arrow({element: arrowElement}),\n  hide(),\n];\n```\n\n## [Resetting the lifecycle](#resetting-the-lifecycle)\n\nThere are use cases for needing to reset the middleware lifecycle\nso that other middleware perform fresh logic.\n\n- When `flip()` and `autoPlacement()` change the\n  placement, they reset the lifecycle so that other middleware\n  that modify the coordinates based on the current\n  `placement` do not perform stale logic.\n- `size()` resets the lifecycle with the newly applied\n  dimensions, as many middleware read the dimensions to perform\n  their logic.\n- `inline()` resets the lifecycle when it changes the\n  reference rect to a custom implementation, similar to a\n  [Virtual Element](/docs/virtual-elements).\n\nIn order to do this, add a `reset` property to the\nreturned object from `fn`.\n\n```\ntype Reset =\n  | true\n  | {\n      placement?: Placement;\n      // `true` will compute the new `rects` if the\n      // dimensions were mutated. Otherwise, you can\n      // return your own new rects.\n      rects?: true | ElementRects;\n    };\n```\n\n```\nconst middleware = {\n  name: 'middleware',\n  fn() {\n    if (someCondition) {\n      return {\n        reset: {\n          placement: nextPlacement,\n        },\n      };\n    }\n \n    return {};\n  },\n};\n```\n\nData supplied to `middlewareData` is preserved by doing\nthis, so you can read it at any point after you\u2019ve reset the\nlifecycle.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:25.645113+00:00",
  "content_length": 6396,
  "content_hash": "00837677a5d6a0b1"
}