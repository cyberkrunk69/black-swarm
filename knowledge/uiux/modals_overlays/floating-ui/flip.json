{
  "id": "floating-ui__docs_flip",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/flip",
  "title": "flip",
  "content": "flip\nChanges the placement of the floating element to keep it in view.\nVisibility Optimizer\nimport\n{\nflip\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nThis prevents the floating element from overflowing along its\nside axis by flipping it to the opposite side by default.\nScroll up\nFloating\nUsage\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nflip\n()\n],\n})\n;\nOptions\nThese are the options you can pass to\nflip\n()\n.\ninterface\nFlipOptions\nextends\nDetectOverflowOptions\n{\nmainAxis\n?:\nboolean\n;\ncrossAxis\n?:\nboolean\n|\n'\nalignment\n'\n;\nfallbackAxisSideDirection\n?:\n'\nnone\n'\n|\n'\nstart\n'\n|\n'\nend\n'\n;\nflipAlignment\n?:\nboolean\n;\nfallbackPlacements\n?:\nArray\n<\nPlacement\n>;\nfallbackStrategy\n?:\n'\nbestFit\n'\n|\n'\ninitialPlacement\n'\n;\n}\nmainAxis\ndefault:\ntrue\nThis is the main axis in which overflow is checked to perform a\nflip. By disabling this, it will ignore overflow.\ny\n-axis for\n'\ntop\n'\nand\n'\nbottom\n'\nplacements\nx\n-axis for\n'\nleft\n'\nand\n'\nright\n'\nplacements\nflip\n({\nmainAxis\n:\nfalse\n,\n})\n;\nScroll up\nI will ignore main axis overflow\ncrossAxis\ndefault:\ntrue\nThis is the cross axis in which overflow is checked to perform a\nflip, the axis perpendicular to\nmainAxis\n. By disabling\nthis, it will ignore overflow.\nflip\n({\ncrossAxis\n:\nfalse\n,\n})\n;\nScroll around\nI will check cross axis overflow (default)\nScroll around\nI will ignore cross axis overflow\nfallbackAxisSideDirection\ndefault:\n'\nnone\n'\nWhether to allow fallback to the opposite axis if no placements\nalong the preferred placement axis fit, and if so, which side\ndirection along that axis to choose. If necessary, it will\nfallback to the other direction.\n'\nnone\n'\nsignals that no fallback to the opposite axis\nshould take place.\n'\nstart\n'\nrepresents\n'\ntop\n'\nor\n'\nleft\n'\n.\n'\nend\n'\nrepresents\n'\nbottom\n'\nor\n'\nright\n'\n.\nFor instance, by default, if the initial\nplacement\nis\nset to\n'\nright\n'\n, then the placements to try (in order) are:\n[\n'\nright\n'\n,\n'\nleft\n'\n]\nOn a narrow viewport, it\u2019s possible or even likely that\nneither\nof these will fit.\nBy specifying a string other than\n'\nnone\n'\n, you allow\nplacements along the perpendicular axis of the initial placement\nto be tried. The direction determines which side of placement is\ntried first:\nflip\n({\nfallbackAxisSideDirection\n:\n'\nstart\n'\n,\n})\n;\nThe above results in:\n[\n'\nright\n'\n,\n'\nleft\n'\n,\n'\ntop\n'\n,\n'\nbottom\n'\n]\n.\nflip\n({\nfallbackAxisSideDirection\n:\n'\nend\n'\n,\n})\n;\nThe above results in:\n[\n'\nright\n'\n,\n'\nleft\n'\n,\n'\nbottom\n'\n,\n'\ntop\n'\n]\n.\nAs an example, if you\u2019d like a tooltip that has a placement of\n'\nright\n'\nto be placed on top on mobile (assuming it doesn\u2019t\nfit), then you\u2019d use\n'\nstart\n'\n. For an interactive popover,\nyou likely want to use\n'\nend\n'\nso it\u2019s placed on the bottom,\ncloser to the user\u2019s fingers.\nIn each of the following demos, the\nplacement\nis\n'\nright\n'\n.\nScroll horizontally\n`fallbackAxisSideDirection` has been set to 'none' (default)\nNotice that it can overflow.\nScroll horizontally\n`fallbackAxisSideDirection` has been set to 'start'\nNotice that it prefers\ntop\nif it doesn\u2019t fit.\nScroll horizontally\n`fallbackAxisSideDirection` has been set to 'end'\nNotice that it prefers\nbottom\nif it doesn\u2019t fit.\nflipAlignment\ndefault:\ntrue\nWhen an alignment is specified, e.g.\n'\ntop-start\n'\ninstead\nof just\n'\ntop\n'\n, this will flip to\n'\ntop-end\n'\nif\nstart\ndoesn\u2019t fit.\nflip\n({\nflipAlignment\n:\nfalse\n,\n})\n;\nWhen using this with the\nshift\n()\nmiddleware, ensure\nflip\n()\nis placed\nbefore\nshift\n()\nin your\nmiddleware array. This ensures the\nflipAlignment\nlogic\ncan act before\nshift\n()\n\u2019s does.\nfallbackPlacements\ndefault:\n[\noppositePlacement\n]\nThis describes an\nexplicit\narray of placements to try if the\ninitial\nplacement\ndoesn\u2019t fit on the axes in which\noverflow is checked.\nflip\n({\nfallbackPlacements\n:\n[\n'\nright\n'\n,\n'\nbottom\n'\n],\n})\n;\nIn the above example, if\nplacement\nis set to\n'\ntop\n'\n, then the placements to try (in order) are:\n[\n'\ntop\n'\n,\n'\nright\n'\n,\n'\nbottom\n'\n]\nScroll down\nFloating\nfallbackStrategy\ndefault:\n'\nbestFit\n'\nWhen no placements fit, then you\u2019ll want to decide what happens.\n'\nbestFit\n'\nwill use the placement which fits best on the\nchecked axes.\n'\ninitialPlacement\n'\nwill use the initial\nplacement\nspecified.\nflip\n({\nfallbackStrategy\n:\n'\ninitialPlacement\n'\n,\n})\n;\n\u2026detectOverflowOptions\nAll of\ndetectOverflow\n\u2019s options\ncan be passed. For instance:\nflip\n({\npadding\n:\n5\n,\n// 0 by default\n})\n;\nDeriving options from state\nYou can derive the options from the\nmiddleware lifecycle state\n:\nflip\n((\nstate\n)\n=>\n({\npadding\n:\nstate\n.\nrects\n.\nreference\n.\nwidth\n,\n}))\n;\nFinal placement\nThe placement returned from the function is always the final one,\nnot necessarily the one you passed in as the \u201cpreferred\u201d one.\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nplacement\n:\n'\nbottom\n'\n,\nmiddleware\n:\n[\nflip\n()\n],\n})\n.\nthen\n((\n{\nplacement\n}\n)\n=>\n{\nconsole\n.\nlog\n(\nplacement\n)\n;\n// 'top' or 'bottom'\n})\n;\nCombining with\nshift\n()\nWhen using\nflip\n()\nwith\nshift\n()\ntogether, the\nrecommended configuration is as follows:\nconst\nmiddleware\n=\n[\noffset\n(\n5\n)\n];\nconst\nflipMiddleware\n=\nflip\n({\n// Ensure we flip to the perpendicular axis if it doesn't fit\n// on narrow viewports.\ncrossAxis\n:\n'\nalignment\n'\n,\nfallbackAxisSideDirection\n:\n'\nend\n'\n,\n// or 'start'\n})\n;\nconst\nshiftMiddleware\n=\nshift\n()\n;\n// Prioritize flip over shift for edge-aligned placements only.\nif\n(\nplacement\n.\nincludes\n(\n'\n-\n'\n))\n{\nmiddleware\n.\npush\n(\nflipMiddleware\n,\nshiftMiddleware\n)\n;\n}\nelse\n{\nmiddleware\n.\npush\n(\nshiftMiddleware\n,\nflipMiddleware\n)\n;\n}\nThis results in the most expected positioning when using both\nmiddleware regardless of the placement used.\nConflict with\nautoPlacement\n()\nflip\n()\nand\nautoPlacement\n()\ncannot be used together\ninside the same middleware array; make sure you choose only one\nof them to use.\nThe reason is they both try to perform work on the placement but\nwith opposing strategies. Therefore, they will continually try to\nchange the result or work of the other one, leading to a reset\nloop.\nflip\n()\nuses a fallback \u201cno space\u201d strategy. Ensures the\npreferred placement is kept unless there is no space left.\nautoPlacement\n()\nuses a primary \u201cmost space\u201d strategy.\nAlways chooses the placement with the most space available.",
  "content_markdown": "# flip\n\nChanges the placement of the floating element to keep it in view.\n\n*Visibility Optimizer*\n\n```\nimport {flip} from '@floating-ui/dom';\n```\n\nThis prevents the floating element from overflowing along its\nside axis by flipping it to the opposite side by default.\n\nScroll up\n\nFloating\n\n## [Usage](#usage)\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [flip()],\n});\n```\n\n## [Options](#options)\n\nThese are the options you can pass to `flip()`.\n\n```\ninterface FlipOptions extends DetectOverflowOptions {\n  mainAxis?: boolean;\n  crossAxis?: boolean | 'alignment';\n  fallbackAxisSideDirection?: 'none' | 'start' | 'end';\n  flipAlignment?: boolean;\n  fallbackPlacements?: Array<Placement>;\n  fallbackStrategy?: 'bestFit' | 'initialPlacement';\n}\n```\n\n### [`mainAxis`](#mainaxis)\n\ndefault: `true`\n\nThis is the main axis in which overflow is checked to perform a\nflip. By disabling this, it will ignore overflow.\n\n- `y`-axis for `'top'` and `'bottom'` placements\n- `x`-axis for `'left'` and `'right'` placements\n\n```\nflip({\n  mainAxis: false,\n});\n```\n\nScroll up\n\nI will ignore main axis overflow\n\n### [`crossAxis`](#crossaxis)\n\ndefault: `true`\n\nThis is the cross axis in which overflow is checked to perform a\nflip, the axis perpendicular to `mainAxis`. By disabling\nthis, it will ignore overflow.\n\n```\nflip({\n  crossAxis: false,\n});\n```\n\nScroll around\n\nI will check cross axis overflow (default)\n\nScroll around\n\nI will ignore cross axis overflow\n\n### [`fallbackAxisSideDirection`](#fallbackaxissidedirection)\n\ndefault: `'none'`\n\nWhether to allow fallback to the opposite axis if no placements\nalong the preferred placement axis fit, and if so, which side\ndirection along that axis to choose. If necessary, it will\nfallback to the other direction.\n\n- `'none'` signals that no fallback to the opposite axis\n  should take place.\n- `'start'` represents `'top'` or `'left'`.\n- `'end'` represents `'bottom'` or `'right'`.\n\nFor instance, by default, if the initial `placement` is\nset to `'right'`, then the placements to try (in order) are:\n\n`['right', 'left']`\n\nOn a narrow viewport, it\u2019s possible or even likely that *neither*\nof these will fit.\n\nBy specifying a string other than `'none'`, you allow\nplacements along the perpendicular axis of the initial placement\nto be tried. The direction determines which side of placement is\ntried first:\n\n```\nflip({\n  fallbackAxisSideDirection: 'start',\n});\n```\n\nThe above results in: `['right', 'left', 'top', 'bottom']`.\n\n```\nflip({\n  fallbackAxisSideDirection: 'end',\n});\n```\n\nThe above results in: `['right', 'left', 'bottom', 'top']`.\n\nAs an example, if you\u2019d like a tooltip that has a placement of\n`'right'` to be placed on top on mobile (assuming it doesn\u2019t\nfit), then you\u2019d use `'start'`. For an interactive popover,\nyou likely want to use `'end'` so it\u2019s placed on the bottom,\ncloser to the user\u2019s fingers.\n\nIn each of the following demos, the `placement` is\n`'right'`.\n\nScroll horizontally\n\n`fallbackAxisSideDirection` has been set to 'none' (default)\n\nNotice that it can overflow.\n\nScroll horizontally\n\n`fallbackAxisSideDirection` has been set to 'start'\n\nNotice that it prefers `top` if it doesn\u2019t fit.\n\nScroll horizontally\n\n`fallbackAxisSideDirection` has been set to 'end'\n\nNotice that it prefers `bottom` if it doesn\u2019t fit.\n\n### [`flipAlignment`](#flipalignment)\n\ndefault: `true`\n\nWhen an alignment is specified, e.g. `'top-start'` instead\nof just `'top'`, this will flip to `'top-end'` if\n`start` doesn\u2019t fit.\n\n```\nflip({\n  flipAlignment: false,\n});\n```\n\nWhen using this with the `shift()` middleware, ensure\n`flip()` is placed **before** `shift()` in your\nmiddleware array. This ensures the `flipAlignment` logic\ncan act before `shift()`\u2019s does.\n\n### [`fallbackPlacements`](#fallbackplacements)\n\ndefault: `[oppositePlacement]`\n\nThis describes an **explicit** array of placements to try if the\ninitial `placement` doesn\u2019t fit on the axes in which\noverflow is checked.\n\n```\nflip({\n  fallbackPlacements: ['right', 'bottom'],\n});\n```\n\nIn the above example, if `placement` is set to\n`'top'`, then the placements to try (in order) are:\n\n`['top', 'right', 'bottom']`\n\nScroll down\n\nFloating\n\n### [`fallbackStrategy`](#fallbackstrategy)\n\ndefault: `'bestFit'`\n\nWhen no placements fit, then you\u2019ll want to decide what happens.\n`'bestFit'` will use the placement which fits best on the\nchecked axes. `'initialPlacement'` will use the initial\n`placement` specified.\n\n```\nflip({\n  fallbackStrategy: 'initialPlacement',\n});\n```\n\n### [\u2026detectOverflowOptions](#detectoverflowoptions)\n\nAll of [`detectOverflow`](/docs/detectOverflow#options)\u2019s options\ncan be passed. For instance:\n\n```\nflip({\n  padding: 5, // 0 by default\n});\n```\n\n### [Deriving options from state](#deriving-options-from-state)\n\nYou can derive the options from the\n[middleware lifecycle state](/docs/middleware#middlewarestate):\n\n```\nflip((state) => ({\n  padding: state.rects.reference.width,\n}));\n```\n\n## [Final placement](#final-placement)\n\nThe placement returned from the function is always the final one,\nnot necessarily the one you passed in as the \u201cpreferred\u201d one.\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  placement: 'bottom',\n  middleware: [flip()],\n}).then(({placement}) => {\n  console.log(placement); // 'top' or 'bottom'\n});\n```\n\n## [Combining with `shift()`](#combining-with-shift)\n\nWhen using `flip()` with `shift()` together, the\nrecommended configuration is as follows:\n\n```\nconst middleware = [offset(5)];\nconst flipMiddleware = flip({\n  // Ensure we flip to the perpendicular axis if it doesn't fit\n  // on narrow viewports.\n  crossAxis: 'alignment',\n  fallbackAxisSideDirection: 'end', // or 'start'\n});\nconst shiftMiddleware = shift();\n \n// Prioritize flip over shift for edge-aligned placements only.\nif (placement.includes('-')) {\n  middleware.push(flipMiddleware, shiftMiddleware);\n} else {\n  middleware.push(shiftMiddleware, flipMiddleware);\n}\n```\n\nThis results in the most expected positioning when using both\nmiddleware regardless of the placement used.\n\n## [Conflict with `autoPlacement()`](#conflict-with-autoplacement)\n\n`flip()` and `autoPlacement()` cannot be used together\ninside the same middleware array; make sure you choose only one\nof them to use.\n\nThe reason is they both try to perform work on the placement but\nwith opposing strategies. Therefore, they will continually try to\nchange the result or work of the other one, leading to a reset\nloop.\n\n- `flip()` uses a fallback \u201cno space\u201d strategy. Ensures the\n  preferred placement is kept unless there is no space left.\n- `autoPlacement()` uses a primary \u201cmost space\u201d strategy.\n  Always chooses the placement with the most space available.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:30.872952+00:00",
  "content_length": 6130,
  "content_hash": "562c9e8ec284e7d9"
}