{
  "id": "floating-ui__docs_useDismiss",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/useDismiss",
  "title": "useDismiss",
  "content": "use\nDismiss\nCloses the floating element when a dismissal is requested \u2014 by\ndefault, when the user presses the\nescape\nkey or outside of the\nfloating element with their pointer.\nimport\n{\nuseDismiss\n}\nfrom\n'\n@floating-ui/react\n'\n;\nThis is useful to ensure the floating element is closed when the\nuser is finished interacting with it, including keyboard support.\nUsage\nThis Hook returns event handler props.\nTo use it, pass it the\ncontext\nobject returned from\nuseFloating\n()\nor\nuseFloatingRootContext\n,\nand then feed its result into the\nuseInteractions\n()\narray.\nThe returned prop getters are then spread onto the elements for\nrendering.\nfunction\nApp\n()\n{\nconst\n[\nisOpen\n,\nsetIsOpen\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n{\nrefs\n,\nfloatingStyles\n,\ncontext\n}\n=\nuseFloating\n({\nopen\n:\nisOpen\n,\nonOpenChange\n:\nsetIsOpen\n,\n})\n;\nconst\ndismiss\n=\nuseDismiss\n(\ncontext\n)\n;\nconst\n{\ngetReferenceProps\n,\ngetFloatingProps\n}\n=\nuseInteractions\n(\n[\ndismiss\n,\n]\n)\n;\nreturn\n(\n<>\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n{\n...\ngetReferenceProps\n()\n}>\nReference element\n</\ndiv\n>\n{\nisOpen\n&&\n(\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}\n{\n...\ngetFloatingProps\n()\n}\n>\nFloating element\n</\ndiv\n>\n)\n}\n</>\n)\n;\n}\nProps\ninterface\nUseDismissProps\n{\nenabled\n?:\nboolean\n;\nescapeKey\n?:\nboolean\n;\nreferencePress\n?:\nboolean\n;\nreferencePressEvent\n?:\n'\npointerdown\n'\n|\n'\nmousedown\n'\n|\n'\nclick\n'\n;\noutsidePress\n?:\nboolean\n|\n((\nevent\n:\nMouseEvent\n)\n=>\nboolean\n)\n;\noutsidePressEvent\n?:\n'\npointerdown\n'\n|\n'\nmousedown\n'\n|\n'\nclick\n'\n;\nancestorScroll\n?:\nboolean\n;\nbubbles\n?:\n|\nboolean\n|\n{\nescapeKey\n?:\nboolean\n;\noutsidePress\n?:\nboolean\n}\n;\ncapture\n?:\n|\nboolean\n|\n{\nescapeKey\n?:\nboolean\n;\noutsidePress\n?:\nboolean\n}\n;\n}\nenabled\ndefault:\ntrue\nConditionally enable/disable the Hook.\nuseDismiss\n(\ncontext\n,\n{\nenabled\n:\nfalse\n,\n})\n;\nescapeKey\ndefault:\ntrue\nWhether to dismiss the floating element upon pressing the\nesc\nkey.\nuseDismiss\n(\ncontext\n,\n{\nescapeKey\n:\nfalse\n,\n})\n;\nreferencePress\ndefault:\nfalse\nWhether to dismiss the floating element upon pressing the\nreference element.\nuseDismiss\n(\ncontext\n,\n{\nreferencePress\n:\ntrue\n,\n})\n;\nYou likely want to ensure the\nmove\noption in the\nuseHover\n()\nhook has been disabled when this is in use.\nreferencePressEvent\ndefault:\n'\npointerdown\n'\nThe type of event to use to determine a \u201cpress\u201d.\nuseDismiss\n(\ncontext\n,\n{\n// Eager on both mouse + touch input.\nreferencePressEvent\n:\n'\npointerdown\n'\n,\n// Eager on mouse input; lazy on touch input.\nreferencePressEvent\n:\n'\nmousedown\n'\n,\n// Lazy on both mouse + touch input.\nreferencePressEvent\n:\n'\nclick\n'\n,\n})\n;\noutsidePress\ndefault:\ntrue\nWhether to dismiss the floating element upon pressing outside of\nboth the floating and reference elements.\nuseDismiss\n(\ncontext\n,\n{\noutsidePress\n:\nfalse\n,\n})\n;\nIf you have another element, like a toast, that is rendered\noutside the floating element\u2019s React tree and don\u2019t want the\nfloating element to close when pressing it, you can guard the\ncheck like so:\nuseDismiss\n(\ncontext\n,\n{\n// Same as `true`, but with a custom guard check.\noutsidePress\n:\n(\nevent\n)\n=>\n!\nevent\n.\ntarget\n.\nclosest\n(\n'\n.toast\n'\n)\n,\n})\n;\nfunction\nApp\n()\n{\n// The toast is not inside the Dialog's React tree, so we\n// need to add a guard to consider it a child of the Dialog\n// to prevent the Dialog's outside press from closing it.\nreturn\n(\n<>\n<\nDialog\n/>\n<\nToast\nclassName\n=\n\"\ntoast\n\"\n/>\n</>\n)\n;\n}\noutsidePressEvent\ndefault:\n'\npointerdown\n'\nThe type of event to use to determine a \u201cpress\u201d.\nuseDismiss\n(\ncontext\n,\n{\n// Eager on both mouse + touch input.\noutsidePressEvent\n:\n'\npointerdown\n'\n,\n// Eager on mouse input; lazy on touch input.\noutsidePressEvent\n:\n'\nmousedown\n'\n,\n// Lazy on both mouse + touch input.\noutsidePressEvent\n:\n'\nclick\n'\n,\n})\n;\nancestorScroll\ndefault:\nfalse\nWhether to dismiss the floating element upon scrolling an\noverflow ancestor.\nuseDismiss\n(\ncontext\n,\n{\nancestorScroll\n:\ntrue\n,\n})\n;\nbubbles\ndefault:\nundefined\nDetermines whether event listeners bubble upwards through a tree\nof floating elements.\nescapeKey\ndetermines whether pressing the\nesc\nkey\nbubbles, causing ancestor floating elements to dismiss as well.\nFor instance, if you\u2019re dismissing a tooltip inside a dialog\nusing the\nesc\nkey, you likely don\u2019t want the dialog to\ndismiss as well until a second key press, which is the default\nbehavior.\noutsidePress\ndetermines whether pressing outside of a\nchild floating element bubbles, causing ancestor floating\nelements to dismiss as well. Setting this to\nfalse\nrequires a\nFloatingTree\nto be set up.\nuseDismiss\n(\ncontext\n,\n{\n// Configure bubbling for all relevant events:\nbubbles\n:\nfalse\n,\n// Or, individually configure by event:\nbubbles\n:\n{\nescapeKey\n:\ntrue\n,\n// false by default\noutsidePress\n:\nfalse\n,\n// true by default\n}\n,\n})\n;\ncapture\ndefault:\nundefined\nDetermines whether to use capture phase event listeners.\nuseDismiss\n(\ncontext\n,\n{\n// Configure capturing for all relevant events:\ncapture\n:\ntrue\n,\n// Or, individually configure by event:\ncapture\n:\n{\nescapeKey\n:\ntrue\n,\n// false by default\noutsidePress\n:\nfalse\n,\n// true by default\n}\n,\n})\n;\nReacting to dismissal\nTo react to the dismissal event, you can check for the\nreason\nstring in the\nonOpenChange\ncallback:\nuseFloating\n({\nopen\n:\nisOpen\n,\nonOpenChange\n(\nnextOpen\n,\nevent\n,\nreason\n)\n{\nsetIsOpen\n(\nnextOpen\n)\n;\n// Other ones include 'reference-press' and 'ancestor-scroll'\n// if enabled.\nif\n(\nreason\n===\n'\nescape-key\n'\n||\nreason\n===\n'\noutside-press\n'\n)\n{\nconsole\n.\nlog\n(\n'\nDismissed\n'\n)\n;\n}\n}\n,\n})\n;\nTroubleshooting\nDoes not close when clicking in an iframe\nYou can use the\nFloatingOverlay\ncomponent\nwhich will\n\u201ccover\u201d iframes to ensure clicks are captured in the same\ndocument as the floating element, as the click occurs on the\noverlay backdrop. This guarantees \u201coutside press\u201d detection will\nwork.",
  "content_markdown": "# useDismiss\n\nCloses the floating element when a dismissal is requested \u2014 by\ndefault, when the user presses the `escape` key or outside of the\nfloating element with their pointer.\n\n```\nimport {useDismiss} from '@floating-ui/react';\n```\n\nThis is useful to ensure the floating element is closed when the\nuser is finished interacting with it, including keyboard support.\n\n## [Usage](#usage)\n\nThis Hook returns event handler props.\n\nTo use it, pass it the `context` object returned from\n`useFloating()` or\n[`useFloatingRootContext`](/docs/useInteractions#external-reference),\nand then feed its result into the `useInteractions()` array.\nThe returned prop getters are then spread onto the elements for\nrendering.\n\n```\nfunction App() {\n  const [isOpen, setIsOpen] = useState(false);\n \n  const {refs, floatingStyles, context} = useFloating({\n    open: isOpen,\n    onOpenChange: setIsOpen,\n  });\n \n  const dismiss = useDismiss(context);\n \n  const {getReferenceProps, getFloatingProps} = useInteractions([\n    dismiss,\n  ]);\n \n  return (\n    <>\n      <div ref={refs.setReference} {...getReferenceProps()}>\n        Reference element\n      </div>\n      {isOpen && (\n        <div\n          ref={refs.setFloating}\n          style={floatingStyles}\n          {...getFloatingProps()}\n        >\n          Floating element\n        </div>\n      )}\n    </>\n  );\n}\n```\n\n## [Props](#props)\n\n```\ninterface UseDismissProps {\n  enabled?: boolean;\n  escapeKey?: boolean;\n  referencePress?: boolean;\n  referencePressEvent?: 'pointerdown' | 'mousedown' | 'click';\n  outsidePress?: boolean | ((event: MouseEvent) => boolean);\n  outsidePressEvent?: 'pointerdown' | 'mousedown' | 'click';\n  ancestorScroll?: boolean;\n  bubbles?:\n    | boolean\n    | {escapeKey?: boolean; outsidePress?: boolean};\n  capture?:\n    | boolean\n    | {escapeKey?: boolean; outsidePress?: boolean};\n}\n```\n\n### [`enabled`](#enabled)\n\ndefault: `true`\n\nConditionally enable/disable the Hook.\n\n```\nuseDismiss(context, {\n  enabled: false,\n});\n```\n\n### [`escapeKey`](#escapekey)\n\ndefault: `true`\n\nWhether to dismiss the floating element upon pressing the `esc`\nkey.\n\n```\nuseDismiss(context, {\n  escapeKey: false,\n});\n```\n\n### [`referencePress`](#referencepress)\n\ndefault: `false`\n\nWhether to dismiss the floating element upon pressing the\nreference element.\n\n```\nuseDismiss(context, {\n  referencePress: true,\n});\n```\n\nYou likely want to ensure the `move` option in the\n`useHover()` hook has been disabled when this is in use.\n\n### [`referencePressEvent`](#referencepressevent)\n\ndefault: `'pointerdown'`\n\nThe type of event to use to determine a \u201cpress\u201d.\n\n```\nuseDismiss(context, {\n  // Eager on both mouse + touch input.\n  referencePressEvent: 'pointerdown',\n  // Eager on mouse input; lazy on touch input.\n  referencePressEvent: 'mousedown',\n  // Lazy on both mouse + touch input.\n  referencePressEvent: 'click',\n});\n```\n\n### [`outsidePress`](#outsidepress)\n\ndefault: `true`\n\nWhether to dismiss the floating element upon pressing outside of\nboth the floating and reference elements.\n\n```\nuseDismiss(context, {\n  outsidePress: false,\n});\n```\n\nIf you have another element, like a toast, that is rendered\noutside the floating element\u2019s React tree and don\u2019t want the\nfloating element to close when pressing it, you can guard the\ncheck like so:\n\n```\nuseDismiss(context, {\n  // Same as `true`, but with a custom guard check.\n  outsidePress: (event) => !event.target.closest('.toast'),\n});\n```\n\n```\nfunction App() {\n  // The toast is not inside the Dialog's React tree, so we\n  // need to add a guard to consider it a child of the Dialog\n  // to prevent the Dialog's outside press from closing it.\n  return (\n    <>\n      <Dialog />\n      <Toast className=\"toast\" />\n    </>\n  );\n}\n```\n\n### [`outsidePressEvent`](#outsidepressevent)\n\ndefault: `'pointerdown'`\n\nThe type of event to use to determine a \u201cpress\u201d.\n\n```\nuseDismiss(context, {\n  // Eager on both mouse + touch input.\n  outsidePressEvent: 'pointerdown',\n  // Eager on mouse input; lazy on touch input.\n  outsidePressEvent: 'mousedown',\n  // Lazy on both mouse + touch input.\n  outsidePressEvent: 'click',\n});\n```\n\n### [`ancestorScroll`](#ancestorscroll)\n\ndefault: `false`\n\nWhether to dismiss the floating element upon scrolling an\noverflow ancestor.\n\n```\nuseDismiss(context, {\n  ancestorScroll: true,\n});\n```\n\n### [`bubbles`](#bubbles)\n\ndefault: `undefined`\n\nDetermines whether event listeners bubble upwards through a tree\nof floating elements.\n\n- `escapeKey` determines whether pressing the `esc` key\n  bubbles, causing ancestor floating elements to dismiss as well.\n  For instance, if you\u2019re dismissing a tooltip inside a dialog\n  using the `esc` key, you likely don\u2019t want the dialog to\n  dismiss as well until a second key press, which is the default\n  behavior.\n- `outsidePress` determines whether pressing outside of a\n  child floating element bubbles, causing ancestor floating\n  elements to dismiss as well. Setting this to `false`\n  requires a [`FloatingTree`](/docs/FloatingTree) to be set up.\n\n```\nuseDismiss(context, {\n  // Configure bubbling for all relevant events:\n  bubbles: false,\n  // Or, individually configure by event:\n  bubbles: {\n    escapeKey: true, // false by default\n    outsidePress: false, // true by default\n  },\n});\n```\n\n### [`capture`](#capture)\n\ndefault: `undefined`\n\nDetermines whether to use capture phase event listeners.\n\n```\nuseDismiss(context, {\n  // Configure capturing for all relevant events:\n  capture: true,\n  // Or, individually configure by event:\n  capture: {\n    escapeKey: true, // false by default\n    outsidePress: false, // true by default\n  },\n});\n```\n\n## [Reacting to dismissal](#reacting-to-dismissal)\n\nTo react to the dismissal event, you can check for the\n`reason` string in the `onOpenChange`\ncallback:\n\n```\nuseFloating({\n  open: isOpen,\n  onOpenChange(nextOpen, event, reason) {\n    setIsOpen(nextOpen);\n \n    // Other ones include 'reference-press' and 'ancestor-scroll'\n    // if enabled.\n    if (reason === 'escape-key' || reason === 'outside-press') {\n      console.log('Dismissed');\n    }\n  },\n});\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [Does not close when clicking in an iframe](#does-not-close-when-clicking-in-an-iframe)\n\nYou can use the\n[`FloatingOverlay` component](/docs/FloatingOverlay) which will\n\u201ccover\u201d iframes to ensure clicks are captured in the same\ndocument as the floating element, as the click occurs on the\noverlay backdrop. This guarantees \u201coutside press\u201d detection will\nwork.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:53.704696+00:00",
  "content_length": 5732,
  "content_hash": "1a442b52f0029eec"
}