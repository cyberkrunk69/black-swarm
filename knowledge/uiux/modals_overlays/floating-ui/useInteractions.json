{
  "id": "floating-ui__docs_useInteractions",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/useInteractions",
  "title": "useInteractions",
  "content": "use\nInteractions\nA hook to merge or compose interaction event handlers together,\npreserving memoization.\nimport\n{\nuseInteractions\n}\nfrom\n'\n@floating-ui/react\n'\n;\nInteraction Hooks like\nuseHover\n()\nand\nuseFocus\n()\ndo\ntwo things: they create Effects inside themselves that work\nindependently, and also return event handlers intended to be\npassed to the elements to add their functionality.\nUsage\nuseInteractions\n()\naccepts an array of the values returned\nfrom interaction Hooks, merging their event handlers into prop\ngetters used for rendering:\nimport\n{\nuseFloating\n,\nuseHover\n,\nuseFocus\n,\nuseInteractions\n,\n}\nfrom\n'\n@floating-ui/react\n'\n;\nfunction\nApp\n()\n{\nconst\n{\ncontext\n}\n=\nuseFloating\n()\n;\nconst\nhover\n=\nuseHover\n(\ncontext\n)\n;\nconst\nfocus\n=\nuseFocus\n(\ncontext\n)\n;\nconst\n{\ngetReferenceProps\n,\ngetFloatingProps\n}\n=\nuseInteractions\n(\n[\nhover\n,\nfocus\n,\n]\n)\n;\n}\nExternal reference\nIn your component API, the reference element may be external to\nthe component that\nuseFloating\n()\nis called in (where the\npositioning data is passed). In such a tree structure, the\ninteractions are shared between the reference element and\nfloating element in a \u201croot\u201d component higher than them \u2014 an\nancestor common to both.\nAn example would be:\n<\nTooltipRoot\n>\n{\n/* useInteractions() called in this component */\n}\n<\nTooltipTrigger\n/>\n<\nTooltipPopup\n/>\n{\n/* useFloating() called in this component */\n}\n</\nTooltipRoot\n>\nTo share the interactions between the reference and floating\nelements, you can use the\nuseFloatingRootContext\n()\nHook:\nimport\n{\nuseFloatingRootContext\n}\nfrom\n'\n@floating-ui/react\n'\n;\nIt returns a\ncontext object\nthat is accepted by all interaction Hooks, similar to the one\nreturned by\nuseFloating\n()\n\u2014 only without the positioning\ndata.\nPass the open state and elements to the Hook:\nfunction\nTooltipRoot\n()\n{\nconst\n[\nisOpen\n,\nsetIsOpen\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n[\nanchor\n,\nsetAnchor\n]\n=\nuseState\n(\nnull\n)\n;\nconst\n[\ntooltip\n,\nsetTooltip\n]\n=\nuseState\n(\nnull\n)\n;\nconst\ncontext\n=\nuseFloatingRootContext\n({\nopen\n:\nisOpen\n,\nonOpenChange\n:\nsetIsOpen\n,\n// Required: both elements must be passed externally.\n// Store them in state.\nelements\n:\n{\nreference\n:\nanchor\n,\nfloating\n:\ntooltip\n,\n}\n,\n})\n;\nconst\nclick\n=\nuseClick\n(\ncontext\n)\n;\nconst\n{\ngetReferenceProps\n,\ngetFloatingProps\n}\n=\nuseInteractions\n(\n[\nclick\n,\n]\n)\n;\nreturn\n(\n<>\n<\nAnchor\nsetAnchor\n={\nsetAnchor\n}\n{\n...\ngetReferenceProps\n()\n}\n/>\n<\nTooltip\nrootContext\n={\ncontext\n}\nsetTooltip\n={\nsetTooltip\n}\n{\n...\ngetFloatingProps\n()\n}\n/>\n;\n</>\n)\n;\n}\nThe root context must be available to\nuseFloating\n()\nby\npassing it as the\nrootContext\noption:\nfunction\nTooltip\n(\n{\nrootContext\n,\nsetTooltip\n,\n...\nprops\n}\n)\n{\nconst\n{\nfloatingStyles\n}\n=\nuseFloating\n({\nrootContext\n,\n})\n;\nreturn\n<\ndiv\nref\n={\nsetTooltip\n}\n{\n...\nprops\n}\n/>;\n}\nReturn value\ninterface\nUseInteractionsReturn\n{\ngetReferenceProps\n(\nuserProps\n?:\nReact\n.\nHTMLProps\n<\nElement\n>,\n)\n:\nRecord\n<\nstring\n,\nunknown\n>;\ngetFloatingProps\n(\nuserProps\n?:\nReact\n.\nHTMLProps\n<\nHTMLElement\n>,\n)\n:\nRecord\n<\nstring\n,\nunknown\n>;\ngetItemProps\n(\nuserProps\n?:\nReact\n.\nHTMLProps\n<\nHTMLElement\n>,\n)\n:\nRecord\n<\nstring\n,\nunknown\n>;\n}\nThe Hook returns two core prop getters, one for the reference\nelement and one for the floating element. These prop getters\nshould be spread onto the elements:\n<>\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n{\n...\ngetReferenceProps\n()\n}\n/>\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}\n{\n...\ngetFloatingProps\n()\n}\n/>\n</>\nAll event handlers you pass in should be done so through the prop\ngetter, not the element itself:\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n{\n...\ngetReferenceProps\n({\nonClick\n:\n()\n=>\nconsole\n.\nlog\n(\n'\nclicked\n'\n)\n,\nonFocus\n:\n()\n=>\nconsole\n.\nlog\n(\n'\nfocused\n'\n)\n,\n})\n}\n/>\nThis is because your handler may be either overwritten or\noverwrite one of the Hooks\u2019 handlers. More event handlers may\nalso be added in future versions.\ngetItemProps\nA third prop getter is returned for item elements when dealing\nwith a list inside the floating element, which is not required\nfor all types of floating elements. See\nuseRole\nfor more information on this prop\ngetter for listbox (e.g. select or combobox) or menu roles.\nconst\n{\ngetReferenceProps\n,\ngetFloatingProps\n,\ngetItemProps\n}\n=\nuseInteractions\n(\n[]\n)\n;",
  "content_markdown": "# useInteractions\n\nA hook to merge or compose interaction event handlers together,\npreserving memoization.\n\n```\nimport {useInteractions} from '@floating-ui/react';\n```\n\nInteraction Hooks like `useHover()` and `useFocus()` do\ntwo things: they create Effects inside themselves that work\nindependently, and also return event handlers intended to be\npassed to the elements to add their functionality.\n\n## [Usage](#usage)\n\n`useInteractions()` accepts an array of the values returned\nfrom interaction Hooks, merging their event handlers into prop\ngetters used for rendering:\n\n```\nimport {\n  useFloating,\n  useHover,\n  useFocus,\n  useInteractions,\n} from '@floating-ui/react';\n \nfunction App() {\n  const {context} = useFloating();\n \n  const hover = useHover(context);\n  const focus = useFocus(context);\n \n  const {getReferenceProps, getFloatingProps} = useInteractions([\n    hover,\n    focus,\n  ]);\n}\n```\n\n## [External reference](#external-reference)\n\nIn your component API, the reference element may be external to\nthe component that `useFloating()` is called in (where the\npositioning data is passed). In such a tree structure, the\ninteractions are shared between the reference element and\nfloating element in a \u201croot\u201d component higher than them \u2014 an\nancestor common to both.\n\nAn example would be:\n\n```\n<TooltipRoot> {/* useInteractions() called in this component */}\n  <TooltipTrigger />\n  <TooltipPopup /> {/* useFloating() called in this component */}\n</TooltipRoot>\n```\n\nTo share the interactions between the reference and floating\nelements, you can use the `useFloatingRootContext()` Hook:\n\n```\nimport {useFloatingRootContext} from '@floating-ui/react';\n```\n\nIt returns a context object\nthat is accepted by all interaction Hooks, similar to the one\nreturned by `useFloating()` \u2014 only without the positioning\ndata.\n\nPass the open state and elements to the Hook:\n\n```\nfunction TooltipRoot() {\n  const [isOpen, setIsOpen] = useState(false);\n \n  const [anchor, setAnchor] = useState(null);\n  const [tooltip, setTooltip] = useState(null);\n \n  const context = useFloatingRootContext({\n    open: isOpen,\n    onOpenChange: setIsOpen,\n    // Required: both elements must be passed externally.\n    // Store them in state.\n    elements: {\n      reference: anchor,\n      floating: tooltip,\n    },\n  });\n \n  const click = useClick(context);\n \n  const {getReferenceProps, getFloatingProps} = useInteractions([\n    click,\n  ]);\n \n  return (\n    <>\n      <Anchor setAnchor={setAnchor} {...getReferenceProps()} />\n      <Tooltip\n        rootContext={context}\n        setTooltip={setTooltip}\n        {...getFloatingProps()}\n      />;\n    </>\n  );\n}\n```\n\nThe root context must be available to `useFloating()` by\npassing it as the `rootContext` option:\n\n```\nfunction Tooltip({rootContext, setTooltip, ...props}) {\n  const {floatingStyles} = useFloating({\n    rootContext,\n  });\n  return <div ref={setTooltip} {...props} />;\n}\n```\n\n## [Return value](#return-value)\n\n```\ninterface UseInteractionsReturn {\n  getReferenceProps(\n    userProps?: React.HTMLProps<Element>,\n  ): Record<string, unknown>;\n  getFloatingProps(\n    userProps?: React.HTMLProps<HTMLElement>,\n  ): Record<string, unknown>;\n  getItemProps(\n    userProps?: React.HTMLProps<HTMLElement>,\n  ): Record<string, unknown>;\n}\n```\n\nThe Hook returns two core prop getters, one for the reference\nelement and one for the floating element. These prop getters\nshould be spread onto the elements:\n\n```\n<>\n  <div ref={refs.setReference} {...getReferenceProps()} />\n  <div\n    ref={refs.setFloating}\n    style={floatingStyles}\n    {...getFloatingProps()}\n  />\n</>\n```\n\nAll event handlers you pass in should be done so through the prop\ngetter, not the element itself:\n\n```\n<div\n  ref={refs.setReference}\n  {...getReferenceProps({\n    onClick: () => console.log('clicked'),\n    onFocus: () => console.log('focused'),\n  })}\n/>\n```\n\nThis is because your handler may be either overwritten or\noverwrite one of the Hooks\u2019 handlers. More event handlers may\nalso be added in future versions.\n\n## [`getItemProps`](#getitemprops)\n\nA third prop getter is returned for item elements when dealing\nwith a list inside the floating element, which is not required\nfor all types of floating elements. See\n[`useRole`](/docs/useRole#role) for more information on this prop\ngetter for listbox (e.g. select or combobox) or menu roles.\n\n```\nconst {\n  getReferenceProps, \n  getFloatingProps, \n  getItemProps\n} = useInteractions([]);\n```",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:57.622309+00:00",
  "content_length": 4219,
  "content_hash": "acb785d0d2eac0ec"
}