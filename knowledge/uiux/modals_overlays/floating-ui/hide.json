{
  "id": "floating-ui__docs_hide",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/hide",
  "title": "hide",
  "content": "hide\nA data provider that allows you to hide the floating element in\napplicable situations.\nData Provider\nimport\n{\nhide\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nThis is useful for situations where you want to hide the floating\nelement because it appears detached from the reference element\n(or attached to nothing).\nScroll up\nIn the above example, the floating element turns partially\ntransparent once it has\nescaped\nthe reference element\u2019s\nclipping context. Once the reference element is hidden, it hides\nitself.\nUsage\nApply a hidden visibility style to the floating element based on\nthe data in\nmiddlewareData\n.\nhide\n:\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nhide\n()\n],\n})\n.\nthen\n((\n{\nmiddlewareData\n}\n)\n=>\n{\nif\n(\nmiddlewareData\n.\nhide\n)\n{\nObject\n.\nassign\n(\nfloatingEl\n.\nstyle\n,\n{\nvisibility\n:\nmiddlewareData\n.\nhide\n.\nreferenceHidden\n?\n'\nhidden\n'\n:\n'\nvisible\n'\n,\n})\n;\n}\n})\n;\nOrder\nhide\n()\nshould generally be placed at the end of your\nmiddleware array.\nOptions\nThese are the options you can pass to\nhide\n()\n.\ninterface\nHideOptions\nextends\nDetectOverflowOptions\n{\nstrategy\n?:\n'\nreferenceHidden\n'\n|\n'\nescaped\n'\n;\n}\nstrategy\ndefault:\n'\nreferenceHidden\n'\nThe strategy used to determine when to hide the floating element.\nhide\n({\nstrategy\n:\n'\nescaped\n'\n,\n// 'referenceHidden' by default\n})\n;\nIf you\u2019d like to use multiple strategies, call\nhide\n()\nmultiple times in your middleware array with different options.\n\u2026detectOverflowOptions\nAll of\ndetectOverflow\n\u2019s options\ncan be passed. For instance:\nhide\n({\npadding\n:\n5\n,\n// 0 by default\n})\n;\nDeriving options from state\nYou can derive the options from the\nmiddleware lifecycle state\n:\nhide\n((\nstate\n)\n=>\n({\npadding\n:\nstate\n.\nrects\n.\nreference\n.\nwidth\n,\n}))\n;\nData\ninterface\nData\n{\nreferenceHidden\n?:\nboolean\n;\nreferenceHiddenOffsets\n?:\nSideObject\n;\nescaped\n?:\nboolean\n;\nescapedOffsets\n?:\nSideObject\n;\n}\nDepending on the strategy used, these options may exist in the\ndata object.\nreferenceHidden\nDetermines whether the reference element is fully clipped, and is\ntherefore hidden from view.\nNote that \u201chidden\u201d means clipping,\nvisibility\nand\nopacity\nstyles are not considered.\nreferenceHiddenOffsets\nA side object containing overflow offsets.\nescaped\nDetermines whether the floating element has \u201cescaped\u201d the\nreference\u2019s clipping context and appears fully detached from it.\nescapedOffsets\nA side object containing overflow offsets.",
  "content_markdown": "# hide\n\nA data provider that allows you to hide the floating element in\napplicable situations.\n\n*Data Provider*\n\n```\nimport {hide} from '@floating-ui/dom';\n```\n\nThis is useful for situations where you want to hide the floating\nelement because it appears detached from the reference element\n(or attached to nothing).\n\nScroll up\n\nIn the above example, the floating element turns partially\ntransparent once it has `escaped` the reference element\u2019s\nclipping context. Once the reference element is hidden, it hides\nitself.\n\n## [Usage](#usage)\n\nApply a hidden visibility style to the floating element based on\nthe data in `middlewareData.hide`:\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [hide()],\n}).then(({middlewareData}) => {\n  if (middlewareData.hide) {\n    Object.assign(floatingEl.style, {\n      visibility: middlewareData.hide.referenceHidden\n        ? 'hidden'\n        : 'visible',\n    });\n  }\n});\n```\n\n## [Order](#order)\n\n`hide()` should generally be placed at the end of your\nmiddleware array.\n\n## [Options](#options)\n\nThese are the options you can pass to `hide()`.\n\n```\ninterface HideOptions extends DetectOverflowOptions {\n  strategy?: 'referenceHidden' | 'escaped';\n}\n```\n\n### [`strategy`](#strategy)\n\ndefault: `'referenceHidden'`\n\nThe strategy used to determine when to hide the floating element.\n\n```\nhide({\n  strategy: 'escaped', // 'referenceHidden' by default\n});\n```\n\nIf you\u2019d like to use multiple strategies, call `hide()`\nmultiple times in your middleware array with different options.\n\n### [\u2026detectOverflowOptions](#detectoverflowoptions)\n\nAll of [`detectOverflow`](/docs/detectOverflow#options)\u2019s options\ncan be passed. For instance:\n\n```\nhide({\n  padding: 5, // 0 by default\n});\n```\n\n### [Deriving options from state](#deriving-options-from-state)\n\nYou can derive the options from the\n[middleware lifecycle state](/docs/middleware#middlewarestate):\n\n```\nhide((state) => ({\n  padding: state.rects.reference.width,\n}));\n```\n\n## [Data](#data)\n\n```\ninterface Data {\n  referenceHidden?: boolean;\n  referenceHiddenOffsets?: SideObject;\n  escaped?: boolean;\n  escapedOffsets?: SideObject;\n}\n```\n\nDepending on the strategy used, these options may exist in the\ndata object.\n\n### [`referenceHidden`](#referencehidden)\n\nDetermines whether the reference element is fully clipped, and is\ntherefore hidden from view.\n\nNote that \u201chidden\u201d means clipping, `visibility` and `opacity`\nstyles are not considered.\n\n### [`referenceHiddenOffsets`](#referencehiddenoffsets)\n\nA side object containing overflow offsets.\n\n### [`escaped`](#escaped)\n\nDetermines whether the floating element has \u201cescaped\u201d the\nreference\u2019s clipping context and appears fully detached from it.\n\n### [`escapedOffsets`](#escapedoffsets)\n\nA side object containing overflow offsets.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:38.424523+00:00",
  "content_length": 2383,
  "content_hash": "4f9224916cb2df92"
}