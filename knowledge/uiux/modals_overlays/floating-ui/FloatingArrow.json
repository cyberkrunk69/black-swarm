{
  "id": "floating-ui__docs_FloatingArrow",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/FloatingArrow",
  "title": "FloatingArrow",
  "content": "Floating\nArrow\nRenders a customizable\n<\nsvg\n>\npointing arrow triangle\ninside the floating element that gets automatically positioned.\nimport\n{\nFloatingArrow\n}\nfrom\n'\n@floating-ui/react\n'\n;\nFloating\nFloating\nFloating\nFloating\nUsage\nCreate an\narrowRef\nand\npass it to the\narrow middleware\n\u2019s\nelement\noption and the\n<\nFloatingArrow\n/>\ncomponent. This lets the arrow be measured for positioning.\nPass the\ncontext\nto the\n<\nFloatingArrow\n/>\ncomponent. This lets the component\nread the positioning data.\nimport\n{\nFloatingArrow\n,\narrow\n}\nfrom\n'\n@floating-ui/react\n'\n;\nfunction\nApp\n()\n{\nconst\narrowRef\n=\nuseRef\n(\nnull\n)\n;\nconst\n{\nrefs\n,\nfloatingStyles\n,\ncontext\n}\n=\nuseFloating\n({\nmiddleware\n:\n[\narrow\n({\nelement\n:\narrowRef\n,\n})\n,\n],\n})\n;\nreturn\n(\n<>\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n/>\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}>\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\n/>\n</\ndiv\n>\n</>\n)\n;\n}\nThe arrow will, by default, overlap the reference element. The\nheight\nof the arrow will offset it by the desired\namount.\nimport\n{\noffset\n}\nfrom\n'\n@floating-ui/react\n'\n;\nconst\nARROW_HEIGHT\n=\n7\n;\nconst\nGAP\n=\n2\n;\nuseFloating\n({\nmiddleware\n:\n[\noffset\n(\nARROW_HEIGHT\n+\nGAP\n)\n],\n})\n;\nThis does not take into account tip rounding or strokes.\nProps\nThe arrow accepts all the props of an\n<\nsvg\n>\nelement, plus\nsome additional props:\ninterface\nProps\nextends\nReact\n.\nSVGAttributes\n<\nSVGSVGElement\n>\n{\ncontext\n:\nFloatingContext\n;\nwidth\n?:\nnumber\n;\nheight\n?:\nnumber\n;\ntipRadius\n?:\nnumber\n;\nstaticOffset\n?:\nnumber\n|\nstring\n|\nnull\n;\n// Inherited SVG props that are intercepted and passed\n// to the <path>s\nd\n?:\nstring\n;\nfill\n?:\nstring\n;\nstroke\n?:\nstring\n;\nstrokeWidth\n?:\nnumber\n;\n}\nref\nRequired\n<\nFloatingArrow\nref\n={\narrowRef\n}\n/>\ncontext\nRequired\nThe\ncontext\nobject returned from\nuseFloating\n()\n.\nconst\n{\ncontext\n}\n=\nuseFloating\n()\n;\n<\nFloatingArrow\ncontext\n={\ncontext\n}\n/>;\nwidth\ndefault:\n14\nThe width of the arrow.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nwidth\n={\n10\n}\n/>\nheight\ndefault:\n7\nThe height of the arrow.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nheight\n={\n10\n}\n/>\ntipRadius\ndefault:\n0\n(sharp)\nThe radius (rounding) of the arrow tip.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\ntipRadius\n={\n2\n}\n/>\nstaticOffset\ndefault:\nundefined\n(use dynamic position)\nA static offset override of the arrow from the floating element\nedge. Often desirable if the floating element is smaller than the\nreference element along the relevant axis and has an edge\nalignment (\n'\nstart\n'\n/\n'\nend\n'\n). This is ignored if the\nshift() middleware caused the floating element to shift.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nstaticOffset\n={\nisEdgeAlignedAndSmaller\n?\n'\n15%\n'\n:\nnull\n}\n/>\nd\ndefault:\nundefined\n(use dynamic path)\nA custom path for the arrow. Useful if you want fancy rounding.\nThe path should be inside a square SVG and placed at the bottom\nof it. The path is designed for the\n'\nbottom\n'\nplacement,\nwhich will be rotated for other placements.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nwidth\n={\n20\n}\nheight\n={\n20\n}\nd\n=\n\"\nM0 20C0 20 2.06906 19.9829 5.91817 15.4092C7.49986 13.5236 8.97939 12.3809 10.0002 12.3809C11.0202 12.3809 12.481 13.6451 14.0814 15.5472C17.952 20.1437 20 20 20 20H0Z\n\"\n/>\nfill\ndefault:\n\"\nblack\n\"\n(browser default)\nThe color of the arrow.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nfill\n=\n\"\nred\n\"\n/>\nstroke\ndefault:\n\"\nnone\n\"\nThe stroke (border) color of the arrow.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nstroke\n=\n\"\nred\n\"\n/>\nstrokeWidth\ndefault:\n0\nThe stroke (border) width of the arrow. This must match (or be\nless than) the floating element\u2019s border width.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nstrokeWidth\n={\n2\n}\n/>\nTailwind and utility CSS styling\nfill-*\nsets the arrow\u2019s fill color.\n[&>path:first-of-type]\ntargets the \u201cstroke\u201d path.\n[&>path:last-of-type]\ntargets the \u201cfill\u201d path\u2019s\nextra stroke, to reduce gaps.\nstrokeWidth\nshould still be manually specified as a\nprop.\n<\nFloatingArrow\nref\n={\narrowRef\n}\ncontext\n={\ncontext\n}\nclassName\n=\n\"\nfill-white\n[&>path:first-of-type]:stroke-pink-500\n[&>path:last-of-type]:stroke-white\n\"\n/>\nScale transforms\nWhen animating the floating element\u2019s scale, it looks best if the\nfloating element\u2019s\ntransform-origin\nis at the tip of the arrow.\nThe\narrow\nmiddleware provides data to achieve this.\nView on CodeSandbox\nTroubleshooting\nStroke is not visible\nEnsure you\u2019ve specified at least a\nstrokeWidth\nof\n1\n.\nA gap is present\nStyling the top-level\n<\nsvg\n>\nusing native CSS properties\nlike\nfill\nand\nstroke\ndirectly won\u2019t work correctly. This\ncan happen if you\u2019re styling using\nstyled\n(\nFloatingArrow\n)\nfor example. Instead, use the\nfill\nand\nstroke\nprops, or target the child path elements as\nshown in\nTailwind and utility CSS styling\n.\nIf a border is applied to an inner element of the floating\nelement, make sure arrow is inside the inner element and that\nthe inner element has\nposition\n:\nrelative\nCSS. This\nensures the arrow will align with the border correctly.\nEnsure the\nstrokeWidth\nof the arrow is the same as\nthe floating element\u2019s border width.\nThe gap may be related to zoom levels in some browsers or the\nOS. To support transparency and prevent overlapping of colors\nof the floating and arrow element, this problem cannot be\navoided. If your floating element and arrow are not partially\ntransparent and are instead solid colors, you can use the\nfollowing workaround:\n<\nFloatingArrow\nstyle\n={\n{\ntransform\n:\n'\ntranslateY(-1px)\n'\n}\n}>\nArrow does not avoid rounded corners\nThe arrow doesn\u2019t automatically avoid rounded corners of the\nfloating element when it\u2019s shifted. To ensure it doesn\u2019t overflow\nthe corners, you can use the\npadding\nprop in the\narrow\n()\nmiddleware when calling\nuseFloating\n()\nto\naccount for this.",
  "content_markdown": "# FloatingArrow\n\nRenders a customizable `<svg>` pointing arrow triangle\ninside the floating element that gets automatically positioned.\n\n```\nimport {FloatingArrow} from '@floating-ui/react';\n```\n\nFloating\n\nFloating\n\nFloating\n\nFloating\n\n## [Usage](#usage)\n\n- Create an arrowRef and\n  pass it to the [arrow middleware](/docs/arrow)\u2019s\n  `element` option and the `<FloatingArrow />`\n  component. This lets the arrow be measured for positioning.\n- Pass the context to the\n  `<FloatingArrow />` component. This lets the component\n  read the positioning data.\n\n```\nimport {FloatingArrow, arrow} from '@floating-ui/react';\n \nfunction App() {\n  const arrowRef = useRef(null);\n  const {refs, floatingStyles, context} = useFloating({\n    middleware: [\n      arrow({\n        element: arrowRef,\n      }),\n    ],\n  });\n \n  return (\n    <>\n      <div ref={refs.setReference} />\n      <div ref={refs.setFloating} style={floatingStyles}>\n        <FloatingArrow ref={arrowRef} context={context} />\n      </div>\n    </>\n  );\n}\n```\n\nThe arrow will, by default, overlap the reference element. The\n`height` of the arrow will offset it by the desired\namount.\n\n```\nimport {offset} from '@floating-ui/react';\n \nconst ARROW_HEIGHT = 7;\nconst GAP = 2;\n \nuseFloating({\n  middleware: [offset(ARROW_HEIGHT + GAP)],\n});\n```\n\nThis does not take into account tip rounding or strokes.\n\n## [Props](#props)\n\nThe arrow accepts all the props of an `<svg>` element, plus\nsome additional props:\n\n```\ninterface Props extends React.SVGAttributes<SVGSVGElement> {\n  context: FloatingContext;\n  width?: number;\n  height?: number;\n  tipRadius?: number;\n  staticOffset?: number | string | null;\n \n  // Inherited SVG props that are intercepted and passed\n  // to the <path>s\n  d?: string;\n  fill?: string;\n  stroke?: string;\n  strokeWidth?: number;\n}\n```\n\n### [`ref`](#ref)\n\nRequired\n\n```\n<FloatingArrow ref={arrowRef} />\n```\n\n### [`context`](#context)\n\nRequired\n\nThe `context` object returned from `useFloating()`.\n\n```\nconst {context} = useFloating();\n<FloatingArrow context={context} />;\n```\n\n### [`width`](#width)\n\ndefault: `14`\n\nThe width of the arrow.\n\n```\n<FloatingArrow ref={arrowRef} context={context} width={10} />\n```\n\n### [`height`](#height)\n\ndefault: `7`\n\nThe height of the arrow.\n\n```\n<FloatingArrow ref={arrowRef} context={context} height={10} />\n```\n\n### [`tipRadius`](#tipradius)\n\ndefault: `0` (sharp)\n\nThe radius (rounding) of the arrow tip.\n\n```\n<FloatingArrow ref={arrowRef} context={context} tipRadius={2} />\n```\n\n### [`staticOffset`](#staticoffset)\n\ndefault: `undefined` (use dynamic position)\n\nA static offset override of the arrow from the floating element\nedge. Often desirable if the floating element is smaller than the\nreference element along the relevant axis and has an edge\nalignment (`'start'`/`'end'`). This is ignored if the\nshift() middleware caused the floating element to shift.\n\n```\n<FloatingArrow\n  ref={arrowRef}\n  context={context}\n  staticOffset={isEdgeAlignedAndSmaller ? '15%' : null}\n/>\n```\n\n### [`d`](#d)\n\ndefault: `undefined` (use dynamic path)\n\nA custom path for the arrow. Useful if you want fancy rounding.\nThe path should be inside a square SVG and placed at the bottom\nof it. The path is designed for the `'bottom'` placement,\nwhich will be rotated for other placements.\n\n```\n<FloatingArrow\n  ref={arrowRef}\n  context={context}\n  width={20}\n  height={20}\n  d=\"M0 20C0 20 2.06906 19.9829 5.91817 15.4092C7.49986 13.5236 8.97939 12.3809 10.0002 12.3809C11.0202 12.3809 12.481 13.6451 14.0814 15.5472C17.952 20.1437 20 20 20 20H0Z\"\n/>\n```\n\n### [`fill`](#fill)\n\ndefault: `\"black\"` (browser default)\n\nThe color of the arrow.\n\n```\n<FloatingArrow ref={arrowRef} context={context} fill=\"red\" />\n```\n\n### [`stroke`](#stroke)\n\ndefault: `\"none\"`\n\nThe stroke (border) color of the arrow.\n\n```\n<FloatingArrow ref={arrowRef} context={context} stroke=\"red\" />\n```\n\n### [`strokeWidth`](#strokewidth)\n\ndefault: `0`\n\nThe stroke (border) width of the arrow. This must match (or be\nless than) the floating element\u2019s border width.\n\n```\n<FloatingArrow\n  ref={arrowRef}\n  context={context}\n  strokeWidth={2}\n/>\n```\n\n## [Tailwind and utility CSS styling](#tailwind-and-utility-css-styling)\n\n- `fill-*` sets the arrow\u2019s fill color.\n- `[&>path:first-of-type]` targets the \u201cstroke\u201d path.\n- `[&>path:last-of-type]` targets the \u201cfill\u201d path\u2019s\n  extra stroke, to reduce gaps.\n\n`strokeWidth` should still be manually specified as a\nprop.\n\n```\n<FloatingArrow\n  ref={arrowRef}\n  context={context}\n  className=\"\n    fill-white \n    [&>path:first-of-type]:stroke-pink-500\n    [&>path:last-of-type]:stroke-white\n  \"\n/>\n```\n\n## [Scale transforms](#scale-transforms)\n\nWhen animating the floating element\u2019s scale, it looks best if the\nfloating element\u2019s `transform-origin` is at the tip of the arrow.\nThe `arrow` middleware provides data to achieve this.\n\n[View on CodeSandbox](https://codesandbox.io/s/floating-ui-react-scale-transform-origin-qv0t1c?file=/src/App.tsx)\n\n## [Troubleshooting](#troubleshooting)\n\n### [Stroke is not visible](#stroke-is-not-visible)\n\nEnsure you\u2019ve specified at least a `strokeWidth` of\n`1`.\n\n### [A gap is present](#a-gap-is-present)\n\n- Styling the top-level `<svg>` using native CSS properties\n  like `fill` and `stroke` directly won\u2019t work correctly. This\n  can happen if you\u2019re styling using `styled(FloatingArrow)`\n  for example. Instead, use the `fill` and\n  `stroke` props, or target the child path elements as\n  shown in\n  [Tailwind and utility CSS styling](/docs/FloatingArrow#tailwind-and-utility-css-styling).\n- If a border is applied to an inner element of the floating\n  element, make sure arrow is inside the inner element and that\n  the inner element has `position: relative` CSS. This\n  ensures the arrow will align with the border correctly.\n- Ensure the `strokeWidth` of the arrow is the same as\n  the floating element\u2019s border width.\n- The gap may be related to zoom levels in some browsers or the\n  OS. To support transparency and prevent overlapping of colors\n  of the floating and arrow element, this problem cannot be\n  avoided. If your floating element and arrow are not partially\n  transparent and are instead solid colors, you can use the\n  following workaround:\n\n```\n<FloatingArrow style={{ transform: 'translateY(-1px)' }}>\n```\n\n### [Arrow does not avoid rounded corners](#arrow-does-not-avoid-rounded-corners)\n\nThe arrow doesn\u2019t automatically avoid rounded corners of the\nfloating element when it\u2019s shifted. To ensure it doesn\u2019t overflow\nthe corners, you can use the `padding` prop in the\n`arrow()` middleware when calling `useFloating()` to\naccount for this.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:54:05.196166+00:00",
  "content_length": 5789,
  "content_hash": "028fe60c8c9e9e8d"
}