{
  "id": "floating-ui__docs_size",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/size",
  "title": "size",
  "content": "size\nProvides data to change the size of a floating element.\nVisibility Optimizer\nData Provider\nimport\n{\nsize\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nThis is useful to ensure the floating element isn\u2019t too big to\nfit in the viewport (or more specifically, its clipping context),\nespecially when a maximum size isn\u2019t specified. It also allows\nmatching the width/height of the reference element.\nScroll the container\nFloating\nUsage\nIf your floating element\u2019s content cannot be resized such as in\nthe example, you can make the floating element scrollable with\noverflow\n:\nscroll\n(or\nauto\n). Ensure your CSS\nis using\nbox-sizing\n:\nborder-box\n!\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nsize\n({\napply\n(\n{\navailableWidth\n,\navailableHeight\n,\nelements\n}\n)\n{\n// Change styles, e.g.\nObject\n.\nassign\n(\nelements\n.\nfloating\n.\nstyle\n,\n{\nmaxWidth\n:\n`${\nMath\n.\nmax\n(\n0\n,\navailableWidth\n)\n}\npx\n`\n,\nmaxHeight\n:\n`${\nMath\n.\nmax\n(\n0\n,\navailableHeight\n)\n}\npx\n`\n,\n})\n;\n}\n,\n})\n,\n],\n})\n;\nOptions\nThese are the options you can pass to\nsize\n()\n.\ninterface\nSizeOptions\nextends\nDetectOverflowOptions\n{\napply\n?:\n(\nstate\n:\nMiddlewareState\n&\n{\navailableWidth\n:\nnumber\n;\navailableHeight\n:\nnumber\n;\n}\n,\n)\n=>\nvoid\n;\n}\napply\ndefault:\nundefined\nUnlike other middleware, in which you assign styles after\ncomputePosition\n()\nhas done its work,\nsize\n()\nhas its\nown\napply\nfunction to do the work during the\nlifecycle:\nsize\n({\napply\n(\n{\navailableWidth\n,\navailableHeight\n,\n...\nstate\n}\n)\n{\n// Style mutations here\n}\n,\n})\n;\navailableWidth\nRepresents how wide the floating element can be before it will\noverflow its clipping context. You\u2019ll generally set this as the\nmaxWidth\nCSS property.\navailableHeight\nRepresents how tall the floating element can be before it will\noverflow its clipping context. You\u2019ll generally set this as the\nmaxHeight\nCSS property.\n\u2026middlewareState\nSee\nMiddlewareState\n.\nMany useful properties are also accessible via this callback,\nsuch as\nrects\nand\nelements\n.\n\u2026detectOverflowOptions\nAll of\ndetectOverflow\n\u2019s options\ncan be passed. For instance:\nsize\n({\npadding\n:\n5\n})\n;\n// 0 by default\nDeriving options from state\nYou can derive the options from the\nmiddleware lifecycle state\n:\nsize\n((\nstate\n)\n=>\n({\npadding\n:\nstate\n.\nrects\n.\nreference\n.\nwidth\n,\n}))\n;\nUsing with\nflip\n()\nUsing\nsize\n()\ntogether with\nflip\n()\nenables some\nuseful behavior. The floating element can be resized, thus\nallowing it to prefer its initial placement as much as possible,\nuntil it reaches a minimum size, at which point it will flip.\nIf you\u2019re using the\npadding\noption in either middleware,\nensure they share the\nsame value\n.\nbestFit\nThe\n'\nbestFit\n'\nfallback strategy in the\nflip\n()\nmiddleware is the default, which ensures the best fitting\nplacement is used. In this scenario, place\nsize\n()\nafter\nflip\n()\n:\nconst\nmiddleware\n=\n[\nflip\n()\n,\nsize\n({\napply\n(\n{\navailableWidth\n,\navailableHeight\n}\n)\n{\n// ...\n}\n,\n})\n,\n];\nScroll the container\nFloating\nThis strategy ensures the floating element stays in view at all\ntimes at the most optimal size.\ninitialPlacement\nIf instead, you want the initial placement to take precedence,\nand are setting a minimum acceptable size, place\nsize\n()\nbefore\nflip\n()\n:\nconst\nmiddleware\n=\n[\nsize\n({\napply\n(\n{\navailableHeight\n,\nelements\n}\n)\n{\nObject\n.\nassign\n(\nelements\n.\nfloating\n.\nstyle\n,\n{\n// Minimum acceptable height is 50px.\n// `flip` will then take over.\nmaxHeight\n:\n`${\nMath\n.\nmax\n(\n50\n,\navailableHeight\n)\n}\npx\n`\n,\n})\n;\n}\n,\n})\n,\nflip\n({\nfallbackStrategy\n:\n'\ninitialPlacement\n'\n,\n})\n,\n];\nMatch reference width\nA common feature of select dropdowns is that the dropdown matches\nthe width of the reference regardless of its contents. You can\nalso use\nsize\n()\nfor this, as the\nRect\ns get\npassed in:\nsize\n({\napply\n(\n{\nrects\n,\nelements\n}\n)\n{\nObject\n.\nassign\n(\nelements\n.\nfloating\n.\nstyle\n,\n{\nminWidth\n:\n`${\nrects\n.\nreference\n.\nwidth\n}\npx\n`\n,\n})\n;\n}\n,\n})\n;\nTroubleshooting\nmaxHeight\nstyle left on floating element\nLeaving the\nmaxHeight\nstyle on the floating element that\u2019s kept\nmounted in the DOM when closed can cause issues in certain\nsituations where it can and should expand more.\nBy removing the style inside the\napply\nfunction\nwhen the\nscrollHeight\nis less than the\navailableHeight\n, you\ncan prevent this:\nelements\n.\nfloating\n.\nstyle\n.\nmaxHeight\n=\navailableHeight\n>=\nelements\n.\nfloating\n.\nscrollHeight\n?\n''\n:\n`${\navailableHeight\n}\npx\n`\n;",
  "content_markdown": "# size\n\nProvides data to change the size of a floating element.\n\n*Visibility Optimizer**Data Provider*\n\n```\nimport {size} from '@floating-ui/dom';\n```\n\nThis is useful to ensure the floating element isn\u2019t too big to\nfit in the viewport (or more specifically, its clipping context),\nespecially when a maximum size isn\u2019t specified. It also allows\nmatching the width/height of the reference element.\n\nScroll the container\n\nFloating\n\n## [Usage](#usage)\n\nIf your floating element\u2019s content cannot be resized such as in\nthe example, you can make the floating element scrollable with\n`overflow: scroll` (or `auto`). Ensure your CSS\nis using `box-sizing: border-box`!\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [\n    size({\n      apply({availableWidth, availableHeight, elements}) {\n        // Change styles, e.g.\n        Object.assign(elements.floating.style, {\n          maxWidth: `${Math.max(0, availableWidth)}px`,\n          maxHeight: `${Math.max(0, availableHeight)}px`,\n        });\n      },\n    }),\n  ],\n});\n```\n\n## [Options](#options)\n\nThese are the options you can pass to `size()`.\n\n```\ninterface SizeOptions extends DetectOverflowOptions {\n  apply?: (\n    state: MiddlewareState & {\n      availableWidth: number;\n      availableHeight: number;\n    },\n  ) => void;\n}\n```\n\n### [`apply`](#apply)\n\ndefault: `undefined`\n\nUnlike other middleware, in which you assign styles after\n`computePosition()` has done its work, `size()` has its\nown `apply` function to do the work during the\nlifecycle:\n\n```\nsize({\n  apply({availableWidth, availableHeight, ...state}) {\n    // Style mutations here\n  },\n});\n```\n\n#### [`availableWidth`](#availablewidth)\n\nRepresents how wide the floating element can be before it will\noverflow its clipping context. You\u2019ll generally set this as the\n`maxWidth` CSS property.\n\n#### [`availableHeight`](#availableheight)\n\nRepresents how tall the floating element can be before it will\noverflow its clipping context. You\u2019ll generally set this as the\n`maxHeight` CSS property.\n\n#### [\u2026middlewareState](#middlewarestate)\n\nSee [MiddlewareState](/docs/middleware#middlewarestate).\n\nMany useful properties are also accessible via this callback,\nsuch as `rects` and `elements`.\n\n### [\u2026detectOverflowOptions](#detectoverflowoptions)\n\nAll of [`detectOverflow`](/docs/detectOverflow#options)\u2019s options\ncan be passed. For instance:\n\n```\nsize({padding: 5}); // 0 by default\n```\n\n### [Deriving options from state](#deriving-options-from-state)\n\nYou can derive the options from the\n[middleware lifecycle state](/docs/middleware#middlewarestate):\n\n```\nsize((state) => ({\n  padding: state.rects.reference.width,\n}));\n```\n\n## [Using with `flip()`](#using-with-flip)\n\nUsing `size()` together with `flip()` enables some\nuseful behavior. The floating element can be resized, thus\nallowing it to prefer its initial placement as much as possible,\nuntil it reaches a minimum size, at which point it will flip.\n\nIf you\u2019re using the `padding` option in either middleware,\nensure they share the **same value**.\n\n### [`bestFit`](#bestfit)\n\nThe `'bestFit'` fallback strategy in the `flip()`\nmiddleware is the default, which ensures the best fitting\nplacement is used. In this scenario, place `size()`\n**after** `flip()`:\n\n```\nconst middleware = [\n  flip(),\n  size({\n    apply({availableWidth, availableHeight}) {\n      // ...\n    },\n  }),\n];\n```\n\nScroll the container\n\nFloating\n\nThis strategy ensures the floating element stays in view at all\ntimes at the most optimal size.\n\n### [`initialPlacement`](#initialplacement)\n\nIf instead, you want the initial placement to take precedence,\nand are setting a minimum acceptable size, place `size()`\n**before** `flip()`:\n\n```\nconst middleware = [\n  size({\n    apply({availableHeight, elements}) {\n      Object.assign(elements.floating.style, {\n        // Minimum acceptable height is 50px.\n        // `flip` will then take over.\n        maxHeight: `${Math.max(50, availableHeight)}px`,\n      });\n    },\n  }),\n  flip({\n    fallbackStrategy: 'initialPlacement',\n  }),\n];\n```\n\n## [Match reference width](#match-reference-width)\n\nA common feature of select dropdowns is that the dropdown matches\nthe width of the reference regardless of its contents. You can\nalso use `size()` for this, as the `Rect`s get\npassed in:\n\n```\nsize({\n  apply({rects, elements}) {\n    Object.assign(elements.floating.style, {\n      minWidth: `${rects.reference.width}px`,\n    });\n  },\n});\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [`maxHeight` style left on floating element](#maxheight-style-left-on-floating-element)\n\nLeaving the `maxHeight` style on the floating element that\u2019s kept\nmounted in the DOM when closed can cause issues in certain\nsituations where it can and should expand more.\n\nBy removing the style inside the `apply` function\nwhen the `scrollHeight` is less than the `availableHeight`, you\ncan prevent this:\n\n```\nelements.floating.style.maxHeight =\n  availableHeight >= elements.floating.scrollHeight\n    ? ''\n    : `${availableHeight}px`;\n```",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:34.600747+00:00",
  "content_length": 4328,
  "content_hash": "676eb3f92b7b97f7"
}