{
  "id": "floating-ui__docs_useHover",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/useHover",
  "title": "useHover",
  "content": "use\nHover\nOpens the floating element while hovering over the reference\nelement, like CSS\n:hover\n.\nimport\n{\nuseHover\n}\nfrom\n'\n@floating-ui/react\n'\n;\nIncludes the ability to enter the floating element\nwithout it closing\n.\nUsage\nThis Hook returns event handler props.\nTo use it, pass it the\ncontext\nobject returned from\nuseFloating\n()\nor\nuseFloatingRootContext\n,\nand then feed its result into the\nuseInteractions\n()\narray.\nThe returned prop getters are then spread onto the elements for\nrendering.\nfunction\nApp\n()\n{\nconst\n[\nisOpen\n,\nsetIsOpen\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n{\nrefs\n,\nfloatingStyles\n,\ncontext\n}\n=\nuseFloating\n({\nopen\n:\nisOpen\n,\nonOpenChange\n:\nsetIsOpen\n,\n})\n;\nconst\nhover\n=\nuseHover\n(\ncontext\n)\n;\nconst\n{\ngetReferenceProps\n,\ngetFloatingProps\n}\n=\nuseInteractions\n(\n[\nhover\n,\n]\n)\n;\nreturn\n(\n<>\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n{\n...\ngetReferenceProps\n()\n}>\nReference element\n</\ndiv\n>\n{\nisOpen\n&&\n(\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}\n{\n...\ngetFloatingProps\n()\n}\n>\nFloating element\n</\ndiv\n>\n)\n}\n</>\n)\n;\n}\nExamples\nDefault hover\nProps\ninterface\nUseHoverProps\n{\nenabled\n?:\nboolean\n;\nmouseOnly\n?:\nboolean\n;\ndelay\n?:\nnumber\n|\nPartial\n<\n{\nopen\n:\nnumber\n;\nclose\n:\nnumber\n}\n>;\nrestMs\n?:\nnumber\n;\nmove\n?:\nboolean\n;\nhandleClose\n?:\nnull\n|\nHandleCloseFn\n;\n}\nenabled\ndefault:\ntrue\nConditionally enable/disable the Hook.\nuseHover\n(\ncontext\n,\n{\nenabled\n:\nfalse\n,\n})\n;\nThis is also useful when you want to disable further events from\nfiring based on some condition. For example, you may disable the\nhook after hovering over the floating element to then prevent it\nfrom closing.\nmouseOnly\ndefault:\nfalse\nWhether the logic only runs for mouse input, ignoring both touch\nand pen pointer inputs.\nuseHover\n(\ncontext\n,\n{\nmouseOnly\n:\ntrue\n,\n})\n;\ndelay\ndefault:\n0\nWaits for the specified time when the event listener runs before\nchanging the\nopen\nstate.\nuseHover\n(\ncontext\n,\n{\n// Delay opening or closing the floating element by 500ms.\ndelay\n:\n500\n,\n// Configure the delay for opening and closing separately.\ndelay\n:\n{\nopen\n:\n500\n,\nclose\n:\n0\n,\n}\n,\n})\n;\nrestMs\ndefault:\n0\n(off)\nWaits until the user\u2019s cursor is at \u201crest\u201d over the reference\nelement before changing the open state.\nuseHover\n(\ncontext\n,\n{\n// The user's cursor must be at rest for 150ms before opening.\nrestMs\n:\n150\n,\n})\n;\nYou can also use a fallback delay if the user\u2019s cursor never\nrests, to ensure the floating element will eventually open:\nuseHover\n(\ncontext\n,\n{\nrestMs\n:\n150\n,\n// If their cursor never rests, open it after 1000ms as a\n// fallback.\ndelay\n:\n{\nopen\n:\n1000\n}\n,\n})\n;\nmove\ndefault:\ntrue\nWhether moving the cursor over the floating element will open it,\nwithout a regular hover event required.\nFor example, if it was resting over the reference element when it\nclosed. Uses the\n'\nmousemove\n'\nevent.\nuseHover\n(\ncontext\n,\n{\nmove\n:\nfalse\n,\n})\n;\nhandleClose\ndefault:\nnull\nAccepts an event handler that runs on\nmousemove\nto\ncontrol when the floating element closes once the cursor leaves\nthe reference element.\nThe package exports a\nsafePolygon\n()\nhandler which will\nonly close the floating element if the pointer is outside a\ndynamically computed polygon area. This allows the user to move\nthe cursor off the reference element and towards the floating\nelement without it closing (e.g. it has interactive content\ninside).\nimport\n{\nuseHover\n,\nsafePolygon\n}\nfrom\n'\n@floating-ui/react\n'\n;\nuseHover\n(\ncontext\n,\n{\nhandleClose\n:\nsafePolygon\n()\n,\n})\n;\nThis handler runs on\nmousemove\n.\nFor a simpler alternative, depending on the type of floating\nelement, you can use a short close delay instead.\nsafePolygon\nA \u201csafe\u201d polygon is one that a pointer is safe to traverse as it\nmoves off the reference element and toward the floating element\nafter hovering it. If the pointer moves outside of this safe\narea, the floating element closes.\nIt is a dynamic polygon (either a rect or a triangle) originating\nfrom the cursor once it leaves a reference element. The triangle\nlooks like this:\nThis function takes options.\nrequireIntent\ndefault:\ntrue\nDetermines whether intent is required for the triangle polygon to\nbe generated (that is, the cursor is moving quickly enough toward\nthe floating element).\nfalse\nwill keep the triangle active\nno matter the intent.\nuseHover\n(\ncontext\n,\n{\nhandleClose\n:\nsafePolygon\n({\nrequireIntent\n:\nfalse\n,\n})\n,\n})\n;\nWhen reference elements are placed near each other and they each\nhave a hoverable floating element attached,\ntrue\nensures\nthat hover events for the other nearby references aren\u2019t too\naggressively blocked.\nbuffer\ndefault:\n0.5\nDetermines the amount of buffer (in pixels) there is around the\npolygon.\nWhile the default value should handle the vast majority of cases\ncorrectly, if you find your floating element is closing\nunexpectedly as the pointer tries to move toward the floating\nelement, try increasing this value.\nuseHover\n(\ncontext\n,\n{\nhandleClose\n:\nsafePolygon\n({\nbuffer\n:\n1\n,\n})\n,\n})\n;\nIgnoring the triangle\nIf you only want the offset portion (rectangle bridge) between\nthe reference and floating elements to be considered, you can set\nthe value to\n-\nInfinity\n.\nuseHover\n(\ncontext\n,\n{\nhandleClose\n:\nsafePolygon\n({\n// Don't generate a triangle polygon, only consider the\n// rectangular bridge between the elements.\nbuffer\n:\n-\nInfinity\n,\n})\n,\n})\n;\nblockPointerEvents\ndefault:\nfalse\nWhether CSS\npointer-events\nbehind the polygon, reference, and\nfloating elements are blocked. This ensures the user does not\nfire hover events over other elements unintentionally while they\ntraverse the polygon.\nuseHover\n(\ncontext\n,\n{\nhandleClose\n:\nsafePolygon\n({\nblockPointerEvents\n:\ntrue\n,\n})\n,\n})\n;\nThis can cause container elements that listen for\nmouseleave\nevents to fire. In older versions of Chrome (<114), scrolling\ncontainers can\u2019t be scrolled while the pointer is over the\nfloating element (the main window remains unaffected).\nA\n[data-floating-ui-safe-polygon]\nselector is\navailable as a parent, so scrolling containers can negate the\npointer-events\nstyle:\n[\ndata-floating-ui-safe-polygon\n]\n.\nscroll\n{\npointer-events\n:\nauto\n;\n}\n[\ndata-floating-ui-safe-polygon\n]\n.\nscroll\n>\ndiv\n{\npointer-events\n:\nnone\n;\n}\n<\ndiv\nclassName\n=\n\"\nscroll\n\"\n>\n<\ndiv\n>\nContent inside here will remain blocked without affecting the\nscrolling parent.\n</\ndiv\n>\n</\ndiv\n>",
  "content_markdown": "# useHover\n\nOpens the floating element while hovering over the reference\nelement, like CSS `:hover`.\n\n```\nimport {useHover} from '@floating-ui/react';\n```\n\nIncludes the ability to enter the floating element\n[without it closing](/docs/useHover#safepolygon).\n\n## [Usage](#usage)\n\nThis Hook returns event handler props.\n\nTo use it, pass it the `context` object returned from\n`useFloating()` or\n[`useFloatingRootContext`](/docs/useInteractions#external-reference),\nand then feed its result into the `useInteractions()` array.\nThe returned prop getters are then spread onto the elements for\nrendering.\n\n```\nfunction App() {\n  const [isOpen, setIsOpen] = useState(false);\n \n  const {refs, floatingStyles, context} = useFloating({\n    open: isOpen,\n    onOpenChange: setIsOpen,\n  });\n \n  const hover = useHover(context);\n \n  const {getReferenceProps, getFloatingProps} = useInteractions([\n    hover,\n  ]);\n \n  return (\n    <>\n      <div ref={refs.setReference} {...getReferenceProps()}>\n        Reference element\n      </div>\n      {isOpen && (\n        <div\n          ref={refs.setFloating}\n          style={floatingStyles}\n          {...getFloatingProps()}\n        >\n          Floating element\n        </div>\n      )}\n    </>\n  );\n}\n```\n\n## [Examples](#examples)\n\n- [Default hover](https://codesandbox.io/s/late-https-lu3833?file=/src/App.tsx)\n\n## [Props](#props)\n\n```\ninterface UseHoverProps {\n  enabled?: boolean;\n  mouseOnly?: boolean;\n  delay?: number | Partial<{open: number; close: number}>;\n  restMs?: number;\n  move?: boolean;\n  handleClose?: null | HandleCloseFn;\n}\n```\n\n### [`enabled`](#enabled)\n\ndefault: `true`\n\nConditionally enable/disable the Hook.\n\n```\nuseHover(context, {\n  enabled: false,\n});\n```\n\nThis is also useful when you want to disable further events from\nfiring based on some condition. For example, you may disable the\nhook after hovering over the floating element to then prevent it\nfrom closing.\n\n### [`mouseOnly`](#mouseonly)\n\ndefault: `false`\n\nWhether the logic only runs for mouse input, ignoring both touch\nand pen pointer inputs.\n\n```\nuseHover(context, {\n  mouseOnly: true,\n});\n```\n\n### [`delay`](#delay)\n\ndefault: `0`\n\nWaits for the specified time when the event listener runs before\nchanging the `open` state.\n\n```\nuseHover(context, {\n  // Delay opening or closing the floating element by 500ms.\n  delay: 500,\n \n  // Configure the delay for opening and closing separately.\n  delay: {\n    open: 500,\n    close: 0,\n  },\n});\n```\n\n### [`restMs`](#restms)\n\ndefault: `0` (off)\n\nWaits until the user\u2019s cursor is at \u201crest\u201d over the reference\nelement before changing the open state.\n\n```\nuseHover(context, {\n  // The user's cursor must be at rest for 150ms before opening.\n  restMs: 150,\n});\n```\n\nYou can also use a fallback delay if the user\u2019s cursor never\nrests, to ensure the floating element will eventually open:\n\n```\nuseHover(context, {\n  restMs: 150,\n  // If their cursor never rests, open it after 1000ms as a\n  // fallback.\n  delay: {open: 1000},\n});\n```\n\n### [`move`](#move)\n\ndefault: `true`\n\nWhether moving the cursor over the floating element will open it,\nwithout a regular hover event required.\n\nFor example, if it was resting over the reference element when it\nclosed. Uses the `'mousemove'` event.\n\n```\nuseHover(context, {\n  move: false,\n});\n```\n\n### [`handleClose`](#handleclose)\n\ndefault: `null`\n\nAccepts an event handler that runs on `mousemove` to\ncontrol when the floating element closes once the cursor leaves\nthe reference element.\n\nThe package exports a `safePolygon()` handler which will\nonly close the floating element if the pointer is outside a\ndynamically computed polygon area. This allows the user to move\nthe cursor off the reference element and towards the floating\nelement without it closing (e.g. it has interactive content\ninside).\n\n```\nimport {useHover, safePolygon} from '@floating-ui/react';\n \nuseHover(context, {\n  handleClose: safePolygon(),\n});\n```\n\nThis handler runs on `mousemove`.\n\nFor a simpler alternative, depending on the type of floating\nelement, you can use a short close delay instead.\n\n## [safePolygon](#safepolygon)\n\nA \u201csafe\u201d polygon is one that a pointer is safe to traverse as it\nmoves off the reference element and toward the floating element\nafter hovering it. If the pointer moves outside of this safe\narea, the floating element closes.\n\nIt is a dynamic polygon (either a rect or a triangle) originating\nfrom the cursor once it leaves a reference element. The triangle\nlooks like this:\n\n[](/safe-polygon.mp4)\n\nThis function takes options.\n\n### [`requireIntent`](#requireintent)\n\ndefault: `true`\n\nDetermines whether intent is required for the triangle polygon to\nbe generated (that is, the cursor is moving quickly enough toward\nthe floating element). `false` will keep the triangle active\nno matter the intent.\n\n```\nuseHover(context, {\n  handleClose: safePolygon({\n    requireIntent: false,\n  }),\n});\n```\n\nWhen reference elements are placed near each other and they each\nhave a hoverable floating element attached, `true` ensures\nthat hover events for the other nearby references aren\u2019t too\naggressively blocked.\n\n### [`buffer`](#buffer)\n\ndefault: `0.5`\n\nDetermines the amount of buffer (in pixels) there is around the\npolygon.\n\nWhile the default value should handle the vast majority of cases\ncorrectly, if you find your floating element is closing\nunexpectedly as the pointer tries to move toward the floating\nelement, try increasing this value.\n\n```\nuseHover(context, {\n  handleClose: safePolygon({\n    buffer: 1,\n  }),\n});\n```\n\n#### [Ignoring the triangle](#ignoring-the-triangle)\n\nIf you only want the offset portion (rectangle bridge) between\nthe reference and floating elements to be considered, you can set\nthe value to `-Infinity`.\n\n```\nuseHover(context, {\n  handleClose: safePolygon({\n    // Don't generate a triangle polygon, only consider the\n    // rectangular bridge between the elements.\n    buffer: -Infinity,\n  }),\n});\n```\n\n### [`blockPointerEvents`](#blockpointerevents)\n\ndefault: `false`\n\nWhether CSS `pointer-events` behind the polygon, reference, and\nfloating elements are blocked. This ensures the user does not\nfire hover events over other elements unintentionally while they\ntraverse the polygon.\n\n```\nuseHover(context, {\n  handleClose: safePolygon({\n    blockPointerEvents: true,\n  }),\n});\n```\n\nThis can cause container elements that listen for `mouseleave`\nevents to fire. In older versions of Chrome (<114), scrolling\ncontainers can\u2019t be scrolled while the pointer is over the\nfloating element (the main window remains unaffected).\n\nA `[data-floating-ui-safe-polygon]` selector is\navailable as a parent, so scrolling containers can negate the\n`pointer-events` style:\n\n```\n[data-floating-ui-safe-polygon] .scroll {\n  pointer-events: auto;\n}\n \n[data-floating-ui-safe-polygon] .scroll > div {\n  pointer-events: none;\n}\n```\n\n```\n<div className=\"scroll\">\n  <div>\n    Content inside here will remain blocked without affecting the\n    scrolling parent.\n  </div>\n</div>\n```",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:48.128303+00:00",
  "content_length": 6252,
  "content_hash": "0f757c0526835572"
}