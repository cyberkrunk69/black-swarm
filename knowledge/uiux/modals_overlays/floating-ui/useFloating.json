{
  "id": "floating-ui__docs_useFloating",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/useFloating",
  "title": "useFloating",
  "content": "use\nFloating\nThe main Hook of the library that acts as a controller for all\nother Hooks and components.\nUsage\nCall the Hook inside a component.\nfunction\nApp\n()\n{\nconst\n{\nrefs\n,\nfloatingStyles\n}\n=\nuseFloating\n()\n;\nreturn\n(\n<>\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n/>\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}\n/>\n</>\n)\n;\n}\nOptions\nThe Hook accepts an object of options to configure its behavior.\nuseFloating\n({\n// options\n})\n;\nplacement\ndefault:\n'\nbottom\n'\nThe placement of the floating element relative to the reference\nelement.\nuseFloating\n({\nplacement\n:\n'\nleft\n'\n,\n})\n;\n12 strings are available:\ntype\nPlacement\n=\n|\n'\ntop\n'\n|\n'\ntop-start\n'\n|\n'\ntop-end\n'\n|\n'\nright\n'\n|\n'\nright-start\n'\n|\n'\nright-end\n'\n|\n'\nbottom\n'\n|\n'\nbottom-start\n'\n|\n'\nbottom-end\n'\n|\n'\nleft\n'\n|\n'\nleft-start\n'\n|\n'\nleft-end\n'\n;\nThe\n-start\nand\n-end\nalignments are\nlogical\nand will adapt to the writing direction (e.g. RTL) as expected.\nstrategy\ndefault:\n'\nabsolute\n'\nThis is the type of CSS position property to use. Two strings are\navailable:\ntype\nStrategy\n=\n'\nabsolute\n'\n|\n'\nfixed\n'\n;\nuseFloating\n({\nstrategy\n:\n'\nfixed\n'\n,\n})\n;\nThese strategies are differentiated as follows:\n'\nabsolute\n'\n\u2014 the floating element is positioned relative\nto its nearest positioned ancestor. With most layouts, this\nusually requires the browser to do the least work when updating\nthe position.\n'\nfixed\n'\n\u2014 the floating element is positioned relative to\nits nearest containing block (usually the viewport). This is\nuseful when the reference element is also fixed to reduce\njumpiness with positioning while scrolling. It will in many\ncases also\n\u201cbreak\u201d the floating element out of a clipping ancestor\n.\ntransform\ndefault:\ntrue\nWhether to use CSS transforms to position the floating element\ninstead of layout (\ntop\nand\nleft\nCSS properties).\nuseFloating\n({\ntransform\n:\nfalse\n,\n})\n;\nCSS transforms are more performant, but can cause conflicts with\ntransform animations. In that case, you can make the positioned\nfloating element a wrapper to avoid the conflict:\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\nstyle\n={\nfloatingStyles\n}>\n<\ndiv\nstyle\n={\ntransitionStyles\n}>\nContent\n</\ndiv\n>\n</\ndiv\n>\nmiddleware\ndefault:\n[]\nAn array of middleware objects that change the positioning of the\nfloating element.\nuseFloating\n({\nmiddleware\n:\n[\n// ...\n],\n})\n;\nWhen you want granular control over how the floating element is\npositioned, middleware are used. They read the current\ncoordinates, optionally alter them, and/or provide data for\nrendering. They compose and work together to produce the final\ncoordinates which are in the\nfloatingStyles\nobject.\nThe following are included in the package:\nPlacement modifiers\nThese middleware alter the base placement coordinates.\noffset\nmodifies the placement to add distance\nor margin between the reference and floating elements.\ninline\npositions the floating element\nrelative to individual client rects rather than the bounding\nbox for better precision.\nVisibility optimizers\nThese middleware alter the coordinates to ensure the floating\nelement stays on screen optimally.\nshift\nprevents the floating element from\noverflowing a clipping container by shifting it to stay in\nview.\nflip\nprevents the floating element from\noverflowing a clipping container by flipping it to the opposite\nplacement to stay in view.\nautoPlacement\nautomatically chooses a\nplacement for you using a \u201cmost space\u201d strategy.\nsize\nresizes the floating element, for example\nso it will not overflow a clipping container, or to match the\nwidth of the reference element.\nData providers\nThese middleware only provide data and do not alter the\ncoordinates.\narrow\nprovides data to position an inner\nelement of the floating element such that it is centered to its\nreference element.\nhide\nprovides data to hide the floating element\nin applicable situations when it no longer appears attached to\nits reference element due to different clipping contexts.\nOption reactivity\nWhen using React state and middleware, stateful values inside\nfunctions\naren\u2019t fresh or reactive.\nconst\n[\nvalue\n,\nsetValue\n]\n=\nuseState\n(\n0\n)\n;\noffset\n(\nvalue\n)\n;\n// reactive and fresh\noffset\n(()\n=>\nvalue\n)\n;\n// NOT reactive or fresh\nSpecifying the dependencies as a second argument of any\nmiddleware function will keep it reactive:\noffset\n(()\n=>\nvalue\n,\n[\nvalue\n]\n)\n;\nThis goes for any function option, including\nsize\n()\n\u2019s\napply\nfunction.\nelements\ndefault:\nundefined\nAn object of elements passed to the Hook, which is useful for\nexternally passing them, as an alternative to the\nrefs\nobject setters.\nThe elements must be held in state (not plain refs) to ensure\nthat they are reactive.\nconst\n[\nreference\n,\nsetReference\n]\n=\nuseState\n(\nnull\n)\n;\nconst\n{\nrefs\n}\n=\nuseFloating\n({\nelements\n:\n{\nreference\n,\n}\n,\n})\n;\nreturn\n(\n<>\n<\ndiv\nref\n={\nsetReference\n}\n/>\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\n/>\n</>\n)\n;\nYou can also do the inverse of the above, or pass both\nexternally.\nwhileElementsMounted\ndefault:\nundefined\nA function that is called when the reference and floating\nelements are mounted, and returns a cleanup function called when\nthey are unmounted.\nuseFloating\n({\nwhileElementsMounted\n:\n(\nreference\n,\nfloating\n,\nupdate\n)\n=>\n{\n// ...\nreturn\n()\n=>\n{\n// ...\n}\n;\n}\n,\n})\n;\nThis allows you to pass\nautoUpdate\nwhose\nsignature matches the option, to ensure the floating element\nremains anchored to the reference element:\nimport\n{\nautoUpdate\n}\nfrom\n'\n@floating-ui/react\n'\n;\nuseFloating\n({\nwhileElementsMounted\n:\nautoUpdate\n,\n})\n;\nopen\ndefault:\nfalse\nWhether the floating element is open or not, which allows you to\ndetermine if the floating element has been positioned yet.\nconst\n[\nisOpen\n,\nsetIsOpen\n]\n=\nuseState\n(\nfalse\n)\n;\nconst\n{\nisPositioned\n}\n=\nuseFloating\n({\nopen\n:\nisOpen\n,\n})\n;\n// Once `isOpen` flips to `true`, `isPositioned` will switch to `true`\n// asynchronously. We can use an Effect to determine when it has\n// been positioned.\nuseEffect\n(()\n=>\n{\nif\n(\nisPositioned\n)\n{\n// ...\n}\n}\n,\n[\nisPositioned\n]\n)\n;\nReturn value\nThe Hook returns the following type:\ninterface\nUseFloatingReturn\n{\ncontext\n:\nFloatingContext\n;\nplacement\n:\nPlacement\n;\nstrategy\n:\nStrategy\n;\nx\n:\nnumber\n;\ny\n:\nnumber\n;\nmiddlewareData\n:\nMiddlewareData\n;\nisPositioned\n:\nboolean\n;\nupdate\n()\n:\nvoid\n;\nfloatingStyles\n:\nReact\n.\nCSSProperties\n;\nrefs\n:\n{\nreference\n:\nReact\n.\nMutableRefObject\n<\nReferenceElement\n|\nnull\n>;\nfloating\n:\nReact\n.\nMutableRefObject\n<\nHTMLElement\n|\nnull\n>;\ndomReference\n:\nReact\n.\nMutableRefObject\n<\nElement\n|\nnull\n>;\nsetReference\n(\nnode\n:\nRT\n|\nnull\n)\n:\nvoid\n;\nsetFloating\n(\nnode\n:\nHTMLElement\n|\nnull\n)\n:\nvoid\n;\nsetPositionReference\n(\nnode\n:\nReferenceElement\n)\n:\nvoid\n;\n}\n;\nelements\n:\n{\nreference\n:\nRT\n|\nnull\n;\nfloating\n:\nHTMLElement\n|\nnull\n;\n}\n;\n}\nplacement\nThe\nfinal\nplacement of the floating element relative to the\nreference element. Unlike the one passed in the options, this one\ncan be mutated by middleware like\nflip\n()\n. This is\nnecessary to determine the actual side of the floating element\nfor styling.\nconst\n{\nplacement\n}\n=\nuseFloating\n()\n;\nstrategy\nThe positioning strategy of the floating element.\nconst\n{\nstrategy\n}\n=\nuseFloating\n()\n;\nx\nThe final x-coordinate of the floating element. This can be used\nas an alternative to\nfloatingStyles\nto manually position the\nfloating element with custom CSS.\nconst\n{\nx\n}\n=\nuseFloating\n()\n;\ny\nThe final y-coordinate of the floating element. This can be used\nas an alternative to\nfloatingStyles\nto manually position the\nfloating element with custom CSS.\nconst\n{\ny\n}\n=\nuseFloating\n()\n;\nmiddlewareData\nThe data provided by any middleware used.\nconst\n{\nmiddlewareData\n}\n=\nuseFloating\n()\n;\nisPositioned\nWhether the floating element has been positioned yet when used\ninside an Effect (not during render). Requires the\nopen\noption to be passed.\nconst\n{\nisPositioned\n}\n=\nuseFloating\n()\n;\nupdate\nA function that updates the floating element\u2019s position manually.\nconst\n{\nupdate\n}\n=\nuseFloating\n()\n;\nfloatingStyles\nThe styles that should be applied to the floating element.\nconst\n{\nfloatingStyles\n}\n=\nuseFloating\n()\n;\nrefs\nThe refs that should be applied to the reference and floating\nelements.\nconst\n{\nrefs\n}\n=\nuseFloating\n()\n;\nreference\nA ref for the reference element. You can access this inside an\nevent handler or in an Effect.\nconst\n{\nrefs\n}\n=\nuseFloating\n()\n;\nuseEffect\n(()\n=>\n{\nconsole\n.\nlog\n(\nrefs\n.\nreference\n.\ncurrent\n)\n;\n}\n,\n[\nrefs\n]\n)\n;\nfloating\nA ref for the floating element. You can access this inside an\nevent handler.\nFor usage in Effects, prefer using\nelements\n.\nfloating\n,\nsince it\u2019s not guaranteed the floating element will be available\non the first pass.\nconst\n{\nrefs\n}\n=\nuseFloating\n()\n;\n// Inside an event handler:\nconsole\n.\nlog\n(\nrefs\n.\nfloating\n.\ncurrent\n)\n;\nsetReference\nA function that sets the reference element.\nconst\n{\nrefs\n}\n=\nuseFloating\n()\n;\nreturn\n<\ndiv\nref\n={\nrefs\n.\nsetReference\n}\n/>;\nsetFloating\nA function that sets the floating element.\nconst\n{\nrefs\n}\n=\nuseFloating\n()\n;\nreturn\n<\ndiv\nref\n={\nrefs\n.\nsetFloating\n}\n/>;\nelements\nThe elements as set by the refs, useful for access during\nrendering or when needing to reactively check if the element\nexists.\nconst\n{\nelements\n}\n=\nuseFloating\n()\n;\nreference\nThe reference element. May be virtual.\nconst\n{\nelements\n}\n=\nuseFloating\n()\n;\nconsole\n.\nlog\n(\nelements\n.\nreference\n)\n;\nfloating\nThe floating element. Enables you to reactively check if the\nfloating element exists inside Effects, notable when using\n<\nFloatingPortal\n>\n, as it won\u2019t be available on the first\npass.\nconst\n{\nelements\n}\n=\nuseFloating\n()\n;\nReact\n.\nuseEffect\n(()\n=>\n{\nif\n(\n!\nelements\n.\nfloating\n)\nreturn;\n// ...\n}\n,\n[\nelements\n.\nfloating\n]\n)\n;",
  "content_markdown": "# useFloating\n\nThe main Hook of the library that acts as a controller for all\nother Hooks and components.\n\n## [Usage](#usage)\n\nCall the Hook inside a component.\n\n```\nfunction App() {\n  const {refs, floatingStyles} = useFloating();\n  return (\n    <>\n      <div ref={refs.setReference} />\n      <div ref={refs.setFloating} style={floatingStyles} />\n    </>\n  );\n}\n```\n\n## [Options](#options)\n\nThe Hook accepts an object of options to configure its behavior.\n\n```\nuseFloating({\n  // options\n});\n```\n\n### [`placement`](#placement)\n\ndefault: `'bottom'`\n\nThe placement of the floating element relative to the reference\nelement.\n\n```\nuseFloating({\n  placement: 'left',\n});\n```\n\n12 strings are available:\n\n```\ntype Placement =\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n```\n\nThe `-start` and `-end` alignments are\n[logical](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties)\nand will adapt to the writing direction (e.g. RTL) as expected.\n\n### [`strategy`](#strategy)\n\ndefault: `'absolute'`\n\nThis is the type of CSS position property to use. Two strings are\navailable:\n\n```\ntype Strategy = 'absolute' | 'fixed';\n```\n\n```\nuseFloating({\n  strategy: 'fixed',\n});\n```\n\nThese strategies are differentiated as follows:\n\n- `'absolute'` \u2014 the floating element is positioned relative\n  to its nearest positioned ancestor. With most layouts, this\n  usually requires the browser to do the least work when updating\n  the position.\n- `'fixed'` \u2014 the floating element is positioned relative to\n  its nearest containing block (usually the viewport). This is\n  useful when the reference element is also fixed to reduce\n  jumpiness with positioning while scrolling. It will in many\n  cases also\n  [\u201cbreak\u201d the floating element out of a clipping ancestor](/docs/misc#clipping).\n\n### [`transform`](#transform)\n\ndefault: `true`\n\nWhether to use CSS transforms to position the floating element\ninstead of layout (`top` and `left` CSS properties).\n\n```\nuseFloating({\n  transform: false,\n});\n```\n\nCSS transforms are more performant, but can cause conflicts with\ntransform animations. In that case, you can make the positioned\nfloating element a wrapper to avoid the conflict:\n\n```\n<div ref={refs.setFloating} style={floatingStyles}>\n  <div style={transitionStyles}>Content</div>\n</div>\n```\n\n### [`middleware`](#middleware)\n\ndefault: `[]`\n\nAn array of middleware objects that change the positioning of the\nfloating element.\n\n```\nuseFloating({\n  middleware: [\n    // ...\n  ],\n});\n```\n\nWhen you want granular control over how the floating element is\npositioned, middleware are used. They read the current\ncoordinates, optionally alter them, and/or provide data for\nrendering. They compose and work together to produce the final\ncoordinates which are in the `floatingStyles` object.\n\nThe following are included in the package:\n\n#### [Placement modifiers](#placement-modifiers)\n\nThese middleware alter the base placement coordinates.\n\n- [`offset`](/docs/offset) modifies the placement to add distance\n  or margin between the reference and floating elements.\n- [`inline`](/docs/inline) positions the floating element\n  relative to individual client rects rather than the bounding\n  box for better precision.\n\n#### [Visibility optimizers](#visibility-optimizers)\n\nThese middleware alter the coordinates to ensure the floating\nelement stays on screen optimally.\n\n- [`shift`](/docs/shift) prevents the floating element from\n  overflowing a clipping container by shifting it to stay in\n  view.\n- [`flip`](/docs/flip) prevents the floating element from\n  overflowing a clipping container by flipping it to the opposite\n  placement to stay in view.\n- [`autoPlacement`](/docs/autoPlacement) automatically chooses a\n  placement for you using a \u201cmost space\u201d strategy.\n- [`size`](/docs/size) resizes the floating element, for example\n  so it will not overflow a clipping container, or to match the\n  width of the reference element.\n\n#### [Data providers](#data-providers)\n\nThese middleware only provide data and do not alter the\ncoordinates.\n\n- [`arrow`](/docs/arrow) provides data to position an inner\n  element of the floating element such that it is centered to its\n  reference element.\n- [`hide`](/docs/hide) provides data to hide the floating element\n  in applicable situations when it no longer appears attached to\n  its reference element due to different clipping contexts.\n\n#### [Option reactivity](#option-reactivity)\n\nWhen using React state and middleware, stateful values inside\n*functions* aren\u2019t fresh or reactive.\n\n```\nconst [value, setValue] = useState(0);\n \noffset(value); // reactive and fresh\noffset(() => value); // NOT reactive or fresh\n```\n\nSpecifying the dependencies as a second argument of any\nmiddleware function will keep it reactive:\n\n```\noffset(() => value, [value]);\n```\n\nThis goes for any function option, including `size()`\u2019s\n`apply` function.\n\n### [`elements`](#elements)\n\ndefault: `undefined`\n\nAn object of elements passed to the Hook, which is useful for\nexternally passing them, as an alternative to the `refs`\nobject setters.\n\nThe elements must be held in state (not plain refs) to ensure\nthat they are reactive.\n\n```\nconst [reference, setReference] = useState(null);\n \nconst {refs} = useFloating({\n  elements: {\n    reference,\n  },\n});\n \nreturn (\n  <>\n    <div ref={setReference} />\n    <div ref={refs.setFloating} />\n  </>\n);\n```\n\nYou can also do the inverse of the above, or pass both\nexternally.\n\n### [`whileElementsMounted`](#whileelementsmounted)\n\ndefault: `undefined`\n\nA function that is called when the reference and floating\nelements are mounted, and returns a cleanup function called when\nthey are unmounted.\n\n```\nuseFloating({\n  whileElementsMounted: (reference, floating, update) => {\n    // ...\n    return () => {\n      // ...\n    };\n  },\n});\n```\n\nThis allows you to pass [`autoUpdate`](/docs/autoUpdate) whose\nsignature matches the option, to ensure the floating element\nremains anchored to the reference element:\n\n```\nimport {autoUpdate} from '@floating-ui/react';\n \nuseFloating({\n  whileElementsMounted: autoUpdate,\n});\n```\n\n### [`open`](#open)\n\ndefault: `false`\n\nWhether the floating element is open or not, which allows you to\ndetermine if the floating element has been positioned yet.\n\n```\nconst [isOpen, setIsOpen] = useState(false);\n \nconst {isPositioned} = useFloating({\n  open: isOpen,\n});\n \n// Once `isOpen` flips to `true`, `isPositioned` will switch to `true`\n// asynchronously. We can use an Effect to determine when it has\n// been positioned.\nuseEffect(() => {\n  if (isPositioned) {\n    // ...\n  }\n}, [isPositioned]);\n```\n\n## [Return value](#return-value)\n\nThe Hook returns the following type:\n\n```\ninterface UseFloatingReturn {\n  context: FloatingContext;\n  placement: Placement;\n  strategy: Strategy;\n  x: number;\n  y: number;\n  middlewareData: MiddlewareData;\n  isPositioned: boolean;\n  update(): void;\n  floatingStyles: React.CSSProperties;\n  refs: {\n    reference: React.MutableRefObject<ReferenceElement | null>;\n    floating: React.MutableRefObject<HTMLElement | null>;\n    domReference: React.MutableRefObject<Element | null>;\n    setReference(node: RT | null): void;\n    setFloating(node: HTMLElement | null): void;\n    setPositionReference(node: ReferenceElement): void;\n  };\n  elements: {\n    reference: RT | null;\n    floating: HTMLElement | null;\n  };\n}\n```\n\n### [`placement`](#placement-1)\n\nThe **final** placement of the floating element relative to the\nreference element. Unlike the one passed in the options, this one\ncan be mutated by middleware like `flip()`. This is\nnecessary to determine the actual side of the floating element\nfor styling.\n\n```\nconst {placement} = useFloating();\n```\n\n### [`strategy`](#strategy-1)\n\nThe positioning strategy of the floating element.\n\n```\nconst {strategy} = useFloating();\n```\n\n### [`x`](#x)\n\nThe final x-coordinate of the floating element. This can be used\nas an alternative to `floatingStyles` to manually position the\nfloating element with custom CSS.\n\n```\nconst {x} = useFloating();\n```\n\n### [`y`](#y)\n\nThe final y-coordinate of the floating element. This can be used\nas an alternative to `floatingStyles` to manually position the\nfloating element with custom CSS.\n\n```\nconst {y} = useFloating();\n```\n\n### [`middlewareData`](#middlewaredata)\n\nThe data provided by any middleware used.\n\n```\nconst {middlewareData} = useFloating();\n```\n\n### [`isPositioned`](#ispositioned)\n\nWhether the floating element has been positioned yet when used\ninside an Effect (not during render). Requires the `open`\noption to be passed.\n\n```\nconst {isPositioned} = useFloating();\n```\n\n### [`update`](#update)\n\nA function that updates the floating element\u2019s position manually.\n\n```\nconst {update} = useFloating();\n```\n\n### [`floatingStyles`](#floatingstyles)\n\nThe styles that should be applied to the floating element.\n\n```\nconst {floatingStyles} = useFloating();\n```\n\n### [`refs`](#refs)\n\nThe refs that should be applied to the reference and floating\nelements.\n\n```\nconst {refs} = useFloating();\n```\n\n#### [`reference`](#reference)\n\nA ref for the reference element. You can access this inside an\nevent handler or in an Effect.\n\n```\nconst {refs} = useFloating();\nuseEffect(() => {\n  console.log(refs.reference.current);\n}, [refs]);\n```\n\n#### [`floating`](#floating)\n\nA ref for the floating element. You can access this inside an\nevent handler.\n\nFor usage in Effects, prefer using `elements.floating`,\nsince it\u2019s not guaranteed the floating element will be available\non the first pass.\n\n```\nconst {refs} = useFloating();\n// Inside an event handler:\nconsole.log(refs.floating.current);\n```\n\n#### [`setReference`](#setreference)\n\nA function that sets the reference element.\n\n```\nconst {refs} = useFloating();\nreturn <div ref={refs.setReference} />;\n```\n\n#### [`setFloating`](#setfloating)\n\nA function that sets the floating element.\n\n```\nconst {refs} = useFloating();\nreturn <div ref={refs.setFloating} />;\n```\n\n### [`elements`](#elements-1)\n\nThe elements as set by the refs, useful for access during\nrendering or when needing to reactively check if the element\nexists.\n\n```\nconst {elements} = useFloating();\n```\n\n#### [`reference`](#reference-1)\n\nThe reference element. May be virtual.\n\n```\nconst {elements} = useFloating();\nconsole.log(elements.reference);\n```\n\n#### [`floating`](#floating-1)\n\nThe floating element. Enables you to reactively check if the\nfloating element exists inside Effects, notable when using\n`<FloatingPortal>`, as it won\u2019t be available on the first\npass.\n\n```\nconst {elements} = useFloating();\nReact.useEffect(() => {\n  if (!elements.floating) return;\n  // ...\n}, [elements.floating]);\n```",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:45.939731+00:00",
  "content_length": 9526,
  "content_hash": "6278a5e8cc2152b7"
}