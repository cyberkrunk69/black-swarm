{
  "id": "floating-ui__docs_autoPlacement",
  "source_id": "floating-ui",
  "source_name": "Floating UI",
  "category": "modals_overlays",
  "url": "https://floating-ui.com/docs/autoPlacement",
  "title": "autoPlacement",
  "content": "auto\nPlacement\nChooses the placement that has the most space available\nautomatically.\nVisibility Optimizer\nimport\n{\nautoPlacement\n}\nfrom\n'\n@floating-ui/dom\n'\n;\nThis is useful when you don\u2019t know which placement will be best\nfor the floating element, or don\u2019t want to have to explicitly\nspecify it.\nScroll the container\nFloating\nUsage\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nautoPlacement\n()\n],\n})\n;\nOptions\nThese are the options you can pass to\nautoPlacement\n()\n.\ninterface\nAutoPlacementOptions\nextends\nDetectOverflowOptions\n{\ncrossAxis\n?:\nboolean\n;\nalignment\n?:\nAlignment\n|\nnull\n;\nautoAlignment\n?:\nboolean\n;\nallowedPlacements\n?:\nArray\n<\nPlacement\n>;\n}\ncrossAxis\ndefault:\nfalse\nDetermines whether a \u201cmost space\u201d strategy is also used for the\ncross axis (which runs along the alignment of the floating\nelement). May be desirable when the\nallowedPlacements\nare all on the same axis.\nautoPlacement\n({\ncrossAxis\n:\ntrue\n,\n})\n;\nalignment\ndefault:\nundefined\nWithout options,\nautoPlacement\n()\nwill choose any of the\nSide\nplacements which fit best, i.e.\n'\ntop\n'\n,\n'\nright\n'\n,\n'\nbottom\n'\n, or\n'\nleft\n'\n.\nBy specifying an alignment, it will choose those aligned\nplacements.\nautoPlacement\n({\n// top-start, right-start, bottom-start, left-start\nalignment\n:\n'\nstart\n'\n,\n})\n;\nautoAlignment\ndefault:\ntrue\nWhen\nalignment\nis specified, this describes whether to\nautomatically choose placements with the opposite alignment if\nthey fit better.\nautoPlacement\n({\nalignment\n:\n'\nstart\n'\n,\n// Won't also choose 'end' alignments if those fit better\nautoAlignment\n:\nfalse\n,\n})\n;\nallowedPlacements\ndefault: computed subset of\nallPlacements\nDescribes the placements which are allowed to be chosen.\nautoPlacement\n({\n// 'right' and 'left' won't be chosen\nallowedPlacements\n:\n[\n'\ntop\n'\n,\n'\nbottom\n'\n],\n})\n;\nautoPlacement\n({\n// Only choose these placements\nallowedPlacements\n:\n[\n'\ntop-start\n'\n,\n'\nbottom-end\n'\n],\n})\n;\n\u2026detectOverflowOptions\nAll of\ndetectOverflow\n\u2019s options\ncan be passed. For instance:\nautoPlacement\n({\npadding\n:\n5\n,\n// 0 by default\n})\n;\nDeriving options from state\nYou can derive the options from the\nmiddleware lifecycle state\n:\nautoPlacement\n((\nstate\n)\n=>\n({\npadding\n:\nstate\n.\nrects\n.\nreference\n.\nwidth\n,\n}))\n;\nFinal placement\nThe placement returned is always the final one.\ncomputePosition\n(\nreferenceEl\n,\nfloatingEl\n,\n{\nmiddleware\n:\n[\nautoPlacement\n()\n],\n})\n.\nthen\n((\n{\nplacement\n}\n)\n=>\n{\nconsole\n.\nlog\n(\nplacement\n)\n;\n// any side\n})\n;\nConflict with\nflip\n()\nflip\n()\nand\nautoPlacement\n()\ncannot be used together\ninside the same middleware array; make sure you choose only one\nof them to use.\nThe reason is they both try to perform work on the placement but\nwith opposing strategies. Therefore, they will continually try to\nchange the result or work of the other one, leading to a reset\nloop.\nflip\n()\nuses a fallback \u201cno space\u201d strategy. Ensures the\npreferred placement is kept unless there is no space left.\nautoPlacement\n()\nuses a primary \u201cmost space\u201d strategy.\nAlways chooses the placement with the most space available.",
  "content_markdown": "# autoPlacement\n\nChooses the placement that has the most space available\nautomatically.\n\n*Visibility Optimizer*\n\n```\nimport {autoPlacement} from '@floating-ui/dom';\n```\n\nThis is useful when you don\u2019t know which placement will be best\nfor the floating element, or don\u2019t want to have to explicitly\nspecify it.\n\nScroll the container\n\nFloating\n\n## [Usage](#usage)\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [autoPlacement()],\n});\n```\n\n## [Options](#options)\n\nThese are the options you can pass to `autoPlacement()`.\n\n```\ninterface AutoPlacementOptions extends DetectOverflowOptions {\n  crossAxis?: boolean;\n  alignment?: Alignment | null;\n  autoAlignment?: boolean;\n  allowedPlacements?: Array<Placement>;\n}\n```\n\n### [`crossAxis`](#crossaxis)\n\ndefault: `false`\n\nDetermines whether a \u201cmost space\u201d strategy is also used for the\ncross axis (which runs along the alignment of the floating\nelement). May be desirable when the `allowedPlacements`\nare all on the same axis.\n\n```\nautoPlacement({\n  crossAxis: true,\n});\n```\n\n### [`alignment`](#alignment)\n\ndefault: `undefined`\n\nWithout options, `autoPlacement()` will choose any of the\n`Side` placements which fit best, i.e. `'top'`,\n`'right'`, `'bottom'`, or `'left'`.\n\nBy specifying an alignment, it will choose those aligned\nplacements.\n\n```\nautoPlacement({\n  // top-start, right-start, bottom-start, left-start\n  alignment: 'start',\n});\n```\n\n### [`autoAlignment`](#autoalignment)\n\ndefault: `true`\n\nWhen `alignment` is specified, this describes whether to\nautomatically choose placements with the opposite alignment if\nthey fit better.\n\n```\nautoPlacement({\n  alignment: 'start',\n  // Won't also choose 'end' alignments if those fit better\n  autoAlignment: false,\n});\n```\n\n### [`allowedPlacements`](#allowedplacements)\n\ndefault: computed subset of `allPlacements`\n\nDescribes the placements which are allowed to be chosen.\n\n```\nautoPlacement({\n  // 'right' and 'left' won't be chosen\n  allowedPlacements: ['top', 'bottom'],\n});\n```\n\n```\nautoPlacement({\n  // Only choose these placements\n  allowedPlacements: ['top-start', 'bottom-end'],\n});\n```\n\n### [\u2026detectOverflowOptions](#detectoverflowoptions)\n\nAll of [`detectOverflow`](/docs/detectOverflow#options)\u2019s options\ncan be passed. For instance:\n\n```\nautoPlacement({\n  padding: 5, // 0 by default\n});\n```\n\n### [Deriving options from state](#deriving-options-from-state)\n\nYou can derive the options from the\n[middleware lifecycle state](/docs/middleware#middlewarestate):\n\n```\nautoPlacement((state) => ({\n  padding: state.rects.reference.width,\n}));\n```\n\n## [Final placement](#final-placement)\n\nThe placement returned is always the final one.\n\n```\ncomputePosition(referenceEl, floatingEl, {\n  middleware: [autoPlacement()],\n}).then(({placement}) => {\n  console.log(placement); // any side\n});\n```\n\n## [Conflict with `flip()`](#conflict-with-flip)\n\n`flip()` and `autoPlacement()` cannot be used together\ninside the same middleware array; make sure you choose only one\nof them to use.\n\nThe reason is they both try to perform work on the placement but\nwith opposing strategies. Therefore, they will continually try to\nchange the result or work of the other one, leading to a reset\nloop.\n\n- `flip()` uses a fallback \u201cno space\u201d strategy. Ensures the\n  preferred placement is kept unless there is no space left.\n- `autoPlacement()` uses a primary \u201cmost space\u201d strategy.\n  Always chooses the placement with the most space available.",
  "tags": [
    "floating-ui",
    "positioning",
    "popovers",
    "tooltips"
  ],
  "extracted_at": "2026-02-03T12:53:36.663247+00:00",
  "content_length": 3032,
  "content_hash": "d70a00834b7d92ec"
}