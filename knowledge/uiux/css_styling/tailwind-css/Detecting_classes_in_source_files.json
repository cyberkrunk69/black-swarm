{
  "id": "tailwind-css__docs_content-configuration",
  "source_id": "tailwind-css",
  "source_name": "Tailwind CSS Documentation",
  "category": "css_styling",
  "url": "https://tailwindcss.com/docs/content-configuration",
  "title": "Detecting classes in source files",
  "content": "Overview\nTailwind works by scanning your project for utility classes, then generating all of the necessary CSS based on the classes you've actually used.\nThis makes sure your CSS is as small as possible, and is also what makes features like\narbitrary values\npossible.\nHow classes are detected\nTailwind treats all of your source files as plain text, and doesn't attempt to actually parse your files as code in any way.\nInstead it just looks for any tokens in your file that could be classes based on which characters Tailwind is expecting in class names:\nJSX\nexport\nfunction\nButton\n({\ncolor\n,\nchildren\n})\n{\nconst\ncolor\ns\n=\n{\nblack\n:\n\"\nbg-\nblack\ntext-\nwhite\n\"\n,\nblue\n:\n\"\nbg-\nblue\n-500\ntext-\nwhite\n\"\n,\nwhite\n:\n\"\nbg-\nwhite\ntext-\nblack\n\"\n,\n};\nreturn\n(\n<\nbutton\nclassName\n={\n`\n${\ncolor\ns\n[\ncolor\n]\n}\nrounded-full\npx-2\npy-1.5\nfont-sans\ntext-sm/6\nfont-medium\nshadow\n`\n}>\n{\nchildren\n}\n</\nbutton\n>\n)\n;\n}\nThen it tries to generate the CSS for all of these tokens, throwing away any tokens that don't map to a utility class the framework knows about.\nDynamic class names\nSince Tailwind scans your source files as plain text, it has no way of understanding string concatenation or interpolation in the programming language you're using.\nDon't construct class names dynamically\nHTML\n<\ndiv\nclass\n=\n\"text-{{ error ? 'red' : 'green' }}-600\"\n></\ndiv\n>\nIn the example above, the strings\ntext-red-600\nand\ntext-green-600\ndo not exist, so Tailwind will not generate those classes.\nInstead, make sure any class names you\u2019re using exist in full:\nAlways use complete class names\nHTML\n<\ndiv\nclass\n=\n\"{{ error ? '\ntext-red-600\n' : '\ntext-green-600\n' }}\"\n></\ndiv\n>\nIf you're using a component library like React or Vue, this means you shouldn't use props to dynamically construct classes:\nDon't use props to build class names dynamically\nJSX\nfunction\nButton\n({\ncolor\n,\nchildren\n})\n{\nreturn\n<\nbutton\nclassName\n={\n`bg-\n${\ncolor\n}\n-600 hover:bg-\n${\ncolor\n}\n-500 ...`\n}>{\nchildren\n}</\nbutton\n>;\n}\nInstead, map props to complete class names that are statically detectable at build-time:\nAlways map props to static class names\nJSX\nfunction\nButton\n({\ncolor\n,\nchildren\n})\n{\nconst\ncolorVariants\n=\n{\nblue\n:\n\"bg-blue-600 hover:bg-blue-500\"\n,\nred\n:\n\"bg-red-600 hover:bg-red-500\"\n,\n};\nreturn\n<\nbutton\nclassName\n={\n`\n${\ncolorVariants\n[\ncolor\n]\n}\n...`\n}>{\nchildren\n}</\nbutton\n>;\n}\nThis has the added benefit of letting you map different prop values to different color shades for example:\nJSX\nfunction\nButton\n({\ncolor\n,\nchildren\n})\n{\nconst\ncolorVariants\n=\n{\nblue\n:\n\"bg-blue-600 hover:bg-blue-500 text-white\"\n,\nred\n:\n\"bg-red-500 hover:bg-red-400 text-white\"\n,\nyellow\n:\n\"bg-yellow-300 hover:bg-yellow-400 text-black\"\n,\n};\nreturn\n<\nbutton\nclassName\n={\n`\n${\ncolorVariants\n[\ncolor\n]\n}\n...`\n}>{\nchildren\n}</\nbutton\n>;\n}\nAs long as you always use complete class names in your code, Tailwind will generate all of your CSS perfectly every time.\nWhich files are scanned\nTailwind will scan every file in your project for class names, except in the following cases:\nFiles that are in your\n.gitignore\nfile\nFiles in the\nnode_modules\ndirectory\nBinary files like images, videos, or zip files\nCSS files\nCommon package manager lock files\nIf you need to scan any files that Tailwind is ignoring by default, you can\nexplicitly register\nthose sources.\nExplicitly registering sources\nUse\n@source\nto explicitly register source paths relative to the stylesheet:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\n\"../node_modules/@acmecorp/ui-lib\"\n;\nThis is especially useful when you need to scan an external library that is built with Tailwind, since dependencies are usually listed in your\n.gitignore\nfile and ignored by Tailwind by default.\nSetting your base path\nTailwind uses the current working directory as its starting point when scanning for class names by default.\nTo set the base path for source detection explicitly, use the\nsource()\nfunction when importing Tailwind in your CSS:\nCSS\n@import\n\"tailwindcss\"\nsource\n(\n\"../src\"\n)\n;\nThis can be useful when working with monorepos where your build commands run from the root of the monorepo instead of the root of each project.\nIgnoring specific paths\nUse\n@source not\nto ignore specific paths, relative to the stylesheet, when scanning for class names:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\nnot\n\"../src/components/legacy\"\n;\nThis is useful when you have large directories in your project that you know don't use Tailwind classes, like legacy components or third-party libraries.\nDisabling automatic detection\nUse\nsource(none)\nto completely disable automatic source detection if you want to register all of your sources explicitly:\nCSS\n@import\n\"tailwindcss\"\nsource\n(\nnone\n);\n@source\n\"../admin\"\n;\n@source\n\"../shared\"\n;\nThis can be useful in projects that have multiple Tailwind stylesheets where you want to make sure each one only includes the classes each stylesheet needs.\nSafelisting specific utilities\nIf you need to make sure Tailwind generates certain class names that don\u2019t exist in your content files, use\n@source inline()\nto force them to be generated:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\ninline(\n\"underline\"\n)\n;\nGenerated CSS\n.underline\n{\ntext-decoration-line\n:\nunderline\n;\n}\nSafelisting variants\nYou can also use\n@source inline()\nto generate classes with variants. For example, to generate the\nunderline\nclass with hover and focus variants, add\n{hover:,focus:,}\nto the source input:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\ninline(\n\"{hover:,focus:,}underline\"\n)\n;\nGenerated CSS\n.underline\n{\ntext-decoration-line\n:\nunderline\n;\n}\n@media\n(\nhover\n:\nhover\n)\n{\n.hover\n\\:\nunderline:hover\n{\ntext-decoration-line\n:\nunderline\n;\n}\n}\n@media\n(\nfocus\n:\nfocus\n)\n{\n.focus\n\\:\nunderline:focus\n{\ntext-decoration-line\n:\nunderline\n;\n}\n}\nSafelisting with ranges\nThe source input is\nbrace expanded\n, so you can generate multiple classes at once. For example, to generate all the red background colors with hover variants, use a range:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\ninline(\n\"{hover:,}bg-red-{50,{100..900..100},950}\"\n)\n;\nGenerated CSS\n.bg-red-50\n{\nbackground-color\n:\nvar\n(\n--color-red-50\n);\n}\n.bg-red-100\n{\nbackground-color\n:\nvar\n(\n--color-red-100\n);\n}\n.bg-red-200\n{\nbackground-color\n:\nvar\n(\n--color-red-200\n);\n}\n/* ... */\n.bg-red-800\n{\nbackground-color\n:\nvar\n(\n--color-red-800\n);\n}\n.bg-red-900\n{\nbackground-color\n:\nvar\n(\n--color-red-900\n);\n}\n.bg-red-950\n{\nbackground-color\n:\nvar\n(\n--color-red-950\n);\n}\n@media\n(\nhover\n:\nhover\n)\n{\n.hover\n\\:\nbg-red-50:hover\n{\nbackground-color\n:\nvar\n(\n--color-red-50\n);\n}\n/* ... */\n.hover\n\\:\nbg-red-950:hover\n{\nbackground-color\n:\nvar\n(\n--color-red-950\n);\n}\n}\nThis generates red background colors from 100 to 900 in increments of 100, along with the first and last shades of 50 and 950. It also adds the\nhover:\nvariant for each of those classes.\nExplicitly excluding classes\nUse\n@source not inline()\nto prevent specific classes from being generated, even if they are detected in your source files:\nCSS\n@import\n\"tailwindcss\"\n;\n@source\nnot inline(\n\"{hover:,focus:,}bg-red-{50,{100..900..100},950}\"\n)\n;\nThis will explicitly exclude the red background utilities, along with their hover and focus variants, from being generated.",
  "content_markdown": "## [Overview](#overview)\n\nTailwind works by scanning your project for utility classes, then generating all of the necessary CSS based on the classes you've actually used.\n\nThis makes sure your CSS is as small as possible, and is also what makes features like [arbitrary values](/docs/adding-custom-styles#using-arbitrary-values) possible.\n\n### [How classes are detected](#how-classes-are-detected)\n\nTailwind treats all of your source files as plain text, and doesn't attempt to actually parse your files as code in any way.\n\nInstead it just looks for any tokens in your file that could be classes based on which characters Tailwind is expecting in class names:\n\nJSX\n\n```\nexport function Button({ color, children }) {  const colors = {    black: \"bg-black text-white\",    blue: \"bg-blue-500 text-white\",    white: \"bg-white text-black\",  };  return (    <button className={`${colors[color]} rounded-full px-2 py-1.5 font-sans text-sm/6 font-medium shadow`}>      {children}    </button>  );}\n```\n\nThen it tries to generate the CSS for all of these tokens, throwing away any tokens that don't map to a utility class the framework knows about.\n\n### [Dynamic class names](#dynamic-class-names)\n\nSince Tailwind scans your source files as plain text, it has no way of understanding string concatenation or interpolation in the programming language you're using.\n\nDon't construct class names dynamically\n\nHTML\n\n```\n<div class=\"text-{{ error ? 'red' : 'green' }}-600\"></div>\n```\n\nIn the example above, the strings `text-red-600` and `text-green-600` do not exist, so Tailwind will not generate those classes.\n\nInstead, make sure any class names you\u2019re using exist in full:\n\nAlways use complete class names\n\nHTML\n\n```\n<div class=\"{{ error ? 'text-red-600' : 'text-green-600' }}\"></div>\n```\n\nIf you're using a component library like React or Vue, this means you shouldn't use props to dynamically construct classes:\n\nDon't use props to build class names dynamically\n\nJSX\n\n```\nfunction Button({ color, children }) {  return <button className={`bg-${color}-600 hover:bg-${color}-500 ...`}>{children}</button>;}\n```\n\nInstead, map props to complete class names that are statically detectable at build-time:\n\nAlways map props to static class names\n\nJSX\n\n```\nfunction Button({ color, children }) {  const colorVariants = {    blue: \"bg-blue-600 hover:bg-blue-500\",    red: \"bg-red-600 hover:bg-red-500\",  };  return <button className={`${colorVariants[color]} ...`}>{children}</button>;}\n```\n\nThis has the added benefit of letting you map different prop values to different color shades for example:\n\nJSX\n\n```\nfunction Button({ color, children }) {  const colorVariants = {    blue: \"bg-blue-600 hover:bg-blue-500 text-white\",    red: \"bg-red-500 hover:bg-red-400 text-white\",    yellow: \"bg-yellow-300 hover:bg-yellow-400 text-black\",  };  return <button className={`${colorVariants[color]} ...`}>{children}</button>;}\n```\n\nAs long as you always use complete class names in your code, Tailwind will generate all of your CSS perfectly every time.\n\n### [Which files are scanned](#which-files-are-scanned)\n\nTailwind will scan every file in your project for class names, except in the following cases:\n\n- Files that are in your `.gitignore` file\n- Files in the `node_modules` directory\n- Binary files like images, videos, or zip files\n- CSS files\n- Common package manager lock files\n\nIf you need to scan any files that Tailwind is ignoring by default, you can [explicitly register](#explicitly-registering-sources) those sources.\n\n## [Explicitly registering sources](#explicitly-registering-sources)\n\nUse `@source` to explicitly register source paths relative to the stylesheet:\n\nCSS\n\n```\n@import \"tailwindcss\";@source \"../node_modules/@acmecorp/ui-lib\";\n```\n\nThis is especially useful when you need to scan an external library that is built with Tailwind, since dependencies are usually listed in your `.gitignore` file and ignored by Tailwind by default.\n\n### [Setting your base path](#setting-your-base-path)\n\nTailwind uses the current working directory as its starting point when scanning for class names by default.\n\nTo set the base path for source detection explicitly, use the `source()` function when importing Tailwind in your CSS:\n\nCSS\n\n```\n@import \"tailwindcss\" source(\"../src\");\n```\n\nThis can be useful when working with monorepos where your build commands run from the root of the monorepo instead of the root of each project.\n\n### [Ignoring specific paths](#ignoring-specific-paths)\n\nUse `@source not` to ignore specific paths, relative to the stylesheet, when scanning for class names:\n\nCSS\n\n```\n@import \"tailwindcss\";@source not \"../src/components/legacy\";\n```\n\nThis is useful when you have large directories in your project that you know don't use Tailwind classes, like legacy components or third-party libraries.\n\n### [Disabling automatic detection](#disabling-automatic-detection)\n\nUse `source(none)` to completely disable automatic source detection if you want to register all of your sources explicitly:\n\nCSS\n\n```\n@import \"tailwindcss\" source(none);@source \"../admin\";@source \"../shared\";\n```\n\nThis can be useful in projects that have multiple Tailwind stylesheets where you want to make sure each one only includes the classes each stylesheet needs.\n\n## [Safelisting specific utilities](#safelisting-specific-utilities)\n\nIf you need to make sure Tailwind generates certain class names that don\u2019t exist in your content files, use `@source inline()` to force them to be generated:\n\nCSS\n\n```\n@import \"tailwindcss\";@source inline(\"underline\");\n```\n\nGenerated CSS\n\n```\n.underline {  text-decoration-line: underline;}\n```\n\n### [Safelisting variants](#safelisting-variants)\n\nYou can also use `@source inline()` to generate classes with variants. For example, to generate the `underline` class with hover and focus variants, add `{hover:,focus:,}` to the source input:\n\nCSS\n\n```\n@import \"tailwindcss\";@source inline(\"{hover:,focus:,}underline\");\n```\n\nGenerated CSS\n\n```\n.underline {  text-decoration-line: underline;}@media (hover: hover) {  .hover\\:underline:hover {    text-decoration-line: underline;  }}@media (focus: focus) {  .focus\\:underline:focus {    text-decoration-line: underline;  }}\n```\n\n### [Safelisting with ranges](#safelisting-with-ranges)\n\nThe source input is [brace expanded](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html), so you can generate multiple classes at once. For example, to generate all the red background colors with hover variants, use a range:\n\nCSS\n\n```\n@import \"tailwindcss\";@source inline(\"{hover:,}bg-red-{50,{100..900..100},950}\");\n```\n\nGenerated CSS\n\n```\n.bg-red-50 {  background-color: var(--color-red-50);}.bg-red-100 {  background-color: var(--color-red-100);}.bg-red-200 {  background-color: var(--color-red-200);}/* ... */.bg-red-800 {  background-color: var(--color-red-800);}.bg-red-900 {  background-color: var(--color-red-900);}.bg-red-950 {  background-color: var(--color-red-950);}@media (hover: hover) {  .hover\\:bg-red-50:hover {    background-color: var(--color-red-50);  }  /* ... */  .hover\\:bg-red-950:hover {    background-color: var(--color-red-950);  }}\n```\n\nThis generates red background colors from 100 to 900 in increments of 100, along with the first and last shades of 50 and 950. It also adds the `hover:` variant for each of those classes.\n\n### [Explicitly excluding classes](#explicitly-excluding-classes)\n\nUse `@source not inline()` to prevent specific classes from being generated, even if they are detected in your source files:\n\nCSS\n\n```\n@import \"tailwindcss\";@source not inline(\"{hover:,focus:,}bg-red-{50,{100..900..100},950}\");\n```\n\nThis will explicitly exclude the red background utilities, along with their hover and focus variants, from being generated.",
  "tags": [
    "tailwind",
    "utility-first",
    "css",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:47:27.317643+00:00",
  "content_length": 7111,
  "content_hash": "b86626b16fcb3c0c"
}