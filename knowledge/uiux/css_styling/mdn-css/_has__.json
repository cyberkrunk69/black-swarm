{
  "id": "mdn-css__en-US_docs_Web_CSS__has",
  "source_id": "mdn-css",
  "source_name": "MDN CSS Reference",
  "category": "css_styling",
  "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/:has",
  "title": ":has()",
  "content": ":has()\nBaseline\n2023\nNewly available\nSince December 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.\nLearn more\nSee full compatibility\nReport feedback\nThe functional\n:has()\nCSS\npseudo-class\nrepresents an element if any of the\nrelative selectors\nthat are passed as an argument match at least one element when anchored against this element. This pseudo-class presents a way of selecting a parent element or a previous sibling element with respect to a reference element by taking a\nrelative selector list\nas an argument.\ncss\n/* Selects an h1 heading with a\nparagraph element that immediately follows\nthe h1 and applies the style to h1 */\nh1:has(+ p) {\n  margin-bottom: 0;\n}\nThe\n:has()\npseudo-class takes on the\nspecificity\nof the most specific selector in its arguments the same way as\n:is()\nand\n:not()\ndo.\nSyntax\ncss\n:has(<relative-selector-list>) {\n  /* ... */\n}\nIf the\n:has()\npseudo-class itself is not supported in a browser, the entire selector block will fail unless\n:has()\nis in a forgiving selector list, such as in\n:is()\nand\n:where()\n.\nThe\n:has()\npseudo-class cannot be nested within another\n:has()\n.\nPseudo-elements are also not valid selectors within\n:has()\nand pseudo-elements are not valid anchors for\n:has()\n. This is because many pseudo-elements exist conditionally based on the styling of their ancestors and allowing these to be queried by\n:has()\ncan introduce cyclic querying.\nExamples\nSelecting a parent element\nYou may be looking for a \"parent\ncombinator\n\", which allows you to go up the DOM tree and select the parent of a specific element. The\n:has()\npseudo-class does that by using\nparent:has(child)\n(for any parent) or\nparent:has(> child)\n(for direct parent). This example shows how to style a\n<section>\nelement when it contains a child with the\nfeatured\nclass.\nhtml\n<section>\n  <article class=\"featured\">Featured content</article>\n  <article>Regular content</article>\n</section>\n<section>\n  <article>Regular content</article>\n</section>\ncss\nsection:has(.featured) {\n  border: 2px solid blue;\n}\nResult\nWith the sibling combinator\nThe\n:has()\nstyle declaration in the following example adjusts the spacing after\n<h1>\nheadings if they are immediately followed by an\n<h2>\nheading.\nHTML\nhtml\n<section>\n  <article>\n    <h1>Morning Times</h1>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n</section>\nCSS\nsection {\n  display: flex;\n  align-items: start;\n  justify-content: space-around;\n}\n\narticle {\n  display: inline-block;\n  width: 40%;\n}\n\nh1,\nh2 {\n  font-size: 1.2em;\n}\n\nh2 {\n  font-size: 1em;\n  color: rgb(150 149 149);\n}\ncss\nh1,\nh2 {\n  margin: 0 0 1rem 0;\n}\n\nh1:has(+ h2) {\n  margin: 0 0 0.25rem 0;\n}\nResult\nThis example shows two similar texts side-by-side for comparison \u00e2\u0080\u0093 the left one with an\nH1\nheading followed by a paragraph and the right one with an\nH1\nheading followed by an\nH2\nheading and then a paragraph. In the example on the right,\n:has()\nhelps to select the\nH1\nelement that is immediately followed by an\nH2\nelement (indicated by the next-sibling combinator\n+\n) and the CSS rule reduces the spacing after such an\nH1\nelement. Without the\n:has()\npseudo-class, you cannot use CSS selectors to select a preceding sibling of a different type or a parent element.\nWith the :is() pseudo-class\nThis example builds on the previous example to show how to select multiple elements with\n:has()\n.\nHTML\nhtml\n<section>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <h3>8:00 am</h3>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n</section>\nCSS\nsection {\n  display: flex;\n  align-items: start;\n  justify-content: space-around;\n}\n\narticle {\n  display: inline-block;\n  width: 40%;\n}\n\nh1 {\n  font-size: 1.2em;\n}\n\nh2 {\n  font-size: 1em;\n  color: rgb(150 149 149);\n}\n\nh3 {\n  font-size: 0.9em;\n  color: darkgrey;\n}\ncss\nh1,\nh2,\nh3 {\n  margin: 0 0 1rem 0;\n}\n\n:is(h1, h2, h3):has(+ :is(h2, h3, h4)) {\n  margin: 0 0 0.25rem 0;\n}\nResult\nHere, the first\n:is()\npseudo-class is used to select any of the heading elements in the list. The second\n:is()\npseudo-class is used to pass a list of next-sibling selectors as an argument to\n:has()\n. The\n:has()\npseudo-class helps to select any\nH1\n,\nH2\n, or\nH3\nelement that is immediately followed by (indicated by\n+\n) an\nH2\n,\nH3\n, or\nH4\nelement and the CSS rule reduces the spacing after such\nH1\n,\nH2\n, or\nH3\nelements.\nThis selector could have also been written as:\ncss\n:is(h1, h2, h3):has(+ h2, + h3, + h4) {\n  margin: 0 0 0.25rem 0;\n}\nLogical operations\nThe\n:has()\nrelational selector can be used to check if one of the multiple features is true or if all the features are true.\nBy using comma-separated values inside the\n:has()\nrelational selector, you are checking to see if any of the parameters exist.\nx:has(a, b)\nwill style\nx\nif descendant\na\nOR\nb\nexists.\nBy chaining together multiple\n:has()\nrelational selectors together, you are checking to see if all of the parameters exist.\nx:has(a):has(b)\nwill style\nx\nif descendant\na\nAND\nb\nexist.\ncss\nbody:has(video, audio) {\n  /* styles to apply if the content contains audio OR video */\n}\nbody:has(video):has(audio) {\n  /* styles to apply if the content contains both audio AND video */\n}\nAnalogy between :has() and regular expressions\nInterestingly, we can relate some CSS\n:has()\nconstructs with the\nlookahead assertion\nin regular expressions because they both allow you to select elements (or strings in regular expressions) based on a condition without actually selecting the condition matching the element (or string) itself.\nPositive lookahead (?=pattern)\nIn the regular expression\nabc(?=xyz)\n, the string\nabc\nis matched only if it is immediately followed by the string\nxyz\n. As it is a lookahead operation, the\nxyz\nis not included in the match.\nThe analogous construct in CSS would be\n.abc:has(+ .xyz)\n: it selects the element\n.abc\nonly if there is a next sibling\n.xyz\n. The part\n:has(+ .xyz)\nacts as a lookahead operation because the element\n.abc\nis selected and not the element\n.xyz\n.\nNegative lookahead (?!pattern)\nSimilarly, for the negative lookahead case, in the regular expression\nabc(?!xyz)\n, the string\nabc\nis matched only if it is\nnot\nfollowed by\nxyz\n. The analogous CSS construct\n.abc:has(+ :not(.xyz))\ndoesn't select the element\n.abc\nif the next element is\n.xyz\n.\nPerformance considerations\nCertain uses of the\n:has()\npseudo-class can significantly impact page performance, particularly during dynamic updates (DOM mutations). Browser engines must re-evaluate\n:has()\nselectors when the DOM changes, and complex or poorly constrained selectors can lead to expensive computations.\nAvoid broad anchoring\nThe anchor selector (the\nA\nin\nA:has(B)\n) should not be an element that has too many children, like\nbody\n,\n:root\n, or\n*\n. Anchoring\n:has()\nto very general selectors can degrade performance because any DOM change within the entire subtree of a broadly selected element requires the browser to re-check the\n:has()\ncondition.\ncss\n/* Avoid anchoring :has() to broad elements */\nbody:has(.sidebar) {\n  /* styles */\n}\n:root:has(.content) {\n  /* styles */\n}\n*:has(.item) {\n  /* styles */\n}\nInstead, anchor\n:has()\nto specific elements like\n.container\nor\n.gallery\nto reduce the scope and improve performance.\ncss\n/* Use specific containers to limit scope */\n.container:has(.sidebar-expanded) {\n  /* styles */\n}\n.content-wrapper:has(> article[data-priority=\"high\"]) {\n  /* styles */\n}\n.gallery:has(> img[data-loaded=\"false\"]) {\n  /* styles */\n}\nMinimize subtree traversals\nThe inner selector (the\nB\nin\nA:has(B)\n) should use combinators like\n>\nor\n+\nto limit traversal. When the selector inside\n:has()\nis not tightly constrained, the browser might need to traverse the entire subtree of the anchor element on every DOM mutation to check if the condition still holds.\nIn this example, any change within\n.ancestor\nrequires checking all descendants for\n.foo\n:\ncss\n/* May trigger full subtree traversal */\n.ancestor:has(.foo) {\n  /* styles */\n}\nUsing child or sibling combinators limits the scope of the inner selector, reducing the performance cost of DOM mutations. In this example, the browser only needs to check direct children or a specific sibling's descendants:\ncss\n/* More constrained - limits traversal */\n.ancestor:has(> .foo) {\n  /* direct child */\n}\n.ancestor:has(+ .sibling .foo) {\n  /* descendant of adjacent sibling */\n}\nCertain inner selectors can force the browser to traverse up the ancestor chain for every DOM mutation, looking for potential anchors that might need updating. This happens when the structure implies a need to check ancestors of the mutated element.\nIn this example, any DOM change requires checking if the changed element is any element (\n*\n) that is a direct child of\n.foo\n, and if its parent (or further ancestors) is\n.ancestor\n.\ncss\n/* Might trigger ancestor traversal */\n.ancestor:has(.foo > *) {\n  /* styles */\n}\nConstraining the inner selector with specific classes or direct child combinators (e.g.,\n.specific-child\nin the next snippet) reduces expensive ancestor traversals by limiting the browser's check to a well-defined element, improving performance.\ncss\n/* Constrain the inner selector to avoid ancestor traversals */\n.ancestor:has(.foo > .specific-child) {\n  /* styles */\n}\nNote:\nThese performance characteristics may improve as browsers optimize\n:has()\nimplementations, but the fundamental constraints remain:\n:has()\nneeds to traverse a whole subtree, so you need to minimize the subtree's size. In a selector like\nA:has(B)\n, make sure your\nA\ndoes not have too many children, and make sure your\nB\nis tightly constrained to avoid unnecessary traversal.\nSpecifications\nSpecification\nSelectors Level 4\n#\nrelational\nBrowser compatibility\nSee also\n:is()\n,\n:where()\n,\n:not()\nCSS selectors and combinators\nCSS selector structure\nSelector list\nCSS selector module\nSelection and traversal on the DOM tree\nHelp improve MDN\nLearn how to contribute\nThis page was last modified on\nDec 16, 2025\nby\nMDN contributors\n.\nView this page on GitHub\n\u00e2\u0080\u00a2\nReport a problem with this content",
  "content_markdown": "# :has()\n\nBaseline\n2023\n\nNewly available\n\nSince December 2023, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers.\n\n- [Learn more](/en-US/docs/Glossary/Baseline/Compatibility)\n- [See full compatibility](#browser_compatibility)\n- [Report feedback](https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FCSS%2FReference%2FSelectors%2F%3Ahas&level=low)\n\n \n\nThe functional **`:has()`** [CSS](/en-US/docs/Web/CSS) [pseudo-class](/en-US/docs/Web/CSS/Reference/Selectors/Pseudo-classes) represents an element if any of the [relative selectors](/en-US/docs/Web/CSS/Guides/Selectors/Selector_structure#relative_selector) that are passed as an argument match at least one element when anchored against this element. This pseudo-class presents a way of selecting a parent element or a previous sibling element with respect to a reference element by taking a [relative selector list](/en-US/docs/Web/CSS/Reference/Selectors/Selector_list#relative_selector_list) as an argument.\n\ncss\n\n```\n/* Selects an h1 heading with a\nparagraph element that immediately follows\nthe h1 and applies the style to h1 */\nh1:has(+ p) {\n  margin-bottom: 0;\n}\n```\n\nThe `:has()` pseudo-class takes on the [specificity](/en-US/docs/Web/CSS/Guides/Cascade/Specificity) of the most specific selector in its arguments the same way as [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is) and [`:not()`](/en-US/docs/Web/CSS/Reference/Selectors/:not) do.\n\n## [Syntax](#syntax)\n\ncss\n\n```\n:has(<relative-selector-list>) {\n  /* ... */\n}\n```\n\nIf the `:has()` pseudo-class itself is not supported in a browser, the entire selector block will fail unless `:has()` is in a forgiving selector list, such as in [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is) and [`:where()`](/en-US/docs/Web/CSS/Reference/Selectors/:where).\n\nThe `:has()` pseudo-class cannot be nested within another `:has()`.\n\nPseudo-elements are also not valid selectors within `:has()` and pseudo-elements are not valid anchors for `:has()`. This is because many pseudo-elements exist conditionally based on the styling of their ancestors and allowing these to be queried by `:has()` can introduce cyclic querying.\n\n## [Examples](#examples)\n\n### [Selecting a parent element](#selecting_a_parent_element)\n\nYou may be looking for a \"parent [combinator](/en-US/docs/Web/CSS/Guides/Selectors/Selectors_and_combinators#combinators)\", which allows you to go up the DOM tree and select the parent of a specific element. The `:has()` pseudo-class does that by using `parent:has(child)` (for any parent) or `parent:has(> child)` (for direct parent). This example shows how to style a `<section>` element when it contains a child with the `featured` class.\n\nhtml\n\n```\n<section>\n  <article class=\"featured\">Featured content</article>\n  <article>Regular content</article>\n</section>\n<section>\n  <article>Regular content</article>\n</section>\n```\n\ncss\n\n```\nsection:has(.featured) {\n  border: 2px solid blue;\n}\n```\n\n### [Result](#result)\n\n### [With the sibling combinator](#with_the_sibling_combinator)\n\nThe `:has()` style declaration in the following example adjusts the spacing after `<h1>` headings if they are immediately followed by an `<h2>` heading.\n\n#### HTML\n\nhtml\n\n```\n<section>\n  <article>\n    <h1>Morning Times</h1>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n</section>\n```\n\n#### CSS\n\n```\nsection {\n  display: flex;\n  align-items: start;\n  justify-content: space-around;\n}\n\narticle {\n  display: inline-block;\n  width: 40%;\n}\n\nh1,\nh2 {\n  font-size: 1.2em;\n}\n\nh2 {\n  font-size: 1em;\n  color: rgb(150 149 149);\n}\n```\n\ncss\n\n```\nh1,\nh2 {\n  margin: 0 0 1rem 0;\n}\n\nh1:has(+ h2) {\n  margin: 0 0 0.25rem 0;\n}\n```\n\n#### Result\n\nThis example shows two similar texts side-by-side for comparison \u00e2\u0080\u0093 the left one with an `H1` heading followed by a paragraph and the right one with an `H1` heading followed by an `H2` heading and then a paragraph. In the example on the right, `:has()` helps to select the `H1` element that is immediately followed by an `H2` element (indicated by the next-sibling combinator [`+`](/en-US/docs/Web/CSS/Reference/Selectors/Next-sibling_combinator)) and the CSS rule reduces the spacing after such an `H1` element. Without the `:has()` pseudo-class, you cannot use CSS selectors to select a preceding sibling of a different type or a parent element.\n\n### [With the :is() pseudo-class](#with_the_is_pseudo-class)\n\nThis example builds on the previous example to show how to select multiple elements with `:has()`.\n\n#### HTML\n\nhtml\n\n```\n<section>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n  <article>\n    <h1>Morning Times</h1>\n    <h2>Delivering you news every morning</h2>\n    <h3>8:00 am</h3>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod\n      tempor incididunt ut labore et dolore magna aliqua.\n    </p>\n  </article>\n</section>\n```\n\n#### CSS\n\n```\nsection {\n  display: flex;\n  align-items: start;\n  justify-content: space-around;\n}\n\narticle {\n  display: inline-block;\n  width: 40%;\n}\n\nh1 {\n  font-size: 1.2em;\n}\n\nh2 {\n  font-size: 1em;\n  color: rgb(150 149 149);\n}\n\nh3 {\n  font-size: 0.9em;\n  color: darkgrey;\n}\n```\n\ncss\n\n```\nh1,\nh2,\nh3 {\n  margin: 0 0 1rem 0;\n}\n\n:is(h1, h2, h3):has(+ :is(h2, h3, h4)) {\n  margin: 0 0 0.25rem 0;\n}\n```\n\n#### Result\n\nHere, the first [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is) pseudo-class is used to select any of the heading elements in the list. The second `:is()` pseudo-class is used to pass a list of next-sibling selectors as an argument to `:has()`. The `:has()` pseudo-class helps to select any `H1`, `H2`, or `H3` element that is immediately followed by (indicated by [`+`](/en-US/docs/Web/CSS/Reference/Selectors/Next-sibling_combinator)) an `H2`, `H3`, or `H4` element and the CSS rule reduces the spacing after such `H1`, `H2`, or `H3` elements.\n\nThis selector could have also been written as:\n\ncss\n\n```\n:is(h1, h2, h3):has(+ h2, + h3, + h4) {\n  margin: 0 0 0.25rem 0;\n}\n```\n\n### [Logical operations](#logical_operations)\n\nThe `:has()` relational selector can be used to check if one of the multiple features is true or if all the features are true.\n\nBy using comma-separated values inside the `:has()` relational selector, you are checking to see if any of the parameters exist. `x:has(a, b)` will style `x` if descendant `a` OR `b` exists.\n\nBy chaining together multiple `:has()` relational selectors together, you are checking to see if all of the parameters exist. `x:has(a):has(b)` will style `x` if descendant `a` AND `b` exist.\n\ncss\n\n```\nbody:has(video, audio) {\n  /* styles to apply if the content contains audio OR video */\n}\nbody:has(video):has(audio) {\n  /* styles to apply if the content contains both audio AND video */\n}\n```\n\n## [Analogy between :has() and regular expressions](#analogy_between_has_and_regular_expressions)\n\nInterestingly, we can relate some CSS `:has()` constructs with the [lookahead assertion](/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookahead_assertion) in regular expressions because they both allow you to select elements (or strings in regular expressions) based on a condition without actually selecting the condition matching the element (or string) itself.\n\n### [Positive lookahead (?=pattern)](#positive_lookahead_pattern)\n\nIn the regular expression `abc(?=xyz)`, the string `abc` is matched only if it is immediately followed by the string `xyz`. As it is a lookahead operation, the `xyz` is not included in the match.\n\nThe analogous construct in CSS would be `.abc:has(+ .xyz)`: it selects the element `.abc` only if there is a next sibling `.xyz`. The part `:has(+ .xyz)` acts as a lookahead operation because the element `.abc` is selected and not the element `.xyz`.\n\n### [Negative lookahead (?!pattern)](#negative_lookahead_!pattern)\n\nSimilarly, for the negative lookahead case, in the regular expression `abc(?!xyz)`, the string `abc` is matched only if it is *not* followed by `xyz`. The analogous CSS construct `.abc:has(+ :not(.xyz))` doesn't select the element `.abc` if the next element is `.xyz`.\n\n## [Performance considerations](#performance_considerations)\n\nCertain uses of the `:has()` pseudo-class can significantly impact page performance, particularly during dynamic updates (DOM mutations). Browser engines must re-evaluate `:has()` selectors when the DOM changes, and complex or poorly constrained selectors can lead to expensive computations.\n\n### [Avoid broad anchoring](#avoid_broad_anchoring)\n\nThe anchor selector (the `A` in `A:has(B)`) should not be an element that has too many children, like `body`, `:root`, or `*`. Anchoring `:has()` to very general selectors can degrade performance because any DOM change within the entire subtree of a broadly selected element requires the browser to re-check the `:has()` condition.\n\ncss\n\n```\n/* Avoid anchoring :has() to broad elements */\nbody:has(.sidebar) {\n  /* styles */\n}\n:root:has(.content) {\n  /* styles */\n}\n*:has(.item) {\n  /* styles */\n}\n```\n\nInstead, anchor `:has()` to specific elements like `.container` or `.gallery` to reduce the scope and improve performance.\n\ncss\n\n```\n/* Use specific containers to limit scope */\n.container:has(.sidebar-expanded) {\n  /* styles */\n}\n.content-wrapper:has(> article[data-priority=\"high\"]) {\n  /* styles */\n}\n.gallery:has(> img[data-loaded=\"false\"]) {\n  /* styles */\n}\n```\n\n### [Minimize subtree traversals](#minimize_subtree_traversals)\n\nThe inner selector (the `B` in `A:has(B)`) should use combinators like `>` or `+` to limit traversal. When the selector inside `:has()` is not tightly constrained, the browser might need to traverse the entire subtree of the anchor element on every DOM mutation to check if the condition still holds.\n\nIn this example, any change within `.ancestor` requires checking all descendants for `.foo`:\n\ncss\n\n```\n/* May trigger full subtree traversal */\n.ancestor:has(.foo) {\n  /* styles */\n}\n```\n\nUsing child or sibling combinators limits the scope of the inner selector, reducing the performance cost of DOM mutations. In this example, the browser only needs to check direct children or a specific sibling's descendants:\n\ncss\n\n```\n/* More constrained - limits traversal */\n.ancestor:has(> .foo) {\n  /* direct child */\n}\n.ancestor:has(+ .sibling .foo) {\n  /* descendant of adjacent sibling */\n}\n```\n\nCertain inner selectors can force the browser to traverse up the ancestor chain for every DOM mutation, looking for potential anchors that might need updating. This happens when the structure implies a need to check ancestors of the mutated element.\n\nIn this example, any DOM change requires checking if the changed element is any element (`*`) that is a direct child of `.foo`, and if its parent (or further ancestors) is `.ancestor`.\n\ncss\n\n```\n/* Might trigger ancestor traversal */\n.ancestor:has(.foo > *) {\n  /* styles */\n}\n```\n\nConstraining the inner selector with specific classes or direct child combinators (e.g., `.specific-child` in the next snippet) reduces expensive ancestor traversals by limiting the browser's check to a well-defined element, improving performance.\n\ncss\n\n```\n/* Constrain the inner selector to avoid ancestor traversals */\n.ancestor:has(.foo > .specific-child) {\n  /* styles */\n}\n```\n\n**Note:**\nThese performance characteristics may improve as browsers optimize `:has()` implementations, but the fundamental constraints remain: `:has()` needs to traverse a whole subtree, so you need to minimize the subtree's size. In a selector like `A:has(B)`, make sure your `A` does not have too many children, and make sure your `B` is tightly constrained to avoid unnecessary traversal.\n\n## [Specifications](#specifications)\n\n| Specification |\n| --- |\n| [Selectors Level 4  # relational](https://drafts.csswg.org/selectors/#relational) |\n\n## [Browser compatibility](#browser_compatibility)\n\n## [See also](#see_also)\n\n- [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is), [`:where()`](/en-US/docs/Web/CSS/Reference/Selectors/:where), [`:not()`](/en-US/docs/Web/CSS/Reference/Selectors/:not)\n- [CSS selectors and combinators](/en-US/docs/Web/CSS/Guides/Selectors/Selectors_and_combinators)\n- [CSS selector structure](/en-US/docs/Web/CSS/Guides/Selectors/Selector_structure)\n- [Selector list](/en-US/docs/Web/CSS/Reference/Selectors/Selector_list)\n- [CSS selector module](/en-US/docs/Web/CSS/Guides/Selectors)\n- [Selection and traversal on the DOM tree](/en-US/docs/Web/API/Document_Object_Model/Selection_and_traversal_on_the_DOM_tree)\n\n## Help improve MDN\n\nWas this page helpful to you?\n\nYes\n\nNo\n\n[Learn how to contribute](/en-US/docs/MDN/Community/Getting_started)\n\nThis page was last modified on Dec 16, 2025 by [MDN contributors](/en-US/docs/Web/CSS/Reference/Selectors/:has/contributors.txt).\n\n[View this page on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/css/reference/selectors/_colon_has/index.md?plain=1 \"Folder: en-us/web/css/reference/selectors/_colon_has (Opens in a new tab)\") \u00e2\u0080\u00a2 [Report a problem with this content](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FReference%2FSelectors%2F%3Ahas&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fcss%2Freference%2Fselectors%2F_colon_has%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FReference%2FSelectors%2F%3Ahas%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fcss%2Freference%2Fselectors%2F_colon_has%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F33094d735e90b4dcae5733331b79c51fee997410%0A*+Document+last+modified%3A+2025-12-16T15%3A14%3A26.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\")",
  "tags": [
    "mdn",
    "css",
    "reference",
    "layout"
  ],
  "extracted_at": "2026-02-03T12:45:46.728573+00:00",
  "content_length": 10784,
  "content_hash": "7ec98462ad04e9cc"
}