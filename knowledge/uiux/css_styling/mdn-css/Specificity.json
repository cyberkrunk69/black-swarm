{
  "id": "mdn-css__en-US_docs_Web_CSS_CSS_cascade_Specificity",
  "source_id": "mdn-css",
  "source_name": "MDN CSS Reference",
  "category": "css_styling",
  "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity",
  "title": "Specificity",
  "content": "Specificity\nSpecificity\nis the algorithm used by browsers to determine the\nCSS declaration\nthat is the most relevant to an element, which in turn, determines the property value to apply to the element. The specificity algorithm calculates the weight of a\nCSS selector\nto determine which rule from competing CSS declarations gets applied to an element.\nNote:\nBrowsers consider specificity\nafter\ndetermining\ncascade origin and importance\n. In other words, for competing property declarations, specificity is relevant and compared only between selectors from the one\ncascade origin and layer\nthat has precedence for the property.\nScoping proximity\nand order of appearance become relevant when the selector specificities of the competing declarations in the cascade layer with precedence are equal.\nHow is specificity calculated?\nSpecificity is an algorithm that calculates the weight that is applied to a given CSS declaration. The weight is determined by the number of\nselectors of each weight category\nin the selector matching the element (or pseudo-element). If there are two or more declarations providing different property values for the same element, the declaration value in the style block having the matching selector with the greatest algorithmic weight gets applied.\nThe specificity algorithm is basically a three-column value of three categories or weights - ID, CLASS, and TYPE - corresponding to the three types of selectors. The value represents the count of selector components in each weight category and is written as\nID - CLASS - TYPE\n. The three columns are created by counting the number of selector components for each selector weight category in the selectors that match the element.\nSelector weight categories\nThe selector weight categories are listed here in the order of decreasing specificity:\nID column\nIncludes only\nID selectors\n, such as\n#example\n. For each ID in a matching selector, add 1-0-0 to the weight value.\nCLASS column\nIncludes\nclass selectors\n, such as\n.myClass\n, attribute selectors like\n[type=\"radio\"]\nand\n[lang|=\"fr\"]\n, and pseudo-classes, such as\n:hover\n,\n:nth-of-type(3n)\n, and\n:required\n. For each class, attribute selector, or pseudo-class in a matching selector, add 0-1-0 to the weight value.\nTYPE column\nIncludes\ntype selectors\n, such as\np\n,\nh1\n, and\ntd\n, and pseudo-elements like\n::before\n,\n::placeholder\n, and all other selectors with double-colon notation. For each type or pseudo-element in a matching selector, add 0-0-1 to the weight value.\nNo value\nThe universal selector (\n*\n) and the pseudo-class\n:where()\nand its parameters aren't counted when calculating the weight so their value is 0-0-0, but they do match elements. These selectors do not impact the specificity weight value.\nCombinators, such as\n+\n,\n>\n,\n~\n,\n\" \"\n, and\n||\n, may make a selector more specific in what is selected but they don't add any value to the specificity weight.\nThe\n&\nnesting combinator doesn't add specificity weight, but nested rules do. In terms of specificity, and functionality, nesting is very similar to the\n:is()\npseudo-class.\nLike nesting, the\n:is()\n,\n:has()\n, and negation (\n:not()\n) pseudo-classes themselves add no weight. The parameters in these selectors, however, do. The specificity weight of each comes from the selector parameter in the list of selectors with the highest specificity. Similarly, with nested selectors, the specificity weight added by the nested selector component is the selector in the comma-separated list of nested selectors with the highest specificity.\nThe\n:not()\n,\n:is()\n,\n:has()\nand CSS nesting exceptions\nare discussed below.\nMatching selector\nThe specificity weight comes from the matching selector. Take this CSS selector with three comma-separated selectors as an example:\ncss\n[type=\"password\"],\ninput:focus,\n:root #myApp input:required {\n  color: blue;\n}\nThe\n[type=\"password\"]\nselector in the above selector list, with a specificity weight of\n0-1-0\n, applies the\ncolor: blue\ndeclaration to all password input types.\nAll inputs, no matter the type, when receiving focus, match the second selector in the list,\ninput:focus\n, with a specificity weight of\n0-1-1\n; this weight is made up of the\n:focus\npseudo-class (0-1-0) and the\ninput\ntype (0-0-1). If the password input has focus, it will match\ninput:focus\n, and the specificity weight for the\ncolor: blue\nstyle declaration will be\n0-1-1\n. When that password doesn't have focus, the specificity weight remains at\n0-1-0\n.\nThe specificity for a required input nested in an element with attribute\nid=\"myApp\"\nis\n1-2-1\n, based on one ID, two pseudo-classes, and one element type.\nIf the password input type with\nrequired\nis nested in an element with\nid=\"myApp\"\nset, the specificity weight will be\n1-2-1\n, based on one ID, two pseudo-classes, and one element type, whether or not it has focus. Why is the specificity weight\n1-2-1\nrather than\n0-1-1\nor\n0-1-0\nin this case? Because the specificity weight comes from the matching selector with the greatest specificity weight. The weight is determined by comparing the values in the three columns, from left to right.\ncss\n[type=\"password\"] {\n  /* 0-1-0 */\n}\ninput:focus {\n  /* 0-1-1 */\n}\n:root #myApp input:required {\n  /* 1-2-1 */\n}\nThree-column comparison\nOnce the specificity values of the relevant selectors are determined, the number of selector components in each column are compared, from left to right.\ncss\n#myElement {\n  color: green; /* 1-0-0  - WINS!! */\n}\n.bodyClass .sectionClass .parentClass [id=\"myElement\"] {\n  color: yellow; /* 0-4-0 */\n}\nThe first column is the value of the\nID\ncomponent, which is the number of IDs in each selector. The numbers in the\nID\ncolumns of competing selectors are compared. The selector with the greater value in the\nID\ncolumn wins no matter what the values are in the other columns. In the above example, even though the yellow selector has more components in total, only the value of the first column matters.\nIf the number in the\nID\ncolumns of competing selectors is the same, then the next column,\nCLASS\n, is compared, as shown below.\ncss\n#myElement {\n  color: yellow; /* 1-0-0 */\n}\n#myApp [id=\"myElement\"] {\n  color: green; /* 1-1-0  - WINS!! */\n}\nThe\nCLASS\ncolumn is the count of class names, attribute selectors, and pseudo-classes in the selector. When the\nID\ncolumn value is the same, the selector with the greater value in the\nCLASS\ncolumn wins, no matter the value in the\nTYPE\ncolumn. This is shown in the example below.\ncss\n:root input {\n  color: green; /* 0-1-1 - WINS because CLASS column is greater */\n}\nhtml body main input {\n  color: yellow; /* 0-0-4 */\n}\nIf the numbers in the\nCLASS\nand\nID\ncolumns in competing selectors are the same, the\nTYPE\ncolumn becomes relevant. The\nTYPE\ncolumn is the number of element types and pseudo-elements in the selector. When the first two columns have the same value, the selector with the greater number in the\nTYPE\ncolumn wins.\nIf the competing selectors have the same values in all the three columns, the proximity rule comes into play, wherein the last declared style gets precedence.\ncss\ninput.myClass {\n  color: yellow; /* 0-1-1 */\n}\n:root input {\n  color: green; /* 0-1-1 WINS because it comes later */\n}\nThe\n:is()\n,\n:not()\n,\n:has()\nand CSS nesting exceptions\nThe matches-any pseudo-class\n:is()\n, the relational pseudo-class\n:has()\n, and the negation pseudo-class\n:not()\nare\nnot\nconsidered as pseudo-classes in the specificity weight calculation. They themselves don't add any weight to the specificity equation. However, the selector parameters passed into the pseudo-class parenthesis are part of the specificity algorithm; the weight of the matches-any and negation pseudo-class in the specificity value calculation is the weight of the parameter's\nweight\n.\ncss\np {\n  /* 0-0-1 */\n}\n:is(p) {\n  /* 0-0-1 */\n}\n\nh2:nth-last-of-type(n + 2) {\n  /* 0-1-1 */\n}\nh2:has(~ h2) {\n  /* 0-0-2 */\n}\n\ndiv.outer p {\n  /* 0-1-2 */\n}\ndiv:not(.inner) p {\n  /* 0-1-2 */\n}\nNote that in the above CSS pairing, the specificity weight provided by the\n:is()\n,\n:has()\nand\n:not()\npseudo-classes is the value of the selector parameter, not of the pseudo-class.\nAll three of these pseudo-classes accept complex selector lists, a list of comma-separated selectors, as a parameter. This feature can be used to increase a selector's specificity:\ncss\n:is(p, #fakeId) {\n  /* 1-0-0 */\n}\nh1:has(+ h2, > #fakeId) {\n  /* 1-0-1 */\n}\np:not(#fakeId) {\n  /* 1-0-1 */\n}\ndiv:not(.inner, #fakeId) p {\n  /* 1-0-2 */\n}\nIn the above CSS code block, we have included\n#fakeId\nin the selectors. This\n#fakeId\nadds\n1-0-0\nto the specificity weight of each paragraph.\nWhen creating complex selector lists with\nCSS nesting\nthis behaves in exactly the same way as the\n:is()\npseudo-class.\ncss\np,\n#fakeId {\n  span {\n    /* 1-0-1 */\n  }\n}\nIn the above code block the complex selector\np, #fakeId\nthe specificity is taken from\n#fakeId\nand also the\nspan\n, so this create a specificity of\n1-0-1\nfor both\np span\nand\n#fakeId span\n. This is the equivalent specificity as the\n:is(p, #fakeId) span\nselector.\nGenerally, you want to keep specificity down to a minimum, but if you need to increase an element's specificity for a particular reason, these three pseudo-classes can help.\ncss\na:not(#fakeId#fakeId#fakeID) {\n  color: blue; /* 3-0-1 */\n}\nIn this example, all links will be blue, unless overridden by a link declaration with 3 or more IDs, a color value matching an\na\nincludes the\n!important\nflag\n, or if the link has an\ninline style\ncolor declaration. If you use such a technique, add a comment to explain why the hack was needed.\nInline styles\nInline styles added to an element (e.g.,\nstyle=\"font-weight: bold;\"\n) always overwrite any normal styles in author stylesheets, and therefore, can be thought of as having the highest specificity. Think of inline styles as having a specificity weight of\n1-0-0-0\n.\nThe only way to override inline styles is by using\n!important\n.\nMany JavaScript frameworks and libraries add inline styles. Using\n!important\nwith a very targeted selector, such as an attribute selector using the inline style, is one way to override these inline styles.\nhtml\n<p style=\"color: purple\">\u00e2\u0080\u00a6</p>\ncss\np[style*=\"purple\"] {\n  color: rebeccapurple !important;\n}\nMake sure to include a comment with every inclusion of the important flag so code maintainers understand why a CSS anti-pattern was used.\nThe\n!important\nexception\nCSS declarations marked as important override any other declarations within the same cascade layer and origin. Although technically,\n!important\nhas nothing to do with specificity, it interacts directly with specificity and the cascade. It reverses the\ncascade\norder of stylesheets.\nIf declarations from the same origin and cascade layer conflict and one property value has the\n!important\nflag set, the important declaration is applied no matter the specificity. When conflicting declarations from the same origin and cascade layer with the\n!important\nflag are applied to the same element, the declaration with a greater specificity is applied.\nUsing\n!important\nto override specificity is considered a\nbad practice\nand should be avoided for this purpose. Understanding and effectively using specificity and the cascade can remove any need for the\n!important\nflag.\nInstead of using\n!important\nto override foreign CSS (from external libraries, like Bootstrap or normalize.css), import the third-party scripts directly into\ncascade layers\n. If you must use\n!important\nin your CSS, comment your usage so future code maintainers know why the declaration was marked important and know not to override it. But definitely, don't use\n!important\nwhen writing plugins or frameworks that other developers will need to incorporate without being able to control.\nThe\n:where()\nexception\nThe specificity-adjustment pseudo-class\n:where()\nalways has its specificity replaced with zero,\n0-0-0\n. It enables making CSS selectors very specific in what element is targeted without any increase to specificity.\nIn creating third-party CSS to be used by developers who don't have access to edit your CSS, it's considered a good practice to create CSS with the lowest possible specificity. For example, if your theme includes the following CSS:\ncss\n:where(#defaultTheme) a {\n  /* 0-0-1 */\n  color: red;\n}\nThen the developer implementing the widget can easily override the link color using only type selectors.\ncss\nfooter a {\n  /* 0-0-2 */\n  color: blue;\n}\nHow\n@scope\nblocks affect specificity\nIncluding a ruleset inside a\n@scope\nblock does not affect the specificity of its selector, regardless of the selectors used inside the\nscope root and limit\n.\nHowever, if you decide to explicitly add the\n:scope\npseudo-class, you'll need to factor it in when calculating their specificity.\n:scope\n, like all regular pseudo-classes, has a specificity of 0-1-0. For example:\ncss\n@scope (.article-body) {\n  /* :scope img has a specificity of 0-1-0 + 0-0-1 = 0-1-1 */\n  :scope img {\n  }\n}\nSee\nSpecificity in\n@scope\nfor more information.\nTips for handling specificity headaches\nInstead of using\n!important\n, consider using cascade layers and using low weight specificity throughout your CSS so that styles are easily overridden with slightly more specific rules. Using semantic HTML helps provide anchors from which to apply styling.\nMaking selectors specific with and without adding specificity\nBy indicating the section of the document you're styling before the element you're selecting, the rule becomes more specific. Depending on how you add it, you can add some, a lot, or no specificity, as shown below:\nhtml\n<main id=\"myContent\">\n  <h1>Text</h1>\n</main>\ncss\n#myContent h1 {\n  color: green; /* 1-0-1 */\n}\n[id=\"myContent\"] h1 {\n  color: yellow; /* 0-1-1 */\n}\n:where(#myContent) h1 {\n  color: blue; /* 0-0-1 */\n}\nNo matter the order, the heading will be green because that rule is the most specific.\nReducing ID specificity\nSpecificity is based on the form of a selector. Including the\nid\nof an element as an attribute selector rather than an id selector is a good way to make an element more specific without adding an overabundance of specificity. In the previous example, the selector\n[id=\"myContent\"]\ncounts as an attribute selector for the purpose of determining the selector's specificity, even though it selects an ID.\nYou can also include the\nid\nor any part of a selector as a parameter in the\n:where()\nspecificity-adjustment pseudo class if you need to make a selector more specific but don't want to add any specificity at all.\nIncreasing specificity by duplicating selector\nAs a special case for increasing specificity, you can duplicate weights from the\nCLASS\nor\nID\ncolumns. Duplicating id, class, pseudo-class or attribute selectors within a compound selector will increase specificity when overriding very specific selectors over which you have no control.\ncss\n#myId#myId#myId span {\n  /* 3-0-1 */\n}\n.myClass.myClass.myClass span {\n  /* 0-3-1 */\n}\nUse this sparingly, if at all. If using selector duplication, always comment your CSS.\nBy using\n:is()\nand\n:not()\n(and also\n:has()\n), you can increase specificity even if you can't add an\nid\nto a parent element:\ncss\n:not(#fakeID#fakeId#fakeID) span {\n  /* 3-0-1 */\n}\n:is(#fakeID#fakeId#fakeID, span) {\n  /* 3-0-0 */\n}\nPrecedence over third-party CSS\nLeveraging cascade layers is the standard way of enabling one set of styles to take precedence over another set of styles; cascade layers enable this without using specificity! Normal (not important) author styles imported into cascade layers have lower precedence than unlayered author styles.\nIf styles are coming from a stylesheet you can't edit or don't understand and you need to override styles, a strategy is to import the styles you don't control into a cascade layer. Styles in subsequently declared layers take precedence, with unlayered styles having precedence over all layered styles from the same origin.\nWhen two selectors from different layers match the same element, origin and importance take precedence; the specificity of the selector in the losing stylesheet is irrelevant.\ncss\n@import \"TW.css\" layer();\np,\np * {\n  font-size: 1rem;\n}\nIn the above example, all paragraph text, including the nested content, will be\n1rem\nno matter how many class names the paragraphs have that match the TW stylesheet.\nAvoiding and overriding\n!important\nThe best approach is to not use\n!important\n. The above explanations on specificity should be helpful in avoiding using the flag and removing it altogether when encountered.\nTo remove the perceived need for\n!important\n, you can do one of the following:\nIncrease the specificity of the selector of the formerly\n!important\ndeclaration so that it is greater than other declarations\nGive it the same specificity and put it after the declaration it is meant to override\nReduce the specificity of the selector you are trying to override.\nAll these methods are covered in preceding sections.\nIf you're unable to remove\n!important\nflags from an authors style sheet, the only solution to overriding the important styles is by using\n!important\n. Creating a\ncascade layer\nof important declaration overrides is an excellent solution. Two ways of doing this include:\nMethod 1\nCreate a separate, short style sheet containing only important declarations specifically overriding any important declarations you were unable to remove.\nImport this stylesheet as the first import in your CSS using\nlayer()\n, including the\n@import\nstatement, before linking to other stylesheets. This is to ensure that the important overrides is imported as the first layer.\ncss\n@import \"importantOverrides.css\" layer();\nMethod 2\nAt the beginning of your stylesheet declarations, create a named cascade layer, like so:\ncss\n@layer importantOverrides;\nEach time you need to override an important declaration, declare it within the named layer. Only declare important rules within the layer.\ncss\n[id=\"myElement\"] p {\n  /* normal styles here */\n}\n@layer importantOverrides {\n  [id=\"myElement\"] p {\n    /* important style here */\n  }\n}\nThe specificity of the selector of the important style within the layer can be low, as long as it matches the element you are trying to override. Normal layers should be declared outside the layer because layered styles have lower precedence than unlayered styles.\nTree proximity ignorance\nThe proximity of an element to other elements that are referenced in a given selector has no impact on specificity.\ncss\nbody h1 {\n  color: green;\n}\n\nhtml h1 {\n  color: purple;\n}\nThe\n<h1>\nelements will be purple because when declarations have the same specificity, the last declared selector has precedence.\nDirectly targeted elements vs. inherited styles\nStyles for a directly targeted element will always take precedence over inherited styles, regardless of the specificity of the inherited rule. Given the following CSS and HTML:\ncss\n#parent {\n  color: green;\n}\n\nh1 {\n  color: purple;\n}\nhtml\n<html lang=\"en\">\n  <body id=\"parent\">\n    <h1>Here is a title!</h1>\n  </body>\n</html>\nThe\nh1\nwill be purple because the\nh1\nselector targets the element specifically, while the green is inherited from the\n#parent\ndeclarations.\nExamples\nIn the following CSS, we have three selectors targeting\n<input>\nelements to set a color. For a given input, the specificity weight of the color declaration having precedence is the matching selector with the greatest weight:\ncss\n#myElement input.myClass {\n  color: red;\n} /* 1-1-1 */\ninput[type=\"password\"]:required {\n  color: blue;\n} /* 0-2-1 */\nhtml body main input {\n  color: green;\n} /* 0-0-4 */\nIf the above selectors all target the same input, the input will be red, as the first declaration has the highest value in the\nID\ncolumn.\nThe last selector has four\nTYPE\ncomponents. While it has the highest integer value, no matter how many elements and pseudo-elements are included, even if there were 150, TYPE components never have precedence over\nCLASS\ncomponents. The column values are compared starting from left to right when column values are equal.\nHad we converted the id selector in the example code above to an attribute selector, the first two selectors would have the same specificity, as shown below:\ncss\n[id=\"myElement\"] input.myClass {\n  color: red;\n} /* 0-2-1 */\ninput[type=\"password\"]:required {\n  color: blue;\n} /* 0-2-1 */\nWhen multiple declarations have equal specificity, the last declaration found in the CSS is applied to the element. If both selectors match the same\n<input>\n, the color will be blue.\nAdditional notes\nA few things to remember about specificity:\nSpecificity only applies when the same element is targeted by multiple declarations in the same cascade layer or origin. Specificity only matters for declarations of the same importance and same origin and\ncascade layer\n. If matching selectors are in different origins, the\ncascade\ndetermines which declaration takes precedence.\nWhen two selectors in the same cascade layer and origin have the same specificity, scoping proximity is then calculated; the ruleset with the lowest scoping proximity wins. See\nHow\n@scope\nconflicts are resolved\nfor more details and an example.\nIf scope proximity is also the same for both selectors, source order then comes into play. When all else is equal, the last selector wins.\nAs per CSS rules,\ndirectly targeted elements\nwill always take precedence over rules which an element inherits from its ancestor.\nProximity of elements\nin the document tree has no effect on the specificity.\nSpecifications\nSpecification\nSelectors Level 4\n#\nspecificity-rules\nSee also\nCSS cascading and inheritance\nmodule\nLearn: Handling conflicts\nLearn: Cascade layers\nCSS syntax\nmodule\nIntroduction to CSS syntax: declarations, rulesets, and statements\nCSS error handling\nAt-rules\nInheritance\nValues:\ninitial\n,\ncomputed\n,\nused\n, and\nactual\nValue definition syntax\nCSS nesting\nmodule\nSpecificity Calculator\nby Keegan Street: An interactive website to test and understand your own CSS rules\nSpeciFISHity\non specifishity.com: A fun way to learn about CSS specificity\nID-CLASS-TYPE\nexercise\n: A specificity quiz by Estelle Weyl\nHelp improve MDN\nLearn how to contribute\nThis page was last modified on\nDec 16, 2025\nby\nMDN contributors\n.\nView this page on GitHub\n\u00e2\u0080\u00a2\nReport a problem with this content",
  "content_markdown": "# Specificity\n\n**Specificity** is the algorithm used by browsers to determine the [CSS declaration](/en-US/docs/Learn_web_development/Core/Styling_basics/What_is_CSS#css_syntax_basics) that is the most relevant to an element, which in turn, determines the property value to apply to the element. The specificity algorithm calculates the weight of a [CSS selector](/en-US/docs/Web/CSS/Reference#selectors) to determine which rule from competing CSS declarations gets applied to an element.\n\n**Note:**\nBrowsers consider specificity **after** determining [cascade origin and importance](/en-US/docs/Web/CSS/Guides/Cascade/Introduction). In other words, for competing property declarations, specificity is relevant and compared only between selectors from the one [cascade origin and layer](/en-US/docs/Web/CSS/Reference/At-rules/@layer) that has precedence for the property. [Scoping proximity](/en-US/docs/Web/CSS/Reference/At-rules/@scope#how_scope_conflicts_are_resolved) and order of appearance become relevant when the selector specificities of the competing declarations in the cascade layer with precedence are equal.\n\n## [How is specificity calculated?](#how_is_specificity_calculated)\n\nSpecificity is an algorithm that calculates the weight that is applied to a given CSS declaration. The weight is determined by the number of [selectors of each weight category](#selector_weight_categories) in the selector matching the element (or pseudo-element). If there are two or more declarations providing different property values for the same element, the declaration value in the style block having the matching selector with the greatest algorithmic weight gets applied.\n\nThe specificity algorithm is basically a three-column value of three categories or weights - ID, CLASS, and TYPE - corresponding to the three types of selectors. The value represents the count of selector components in each weight category and is written as *ID - CLASS - TYPE*. The three columns are created by counting the number of selector components for each selector weight category in the selectors that match the element.\n\n### [Selector weight categories](#selector_weight_categories)\n\nThe selector weight categories are listed here in the order of decreasing specificity:\n\n[ID column](#id_column)\n:   Includes only [ID selectors](/en-US/docs/Web/CSS/Reference/Selectors/ID_selectors), such as `#example`. For each ID in a matching selector, add 1-0-0 to the weight value.\n\n[CLASS column](#class_column)\n:   Includes [class selectors](/en-US/docs/Web/CSS/Reference/Selectors/Class_selectors), such as `.myClass`, attribute selectors like `[type=\"radio\"]` and `[lang|=\"fr\"]`, and pseudo-classes, such as `:hover`, `:nth-of-type(3n)`, and `:required`. For each class, attribute selector, or pseudo-class in a matching selector, add 0-1-0 to the weight value.\n\n[TYPE column](#type_column)\n:   Includes [type selectors](/en-US/docs/Web/CSS/Reference/Selectors/Type_selectors), such as `p`, `h1`, and `td`, and pseudo-elements like `::before`, `::placeholder`, and all other selectors with double-colon notation. For each type or pseudo-element in a matching selector, add 0-0-1 to the weight value.\n\n[No value](#no_value)\n:   The universal selector ([`*`](/en-US/docs/Web/CSS/Reference/Selectors/Universal_selectors)) and the pseudo-class [`:where()`](/en-US/docs/Web/CSS/Reference/Selectors/:where) and its parameters aren't counted when calculating the weight so their value is 0-0-0, but they do match elements. These selectors do not impact the specificity weight value.\n\nCombinators, such as [`+`](/en-US/docs/Web/CSS/Reference/Selectors/Next-sibling_combinator), [`>`](/en-US/docs/Web/CSS/Reference/Selectors/Child_combinator), [`~`](/en-US/docs/Web/CSS/Reference/Selectors/Subsequent-sibling_combinator), [\" \"](/en-US/docs/Web/CSS/Reference/Selectors/Descendant_combinator), and [`||`](/en-US/docs/Web/CSS/Reference/Selectors/Column_combinator), may make a selector more specific in what is selected but they don't add any value to the specificity weight.\n\nThe `&` nesting combinator doesn't add specificity weight, but nested rules do. In terms of specificity, and functionality, nesting is very similar to the [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is) pseudo-class.\n\nLike nesting, the [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is), [`:has()`](/en-US/docs/Web/CSS/Reference/Selectors/:has), and negation ([`:not()`](/en-US/docs/Web/CSS/Reference/Selectors/:not)) pseudo-classes themselves add no weight. The parameters in these selectors, however, do. The specificity weight of each comes from the selector parameter in the list of selectors with the highest specificity. Similarly, with nested selectors, the specificity weight added by the nested selector component is the selector in the comma-separated list of nested selectors with the highest specificity.\n\nThe [`:not()`, `:is()`, `:has()` and CSS nesting exceptions](#the_is_not_has_and_css_nesting_exceptions) are discussed below.\n\n#### Matching selector\n\nThe specificity weight comes from the matching selector. Take this CSS selector with three comma-separated selectors as an example:\n\ncss\n\n```\n[type=\"password\"],\ninput:focus,\n:root #myApp input:required {\n  color: blue;\n}\n```\n\nThe `[type=\"password\"]` selector in the above selector list, with a specificity weight of `0-1-0`, applies the `color: blue` declaration to all password input types.\n\nAll inputs, no matter the type, when receiving focus, match the second selector in the list, `input:focus`, with a specificity weight of `0-1-1`; this weight is made up of the `:focus` pseudo-class (0-1-0) and the `input` type (0-0-1). If the password input has focus, it will match `input:focus`, and the specificity weight for the `color: blue` style declaration will be `0-1-1`. When that password doesn't have focus, the specificity weight remains at `0-1-0`.\n\nThe specificity for a required input nested in an element with attribute `id=\"myApp\"` is `1-2-1`, based on one ID, two pseudo-classes, and one element type.\n\nIf the password input type with `required` is nested in an element with `id=\"myApp\"` set, the specificity weight will be `1-2-1`, based on one ID, two pseudo-classes, and one element type, whether or not it has focus. Why is the specificity weight `1-2-1` rather than `0-1-1` or `0-1-0` in this case? Because the specificity weight comes from the matching selector with the greatest specificity weight. The weight is determined by comparing the values in the three columns, from left to right.\n\ncss\n\n```\n[type=\"password\"] {\n  /* 0-1-0 */\n}\ninput:focus {\n  /* 0-1-1 */\n}\n:root #myApp input:required {\n  /* 1-2-1 */\n}\n```\n\n### [Three-column comparison](#three-column_comparison)\n\nOnce the specificity values of the relevant selectors are determined, the number of selector components in each column are compared, from left to right.\n\ncss\n\n```\n#myElement {\n  color: green; /* 1-0-0  - WINS!! */\n}\n.bodyClass .sectionClass .parentClass [id=\"myElement\"] {\n  color: yellow; /* 0-4-0 */\n}\n```\n\nThe first column is the value of the *ID* component, which is the number of IDs in each selector. The numbers in the *ID* columns of competing selectors are compared. The selector with the greater value in the *ID* column wins no matter what the values are in the other columns. In the above example, even though the yellow selector has more components in total, only the value of the first column matters.\n\nIf the number in the *ID* columns of competing selectors is the same, then the next column, *CLASS*, is compared, as shown below.\n\ncss\n\n```\n#myElement {\n  color: yellow; /* 1-0-0 */\n}\n#myApp [id=\"myElement\"] {\n  color: green; /* 1-1-0  - WINS!! */\n}\n```\n\nThe *CLASS* column is the count of class names, attribute selectors, and pseudo-classes in the selector. When the *ID* column value is the same, the selector with the greater value in the *CLASS* column wins, no matter the value in the *TYPE* column. This is shown in the example below.\n\ncss\n\n```\n:root input {\n  color: green; /* 0-1-1 - WINS because CLASS column is greater */\n}\nhtml body main input {\n  color: yellow; /* 0-0-4 */\n}\n```\n\nIf the numbers in the *CLASS* and *ID* columns in competing selectors are the same, the *TYPE* column becomes relevant. The *TYPE* column is the number of element types and pseudo-elements in the selector. When the first two columns have the same value, the selector with the greater number in the *TYPE* column wins.\n\nIf the competing selectors have the same values in all the three columns, the proximity rule comes into play, wherein the last declared style gets precedence.\n\ncss\n\n```\ninput.myClass {\n  color: yellow; /* 0-1-1 */\n}\n:root input {\n  color: green; /* 0-1-1 WINS because it comes later */\n}\n```\n\n### [The `:is()`, `:not()`, `:has()` and CSS nesting exceptions](#the_is_not_has_and_css_nesting_exceptions)\n\nThe matches-any pseudo-class [`:is()`](/en-US/docs/Web/CSS/Reference/Selectors/:is), the relational pseudo-class [`:has()`](/en-US/docs/Web/CSS/Reference/Selectors/:has), and the negation pseudo-class [`:not()`](/en-US/docs/Web/CSS/Reference/Selectors/:not) are *not* considered as pseudo-classes in the specificity weight calculation. They themselves don't add any weight to the specificity equation. However, the selector parameters passed into the pseudo-class parenthesis are part of the specificity algorithm; the weight of the matches-any and negation pseudo-class in the specificity value calculation is the weight of the parameter's [weight](#selector_weight_categories).\n\ncss\n\n```\np {\n  /* 0-0-1 */\n}\n:is(p) {\n  /* 0-0-1 */\n}\n\nh2:nth-last-of-type(n + 2) {\n  /* 0-1-1 */\n}\nh2:has(~ h2) {\n  /* 0-0-2 */\n}\n\ndiv.outer p {\n  /* 0-1-2 */\n}\ndiv:not(.inner) p {\n  /* 0-1-2 */\n}\n```\n\nNote that in the above CSS pairing, the specificity weight provided by the `:is()`, `:has()` and `:not()` pseudo-classes is the value of the selector parameter, not of the pseudo-class.\n\nAll three of these pseudo-classes accept complex selector lists, a list of comma-separated selectors, as a parameter. This feature can be used to increase a selector's specificity:\n\ncss\n\n```\n:is(p, #fakeId) {\n  /* 1-0-0 */\n}\nh1:has(+ h2, > #fakeId) {\n  /* 1-0-1 */\n}\np:not(#fakeId) {\n  /* 1-0-1 */\n}\ndiv:not(.inner, #fakeId) p {\n  /* 1-0-2 */\n}\n```\n\nIn the above CSS code block, we have included `#fakeId` in the selectors. This `#fakeId` adds `1-0-0` to the specificity weight of each paragraph.\n\nWhen creating complex selector lists with [CSS nesting](/en-US/docs/Web/CSS/Guides/Nesting) this behaves in exactly the same way as the `:is()` pseudo-class.\n\ncss\n\n```\np,\n#fakeId {\n  span {\n    /* 1-0-1 */\n  }\n}\n```\n\nIn the above code block the complex selector `p, #fakeId` the specificity is taken from `#fakeId` and also the `span`, so this create a specificity of `1-0-1` for both `p span` and `#fakeId span`. This is the equivalent specificity as the `:is(p, #fakeId) span` selector.\n\nGenerally, you want to keep specificity down to a minimum, but if you need to increase an element's specificity for a particular reason, these three pseudo-classes can help.\n\ncss\n\n```\na:not(#fakeId#fakeId#fakeID) {\n  color: blue; /* 3-0-1 */\n}\n```\n\nIn this example, all links will be blue, unless overridden by a link declaration with 3 or more IDs, a color value matching an `a` includes the [`!important` flag](#the_!important_exception), or if the link has an [inline style](#inline_styles) color declaration. If you use such a technique, add a comment to explain why the hack was needed.\n\n### [Inline styles](#inline_styles)\n\nInline styles added to an element (e.g., `style=\"font-weight: bold;\"`) always overwrite any normal styles in author stylesheets, and therefore, can be thought of as having the highest specificity. Think of inline styles as having a specificity weight of `1-0-0-0`.\n\nThe only way to override inline styles is by using `!important`.\n\nMany JavaScript frameworks and libraries add inline styles. Using `!important` with a very targeted selector, such as an attribute selector using the inline style, is one way to override these inline styles.\n\nhtml\n\n```\n<p style=\"color: purple\">\u00e2\u0080\u00a6</p>\n```\n\ncss\n\n```\np[style*=\"purple\"] {\n  color: rebeccapurple !important;\n}\n```\n\nMake sure to include a comment with every inclusion of the important flag so code maintainers understand why a CSS anti-pattern was used.\n\n### [The `!important` exception](#the_!important_exception)\n\nCSS declarations marked as important override any other declarations within the same cascade layer and origin. Although technically, [`!important`](/en-US/docs/Web/CSS/Reference/Values/important) has nothing to do with specificity, it interacts directly with specificity and the cascade. It reverses the [cascade](/en-US/docs/Web/CSS/Guides/Cascade/Introduction) order of stylesheets.\n\nIf declarations from the same origin and cascade layer conflict and one property value has the `!important` flag set, the important declaration is applied no matter the specificity. When conflicting declarations from the same origin and cascade layer with the `!important` flag are applied to the same element, the declaration with a greater specificity is applied.\n\nUsing `!important` to override specificity is considered a **bad practice** and should be avoided for this purpose. Understanding and effectively using specificity and the cascade can remove any need for the `!important` flag.\n\nInstead of using `!important` to override foreign CSS (from external libraries, like Bootstrap or normalize.css), import the third-party scripts directly into [cascade layers](/en-US/docs/Web/CSS/Reference/At-rules/@layer). If you must use `!important` in your CSS, comment your usage so future code maintainers know why the declaration was marked important and know not to override it. But definitely, don't use `!important` when writing plugins or frameworks that other developers will need to incorporate without being able to control.\n\n### [The `:where()` exception](#the_where_exception)\n\nThe specificity-adjustment pseudo-class [`:where()`](/en-US/docs/Web/CSS/Reference/Selectors/:where) always has its specificity replaced with zero, `0-0-0`. It enables making CSS selectors very specific in what element is targeted without any increase to specificity.\n\nIn creating third-party CSS to be used by developers who don't have access to edit your CSS, it's considered a good practice to create CSS with the lowest possible specificity. For example, if your theme includes the following CSS:\n\ncss\n\n```\n:where(#defaultTheme) a {\n  /* 0-0-1 */\n  color: red;\n}\n```\n\nThen the developer implementing the widget can easily override the link color using only type selectors.\n\ncss\n\n```\nfooter a {\n  /* 0-0-2 */\n  color: blue;\n}\n```\n\n### [How `@scope` blocks affect specificity](#how_scope_blocks_affect_specificity)\n\nIncluding a ruleset inside a [`@scope`](/en-US/docs/Web/CSS/Reference/At-rules/@scope) block does not affect the specificity of its selector, regardless of the selectors used inside the [scope root and limit](/en-US/docs/Web/CSS/Reference/At-rules/@scope#syntax).\nHowever, if you decide to explicitly add the [`:scope`](/en-US/docs/Web/CSS/Reference/Selectors/:scope) pseudo-class, you'll need to factor it in when calculating their specificity.\n`:scope`, like all regular pseudo-classes, has a specificity of 0-1-0. For example:\n\ncss\n\n```\n@scope (.article-body) {\n  /* :scope img has a specificity of 0-1-0 + 0-0-1 = 0-1-1 */\n  :scope img {\n  }\n}\n```\n\nSee [Specificity in `@scope`](/en-US/docs/Web/CSS/Reference/At-rules/@scope#specificity_in_scope) for more information.\n\n## [Tips for handling specificity headaches](#tips_for_handling_specificity_headaches)\n\nInstead of using `!important`, consider using cascade layers and using low weight specificity throughout your CSS so that styles are easily overridden with slightly more specific rules. Using semantic HTML helps provide anchors from which to apply styling.\n\n### [Making selectors specific with and without adding specificity](#making_selectors_specific_with_and_without_adding_specificity)\n\nBy indicating the section of the document you're styling before the element you're selecting, the rule becomes more specific. Depending on how you add it, you can add some, a lot, or no specificity, as shown below:\n\nhtml\n\n```\n<main id=\"myContent\">\n  <h1>Text</h1>\n</main>\n```\n\ncss\n\n```\n#myContent h1 {\n  color: green; /* 1-0-1 */\n}\n[id=\"myContent\"] h1 {\n  color: yellow; /* 0-1-1 */\n}\n:where(#myContent) h1 {\n  color: blue; /* 0-0-1 */\n}\n```\n\nNo matter the order, the heading will be green because that rule is the most specific.\n\n#### Reducing ID specificity\n\nSpecificity is based on the form of a selector. Including the `id` of an element as an attribute selector rather than an id selector is a good way to make an element more specific without adding an overabundance of specificity. In the previous example, the selector `[id=\"myContent\"]` counts as an attribute selector for the purpose of determining the selector's specificity, even though it selects an ID.\n\nYou can also include the `id` or any part of a selector as a parameter in the `:where()` specificity-adjustment pseudo class if you need to make a selector more specific but don't want to add any specificity at all.\n\n### [Increasing specificity by duplicating selector](#increasing_specificity_by_duplicating_selector)\n\nAs a special case for increasing specificity, you can duplicate weights from the *CLASS* or *ID* columns. Duplicating id, class, pseudo-class or attribute selectors within a compound selector will increase specificity when overriding very specific selectors over which you have no control.\n\ncss\n\n```\n#myId#myId#myId span {\n  /* 3-0-1 */\n}\n.myClass.myClass.myClass span {\n  /* 0-3-1 */\n}\n```\n\nUse this sparingly, if at all. If using selector duplication, always comment your CSS.\n\nBy using `:is()` and `:not()` (and also `:has()`), you can increase specificity even if you can't add an `id` to a parent element:\n\ncss\n\n```\n:not(#fakeID#fakeId#fakeID) span {\n  /* 3-0-1 */\n}\n:is(#fakeID#fakeId#fakeID, span) {\n  /* 3-0-0 */\n}\n```\n\n### [Precedence over third-party CSS](#precedence_over_third-party_css)\n\nLeveraging cascade layers is the standard way of enabling one set of styles to take precedence over another set of styles; cascade layers enable this without using specificity! Normal (not important) author styles imported into cascade layers have lower precedence than unlayered author styles.\n\nIf styles are coming from a stylesheet you can't edit or don't understand and you need to override styles, a strategy is to import the styles you don't control into a cascade layer. Styles in subsequently declared layers take precedence, with unlayered styles having precedence over all layered styles from the same origin.\n\nWhen two selectors from different layers match the same element, origin and importance take precedence; the specificity of the selector in the losing stylesheet is irrelevant.\n\ncss\n\n```\n@import \"TW.css\" layer();\np,\np * {\n  font-size: 1rem;\n}\n```\n\nIn the above example, all paragraph text, including the nested content, will be `1rem` no matter how many class names the paragraphs have that match the TW stylesheet.\n\n### [Avoiding and overriding `!important`](#avoiding_and_overriding_!important)\n\nThe best approach is to not use `!important`. The above explanations on specificity should be helpful in avoiding using the flag and removing it altogether when encountered.\n\nTo remove the perceived need for `!important`, you can do one of the following:\n\n- Increase the specificity of the selector of the formerly `!important` declaration so that it is greater than other declarations\n- Give it the same specificity and put it after the declaration it is meant to override\n- Reduce the specificity of the selector you are trying to override.\n\nAll these methods are covered in preceding sections.\n\nIf you're unable to remove `!important` flags from an authors style sheet, the only solution to overriding the important styles is by using `!important`. Creating a [cascade layer](/en-US/docs/Web/CSS/Reference/At-rules/@layer) of important declaration overrides is an excellent solution. Two ways of doing this include:\n\n#### Method 1\n\n1. Create a separate, short style sheet containing only important declarations specifically overriding any important declarations you were unable to remove.\n2. Import this stylesheet as the first import in your CSS using `layer()`, including the `@import` statement, before linking to other stylesheets. This is to ensure that the important overrides is imported as the first layer.\n\ncss\n\n```\n@import \"importantOverrides.css\" layer();\n```\n\n#### Method 2\n\n1. At the beginning of your stylesheet declarations, create a named cascade layer, like so:\n\n   css\n\n   ```\n   @layer importantOverrides;\n   ```\n2. Each time you need to override an important declaration, declare it within the named layer. Only declare important rules within the layer.\n\n   css\n\n   ```\n   [id=\"myElement\"] p {\n     /* normal styles here */\n   }\n   @layer importantOverrides {\n     [id=\"myElement\"] p {\n       /* important style here */\n     }\n   }\n   ```\n\nThe specificity of the selector of the important style within the layer can be low, as long as it matches the element you are trying to override. Normal layers should be declared outside the layer because layered styles have lower precedence than unlayered styles.\n\n### [Tree proximity ignorance](#tree_proximity_ignorance)\n\nThe proximity of an element to other elements that are referenced in a given selector has no impact on specificity.\n\ncss\n\n```\nbody h1 {\n  color: green;\n}\n\nhtml h1 {\n  color: purple;\n}\n```\n\nThe `<h1>` elements will be purple because when declarations have the same specificity, the last declared selector has precedence.\n\n### [Directly targeted elements vs. inherited styles](#directly_targeted_elements_vs._inherited_styles)\n\nStyles for a directly targeted element will always take precedence over inherited styles, regardless of the specificity of the inherited rule. Given the following CSS and HTML:\n\ncss\n\n```\n#parent {\n  color: green;\n}\n\nh1 {\n  color: purple;\n}\n```\n\nhtml\n\n```\n<html lang=\"en\">\n  <body id=\"parent\">\n    <h1>Here is a title!</h1>\n  </body>\n</html>\n```\n\nThe `h1` will be purple because the `h1` selector targets the element specifically, while the green is inherited from the `#parent` declarations.\n\n## [Examples](#examples)\n\nIn the following CSS, we have three selectors targeting [`<input>`](/en-US/docs/Web/HTML/Reference/Elements/input) elements to set a color. For a given input, the specificity weight of the color declaration having precedence is the matching selector with the greatest weight:\n\ncss\n\n```\n#myElement input.myClass {\n  color: red;\n} /* 1-1-1 */\ninput[type=\"password\"]:required {\n  color: blue;\n} /* 0-2-1 */\nhtml body main input {\n  color: green;\n} /* 0-0-4 */\n```\n\nIf the above selectors all target the same input, the input will be red, as the first declaration has the highest value in the *ID* column.\n\nThe last selector has four *TYPE* components. While it has the highest integer value, no matter how many elements and pseudo-elements are included, even if there were 150, TYPE components never have precedence over *CLASS* components. The column values are compared starting from left to right when column values are equal.\n\nHad we converted the id selector in the example code above to an attribute selector, the first two selectors would have the same specificity, as shown below:\n\ncss\n\n```\n[id=\"myElement\"] input.myClass {\n  color: red;\n} /* 0-2-1 */\ninput[type=\"password\"]:required {\n  color: blue;\n} /* 0-2-1 */\n```\n\nWhen multiple declarations have equal specificity, the last declaration found in the CSS is applied to the element. If both selectors match the same [`<input>`](/en-US/docs/Web/HTML/Reference/Elements/input), the color will be blue.\n\n## [Additional notes](#additional_notes)\n\nA few things to remember about specificity:\n\n1. Specificity only applies when the same element is targeted by multiple declarations in the same cascade layer or origin. Specificity only matters for declarations of the same importance and same origin and [cascade layer](/en-US/docs/Web/CSS/Reference/At-rules/@layer). If matching selectors are in different origins, the [cascade](/en-US/docs/Web/CSS/Guides/Cascade/Introduction) determines which declaration takes precedence.\n2. When two selectors in the same cascade layer and origin have the same specificity, scoping proximity is then calculated; the ruleset with the lowest scoping proximity wins. See [How `@scope` conflicts are resolved](/en-US/docs/Web/CSS/Reference/At-rules/@scope#how_scope_conflicts_are_resolved) for more details and an example.\n3. If scope proximity is also the same for both selectors, source order then comes into play. When all else is equal, the last selector wins.\n4. As per CSS rules, [directly targeted elements](#directly_targeted_elements_vs._inherited_styles) will always take precedence over rules which an element inherits from its ancestor.\n5. [Proximity of elements](#tree_proximity_ignorance) in the document tree has no effect on the specificity.\n\n## [Specifications](#specifications)\n\n| Specification |\n| --- |\n| [Selectors Level 4  # specificity-rules](https://drafts.csswg.org/selectors/#specificity-rules) |\n\n## [See also](#see_also)\n\n- [CSS cascading and inheritance](/en-US/docs/Web/CSS/Guides/Cascade) module\n- [Learn: Handling conflicts](/en-US/docs/Learn_web_development/Core/Styling_basics/Handling_conflicts#specificity_2)\n- [Learn: Cascade layers](/en-US/docs/Learn_web_development/Core/Styling_basics/Cascade_layers)\n- [CSS syntax](/en-US/docs/Web/CSS/Guides/Syntax) module\n- [Introduction to CSS syntax: declarations, rulesets, and statements](/en-US/docs/Web/CSS/Guides/Syntax/Introduction)\n- [CSS error handling](/en-US/docs/Web/CSS/Guides/Syntax/Error_handling)\n- [At-rules](/en-US/docs/Web/CSS/Guides/Syntax/At-rules)\n- [Inheritance](/en-US/docs/Web/CSS/Guides/Cascade/Inheritance)\n- Values: [initial](/en-US/docs/Web/CSS/Guides/Cascade/Property_value_processing#initial_value), [computed](/en-US/docs/Web/CSS/Guides/Cascade/Property_value_processing#computed_value), [used](/en-US/docs/Web/CSS/Guides/Cascade/Property_value_processing#used_value), and [actual](/en-US/docs/Web/CSS/Guides/Cascade/Property_value_processing#actual_value)\n- [Value definition syntax](/en-US/docs/Web/CSS/Guides/Values_and_units/Value_definition_syntax)\n- [CSS nesting](/en-US/docs/Web/CSS/Guides/Nesting) module\n- [Specificity Calculator](https://specificity.keegan.st/) by Keegan Street: An interactive website to test and understand your own CSS rules\n- [SpeciFISHity](https://specifishity.com/) on specifishity.com: A fun way to learn about CSS specificity\n- [*ID-CLASS-TYPE* exercise](https://estelle.github.io/CSS/selectors/exercises/specificity.html): A specificity quiz by Estelle Weyl\n\n## Help improve MDN\n\nWas this page helpful to you?\n\nYes\n\nNo\n\n[Learn how to contribute](/en-US/docs/MDN/Community/Getting_started)\n\nThis page was last modified on Dec 16, 2025 by [MDN contributors](/en-US/docs/Web/CSS/Guides/Cascade/Specificity/contributors.txt).\n\n[View this page on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/css/guides/cascade/specificity/index.md?plain=1 \"Folder: en-us/web/css/guides/cascade/specificity (Opens in a new tab)\") \u00e2\u0080\u00a2 [Report a problem with this content](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FGuides%2FCascade%2FSpecificity&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fcss%2Fguides%2Fcascade%2Fspecificity%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FGuides%2FCascade%2FSpecificity%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fcss%2Fguides%2Fcascade%2Fspecificity%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F33094d735e90b4dcae5733331b79c51fee997410%0A*+Document+last+modified%3A+2025-12-16T15%3A14%3A26.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\")",
  "tags": [
    "mdn",
    "css",
    "reference",
    "layout"
  ],
  "extracted_at": "2026-02-03T12:45:22.645818+00:00",
  "content_length": 22190,
  "content_hash": "99da32fcf28137ef"
}