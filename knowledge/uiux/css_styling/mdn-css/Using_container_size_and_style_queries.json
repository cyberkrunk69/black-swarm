{
  "id": "mdn-css__en-US_docs_Web_CSS_CSS_containment_Container_size",
  "source_id": "mdn-css",
  "source_name": "MDN CSS Reference",
  "category": "css_styling",
  "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_size_and_style_queries",
  "title": "Using container size and style queries",
  "content": "Using container size and style queries\nContainer queries\nenable you to apply styles to elements nested within a specific container based on the features of that container. The query returns true or false depending on whether the query condition is true for the container.\nContainer queries are similar to\nmedia queries\n. The\n@media\nat-rule enables applying styles to elements based on viewport size or other device characteristics. Similarly, the\n@container\nat-rule enables applying styles to elements based on a containing element's size or other style features, rather than the viewport's. Container queries have the same syntax rules and logical operators as media queries.\ncss\n@container <container-condition># {\n  /* <stylesheet> */\n}\nThere are three types of container queries:\nContainer size queries\nSize queries enable applying styles to elements based on the current\nsize\nof a containing element, including the orientation and\naspect ratio\n. The containing elements need to be explicitly declared as\nsize query containers\n.\nContainer style queries\nStyle queries enable applying styles to elements based on a containing element's style features. Any non-empty element can be a style query container. Currently, the only style feature supported by style queries is CSS\ncustom properties\n. In this case, the query returns true or false depending on the computed value of the containing element's custom properties. When container style queries are fully supported, they will enable you to apply styles to any element's descendants based on any property, declaration, or computed value \u00e2\u0080\u0094 for example if the container is\ndisplay: inline flex\nor has a non-transparent background color.\nContainer scroll-state queries\nScroll-state queries allow you to selectively apply CSS rules to a container's descendants based on scroll-state conditions, such as whether the queried element is partially scrolled or whether the container is snapped to a scroll snap container. The containing elements need to be explicitly declared as\nscroll-state query containers\n.\nIn this guide, we learn the basics of container queries by looking at:\ncontainer size queries\n,\nnaming containers\nto limit their scope, and\nusing the\nstyle()\nfunctional notation within the\n@container\nat rule's\n<container-condition>\nto create\nstyle queries with custom properties\n.\nScroll-state queries are discussed in\nUsing container scroll-state queries\n.\nContainer size queries\nContainer size queries are filtered by a size condition. The associated styles are applied to contained elements if the container element has been declared to be a container and the container condition is true for that element. An element's size container is the nearest ancestor with containment.\nElements are declared as\nsize query containers\nby setting their\ncontainer-type\nproperty (or the\ncontainer\nshorthand) to\nsize\nor\ninline-size\n.\ncss\n@container (orientation: landscape) {\n  /* styles applied to descendants of this size container */\n}\n\n.sizeContainer {\n  container-type: size;\n}\nDeclaring size query containers adds\ncontainment\nto them. This is a performance necessity \u00e2\u0080\u0094 querying the size of every element in the DOM, all the time, would be bad for performance and user experience. Additionally, if a descendant style changed the size of the container element, an infinite loop could occur.\nIn a container size query, the\n<container-condition>\nincludes one or more\n<size-query>\ns. Each size query includes a size feature name, a comparison operator, and a value. The size features that can be queried are limited to\nwidth\n,\nheight\n,\ninline-size\n,\nblock-size\n,\naspect-ratio\n, and\norientation\n. The boolean syntax and logic combining one or more\n<size-query>\ns is the same as for\n@media\nsize feature queries.\ncss\nform {\n  container-type: inline-size;\n}\n\n@container (10em <= width <= 20em) {\n  /* styles */\n}\nThe\n<container-condition>\nin this example contains a single\n<size-query>\n\u00e2\u0080\u0094\n(10em <= width <= 20em)\n. In this case, all\n<form>\nelements are potential matches for any unnamed container query. The styles declared within our container query apply to the descendants of all forms between\n10em\nand\n30em\nwide, inclusive.\nNaming containers\nA\n<container-condition>\ncan include an optional case-sensitive\ncontainer-name\n. A container name makes the container condition more specific \u00e2\u0080\u0094 it is evaluated only against elements that have that name set in the\ncontainer-name\nproperty.\nThe\ncontainer-name\nproperty specifies a list of query\n<container-name>\nvalues that can be used in\n@container\nrules; these are case-sensitive\n<ident>\nvalues. The container names enable targeting any container ancestor of the element. Without a container name, the query matches only the nearest container ancestor.\ncss\n@container [ [ <container-name> ]? <container-query> ]# {\n  /* <stylesheet> */\n}\nAfter you add names to your\n@container\nat rules, you can use the\ncontainer-name\nproperty or the\ncontainer\nshorthand to target specific container elements. Styles inside the named\n@container\nat rules will be applied only to matching elements inside containers with those names set, which satisfy the container queries.\ncss\n@container card (orientation: landscape) {\n  /* styles */\n}\n\n.todo-panel > li {\n  container-type: inline-size;\n  container-name: card;\n}\nIn the above example, the styles within the container query block will apply to the descendants of all\n<li>\nelements with a width that is greater than their height. Note that other elements with\ncontainer-name: card\napplied to them that match the size query will also have these styles applied to their elements' descendants.\ncss\n@container wide (width >= 20em) {\n  /* styles applied to descendants of wide .sizeContainer */\n}\n\n@container narrow (width < 20em) {\n  /* styles applied to descendants of narrow .sizeContainer */\n}\n\n.sizeContainer {\n  container-type: size;\n  container-name: wide narrow;\n}\nIn the above example, the element has two container names,\nwide\nand\nnarrow\n. The descendants of any elements with\nclass=\"sizeContainer\"\nwill get the styles from the\nwide\nor\nnarrow\nquery applied.\nThe default value\ncontainer-type: normal\nprevents the container from being a size container, but it can still be a\nstyle container\n. The default value\ncontainer-name: none\nstates the container has no name, but it does not prevent the element from matching unnamed queries.\nWith container queries, we are not limited to size queries! You can also query a container's style features.\nContainer style queries\nA\ncontainer style query\nis a\n@container\nquery that evaluates computed styles of the container element as defined in one or more\nstyle()\nfunctional notations. The boolean syntax and logic used to combine style features into a style query are the same as in\nCSS feature queries\n. The only difference is the function name \u00e2\u0080\u0094\nstyle()\nwithin a\n<style-feature>\nas opposed to\nsupports()\nwithin a\n<support-condition>\n:\ncss\n@container style(<style-feature>),\n    not style(<style-feature>),\n    style(<style-feature>) and style(<style-feature>),\n    style(<style-feature>) or style(<style-feature>) {\n  /* <stylesheet> */\n}\nThe parameter of each\nstyle()\nfunction is a single\n<style-feature>\n. Per the CSS containment specification, a\n<style-feature>\ncan be a valid CSS\ndeclaration\n, a CSS property, or a\n<custom-property-name>\n. The only style feature currently supported is custom properties, with or without a value. See the\nbrowser compatibility table for\n@container\n.\nIf the\n<style-feature>\nincludes a value, the style query evaluates to true if the computed value of the custom property (or, in the future, the CSS declaration) passed as the\nstyle()\nargument is true for the container being queried. Otherwise, it resolves to false.\nA style feature without a value evaluates to true if the computed value is different from the\ninitial value\nfor the given property.\nIn the future, we'll be able to write style queries like so:\ncss\n@container style(color: green) and style(background-color: transparent),\n    not style(background-color: red),\n    style(--themeBackground),\n    style(--themeColor: blue) or style(--themeColor: purple),\n    (width <= 100vw) and style(max-width: 600px) {\n  /* <stylesheet> */\n}\nThe\nstyle()\nfunctional notation is used to differentiate style queries from size queries. While not yet supported, we will eventually be able to query regular CSS declarations such as\nmax-width: 600px\n. Querying\n@container (max-width: 600px)\nis a size query; containment with\ncontainer-type\n, or the\ncontainer\nshorthand, is needed. That query will return true if the container is 600px or less. That is different from querying\n@container style(max-width: 600px)\n, which is a style query; when supported, this query will return true if the container has a\nmax-width\nvalue of\n600px\n.\nUntil style queries for regular CSS declarations and properties are supported, we are limited to including only custom properties as the\nstyle()\nparameter, with or without a value:\ncss\n@container style(--themeBackground),\n    style(--themeColor: blue) or style(--themeColor: purple) {\n  /* <stylesheet> */\n}\nA few things to note that have already been mentioned but are important to remember:\nAll elements can be style query containers; setting a\ncontainer-type\nis not required. When descendant styles don't impact the computed styles of an ancestor, containment is not needed.\nA\n<container-condition>\ncan include both style and size features. If including size features in your query, make sure your container elements have a\ncontainer-type\nof\nsize\nor\ninline-size\nset.\nIf you don't want an element to be considered as a container, ever, give it a\ncontainer-name\nthat will not be used. Setting\ncontainer-name: none\nremoves any query names associated with a container; it does not prevent the element from being a style container.\nAt the time of this writing (February 2024), container style queries only work with CSS custom property values in the\nstyle()\nquery.\nNow, let's dive in and take a look at the different\n<style-feature>\ntypes.\nStyle queries for custom properties\nStyle queries for custom properties allow you to query the\ncustom properties\n, also called \"CSS variables\", of a parent element. They are included within a\n<style-query>\njust as you would include any regular CSS property within a feature query: either with or without a value.\nStandalone custom property queries\nThe\n<style-query>\nparameter of the\nstyle()\nfunctional notation can include just a CSS variable name; a custom property with no value. When no value is included, the query will return false if the value is the same as the value of the\ninitial-value\ndescriptor within the\n@property\nat-rule, if there is one. The style query will return true and match all elements that have a custom property value that differs from the\ninitial-value\nor for all elements that have a custom property of any value if the custom property was declared without being registered.\nUnregistered custom properties\nWhen CSS variables are introduced via a CSS custom property value assignment, valueless custom property queries always return true.\ncss\n:root {\n  --theme-color: rebeccapurple;\n}\n\n@container style(--theme-color) {\n  /* <stylesheet> */\n}\nIn this example, the container query matches the element on which the\n--theme-color\nproperty was declared and all of its descendants. As the CSS variable\n--theme-color\nwas declared on the\n:root\n, the style query\nstyle(--theme-color)\nwill be true for every element within that\nDOM\nnode.\nRegistered properties\nThe behavior of registered custom properties is different. When explicitly defined with the\n@property\nCSS at-rule or via JavaScript with\nCSS.registerProperty()\n, the style query\nstyle(--theme-color)\nonly returns true for elements if the element's computed value for\n--theme-color\nis different from the\ninitial-value\nset in the original definition of that custom property.\ncss\n@property --theme-color {\n  initial-value: rebeccapurple;\n  inherits: true;\n}\n\n:root {\n  --theme-color: rebeccapurple;\n}\n\nmain {\n  --theme-color: blue;\n}\n\n@container style(--theme-color) {\n  /* <stylesheet> */\n}\nIn this example, the\n:root\nelement does NOT match the style query because the value of the custom property is the same as the\ninitial-value\nvalue. The custom property value for the element (and all the elements inheriting the value) is still\nrebeccapurple\n. Only elements that differ from the initial value, in this case, the\n<main>\nand its descendants that inherit that changed value, are a match.\nCustom property with a value\nIf a style query includes a value for the custom property, the element's computed value for that property must be an exact match, with equivalent values only being a match if the custom property was defined with a\n@property\nat rule (or a\nCSS.registerProperty()\nmethod call) containing a\nsyntax\ndescriptor.\ncss\n@container style(--accent-color: blue) {\n  /* <stylesheet> */\n}\nThis container style query matches any element that has\nblue\nas the\ncomputed value\nof the\n--accent-color\ncustom property.\nIn this case, other color values equivalent to sRGB\nblue\n(such as the hexadecimal code\n#0000ff\n) will match only if the\n--accent-color\nproperty was defined as a color with\n@property\nor\nCSS.registerProperty()\n, for example:\ncss\n@property --accent-color {\n  syntax: \"<color>\";\n  inherits: true;\n  initial-value: #0000ff;\n}\nIn this case, if the value of\n--accent-color\nwere set to\nblue\n,\n#00f\n,\n#0000ff\n,\nrgb(0 0 255 / 1)\n, or\nrgb(0% 0% 100%)\nit would return true for\n@container style(--accent-color: blue)\n.\nExample\nIn this example, we have a\n<fieldset>\nwith four radio buttons. The fourth option includes a text\n<input>\nfor entering a custom color.\nhtml\n<form>\n  <fieldset>\n    <legend>Change the value of <code>--theme</code></legend>\n    <ol>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"red\" id=\"red\" />\n        <label for=\"red\">--theme: red;</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"green\" id=\"green\" />\n        <label for=\"green\">--theme: green</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"blue\" id=\"blue\" />\n        <label for=\"blue\">--theme: blue</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"currentColor\" id=\"other\" />\n        <label for=\"other\">Other</label>\n        <label for=\"color\">color:</label>\n        <input\n          text=\"checkbox\"\n          name=\"selection-value\"\n          value=\"currentColor\"\n          id=\"color\" />\n      </li>\n    </ol>\n  </fieldset>\n  <output>I change colors</output>\n</form>\nJavaScript updates the value of the CSS\n--theme\nvariable on the\n<body>\nelement, which is an ancestor of the\n<fieldset>\nand\n<output>\nelements, whenever a radio button is selected. When the text\n<input>\nis updated, the\nvalue\nof the\nother\nradio button is updated only if the\nother\nradio button is checked, which in turn updates the value of\n--theme\n.\njs\nconst radios = document.querySelectorAll('input[name=\"selection\"]');\nconst body = document.querySelector(\"body\");\nconst other = document.getElementById(\"other\");\nconst color = document.getElementById(\"color\");\n\nfor (const radio of radios) {\n  radio.addEventListener(\"change\", (e) => {\n    body.style.setProperty(\"--theme\", e.target.value);\n  });\n}\ncolor.addEventListener(\"input\", (e) => {\n  other.style.setProperty(\"value\", e.target.value);\n  if (other.checked) {\n    body.style.setProperty(\"--theme\", e.target.value);\n  }\n});\nWe use the\n@property\nat-rule to define a CSS variable\n--theme\nto be a\n<color>\nvalue and set the\ninitial-value\nto\nred\n, ensuring equivalent colors are a match regardless of what syntax is used (for example,\nred\nis equal to\nrgb(255 0 0)\n,\n#ff0000\n, and\n#f00\n).\ncss\n@property --theme {\n  syntax: \"<color>\";\n  inherits: true;\n  initial-value: red;\n}\noutput {\n  padding: 3px 5px;\n  margin-top: 5px;\n}\nThe first style feature query is a custom property with no value. This query type returns true when the computed value for the custom property value is different from the\ninitial-value\nfor that property. In this case, it will be true when the value of\n--theme\nis any value other than any syntax equivalent value of\nred\n(such as\n#ff0000\n). When true, the\n<output>\nwill have a 5px dotted outline. The outline color is the current value of\n--theme\n. The default text\ncolor\nis grey.\ncss\n@container style(--theme) {\n  output {\n    outline: 5px dotted var(--theme);\n    color: #777777;\n  }\n}\nThe second and third style queries include values for the custom property. These will match if the container's\n--theme\nvalue is an equivalent color to the value listed, even if that value is the same as the\ninitial-value\n. The first query matches elements whose\n--theme\nvalue is equivalent to\nred\n,\nblue\n, or\ngreen\n. When it is, the\ncolor\nwill be the color current value of\n--theme\n(in the case of\nblue\nand\ngreen\n, overriding the grey set in the first style query).\nThe second style query states that when\n--theme\nis equivalent to\nred\n, the\n<output>\n's contents will also be bold. We did this to better demonstrate that the container query is a match.\ncss\n@container style(--theme: green) or style(--theme: blue) or style(--theme: red) {\n  output {\n    color: var(--theme);\n  }\n}\n\n@container style(--theme: red) {\n  output {\n    font-weight: bold;\n  }\n}\nTry entering different color values into the text box. You may notice that values that are sRGB equivalents of\nred\nwill make the\n<output>\nred \u00e2\u0080\u0094 as it matches\nstyle(--theme: red)\n\u00e2\u0080\u0094 while removing the outline, because\nstyle(--theme)\nreturns false if the element's value for\n--theme\nis the same as the initial value for\n--theme\ndefined by the\n@property\nat-rule. Any non-red sRGB valid color value, including\ncurrentColor\nor\nhsl(180 100% 50%)\n, etc., makes the first style query return true; they are values that are different from the\ninitial-value\n.\nBecause we set\nsyntax: \"<color>\";\n, the CSS variable can only be assigned valid\n<color>\nvalues. Valid values for the\ncolor\nproperty that aren't value\n<color>\nvalues, such as\nunset\nor\ninherit\n, are\ninvalid\nfor this custom property, and will be ignored.\nIf you enter\nunset\nor\ngibberish\n, the JavaScript updates the\nstyle\non the\n<body>\nto\n--theme: unset\nor\n--theme: gibberish\n. Neither of these are colors. Both are invalid and ignored. This means the initial value is inherited and unchanged, with\nstyle(--theme)\nreturning false and\nstyle(--theme: red)\nreturning true.\nNote:\nWhen declaring custom properties, consider using\n@property\nwith the\nsyntax\ndescriptor so the browser can properly compare computed values.\nNested queries\nContainer queries can be nested within other container queries. The styles defined inside multiple nested container queries are applied when all of the wrapping container queries are true.\ncss\n@container style(--theme: red) {\n  output {\n    outline: 1px dotted;\n  }\n  @container style(--theme: purple) {\n    output {\n      outline: 5px dotted;\n    }\n  }\n}\nIn this case, the\n<output>\nwill have a 5px dotted border if it's nested in a container where\n--theme: purple\nis set, and that container is nested within a container whose\n--theme\nvalue is\nred\n.\nStyle query CSS declarations and properties\nNot yet supported in any browser, the\nstyle()\nfunctional notation can include regular CSS declarations including CSS properties and property value pairs.\ncss\n@container style(font-weight: bold) {\n  b,\n  strong {\n    background: yellow;\n  }\n}\nWhen supported, this basic example will make the background color of any\n<b>\nand\n<strong>\nelements yellow when the parent is already\nbold\n.\nThe matching is done against the computed value of the parent container; if the parent's computed\nfont-weight\nis\nbold\n(not\nbolder\nor\n900\n), there is a match. Just as with custom property container style queries, we did not have to define any elements as style containers as all elements are style containers by default. As long as an element doesn't have a\ncontainer-name\nset, if it has\nfont-weight: bold\nset or inherited, it will match.\nStyle features that query a shorthand property will be true if the computed values match for each of its longhand properties, and false otherwise. For example,\n@container style(\nborder\n: 2px solid red)\nwill resolve to true if all 12 longhand properties (\nborder-bottom-style\n, etc.) that make up that shorthand are set to the same equivalent values.\nThe global CSS values\nrevert\nand\nrevert-layer\nare invalid as values in a\n<style-feature>\nand cause the container style query to be false.\nDo not apply the styles you are querying in the style query to the element you are styling with that query as this may cause an infinite loop.\nIt is expected that style queries will also accept properties in a boolean context. The style query will return false if the value of the property is the initial value for that property (if it has not been changed), and true otherwise.\ncss\n@container style(font-weight) {\n}\nThe above example will return true for any element that has a value for\nfont-weight\nthat differs from its initial value. User-agent stylesheets set\nfont-weight: bold\nfor\nheading\nand\n<th>\nelements, for example. Some browsers set\n<strong>\nand\n<b>\nto\nbold\n, others to\nbolder\n.\n<optgroup>\nalso sometimes has a\nfont-weight\nother than\nnormal\nset by the user agent. As long as the element's\nfont-weight\nis not the default value for that user-agent, the style query will return true.\nThese features are not yet supported in any browser.\nSee also\nMedia queries\nCSS\n@container\nat-rule\nCSS\ncontain\nproperty\nCSS\ncontainer\nshorthand property\nCSS\ncontainer-name\nproperty\nUsing container scroll-state queries\nUnderstanding\naspect-ratio\nGetting Started with Style Queries\n(2022)\nStyle queries\nvia una.im (2022)\nHelp improve MDN\nLearn how to contribute\nThis page was last modified on\nDec 16, 2025\nby\nMDN contributors\n.\nView this page on GitHub\n\u00e2\u0080\u00a2\nReport a problem with this content",
  "content_markdown": "# Using container size and style queries\n\n[Container queries](/en-US/docs/Web/CSS/Guides/Containment/Container_queries) enable you to apply styles to elements nested within a specific container based on the features of that container. The query returns true or false depending on whether the query condition is true for the container.\n\nContainer queries are similar to [media queries](/en-US/docs/Web/CSS/Guides/Media_queries). The [`@media`](/en-US/docs/Web/CSS/Reference/At-rules/@media) at-rule enables applying styles to elements based on viewport size or other device characteristics. Similarly, the [`@container`](/en-US/docs/Web/CSS/Reference/At-rules/@container) at-rule enables applying styles to elements based on a containing element's size or other style features, rather than the viewport's. Container queries have the same syntax rules and logical operators as media queries.\n\ncss\n\n```\n@container <container-condition># {\n  /* <stylesheet> */\n}\n```\n\nThere are three types of container queries:\n\n[**Container size queries**](#container_size_queries_2)\n:   Size queries enable applying styles to elements based on the current [size](/en-US/docs/Web/CSS/Reference/At-rules/@container#descriptors) of a containing element, including the orientation and [aspect ratio](/en-US/docs/Glossary/Aspect_ratio). The containing elements need to be explicitly declared as *size query containers*.\n\n[**Container style queries**](#container_style_queries_2)\n:   Style queries enable applying styles to elements based on a containing element's style features. Any non-empty element can be a style query container. Currently, the only style feature supported by style queries is CSS [custom properties](/en-US/docs/Web/CSS/Guides/Cascading_variables/Using_custom_properties). In this case, the query returns true or false depending on the computed value of the containing element's custom properties. When container style queries are fully supported, they will enable you to apply styles to any element's descendants based on any property, declaration, or computed value \u00e2\u0080\u0094 for example if the container is `display: inline flex` or has a non-transparent background color.\n\n**[Container scroll-state queries](/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries)**\n:   Scroll-state queries allow you to selectively apply CSS rules to a container's descendants based on scroll-state conditions, such as whether the queried element is partially scrolled or whether the container is snapped to a scroll snap container. The containing elements need to be explicitly declared as *scroll-state query containers*.\n\nIn this guide, we learn the basics of container queries by looking at:\n\n1. [container size queries](#container_size_queries_2),\n2. [naming containers](#naming_containers) to limit their scope, and\n3. using the `style()` functional notation within the [`@container`](/en-US/docs/Web/CSS/Reference/At-rules/@container) at rule's `<container-condition>` to create [style queries with custom properties](#style_queries_for_custom_properties).\n\nScroll-state queries are discussed in [Using container scroll-state queries](/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries).\n\n## [Container size queries](#container_size_queries)\n\nContainer size queries are filtered by a size condition. The associated styles are applied to contained elements if the container element has been declared to be a container and the container condition is true for that element. An element's size container is the nearest ancestor with containment.\n\nElements are declared as *size query containers* by setting their [`container-type`](/en-US/docs/Web/CSS/Reference/Properties/container-type) property (or the [`container`](/en-US/docs/Web/CSS/Reference/Properties/container) shorthand) to `size` or `inline-size`.\n\ncss\n\n```\n@container (orientation: landscape) {\n  /* styles applied to descendants of this size container */\n}\n\n.sizeContainer {\n  container-type: size;\n}\n```\n\nDeclaring size query containers adds [containment](/en-US/docs/Web/CSS/Guides/Containment/Using) to them. This is a performance necessity \u00e2\u0080\u0094 querying the size of every element in the DOM, all the time, would be bad for performance and user experience. Additionally, if a descendant style changed the size of the container element, an infinite loop could occur.\n\nIn a container size query, the `<container-condition>` includes one or more `<size-query>`s. Each size query includes a size feature name, a comparison operator, and a value. The size features that can be queried are limited to `width`, `height`, `inline-size`, `block-size`, `aspect-ratio`, and `orientation`. The boolean syntax and logic combining one or more `<size-query>`s is the same as for [`@media`](/en-US/docs/Web/CSS/Reference/At-rules/@media) size feature queries.\n\ncss\n\n```\nform {\n  container-type: inline-size;\n}\n\n@container (10em <= width <= 20em) {\n  /* styles */\n}\n```\n\nThe `<container-condition>` in this example contains a single `<size-query>` \u00e2\u0080\u0094 `(10em <= width <= 20em)`. In this case, all [`<form>`](/en-US/docs/Web/HTML/Reference/Elements/form) elements are potential matches for any unnamed container query. The styles declared within our container query apply to the descendants of all forms between `10em` and `30em` wide, inclusive.\n\n## [Naming containers](#naming_containers)\n\nA `<container-condition>` can include an optional case-sensitive [`container-name`](/en-US/docs/Web/CSS/Reference/Properties/container-name). A container name makes the container condition more specific \u00e2\u0080\u0094 it is evaluated only against elements that have that name set in the `container-name` property.\n\nThe [`container-name`](/en-US/docs/Web/CSS/Reference/Properties/container-name) property specifies a list of query `<container-name>` values that can be used in `@container` rules; these are case-sensitive [`<ident>`](/en-US/docs/Web/CSS/Reference/Values/ident) values. The container names enable targeting any container ancestor of the element. Without a container name, the query matches only the nearest container ancestor.\n\ncss\n\n```\n@container [ [ <container-name> ]? <container-query> ]# {\n  /* <stylesheet> */\n}\n```\n\nAfter you add names to your `@container` at rules, you can use the [`container-name`](/en-US/docs/Web/CSS/Reference/Properties/container-name) property or the [`container`](/en-US/docs/Web/CSS/Reference/Properties/container) shorthand to target specific container elements. Styles inside the named `@container` at rules will be applied only to matching elements inside containers with those names set, which satisfy the container queries.\n\ncss\n\n```\n@container card (orientation: landscape) {\n  /* styles */\n}\n\n.todo-panel > li {\n  container-type: inline-size;\n  container-name: card;\n}\n```\n\nIn the above example, the styles within the container query block will apply to the descendants of all [`<li>`](/en-US/docs/Web/HTML/Reference/Elements/li) elements with a width that is greater than their height. Note that other elements with `container-name: card` applied to them that match the size query will also have these styles applied to their elements' descendants.\n\ncss\n\n```\n@container wide (width >= 20em) {\n  /* styles applied to descendants of wide .sizeContainer */\n}\n\n@container narrow (width < 20em) {\n  /* styles applied to descendants of narrow .sizeContainer */\n}\n\n.sizeContainer {\n  container-type: size;\n  container-name: wide narrow;\n}\n```\n\nIn the above example, the element has two container names, `wide` and `narrow`. The descendants of any elements with `class=\"sizeContainer\"` will get the styles from the `wide` or `narrow` query applied.\n\nThe default value `container-type: normal` prevents the container from being a size container, but it can still be a [style container](#container_style_queries). The default value `container-name: none` states the container has no name, but it does not prevent the element from matching unnamed queries.\n\nWith container queries, we are not limited to size queries! You can also query a container's style features.\n\n## [Container style queries](#container_style_queries)\n\nA *container style query* is a `@container` query that evaluates computed styles of the container element as defined in one or more `style()` functional notations. The boolean syntax and logic used to combine style features into a style query are the same as in [CSS feature queries](/en-US/docs/Web/CSS/Guides/Conditional_rules/Using_feature_queries). The only difference is the function name \u00e2\u0080\u0094 `style()` within a `<style-feature>` as opposed to `supports()` within a `<support-condition>`:\n\ncss\n\n```\n@container style(<style-feature>),\n    not style(<style-feature>),\n    style(<style-feature>) and style(<style-feature>),\n    style(<style-feature>) or style(<style-feature>) {\n  /* <stylesheet> */\n}\n```\n\nThe parameter of each `style()` function is a single **`<style-feature>`**. Per the CSS containment specification, a `<style-feature>` can be a valid CSS [declaration](/en-US/docs/Web/CSS/Guides/Syntax/Introduction#css_declarations), a CSS property, or a [`<custom-property-name>`](/en-US/docs/Web/CSS/Reference/Values/var#values). The only style feature currently supported is custom properties, with or without a value. See the [browser compatibility table for `@container`](/en-US/docs/Web/CSS/Reference/At-rules/@container#browser_compatibility).\n\nIf the `<style-feature>` includes a value, the style query evaluates to true if the computed value of the custom property (or, in the future, the CSS declaration) passed as the `style()` argument is true for the container being queried. Otherwise, it resolves to false.\nA style feature without a value evaluates to true if the computed value is different from the [initial value](#registered_properties) for the given property.\n\nIn the future, we'll be able to write style queries like so:\n\ncss\n\n```\n@container style(color: green) and style(background-color: transparent),\n    not style(background-color: red),\n    style(--themeBackground),\n    style(--themeColor: blue) or style(--themeColor: purple),\n    (width <= 100vw) and style(max-width: 600px) {\n  /* <stylesheet> */\n}\n```\n\nThe `style()` functional notation is used to differentiate style queries from size queries. While not yet supported, we will eventually be able to query regular CSS declarations such as `max-width: 600px`. Querying `@container (max-width: 600px)` is a size query; containment with [`container-type`](/en-US/docs/Web/CSS/Reference/Properties/container-type), or the [`container`](/en-US/docs/Web/CSS/Reference/Properties/container) shorthand, is needed. That query will return true if the container is 600px or less. That is different from querying `@container style(max-width: 600px)`, which is a style query; when supported, this query will return true if the container has a [`max-width`](/en-US/docs/Web/CSS/Reference/Properties/max-width) value of `600px`.\n\nUntil style queries for regular CSS declarations and properties are supported, we are limited to including only custom properties as the `style()` parameter, with or without a value:\n\ncss\n\n```\n@container style(--themeBackground),\n    style(--themeColor: blue) or style(--themeColor: purple) {\n  /* <stylesheet> */\n}\n```\n\nA few things to note that have already been mentioned but are important to remember:\n\n- All elements can be style query containers; setting a `container-type` is not required. When descendant styles don't impact the computed styles of an ancestor, containment is not needed.\n- A `<container-condition>` can include both style and size features. If including size features in your query, make sure your container elements have a `container-type` of `size` or `inline-size` set.\n- If you don't want an element to be considered as a container, ever, give it a `container-name` that will not be used. Setting `container-name: none` removes any query names associated with a container; it does not prevent the element from being a style container.\n- At the time of this writing (February 2024), container style queries only work with CSS custom property values in the `style()` query.\n\nNow, let's dive in and take a look at the different `<style-feature>` types.\n\n### [Style queries for custom properties](#style_queries_for_custom_properties)\n\nStyle queries for custom properties allow you to query the [custom properties](/en-US/docs/Web/CSS/Guides/Cascading_variables/Using_custom_properties), also called \"CSS variables\", of a parent element. They are included within a `<style-query>` just as you would include any regular CSS property within a feature query: either with or without a value.\n\n#### Standalone custom property queries\n\nThe `<style-query>` parameter of the `style()` functional notation can include just a CSS variable name; a custom property with no value. When no value is included, the query will return false if the value is the same as the value of the `initial-value` descriptor within the `@property` at-rule, if there is one. The style query will return true and match all elements that have a custom property value that differs from the `initial-value` or for all elements that have a custom property of any value if the custom property was declared without being registered.\n\n##### Unregistered custom properties\n\nWhen CSS variables are introduced via a CSS custom property value assignment, valueless custom property queries always return true.\n\ncss\n\n```\n:root {\n  --theme-color: rebeccapurple;\n}\n\n@container style(--theme-color) {\n  /* <stylesheet> */\n}\n```\n\nIn this example, the container query matches the element on which the `--theme-color` property was declared and all of its descendants. As the CSS variable `--theme-color` was declared on the [`:root`](/en-US/docs/Web/CSS/Reference/Selectors/:root), the style query `style(--theme-color)` will be true for every element within that [DOM](/en-US/docs/Glossary/DOM) node.\n\n##### Registered properties\n\nThe behavior of registered custom properties is different. When explicitly defined with the [`@property`](/en-US/docs/Web/CSS/Reference/At-rules/@property) CSS at-rule or via JavaScript with [`CSS.registerProperty()`](/en-US/docs/Web/API/CSS/registerProperty_static \"CSS.registerProperty()\"), the style query `style(--theme-color)` only returns true for elements if the element's computed value for `--theme-color` is different from the [`initial-value`](/en-US/docs/Web/CSS/Reference/At-rules/@property/initial-value) set in the original definition of that custom property.\n\ncss\n\n```\n@property --theme-color {\n  initial-value: rebeccapurple;\n  inherits: true;\n}\n\n:root {\n  --theme-color: rebeccapurple;\n}\n\nmain {\n  --theme-color: blue;\n}\n\n@container style(--theme-color) {\n  /* <stylesheet> */\n}\n```\n\nIn this example, the `:root` element does NOT match the style query because the value of the custom property is the same as the `initial-value` value. The custom property value for the element (and all the elements inheriting the value) is still `rebeccapurple`. Only elements that differ from the initial value, in this case, the [`<main>`](/en-US/docs/Web/HTML/Reference/Elements/main) and its descendants that inherit that changed value, are a match.\n\n#### Custom property with a value\n\nIf a style query includes a value for the custom property, the element's computed value for that property must be an exact match, with equivalent values only being a match if the custom property was defined with a [`@property`](/en-US/docs/Web/CSS/Reference/At-rules/@property) at rule (or a [`CSS.registerProperty()`](/en-US/docs/Web/API/CSS/registerProperty_static \"CSS.registerProperty()\") method call) containing a `syntax` descriptor.\n\ncss\n\n```\n@container style(--accent-color: blue) {\n  /* <stylesheet> */\n}\n```\n\nThis container style query matches any element that has `blue` as the [computed value](/en-US/docs/Web/CSS/Guides/Cascade/Property_value_processing#computed_value) of the `--accent-color` custom property.\n\nIn this case, other color values equivalent to sRGB `blue` (such as the hexadecimal code `#0000ff`) will match only if the `--accent-color` property was defined as a color with `@property` or `CSS.registerProperty()`, for example:\n\ncss\n\n```\n@property --accent-color {\n  syntax: \"<color>\";\n  inherits: true;\n  initial-value: #0000ff;\n}\n```\n\nIn this case, if the value of `--accent-color` were set to `blue`, `#00f`, `#0000ff`, `rgb(0 0 255 / 1)`, or `rgb(0% 0% 100%)` it would return true for `@container style(--accent-color: blue)`.\n\n##### Example\n\nIn this example, we have a [`<fieldset>`](/en-US/docs/Web/HTML/Reference/Elements/fieldset) with four radio buttons. The fourth option includes a text [`<input>`](/en-US/docs/Web/HTML/Reference/Elements/input) for entering a custom color.\n\nhtml\n\n```\n<form>\n  <fieldset>\n    <legend>Change the value of <code>--theme</code></legend>\n    <ol>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"red\" id=\"red\" />\n        <label for=\"red\">--theme: red;</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"green\" id=\"green\" />\n        <label for=\"green\">--theme: green</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"blue\" id=\"blue\" />\n        <label for=\"blue\">--theme: blue</label>\n      </li>\n      <li>\n        <input type=\"radio\" name=\"selection\" value=\"currentColor\" id=\"other\" />\n        <label for=\"other\">Other</label>\n        <label for=\"color\">color:</label>\n        <input\n          text=\"checkbox\"\n          name=\"selection-value\"\n          value=\"currentColor\"\n          id=\"color\" />\n      </li>\n    </ol>\n  </fieldset>\n  <output>I change colors</output>\n</form>\n```\n\nJavaScript updates the value of the CSS `--theme` variable on the [`<body>`](/en-US/docs/Web/HTML/Reference/Elements/body) element, which is an ancestor of the [`<fieldset>`](/en-US/docs/Web/HTML/Reference/Elements/fieldset) and [`<output>`](/en-US/docs/Web/HTML/Reference/Elements/output) elements, whenever a radio button is selected. When the text `<input>` is updated, the [`value`](/en-US/docs/Web/API/HTMLInputElement/value \"value\") of the `other` radio button is updated only if the `other` radio button is checked, which in turn updates the value of `--theme`.\n\njs\n\n```\nconst radios = document.querySelectorAll('input[name=\"selection\"]');\nconst body = document.querySelector(\"body\");\nconst other = document.getElementById(\"other\");\nconst color = document.getElementById(\"color\");\n\nfor (const radio of radios) {\n  radio.addEventListener(\"change\", (e) => {\n    body.style.setProperty(\"--theme\", e.target.value);\n  });\n}\ncolor.addEventListener(\"input\", (e) => {\n  other.style.setProperty(\"value\", e.target.value);\n  if (other.checked) {\n    body.style.setProperty(\"--theme\", e.target.value);\n  }\n});\n```\n\nWe use the `@property` at-rule to define a CSS variable `--theme` to be a [`<color>`](/en-US/docs/Web/CSS/Reference/Values/color_value) value and set the `initial-value` to `red`, ensuring equivalent colors are a match regardless of what syntax is used (for example, `red` is equal to `rgb(255 0 0)`, `#ff0000`, and `#f00`).\n\ncss\n\n```\n@property --theme {\n  syntax: \"<color>\";\n  inherits: true;\n  initial-value: red;\n}\n```\n\n```\noutput {\n  padding: 3px 5px;\n  margin-top: 5px;\n}\n```\n\nThe first style feature query is a custom property with no value. This query type returns true when the computed value for the custom property value is different from the `initial-value` for that property. In this case, it will be true when the value of `--theme` is any value other than any syntax equivalent value of `red` (such as `#ff0000`). When true, the [`<output>`](/en-US/docs/Web/HTML/Reference/Elements/output) will have a 5px dotted outline. The outline color is the current value of `--theme`. The default text [`color`](/en-US/docs/Web/CSS/Reference/Properties/color) is grey.\n\ncss\n\n```\n@container style(--theme) {\n  output {\n    outline: 5px dotted var(--theme);\n    color: #777777;\n  }\n}\n```\n\nThe second and third style queries include values for the custom property. These will match if the container's `--theme` value is an equivalent color to the value listed, even if that value is the same as the `initial-value`. The first query matches elements whose `--theme` value is equivalent to `red`, `blue`, or `green`. When it is, the [`color`](/en-US/docs/Web/CSS/Reference/Properties/color) will be the color current value of `--theme` (in the case of `blue` and `green`, overriding the grey set in the first style query).\n\nThe second style query states that when `--theme` is equivalent to `red`, the `<output>`'s contents will also be bold. We did this to better demonstrate that the container query is a match.\n\ncss\n\n```\n@container style(--theme: green) or style(--theme: blue) or style(--theme: red) {\n  output {\n    color: var(--theme);\n  }\n}\n\n@container style(--theme: red) {\n  output {\n    font-weight: bold;\n  }\n}\n```\n\nTry entering different color values into the text box. You may notice that values that are sRGB equivalents of `red` will make the `<output>` red \u00e2\u0080\u0094 as it matches `style(--theme: red)` \u00e2\u0080\u0094 while removing the outline, because `style(--theme)` returns false if the element's value for `--theme` is the same as the initial value for `--theme` defined by the `@property` at-rule. Any non-red sRGB valid color value, including `currentColor` or `hsl(180 100% 50%)`, etc., makes the first style query return true; they are values that are different from the `initial-value`.\n\nBecause we set `syntax: \"<color>\";`, the CSS variable can only be assigned valid `<color>` values. Valid values for the [`color`](/en-US/docs/Web/CSS/Reference/Properties/color) property that aren't value `<color>` values, such as `unset` or `inherit`, are [invalid](/en-US/docs/Web/CSS/Guides/Syntax/Error_handling) for this custom property, and will be ignored.\n\nIf you enter `unset` or `gibberish`, the JavaScript updates the `style` on the [`<body>`](/en-US/docs/Web/HTML/Reference/Elements/body) to `--theme: unset` or `--theme: gibberish`. Neither of these are colors. Both are invalid and ignored. This means the initial value is inherited and unchanged, with `style(--theme)` returning false and `style(--theme: red)` returning true.\n\n**Note:**\nWhen declaring custom properties, consider using `@property` with the [`syntax`](/en-US/docs/Web/CSS/Reference/At-rules/@property/syntax) descriptor so the browser can properly compare computed values.\n\n### [Nested queries](#nested_queries)\n\nContainer queries can be nested within other container queries. The styles defined inside multiple nested container queries are applied when all of the wrapping container queries are true.\n\ncss\n\n```\n@container style(--theme: red) {\n  output {\n    outline: 1px dotted;\n  }\n  @container style(--theme: purple) {\n    output {\n      outline: 5px dotted;\n    }\n  }\n}\n```\n\nIn this case, the `<output>` will have a 5px dotted border if it's nested in a container where `--theme: purple` is set, and that container is nested within a container whose `--theme` value is `red`.\n\n### [Style query CSS declarations and properties](#style_query_css_declarations_and_properties)\n\nNot yet supported in any browser, the `style()` functional notation can include regular CSS declarations including CSS properties and property value pairs.\n\ncss\n\n```\n@container style(font-weight: bold) {\n  b,\n  strong {\n    background: yellow;\n  }\n}\n```\n\nWhen supported, this basic example will make the background color of any [`<b>`](/en-US/docs/Web/HTML/Reference/Elements/b) and [`<strong>`](/en-US/docs/Web/HTML/Reference/Elements/strong) elements yellow when the parent is already `bold`.\n\nThe matching is done against the computed value of the parent container; if the parent's computed [`font-weight`](/en-US/docs/Web/CSS/Reference/Properties/font-weight) is `bold` (not `bolder` or `900`), there is a match. Just as with custom property container style queries, we did not have to define any elements as style containers as all elements are style containers by default. As long as an element doesn't have a `container-name` set, if it has `font-weight: bold` set or inherited, it will match.\n\nStyle features that query a shorthand property will be true if the computed values match for each of its longhand properties, and false otherwise. For example, `@container style(border: 2px solid red)` will resolve to true if all 12 longhand properties ([`border-bottom-style`](/en-US/docs/Web/CSS/Reference/Properties/border-bottom-style), etc.) that make up that shorthand are set to the same equivalent values.\n\nThe global CSS values `revert` and `revert-layer` are invalid as values in a `<style-feature>` and cause the container style query to be false.\n\nDo not apply the styles you are querying in the style query to the element you are styling with that query as this may cause an infinite loop.\n\nIt is expected that style queries will also accept properties in a boolean context. The style query will return false if the value of the property is the initial value for that property (if it has not been changed), and true otherwise.\n\ncss\n\n```\n@container style(font-weight) {\n}\n```\n\nThe above example will return true for any element that has a value for `font-weight` that differs from its initial value. User-agent stylesheets set `font-weight: bold` for [heading](/en-US/docs/Web/HTML/Reference/Elements/Heading_Elements) and [`<th>`](/en-US/docs/Web/HTML/Reference/Elements/th) elements, for example. Some browsers set [`<strong>`](/en-US/docs/Web/HTML/Reference/Elements/strong) and [`<b>`](/en-US/docs/Web/HTML/Reference/Elements/b) to `bold`, others to `bolder`. [`<optgroup>`](/en-US/docs/Web/HTML/Reference/Elements/optgroup) also sometimes has a `font-weight` other than `normal` set by the user agent. As long as the element's `font-weight` is not the default value for that user-agent, the style query will return true.\n\nThese features are not yet supported in any browser.\n\n## [See also](#see_also)\n\n- [Media queries](/en-US/docs/Web/CSS/Guides/Media_queries)\n- CSS [`@container`](/en-US/docs/Web/CSS/Reference/At-rules/@container) at-rule\n- CSS [`contain`](/en-US/docs/Web/CSS/Reference/Properties/contain) property\n- CSS [`container`](/en-US/docs/Web/CSS/Reference/Properties/container) shorthand property\n- CSS [`container-name`](/en-US/docs/Web/CSS/Reference/Properties/container-name) property\n- [Using container scroll-state queries](/en-US/docs/Web/CSS/Guides/Conditional_rules/Container_scroll-state_queries)\n- [Understanding `aspect-ratio`](/en-US/docs/Web/CSS/Guides/Box_sizing/Aspect_ratios)\n- [Getting Started with Style Queries](https://developer.chrome.com/docs/css-ui/style-queries) (2022)\n- [Style queries](https://una.im/style-queries/) via una.im (2022)\n\n## Help improve MDN\n\nWas this page helpful to you?\n\nYes\n\nNo\n\n[Learn how to contribute](/en-US/docs/MDN/Community/Getting_started)\n\nThis page was last modified on Dec 16, 2025 by [MDN contributors](/en-US/docs/Web/CSS/Guides/Containment/Container_size_and_style_queries/contributors.txt).\n\n[View this page on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/css/guides/containment/container_size_and_style_queries/index.md?plain=1 \"Folder: en-us/web/css/guides/containment/container_size_and_style_queries (Opens in a new tab)\") \u00e2\u0080\u00a2 [Report a problem with this content](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FGuides%2FContainment%2FContainer_size_and_style_queries&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fweb%2Fcss%2Fguides%2Fcontainment%2Fcontainer_size_and_style_queries%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FCSS%2FGuides%2FContainment%2FContainer_size_and_style_queries%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fcss%2Fguides%2Fcontainment%2Fcontainer_size_and_style_queries%2Findex.md%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F33094d735e90b4dcae5733331b79c51fee997410%0A*+Document+last+modified%3A+2025-12-16T15%3A14%3A26.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\")",
  "tags": [
    "mdn",
    "css",
    "reference",
    "layout"
  ],
  "extracted_at": "2026-02-03T12:45:20.881252+00:00",
  "content_length": 21837,
  "content_hash": "f7269a705b48d7c0"
}