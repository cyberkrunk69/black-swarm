{
  "id": "css-tricks__a-complete-guide-to-css-media-queries_",
  "source_id": "css-tricks",
  "source_name": "CSS-Tricks Guides",
  "category": "css_styling",
  "url": "https://css-tricks.com/a-complete-guide-to-css-media-queries/",
  "title": "CSS Media Queries Guide | CSS-Tricks",
  "content": "CSS Media queries are a way to target browser by certain characteristics, features, and  user preferences, then apply styles or run other code based on those things. Perhaps the most common media queries in the world are those that target particular viewport ranges and apply custom styles, which birthed the whole idea of responsive design.\n/* When the browser is at least 600px and above */\n@media screen and (min-width: 600px) {\n  .element {\n    /* Apply some styles */\n  }\n}\nThere are lots of other things we can target beside viewport width. That might be screen resolution, device orientation, operating system preference, or even more among a whole bevy of things we can query and use to style content.\nLooking for a quick list of media queries based on the viewports of standard devices, like phones, tablets and laptops?\nCheck out our collection of snippets.\nUsing media queries\nMedia queries are commonly associated with CSS, but they can be used in HTML and JavaScript as well.\nHTML\nThere are a few ways we can use media queries directly in HTML.\nThere\u2019s the\n<link>\nelement that goes right in the document\n<head>\n. In this example. we\u2019re telling the browser that we want to use different stylesheets at different viewport sizes:\n<html>\n  <head>\n    <!-- Served to all users -->\n    <link rel=\"stylesheet\" href=\"all.css\" media=\"all\" />\n    <!-- Served to screens that are at least 20em wide -->\n    <link rel=\"stylesheet\" href=\"small.css\" media=\"(min-width: 20em)\" />\n    <!-- Served to screens that are at least 64em wide -->\n    <link rel=\"stylesheet\" href=\"medium.css\" media=\"(min-width: 64em)\" />\n    <!-- Served to screens that are at least 90em wide -->\n    <link rel=\"stylesheet\" href=\"large.css\" media=\"(min-width: 90em)\" />\n    <!-- Served to screens that are at least 120em wide -->\n    <link rel=\"stylesheet\" href=\"extra-large.css\" media=\"(min-width: 120em)\" />\n    <!-- Served to print media, like printers -->\n    <link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />\n  </head>\n  <!-- ... -->\n</html>\nWhy would you want to do that? It can be a nice way to fine-tune the performance of your site by splitting styles up in a way that they\u2019re downloaded and served by the devices that need them.\nBut just to be clear, this doesn\u2019t\nalways\nprevent the stylesheets that don\u2019t match those media queries from downloading, it just assigns them a low loading priority level.\nSo, if a small screen device like a phone visits the site, it will only download the stylesheets in the media queries that match its viewport size. But if a larger desktop screen comes along, it will download the entire bunch because it matches all of those queries (well, minus the print query in this specific example).\nThat\u2019s just the\n<link>\nelement. As our\nguide to responsive images\nexplains, we can use media queries on\n<source>\nelement, which informs the\n<picture>\nelement what version of an image the browser should use from a set of image options.\n<picture>\n  <!-- Use this image if the screen is at least 800px wide -->\n  <source srcset=\"cat-landscape.png\" media=\"(min-width: 800px)\">\n  <!-- Use this image if the screen is at least 600px wide -->\n  <source srcset=\"cat-cropped.png\" media=\"(min-width: 600px)\">\n\n  <!-- Use this image if nothing matches -->\n  <img src=\"cat.png\" alt=\"A calico cat with dark aviator sunglasses.\">\n</picture>\nAgain, this can be a nice performance win because we can serve smaller images to smaller devices \u2014 which presumably (but not always) will be low powered devices that might be limited to a data plan.\nAnd let\u2019s not forget that we can use media queries directly on the\n<style>\nelement as well:\n<style>\n  p {\n    background-color: blue;\n    color: white;\n  }\n</style>\n\n<style media=\"all and (max-width: 500px)\">\n  p {\n    background-color: yellow;\n    color: blue;\n  }\n</style>\nCSS\nAgain, CSS is the most common place to spot a media query in the wild. They go right in the stylesheet in an\n@media\nrule that wraps elements with conditions for when and where to apply a set of styles when a browser matches those conditions.\n/* Viewports between 320px and 480px wide */\n@media only screen and (min-device-width: 320px) and (max-device-width: 480px) {\n  .card {\n    background: #bada55;\n  }\n}\nIt\u2019s also possible to scope imported style sheet but as a general rule avoid using @import since it\nperforms poorly\n.\n/* Avoid using @import if possible! */\n\n/* Base styles for all screens */\n@import url(\"style.css\") screen;\n/* Styles for screens in a portrait (narrow) orientation */\n@import url('landscape.css') screen and (orientation: portrait);\n/* Print styles */\n@import url(\"print.css\") print;\nJavaScript\nWe can use media queries in JavaScript, too! And guess, what? They\u2019re work a lot like they do in CSS. The difference? We start by using the\nwindow.matchMedia()\nmethod to define the conditions first.\nSo, say we want to log a message to the console when the browser is at least 768px wide. We can create a constant that calls\nmatchMedia()\nand defines that screen width:\n// Create a media condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia( '( min-width: 768px )' )\nThen we can fire log to the console when that condition is matched:\n// Create a media condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia( '( min-width: 768px )' )\n\u2028\n// Note the `matches` property\nif ( mediaQuery.matches ) {\n  console.log('Media Query Matched!')\n}\nUnfortunately, this only fires once so if the alert is dismissed, it won\u2019t fire again if we change the screen width and try again without refreshing. That\u2019s why it\u2019s a good idea to use a listener that checks for updates.\n// Create a condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia('(min-width: 768px)')\n\u2028\nfunction handleTabletChange(e) {\n  // Check if the media query is true\n  if (e.matches) {\n    // Then log the following message to the console\n    console.log('Media Query Matched!')\n  }\n}\n\u2028\n// Register event listener\nmediaQuery.addListener(handleTabletChange)\n\n// Initial check\nhandleTabletChange(mediaQuery)\nCheck out Marko Ilic\u2019s full post on\n\u201cWorking with JavaScript Media Queries\u201d\nfor a deeper dive on this, including a comparison of using media queries with an older JavaScript approach that binds a\nresize\nevent listener that checks\nwindow.innerWidth\nor\nwindow.innerHeight\nto fire changes.\nAnatomy of a Media Query\nNow that we\u2019ve seen several examples of\nwhere\nmedia queries can be used, let\u2019s pick them apart and see what they\u2019re actually doing.\n@media\n@media [media-type] ([media-feature]) {\n  /* Styles! */\n}\nThe first ingredient in a media query recipe is the\n@media\nrule itself, which is one of\nmany CSS at-rules\n. Why does\n@media\nget all the attention? Because it\u2019s geared to the\ntype\nof media that a site is viewed with, what\nfeatures\nthat media type supports, and\noperators\nthat can be combined to mix and match simple and complex conditions alike.\nMedia types\n@media screen {\n  /* Styles! */\n}\nWhat type of media are we trying to target? In many (if not most) cases, you\u2019ll see a\nscreen\nvalue used here, which makes sense since many of the media types we\u2019re trying to match are devices with screens attached to them.\nBut screens aren\u2019t the only type of media we can target, of course. We have a few, including:\nall\n: Matches all devices\nprint\n: Matches documents that are viewed in a print preview or any media that breaks the content up into pages intended to print.\nscreen\n: Matches devices with a screen\nspeech\n: Matches devices that read the content audibly, such as a screenreader. This replaces the now deprecated\naural\ntype since\nMedia Queries Level 4\n.\nTo preview print styles in a screen all major browsers can\nemulate the output of a print stylesheet using DevTools\n. Other media types such as\ntty\n,\ntv\n,\nprojection\n,\nhandheld\n,\nbraille\n,\nembossed\nand\naural\nhave been deprecated and, while\nthe spec continues to advise browsers to recognize them\n, they must evaluate to nothing. If you are using one of these consider changing it for a modern approach.\nMedia features\nOnce we define the type of media we\u2019re trying to match, we can start defining what features we are trying to match it to. We\u2019ve looked at a lot of examples that match screens to width, where\nscreen\nis the\ntype\nand both\nmin-width\nand\nmax-width\nare\nfeatures\nwith specific values.\nBut there are many, many (many!) more \u201cfeatures\u201d we can match.\nMedia Queries Level 5\ngroups media features into 6 categories.\nViewport/Page Characteristics\nFeature\nSummary\nValues\nAdded\nwidth\nDefines the widths of the viewport. This can be a specific number (e.g.\n400px\n) or a range (using\nmin-width\nand\nmax-width\n).\n<length>\nheight\nDefines the height of the viewport. This can be a specific number (e.g.\n400px\n) or a range (using\nmin-height\nand\nmax-height\n).\n<length>\naspect-ratio\nDefines the width-to-height aspect ratio of the viewport\n<ratio>\norientation\nThe way the screen is oriented, such as tall (\nportrait\n) or wide (\nlandscape\n) based on how the device is rotated.\nportrait\nlandscape\noverflow-block\nChecks how the device treats content that overflows the viewport in the block direction, which can be\nscroll\n(allows scrolling),\noptional-paged\n(allows scrolling and manual page breaks),\npaged\n(broken up into pages), and\nnone\n(not displayed).\nscroll\noptional-paged\npaged\nMedia Queries Level 4\noverflow-inline\nChecks if content that overflows the viewport along the inline axis be scrolled, which is either\nnone\n(no scrolling) or\nscroll\n(allows scrolling).\nscroll\nnone\nMedia Queries Level 4\nDisplay Quality\nFeature\nSummary\nValues\nAdded\nresolution\nDefines the target pixel density of the device\n<resolution>\ninfinite\nscan\nDefines the scanning process of the device, which is the way the device paints an image onto the screen (where\ninterlace\ndraws odd and even lines alternately, and\nprogressive\ndraws them all in sequence).\ninterlace\nprogressive\ngrid\nDetermines if the device uses a grid (\n1\n) or bitmap (\n0\n) screen\n0\n= Bitmap\n1\n= Grid\nMedia Queries Level 5\nupdate\nChecks how frequently the device can modify the appearance of content (if it can at all), with values including\nnone\n,\nslow\nand\nfast\n.\nslow\nfast\nnone\nMedia Queries Level 4\nenvironment-blending\nA method for determining the external environment of a device, such as dim or excessively bright places.\nopaque\nadditive\nsubtractive\ndisplay-mode\nTests the display mode of a device, including\nfullscreen\n(no browsers chrome),\nstandalone\n(a standalone application),\nminimal-ui\n(a standalone application, but with some navigation), and\nbrowser\n(a more traditional browser window)\nfullscreen\nstandalone\nminimal-ui\nbrowser\nWeb App Manifest\nColor\nFeature\nSummary\nValues\nAdded\ncolor\nDefines the color support of a device, expressed numerically as bits. So, a value of\n12\nwould be the equivalent of a device that supports 12-bit color, and a value of zero indicates no color support.\n<integer>\ncolor-index\nDefines the number of values the device supports. This can be a specific number (e.g.\n10000\n) or a range (e.g.\nmin-color-index: 10000\n,\nmax-color-index: 15000\n), just like\nwidth\n.\n<integer>\nmonochrome\nThe number of bits per pixel that a device\u2019s monochrome supports, where zero is no monochrome support.\n<integer>\ncolor-gamut\nDefines the range of colors supported by the browser and device, which could be\nsrgb\n,\np3\nor\nrec2020\nsrgb\np3\nrec2020\nMedia Queries Level 4\ndynamic-range\nThe combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device.\nstandard\nhigh\ninverted-colors\nChecks if the browser or operating system is set to invert colors (which can be useful for optimizing accessibility for sight impairments involving color)\ninverted\nnone\nMedia Queries Level 5\nInteraction\nFeature\nSummary\nValues\nAdded\npointer\nSort of like\nany-pointer\nbut checks if the\nprimary\ninput mechanism is a pointer and, if so, how accurate it is (where\ncoarse\nis less accurate,\nfine\nis more accurate, and\nnone\nis no pointer).\ncoarse\nfine\nnone\nMedia Queries Level 4\nhover\nSort of like\nany-hover\nbut checks if the\nprimary\ninput mechanism (e.g. mouse of touch) allows the user to hover over elements\nhover\nnone\nMedia Queries Level 4\nany-pointer\nChecks if the device uses a pointer, such as a mouse or styles, as well as how accurate it is (where\ncoarse\nis less accurate and\nfine\nis more accurate)\ncoarse\nfine\nnone\nMedia Queries Level 4\nany-hover\nChecks if the device is capable of hovering elements, like with a mouse or stylus. In some rare cases, touch devices are capable of hovers.\nhover\nnone\nMedia Queries Level 4\nVideo Prefixed\nThe spec references user agents, including TVs, that render video and graphics in two separate planes that each have their own characteristics. The following features describe those planes.\nFeature\nSummary\nValues\nAdded\nvideo-color-gamut\nDescribes the approximate range of colors supported by the video plane of the browser and user device\nsrgb\np3\nrec2020\nMedia Queries Level 5\nvideo-dynamic-range\nThe combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device.\nstandard\nhigh\nMedia Queries Level 5\nvideo-width\n\u00b9\nThe width of the video plane area of the targeted display\n<length>\nMedia Queries Level 5\nvideo-height\n\u00b9\nThe height of the video plane area of the targeted display\n<length>\nMedia Queries Level 5\nvideo-resolution\n\u00b9\nThe resolution of the video plane area of the targeted display\n<resolution>\ninifinite\nMedia Queries Level 5\n\u00b9 Under discussion (Issue\n#5044\n)\nScripting\nFeature\nSummary\nValues\nAdded\nscripting\nChecks whether the device allows scripting (i.e. JavaScript) where\nenabled\nallows scripting,\niniital-only\nenabled\ninitial-only\nMedia Queries Level 5\nUser Preference\nFeature\nSummary\nValues\nAdded\nprefers-reduced-motion\nDetects if the user\u2019s system settings are set to reduce motion on the page, which is a\ngreat accessibility check\n.\nno-preference\nreduce\nMedia Queries Level 5\nprefers-reduced-transparency\nDetects if the user\u2019s system settings prevent transparent across elements.\nno-preference\nreduce\nMedia Queries Level 5\nprefers-contrast\nDetects if the user\u2019s system settings are set to either increase or decrease the amount of contrast between colors.\nno-preference\nhigh\nlow\nforced\nMedia Queries Level 5\nprefers-color-scheme\nDetects if the user prefers a light or dark color scheme, which is a rapidly growing way to go about\ncreating \u201cdark mode\u201d interfaces\n.\nlight\ndark\nMedia Queries Level 5\nforced-colors\nTests whether the browser restricts the colors available to use (which is\nnone\nor\nactive\n)\nactive\nnone\nMedia Queries Level 5\nprefers-reduced-data\nDetects if the user prefers to use less data for the page to be rendered.\nno-preference\nreduce\nMedia Queries Level 5\nDeprecated\nName\nSummary\nRemoved\ndevice-aspect-ratio\nThe width-to-height aspect ratio of the output device\nMedia Queries Level 4\ndevice-height\nThe height of the device\u2019s surface that displays rendered elements\nMedia Queries Level 4\ndevice-width\nThe width of the device\u2019s surface that displays rendered elements\nMedia Queries Level 4\nOperators\nMedia queries support logical operators like many programming languages so that we can match media types based on certain conditions. The\n@media\nrule is itself a logical operator that is basically stating that \u201cif\u201d the following types and features are matches, then do some stuff.\nand\nBut we can use the\nand\noperator if we want to target screens within a range of widths:\n/* Matches screen between 320px AND 768px */\n@media screen (min-width: 320px) and (max-width: 768px) {\n  .element {\n    /* Styles! */\n  }\n}\nor\n(or comma-separated)\nWe can also comma-separate features as a way of using an\nor\noperator to match different ones:\n/* \n  Matches screens where either the user prefers dark mode or the screen is at least 1200px wide */\n@media screen (prefers-color-scheme: dark), (min-width 1200px) {\n  .element {\n    /* Styles! */\n  }\n}\nnot\nPerhaps we want to target devices by what they do\nnot\nsupport or match. This declaration removes the body\u2019s background color when the device is a printer and can only show one color.\n@media print and ( not(color) ) {\n  body {\n    background-color: none;\n  }\n}\nWant to go deeper? Check out\n\u201cCSS Media Queries: Quick Reference & Guide\u201d\nfrom the DigitalOcean community for more examples that follow the syntax for media quieries.\nDo you really need CSS media queries?\nMedia queries are a powerful tool in your CSS toolbox with exciting hidden gems. But if you accomodate your design to every possible situation you\u2019ll end up with a codebase that\u2019s too complex to maintain and, as we all know, CSS is like a bear cub: cute and inoffensive but when it grows it will eat you alive.\nThat\u2019s why I recommend following Ranald Mace\u2019s concept of Universal Design which is \u201c\nthe design of products to be usable by all people, to the greatest extent possible, without the need for adaptation or specialized design.\u201d\nIn\n\u201cAccessibility for Everyone\u201d\nLaura Kalbag explains that the difference between accessible and universal design is subtle but important. An accessible designer would create a large door for people on a wheel chair to enter, while a universal designer would produce an entry that anyone would fit disregarding of their abilities.\nI know that talking about universal design on the web is hard and almost sound utopian, but think about it, there are around\n150 different browsers\n, around 50 different combinations of user preferences, and as we mentioned before more than 24000 different and unique Android devices alone.\nThis means that there are at least 18 million possible cases in which your content might be displayed. In the words of the fantastic\nMiriam Suzanne\n,\n\u201cCSS out here trying to do graphic design of unknown content on an infinite and unknown canvas, across operating systems, interfaces, & languages. There\u2019s no possible way for any of us to know what we\u2019re doing.\u201d\nThat\u2019s why assuming is really dangerous, so when you design, develop and think about your products leave assumptions behind and use media queries to make sure that your content is displayed correctly in any contact and before any user.\nMatching value ranges\nMany of the media features outlined in the previous section \u2014 including\nwidth\n,\nheight\n,\ncolor\nand\ncolor-index\n\u2014 can be prefixed with\nmin-\nor\nmax-\nto express minimum or maximum constraints. We\u2019ve already seen these in use throughout many of the examples, but the point is that we can create a range of value to match instead of having to declare specific values.\nIn the following snippet, we\u2019re painting the body\u2019s background purple when the viewport width is wider than 30em and narrower than 80em. If the viewport width does not match that range of values, then it will fallback to white.\nbody {\n  background-color: #fff;\n}\n\n@media (min-width: 30em) and (max-width: 80em) {\n  body {\n    background-color: purple;\n  }\n}\nMedia Queries Level 4 specifies a\nnew and simpler syntax\nusing less then\u00a0(\n<\n), greater than\u00a0(\n>\n)\u00a0and\u00a0equals (\n=\n) operators. So, that last example can be converted to the new syntax, like so:\n@media (30em <= width <= 80em) {\n  /* ... */\n}\nNesting and complex decision making\nCSS allows you to nest at-rules or group statements using parentheses, making it possible to go as deep as we want to evaluate complex operations.\n@media (min-width: 20em), not all and (min-height: 40em) {  \n  @media not all and (pointer: none) { ... }\n  @media screen and ( (min-width: 50em) and (orientation: landscape) ), print and ( not (color) ) { ... }\n}\nBe careful!\neven thought it\u2019s possible to create powerful and complex expressions, you might end up with a very opinionated, hard to maintain query. As Brad Frost\nputs it\n: \u201cThe more complex our interfaces are, the more we have to think to maintain them properly.\u201d\nAccessibility\nMany of the features added in Media Queries Level 4 are centered around accessibility.\nprefers-reduced-motion\nprefers-reduced-motion\ndetects if the user has the reduced motion preference activated to minimize the amount of movements and animations. It takes two values:\nno-preference\n: Indicates that the user has made no preference known to the system.\nreduce\n: Indicates that user has notified the system that they prefer an interface that minimizes the amount of movement or animation, preferably to the point where all non-essential movement is removed.\nThis preference is generally used by people who suffer from vestibular disorder or vertigo, where different movements result in loss of balance, migraine, nausea or hearing loss. If you ever tried to spin quickly and got dizzy, you know what it feels like.\nIn a\nfantastic article\nby Eric Bailey, he suggests stopping all animations with this code:\n@media screen and (prefers-reduced-motion: reduce) {  \n  * {\n    /* Very short durations means JavaScript that relies on events still works */\n    animation-duration: 0.001ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.001ms !important;\n  }\n}\nPopular frameworks like\nBootstrap have this feature on by default\n. In my opinion there is no excuse not to use\nprefers-reduced-motion\n\u2014 just use it.\nprefers-contrast\nThe\nprefers-contrast\nfeature informs whether the user has chosen to increase or reduce contrast in their system preferences or the browser settings. It takes three values:\nno-preference\n:\u00a0When a user has made no preference known to the system. If you use it as a boolean it\u2019ll evaluate\u00a0false.\nhigh\n:\u00a0When a user has selected the option to display a higher level of contrast.\nlow\n:\u00a0When a user has selected the option to display a lower level of contrast.\nAt the moment of writing this feature is not supported by any browser. Microsoft has done a\nnon-standard earlier implementation\nwith the\n-ms-high-contrast\nfeature that works only on Microsoft Edge v18 or earlier\u00a0(but not\u00a0Chromium-based versions).\n.button {\n  background-color: #0958d8;\n  color: #fff;\n}\n\n@media (prefers-contrast: high) {\n  .button {\n    background-color: #0a0db7;\n  }\n}\nThis example is increasing the contrast of a the class button from AA to AAA when the user has high contrast on.\ninverted-colors\nThe\ninverted-colors\nfeature informs whether the user has chosen to invert the colors on their system preferences or the browser settings. Sometimes this option is used as an alternative to high contrast. It takes two values:\nnone\n:\u00a0When colors are displayed normally\ninverted\n:\u00a0When a user has selected the option\u00a0to invert colors\nThe problem with inverted colors is that it\u2019ll also invert the colors of images and videos, making them look like x-ray images. By using a CSS invert filter you can select all images and videos and invert them back.\n@media (inverted-colors) {\n  img, video { \n    filter: invert(100%);\n  }\n}\nAt the time of writing this feature is only supported by Safari.\nprefers-color-scheme\nHaving a \u201cdark mode\u201d color scheme is something we\u2019re seeing a lot more of these days, and thanks to the\nprefers-color-scheme\nfeature, we can tap into a user\u2019s system or browser preferences to determine whether we serve a \u201cdark\u201d or a \u201clight\u201d theme based on the ir preferences.\nIt takes two values:\nlight\n:\u00a0When a user has selected that they prefer a light theme or has no active preferences\ndark\n:\u00a0When a user has selected a dark display in their settings\nbody {\n  --bg-color: white; \n  --text-color: black;\n\n  background-color: var(--bg-color);\n  color: var(--text-color);\n}\n\n@media screen and (prefers-color-scheme: dark) {\n  body {\n    --bg-color: black;\n    --text-color: white;\n  }\n}\nAs Adhuham explains in the\ncomplete guide to Dark Mode\nthere is way more to it than just changing the color of the background. Before you jump into doing dark mode remember that if you don\u2019t have a very smart implementation strategy you might end up with a code base that\u2019s really hard to maintain.\nCSS variables\ncan do wonders for it but that\u2019s a subject for another article.\nWhat lies ahead?\nMedia Queries Level 5\nis currently in Working Draft status, which means a lot can change between now and when it becomes a recommendation. But it includes interesting features that are worth mentioning because they open up new ways to target screens and adapt designs to very specific conditions.\nUser preference media features\nHey, we just covered these in the last section! Oh well. These features are exciting because they\u2019re informed by a user\u2019s actual settings, whether they are from the user agent or even at the operating system level.\nDetecting a forced color palette\nThis is neat. Some browsers will limit the number of available colors that can be used to render styles. This is called\n\u201cforced colors mode\u201d\nand, if enabled in the browser settings, the user can choose a limited set of colors to use on a page. As a result, the user is able to define color combinations and contrasts that make content more comfortable to read.\nThe\nforced-colors\nfeature allows us to detect if a forced color palette is in use with the\nactive\nvalue. If matched, the browser must provide the required color palette through the CSS system colors. The browser is also given the leeway to determine if the background color of the page is light or dark and, if appropriate, trigger the appropriate\nprefers-color-scheme\nvalue so we can adjust the page.\nDetecting the maximum brightness, color depth, and contrast ratio\nSome devices (and browsers) are capable of super bright displays, rendering a wide range of colors, and high contrast ratios between colors. We can detect those devices using the\ndynamic-range\nfeature, where the\nhigh\nkeyword matches these devices and\nstandard\nmatches everything else.\nWe\u2019re likely to see changes to this because, as of right now, there\u2019s still uncertainty about what measurements constitute \u201chigh\u201d levels of brightness and contrast. The browser may get to make that determination.\nVideo prefixed features\nThe spec talks about some screens, like TVs, that are capable of displaying video and graphics on separate \u201cplanes\u201d which might be a way of distinguishing the video frame from other elements on the screen. As such, Media Queries Level 5 is proposing a new set of media features aimed at\ndetecting video characteristics\n, including color gamut and dynamic range.\nThere are also proposals to detect video height, width and resolution, but\nthe jury\u2019s still out\non whether those are the right ways to address video.\nBrowser support\nBrowsers keep evolving and since by the time you are reading this post chances are that browser support for this feature might change, please check\nMDN updated browser compatibility table\n.\nA note on container queries\nWouldn\u2019t be cool if components could adapt themselves on their own size instead of the browser\u2019s? That\u2019s what the concept of\nCSS Container Queries\nis all about. We currently only have the browser screen to make those changes via media queries.\nThat\u2019s unfortunate, as the viewport isn\u2019t always a direct relationship to how big the element itself is. Imagine a widget that renders in many different contexts on a site: sometimes in a sidebar, sometimes in a full-width footer, sometimes in a grid with unknown columns.\nThis is the problem that container queries try to solve. Ideally we could adapt styles of an element according to the size of itself instead of of the size of the viewport. Chrome 105 released support for CSS Container Queries. Same deal with Safari 16.1. Firefox is all we\u2019re really waiting at the time of writing to get broad support.\nThis browser support data is from\nCaniuse\n, which has more detail. A number indicates that browser supports the feature at that version and up.\nDesktop\nChrome\nFirefox\nIE\nEdge\nSafari\n106\n110\nNo\n106\n16.0\nMobile / Tablet\nAndroid Chrome\nAndroid Firefox\nAndroid\niOS Safari\n144\n147\n144\n16.0\nExamples\nLet\u2019s look at a bunch of media query examples. There are so many combinations of media types, features, and operators that the number of possibilities we could show would be exhaustive. Instead, we\u2019ll highlight a handful based on specific media features.\nAdjust layout at different viewport widths\nMore info\nThis is the probably the most widely used media feature. It informs the width of the browser\u2019s viewport including the scrollbar. It unlocked the CSS implementation of what Ethan Marcotte famously coined\nresponsive design\n: a process by which a design responds to the size of the viewport using a combination of a fluid grid, flexible images, and responsive typesetting.\nLater, Luke Wroblewski evolved the concept of responsive design by introducing the term\nmobile-first\n, encouraging designers and developers to start with the small-screen experience first then progressively enhance the experience as the screen width and device capabilities expand.\nA mobile-first can usually be spotted by it\u2019s use of\nmin-width\ninstead of\nmax-width\n. If we start with\nmin-width\n, we\u2019re essentially saying,\n\u201chey, browser, start here and work up.\u201d\nOn the flip side,\nmax-width\nis sort of like prioritizing larger screens.\nOne approach for defining breakpoints by width is using the dimensions of\nstandard devices\n, like the\nexact\npixel width of an iPhone. But there are many, many (many), many different phones, tables, laptops, and desktops. Looking at Android alone, there are more than 24,000 variations of viewport sizes, resolutions, operating systems, and browsers, as of August 2015.\nSo, while targeting the precise width of a specific device might be helpful for troubleshooting or one-off fixes, it\u2019s probably not the most robust solution for maintaining a responsive architecture. This isn\u2019t a new idea by any stretch. Brad Frost was already preaching the virtues of letting content \u2014 not devices \u2014 determine breakpoints in his post\n\u201c7 habits of highly effective media queries\u201d\npublished back in 2013.\nAnd even though media queries are still a valid tool to create responsive interfaces, there are many situations where it\u2019s possible to avoid using width at all. Modern CSS allow us to create flexible layouts with CSS grid and flex that adapts our content to the viewport size without a need to add breakpoints. For example, here is a grid layout that adapts how many columns it will have\nwithout any media queries at all\n.\n.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n}\nThere are many articles about thinking beyond width,\nI wrote about it a few years ago\nand I recommend checking out Una Kravet\u2019s\nTen modern layouts in one line of CSS\n.\nDark mode\nMore info\nThis example is pulled straight from our\nGuide to Dark Mode on the Web\n. The idea is that we can detect whether a user\u2019s system settings are configured to light or dark mode using the\nprefers-color-scheme\nfeature and then define an alternate set of colors for the rendered UI.\nCombining this technique with CSS custom properties makes things even easier because they act like variables that we only need to define once, then use throughout the code. Need to swap colors? Change the custom property value and it updates everywhere. That\u2019s exactly what\nprefers-color-scheme\ndoes. We define a set of colors as custom properties, then redefine them inside a media query using the\nprefer-color-scheme\nfeature to change colors based on the user\u2019s settings.\nDetecting orientation, hover and motion on a responsive card gallery\nMore info\nThis gallery is responsive without using the\nwidth\nfeature.\nIt detects the\norientation\nof the viewport. If it\u2019s a\nportrait\nviewport, the sidebar will became a header; if it\u2019s\nlandscape\nit stays off to the side.\nUsing the\npointer\nmedia feature, it decides if the main input device is\ncoarse\n\u2014 like a finger \u2014 or\nfine\n\u2014 like a mouse cursor \u2014 to set the size of the clickable areas of the checkboxes.\nThen, by using the\nhover\nmedia feature, the example checks if the device is capable of hovering (like a mouse cursor) and display a checkbox in each card.\nThe animations are removed when\nprefers-reduced-motion\nis set to\nreduce\n.\nAnd did you notice something? We\u2019re actually\nnot\nusing media queries for the actual layout and sizing of the cards! That\u2019s handled using the\nminmax()\nfunction on the\n.container\nelement to show how responsive design doesn\u2019t always mean using media queries.\nIn short, this is a fully responsive app without ever measuring\nwidth\nor making assumptions.\nTarget an iPhone in landscape mode\n/* iPhone X Landscape */\n@media only screen \n  and (min-device-width: 375px) \n  and (max-device-width: 812px) \n  and (-webkit-min-device-pixel-ratio: 3)\n  and (orientation: landscape) { \n  /* Styles! */\n}\nMore info\nThe\norientation\nmedia feature tests whether a device is rotated the wide way (landscape) or the tall way (portrait).\nWhile media queries are unable to know exactly which device is being used, we can use the exact dimensions of a specific device. The snippet above is targets the iPhone X.\nApply a sticky header for large viewports\nMore info\nIn the example above, we\u2019re using\nheight\nto detached fixed elements and avoid taking up too much screen real estate when the screen is too short. A horizontal navigation bar is in a fixed position when the screen is tall, but detaches itself on shorter screens.\nLike the\nwidth\nfeature,\nheight\ndetects the height of the viewport, including the scrollbar. Many of us browse the web on small devices with narrow viewports, making designing for different heights more relevant than ever. Anthony Colangelo describes\nhow Apple uses the\nheight\nmedia feature\nin a meaningful way to deal with the size of the hero image as the viewport\u2019s height changes.\nResponsive (fluid) typography\nMore info\nA font can look either too big or too small, depending on the size of the screen that\u2019s showing it. If we\u2019re working on a small screen, then chances are that we\u2019ll want to use smaller type than what we\u2019d use on a much larger screen.\nThe idea here is that we\u2019re using the browser\u2019s width to scale the font size. We set a default font size on the\n<html>\nthat acts as the \u201csmall\u201d font size, then set another font size using a media query that acts as the \u201clarge\u201d font size. In the middle? We set the font size again, but inside another media query that calculates a size based on the browser width.\nThe beauty of this is that it allows the font size to adjust based on the browser width, but never go above or below certain sizes. However, there is a\nmuch simpler way to go about this\nthat requires no media queries at all, thanks to newer CSS features, like\nmin()\n,\nmax()\n, and\nclamp()\n.\nProvide bigger touch targets when devices have a\ncourse\npointer\nMore info\nHave you ever visited a site that had\nsuper\ntiny buttons? Some of us have fat fingers making it tough to tap an object accurately without inadvertently tapping something else instead.\nSure, we can rely on the\nwidth\nfeature to tell if we\u2019re dealing with a small screen, but we can also detect if the device is capable of hovering over elements. If it isn\u2019t then it\u2019s probably a touch device, or perhaps a device that supports both, like the Microsoft Surface.\nThe demo above uses checkboxes as an example. Checkboxes can be a pain to tap on when viewing them on a small screen, so we\u2019re increasing the size and not requiring a hover if the device is incapable of\nhover\nevents.\nAgain, this approach isn\u2019t always accurate. Check out\nPatrick Lauke\u2019s thorough article\nthat details potential issues working with\nhover\n,\npointer\n,\nany-hover\nand\nany-pointer\n.\nSpecifications\nMedia Queries Level 4\n(Candidate Recommendation)\nMedia Queries Level 5\n(Working Draft)\nSpecial thanks to Sarah Rambacher who helped to review this guide.",
  "content_markdown": "CSS Media queries are a way to target browser by certain characteristics, features, and user preferences, then apply styles or run other code based on those things. Perhaps the most common media queries in the world are those that target particular viewport ranges and apply custom styles, which birthed the whole idea of responsive design.\n\n```\n/* When the browser is at least 600px and above */\n@media screen and (min-width: 600px) {\n  .element {\n    /* Apply some styles */\n  }\n}\n```\n\nThere are lots of other things we can target beside viewport width. That might be screen resolution, device orientation, operating system preference, or even more among a whole bevy of things we can query and use to style content.\n\nLooking for a quick list of media queries based on the viewports of standard devices, like phones, tablets and laptops? [Check out our collection of snippets.](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/)\n\n### Using media queries\n\nMedia queries are commonly associated with CSS, but they can be used in HTML and JavaScript as well.\n\nHTML \n\nThere are a few ways we can use media queries directly in HTML.\n\nThere\u2019s the `<link>` element that goes right in the document `<head>`. In this example. we\u2019re telling the browser that we want to use different stylesheets at different viewport sizes:\n\n```\n<html>\n  <head>\n    <!-- Served to all users -->\n    <link rel=\"stylesheet\" href=\"all.css\" media=\"all\" />\n    <!-- Served to screens that are at least 20em wide -->\n    <link rel=\"stylesheet\" href=\"small.css\" media=\"(min-width: 20em)\" />\n    <!-- Served to screens that are at least 64em wide -->\n    <link rel=\"stylesheet\" href=\"medium.css\" media=\"(min-width: 64em)\" />\n    <!-- Served to screens that are at least 90em wide -->\n    <link rel=\"stylesheet\" href=\"large.css\" media=\"(min-width: 90em)\" />\n    <!-- Served to screens that are at least 120em wide -->\n    <link rel=\"stylesheet\" href=\"extra-large.css\" media=\"(min-width: 120em)\" />\n    <!-- Served to print media, like printers -->\n    <link rel=\"stylesheet\" href=\"print.css\" media=\"print\" />\n  </head>\n  <!-- ... -->\n</html>\n```\n\nWhy would you want to do that? It can be a nice way to fine-tune the performance of your site by splitting styles up in a way that they\u2019re downloaded and served by the devices that need them.\n\nBut just to be clear, this doesn\u2019t *always* prevent the stylesheets that don\u2019t match those media queries from downloading, it just assigns them a low loading priority level.\n\nSo, if a small screen device like a phone visits the site, it will only download the stylesheets in the media queries that match its viewport size. But if a larger desktop screen comes along, it will download the entire bunch because it matches all of those queries (well, minus the print query in this specific example).\n\nThat\u2019s just the `<link>` element. As our [guide to responsive images](https://css-tricks.com/a-guide-to-the-responsive-images-syntax-in-html/) explains, we can use media queries on\u00a0`<source>` element, which informs the `<picture>` element what version of an image the browser should use from a set of image options.\n\n```\n<picture>\n  <!-- Use this image if the screen is at least 800px wide -->\n  <source srcset=\"cat-landscape.png\" media=\"(min-width: 800px)\">\n  <!-- Use this image if the screen is at least 600px wide -->\n  <source srcset=\"cat-cropped.png\" media=\"(min-width: 600px)\">\n\n  <!-- Use this image if nothing matches -->\n  <img src=\"cat.png\" alt=\"A calico cat with dark aviator sunglasses.\">\n</picture>\n```\n\nAgain, this can be a nice performance win because we can serve smaller images to smaller devices \u2014 which presumably (but not always) will be low powered devices that might be limited to a data plan.\n\nAnd let\u2019s not forget that we can use media queries directly on the `<style>` element as well:\n\n```\n<style>\n  p {\n    background-color: blue;\n    color: white;\n  }\n</style>\n\n<style media=\"all and (max-width: 500px)\">\n  p {\n    background-color: yellow;\n    color: blue;\n  }\n</style>\n```\n\nCSS \n\nAgain, CSS is the most common place to spot a media query in the wild. They go right in the stylesheet in an `@media` rule that wraps elements with conditions for when and where to apply a set of styles when a browser matches those conditions.\n\n```\n/* Viewports between 320px and 480px wide */\n@media only screen and (min-device-width: 320px) and (max-device-width: 480px) {\n  .card {\n    background: #bada55;\n  }\n}\n```\n\nIt\u2019s also possible to scope imported style sheet but as a general rule avoid using @import since it [performs poorly](https://csswizardry.com/2018/11/css-and-network-performance/).\n\n```\n/* Avoid using @import if possible! */\n\n/* Base styles for all screens */\n@import url(\"style.css\") screen;\n/* Styles for screens in a portrait (narrow) orientation */\n@import url('landscape.css') screen and (orientation: portrait);\n/* Print styles */\n@import url(\"print.css\") print;\n```\n\nJavaScript \n\nWe can use media queries in JavaScript, too! And guess, what? They\u2019re work a lot like they do in CSS. The difference? We start by using the `window.matchMedia()` method to define the conditions first.\n\nSo, say we want to log a message to the console when the browser is at least 768px wide. We can create a constant that calls `matchMedia()` and defines that screen width:\n\n```\n// Create a media condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia( '( min-width: 768px )' )\n```\n\nThen we can fire log to the console when that condition is matched:\n\n```\n// Create a media condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia( '( min-width: 768px )' )\n\u2028\n// Note the `matches` property\nif ( mediaQuery.matches ) {\n  console.log('Media Query Matched!')\n}\n```\n\nUnfortunately, this only fires once so if the alert is dismissed, it won\u2019t fire again if we change the screen width and try again without refreshing. That\u2019s why it\u2019s a good idea to use a listener that checks for updates.\n\n```\n// Create a condition that targets viewports at least 768px wide\nconst mediaQuery = window.matchMedia('(min-width: 768px)')\n\u2028\nfunction handleTabletChange(e) {\n  // Check if the media query is true\n  if (e.matches) {\n    // Then log the following message to the console\n    console.log('Media Query Matched!')\n  }\n}\n\u2028\n// Register event listener\nmediaQuery.addListener(handleTabletChange)\n\n// Initial check\nhandleTabletChange(mediaQuery)\n```\n\nCheck out Marko Ilic\u2019s full post on [\u201cWorking with JavaScript Media Queries\u201d](https://css-tricks.com/working-with-javascript-media-queries/) for a deeper dive on this, including a comparison of using media queries with an older JavaScript approach that binds a\u00a0`resize`\u00a0event listener that checks\u00a0`window.innerWidth`\u00a0or\u00a0`window.innerHeight` to fire changes.\n\n---\n\n### Anatomy of a Media Query\n\nNow that we\u2019ve seen several examples of *where* media queries can be used, let\u2019s pick them apart and see what they\u2019re actually doing.\n\n![Syntax for CSS media queries.](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/media-query-anatomy.jpg?resize=2361%2C156&ssl=1)\n\n@media \n\n```\n@media [media-type] ([media-feature]) {\n  /* Styles! */\n}\n```\n\nThe first ingredient in a media query recipe is the `@media` rule itself, which is one of [many CSS at-rules](https://css-tricks.com/the-at-rules-of-css/). Why does `@media` get all the attention? Because it\u2019s geared to the *type* of media that a site is viewed with, what *features* that media type supports, and *operators* that can be combined to mix and match simple and complex conditions alike.\n\nMedia types \n\n```\n@media screen {\n  /* Styles! */\n}\n```\n\nWhat type of media are we trying to target? In many (if not most) cases, you\u2019ll see a `screen` value used here, which makes sense since many of the media types we\u2019re trying to match are devices with screens attached to them.\n\nBut screens aren\u2019t the only type of media we can target, of course. We have a few, including:\n\n- `all`: Matches all devices\n- `print`: Matches documents that are viewed in a print preview or any media that breaks the content up into pages intended to print.\n- `screen`: Matches devices with a screen\n- `speech`: Matches devices that read the content audibly, such as a screenreader. This replaces the now deprecated `aural` type since [Media Queries Level 4](https://drafts.csswg.org/mediaqueries/#media-types).\n\nTo preview print styles in a screen all major browsers can [emulate the output of a print stylesheet using DevTools](https://css-tricks.com/can-you-view-print-stylesheets-applied-directly-in-the-browser/). Other media types such as `tty`, `tv`, \u00a0`projection`, \u00a0`handheld`, `braille`, `embossed` and `aural` have been deprecated and, while [the spec continues to advise browsers to recognize them](https://www.w3.org/TR/mediaqueries-4/#media-types), they must evaluate to nothing. If you are using one of these consider changing it for a modern approach.\n\nMedia features \n\nOnce we define the type of media we\u2019re trying to match, we can start defining what features we are trying to match it to. We\u2019ve looked at a lot of examples that match screens to width, where `screen` is the *type* and both`min-width` and `max-width` are *features* with specific values.\n\nBut there are many, many (many!) more \u201cfeatures\u201d we can match. [Media Queries Level 5](https://www.w3.org/TR/mediaqueries-5/) groups media features into 6 categories.\n\n#### Viewport/Page Characteristics\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `width` | Defines the widths of the viewport. This can be a specific number (e.g. `400px`) or a range (using `min-width` and `max-width`). | `<length>` |  |\n| `height` | Defines the height of the viewport. This can be a specific number (e.g. `400px`) or a range (using `min-height` and `max-height`). | `<length>` |  |\n| `aspect-ratio` | Defines the width-to-height aspect ratio of the viewport | `<ratio>` |  |\n| `orientation` | The way the screen is oriented, such as tall (`portrait`) or wide (`landscape`) based on how the device is rotated. | `portrait`  `landscape` |  |\n| `overflow-block` | Checks how the device treats content that overflows the viewport in the block direction, which can be `scroll` (allows scrolling), `optional-paged` (allows scrolling and manual page breaks), `paged` (broken up into pages), and `none` (not displayed). | `scroll`  `optional-paged`  `paged` | Media Queries Level 4 |\n| `overflow-inline` | Checks if content that overflows the viewport along the inline axis be scrolled, which is either `none` (no scrolling) or `scroll` (allows scrolling). | `scroll`  `none` | Media Queries Level 4 |\n\n#### Display Quality\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `resolution` | Defines the target pixel density of the device | `<resolution>`  `infinite` |  |\n| `scan` | Defines the scanning process of the device, which is the way the device paints an image onto the screen (where `interlace` draws odd and even lines alternately, and `progressive` draws them all in sequence). | `interlace`  `progressive` |  |\n| `grid` | Determines if the device uses a grid (`1`) or bitmap (`0`) screen | `0` = Bitmap `1` = Grid | Media Queries Level 5 |\n| `update` | Checks how frequently the device can modify the appearance of content (if it can at all), with values including `none`, `slow` and `fast`. | `slow`  `fast`  `none` | Media Queries Level 4 |\n| `environment-blending` | A method for determining the external environment of a device, such as dim or excessively bright places. | `opaque`  `additive`  `subtractive` |  |\n| `display-mode` | Tests the display mode of a device, including `fullscreen`(no browsers chrome), `standalone` (a standalone application), `minimal-ui` (a standalone application, but with some navigation), and `browser` (a more traditional browser window) | `fullscreen`  `standalone`  `minimal-ui`  `browser` | [Web App Manifest](https://w3c.github.io/manifest/#the-display-mode-media-feature) |\n\n#### Color\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `color` | Defines the color support of a device, expressed numerically as bits. So, a value of `12` would be the equivalent of a device that supports 12-bit color, and a value of zero indicates no color support. | `<integer>` |  |\n| `color-index` | Defines the number of values the device supports. This can be a specific number (e.g. `10000`) or a range (e.g. `min-color-index: 10000`, `max-color-index: 15000`), just like `width`. | `<integer>` |  |\n| `monochrome` | The number of bits per pixel that a device\u2019s monochrome supports, where zero is no monochrome support. | `<integer>` |  |\n| `color-gamut` | Defines the range of colors supported by the browser and device, which could be `srgb`, `p3` or `rec2020` | `srgb`  `p3`  `rec2020` | Media Queries Level 4 |\n| `dynamic-range` | The combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device. | `standard`  `high` |  |\n| `inverted-colors` | Checks if the browser or operating system is set to invert colors (which can be useful for optimizing accessibility for sight impairments involving color) | `inverted`  `none` | Media Queries Level 5 |\n\n#### Interaction\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `pointer` | Sort of like `any-pointer` but checks if the *primary* input mechanism is a pointer and, if so, how accurate it is (where `coarse` is less accurate, `fine` is more accurate, and `none` is no pointer). | `coarse`  `fine`  `none` | Media Queries Level 4 |\n| `hover` | Sort of like `any-hover` but checks if the *primary* input mechanism (e.g. mouse of touch) allows the user to hover over elements | `hover`  `none` | Media Queries Level 4 |\n| `any-pointer` | Checks if the device uses a pointer, such as a mouse or styles, as well as how accurate it is (where `coarse` is less accurate and `fine` is more accurate) | `coarse`  `fine`  `none` | Media Queries Level 4 |\n| `any-hover` | Checks if the device is capable of hovering elements, like with a mouse or stylus. In some rare cases, touch devices are capable of hovers. | `hover  none` | Media Queries Level 4 |\n\n#### Video Prefixed\n\nThe spec references user agents, including TVs, that render video and graphics in two separate planes that each have their own characteristics. The following features describe those planes.\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `video-color-gamut` | Describes the approximate range of colors supported by the video plane of the browser and user device | `srgb`  `p3`  `rec2020` | Media Queries Level 5 |\n| `video-dynamic-range` | The combination of how much brightness, color depth, and contrast ratio supported by the video plane of the browser and user device. | `standard`  `high` | Media Queries Level 5 |\n| `video-width`\u00b9 | The width of the video plane area of the targeted display | `<length>` | Media Queries Level 5 |\n| `video-height`\u00b9 | The height of the video plane area of the targeted display | `<length>` | Media Queries Level 5 |\n| `video-resolution`\u00b9 | The resolution of the video plane area of the targeted display | `<resolution>`  `inifinite` | Media Queries Level 5 |\n\n\u00b9 Under discussion (Issue [#5044](https://github.com/w3c/csswg-drafts/issues/5044))\n\n#### Scripting\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `scripting` | Checks whether the device allows scripting (i.e. JavaScript) where `enabled` allows scripting, `iniital-only` | `enabled`  `initial-only` | Media Queries Level 5 |\n\n#### User Preference\n\n| Feature | Summary | Values | Added |\n| --- | --- | --- | --- |\n| `prefers-reduced-motion` | Detects if the user\u2019s system settings are set to reduce motion on the page, which is a [great accessibility check](https://css-tricks.com/introduction-reduced-motion-media-query/). | `no-preference`  `reduce` | Media Queries Level 5 |\n| `prefers-reduced-transparency` | Detects if the user\u2019s system settings prevent transparent across elements. | `no-preference`  `reduce` | Media Queries Level 5 |\n| `prefers-contrast` | Detects if the user\u2019s system settings are set to either increase or decrease the amount of contrast between colors. | `no-preference`  `high`  `low`  `forced` | Media Queries Level 5 |\n| `prefers-color-scheme` | Detects if the user prefers a light or dark color scheme, which is a rapidly growing way to go about [creating \u201cdark mode\u201d interfaces](https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/). | `light`  `dark` | Media Queries Level 5 |\n| `forced-colors` | Tests whether the browser restricts the colors available to use (which is `none` or `active`) | `active`  `none` | Media Queries Level 5 |\n| `prefers-reduced-data` | Detects if the user prefers to use less data for the page to be rendered. | `no-preference`  `reduce` | Media Queries Level 5 |\n\n#### Deprecated\n\n| Name | Summary | Removed |\n| --- | --- | --- |\n| `device-aspect-ratio` | The width-to-height aspect ratio of the output device | Media Queries Level 4 |\n| `device-height` | The height of the device\u2019s surface that displays rendered elements | Media Queries Level 4 |\n| `device-width` | The width of the device\u2019s surface that displays rendered elements | Media Queries Level 4 |\n\nOperators \n\nMedia queries support logical operators like many programming languages so that we can match media types based on certain conditions. The `@media` rule is itself a logical operator that is basically stating that \u201cif\u201d the following types and features are matches, then do some stuff.\n\n#### `and`\n\nBut we can use the `and` operator if we want to target screens within a range of widths:\n\n```\n/* Matches screen between 320px AND 768px */\n@media screen (min-width: 320px) and (max-width: 768px) {\n  .element {\n    /* Styles! */\n  }\n}\n```\n\n#### `or` (or comma-separated)\n\nWe can also comma-separate features as a way of using an `or` operator to match different ones:\n\n```\n/* \n  Matches screens where either the user prefers dark mode or the screen is at least 1200px wide */\n@media screen (prefers-color-scheme: dark), (min-width 1200px) {\n  .element {\n    /* Styles! */\n  }\n}\n```\n\n#### `not`\n\nPerhaps we want to target devices by what they do **not** support or match. This declaration removes the body\u2019s background color when the device is a printer and can only show one color.\n\n```\n@media print and ( not(color) ) {\n  body {\n    background-color: none;\n  }\n}\n```\n\nWant to go deeper? Check out [\u201cCSS Media Queries: Quick Reference & Guide\u201d](https://www.digitalocean.com/community/tutorials/css-media-queries?utm_medium=content_acq&utm_source=css-tricks&utm_campaign=&utm_content=awareness_bestsellers) from the DigitalOcean community for more examples that follow the syntax for media quieries.\n\n---\n\n### Do you really need CSS media queries?\n\nMedia queries are a powerful tool in your CSS toolbox with exciting hidden gems. But if you accomodate your design to every possible situation you\u2019ll end up with a codebase that\u2019s too complex to maintain and, as we all know, CSS is like a bear cub: cute and inoffensive but when it grows it will eat you alive.\n\nThat\u2019s why I recommend following Ranald Mace\u2019s concept of Universal Design which is \u201c*the design of products to be usable by all people, to the greatest extent possible, without the need for adaptation or specialized design.\u201d*\n\nIn [\u201cAccessibility for Everyone\u201d](https://abookapart.com/products/accessibility-for-everyone) Laura Kalbag explains that the difference between accessible and universal design is subtle but important. An accessible designer would create a large door for people on a wheel chair to enter, while a universal designer would produce an entry that anyone would fit disregarding of their abilities.\n\nI know that talking about universal design on the web is hard and almost sound utopian, but think about it, there are around [150 different browsers](https://en.wikipedia.org/wiki/List_of_web_browsers), around 50 different combinations of user preferences, and as we mentioned before more than 24000 different and unique Android devices alone.\n\nThis means that there are at least 18 million possible cases in which your content might be displayed. In the words of the fantastic [Miriam Suzanne](https://twitter.com/MiriSuzanne/status/1261075490628005888), *\u201cCSS out here trying to do graphic design of unknown content on an infinite and unknown canvas, across operating systems, interfaces, & languages. There\u2019s no possible way for any of us to know what we\u2019re doing.\u201d*\n\nThat\u2019s why assuming is really dangerous, so when you design, develop and think about your products leave assumptions behind and use media queries to make sure that your content is displayed correctly in any contact and before any user.\n\n---\n\n### Matching value ranges\n\nMany of the media features outlined in the previous section \u2014 including `width`,\u00a0`height`, `color` and `color-index` \u2014 can be prefixed with `min-` or `max-` to express minimum or maximum constraints. We\u2019ve already seen these in use throughout many of the examples, but the point is that we can create a range of value to match instead of having to declare specific values.\n\nIn the following snippet, we\u2019re painting the body\u2019s background purple when the viewport width is wider than 30em and narrower than 80em. If the viewport width does not match that range of values, then it will fallback to white.\n\n```\nbody {\n  background-color: #fff;\n}\n\n@media (min-width: 30em) and (max-width: 80em) {\n  body {\n    background-color: purple;\n  }\n}\n```\n\nMedia Queries Level 4 specifies a [new and simpler syntax](https://www.w3.org/TR/mediaqueries-4/#mq-ranges) using less then\u00a0(`<`), greater than\u00a0(`>`)\u00a0and\u00a0equals (`=`) operators. So, that last example can be converted to the new syntax, like so:\n\n```\n@media (30em <= width <= 80em) {\n  /* ... */\n}\n```\n\n---\n\n### Nesting and complex decision making\n\nCSS allows you to nest at-rules or group statements using parentheses, making it possible to go as deep as we want to evaluate complex operations.\n\n```\n@media (min-width: 20em), not all and (min-height: 40em) {  \n  @media not all and (pointer: none) { ... }\n  @media screen and ( (min-width: 50em) and (orientation: landscape) ), print and ( not (color) ) { ... }\n}\n```\n\n**Be careful!** even thought it\u2019s possible to create powerful and complex expressions, you might end up with a very opinionated, hard to maintain query. As Brad Frost [puts it](https://bradfrost.com/blog/post/7-habits-of-highly-effective-media-queries/): \u201cThe more complex our interfaces are, the more we have to think to maintain them properly.\u201d\n\n---\n\n### Accessibility\n\nMany of the features added in Media Queries Level 4 are centered around accessibility.\n\n#### `prefers-reduced-motion`\n\n`prefers-reduced-motion` detects if the user has the reduced motion preference activated to minimize the amount of movements and animations. It takes two values:\n\n- `no-preference`: Indicates that the user has made no preference known to the system.\n- `reduce`: Indicates that user has notified the system that they prefer an interface that minimizes the amount of movement or animation, preferably to the point where all non-essential movement is removed.\n\n![](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/macos-preference-motion.png?resize=1560%2C1176&ssl=1)\n\nThis preference is generally used by people who suffer from vestibular disorder or vertigo, where different movements result in loss of balance, migraine, nausea or hearing loss. If you ever tried to spin quickly and got dizzy, you know what it feels like.\n\nIn a [fantastic article](https://css-tricks.com/revisiting-prefers-reduced-motion-the-reduced-motion-media-query/) by Eric Bailey, he suggests stopping all animations with this code:\n\n```\n@media screen and (prefers-reduced-motion: reduce) {  \n  * {\n    /* Very short durations means JavaScript that relies on events still works */\n    animation-duration: 0.001ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.001ms !important;\n  }\n}\n```\n\nPopular frameworks like [Bootstrap have this feature on by default](https://v5.getbootstrap.com/docs/5.0/getting-started/accessibility/#reduced-motion). In my opinion there is no excuse not to use `prefers-reduced-motion` \u2014 just use it.\n\n#### `prefers-contrast`\n\nThe\u00a0`prefers-contrast`\u00a0feature informs whether the user has chosen to increase or reduce contrast in their system preferences or the browser settings. It takes three values:\n\n- `no-preference`:\u00a0When a user has made no preference known to the system. If you use it as a boolean it\u2019ll evaluate\u00a0false.\n- `high`:\u00a0When a user has selected the option to display a higher level of contrast.\n- `low`:\u00a0When a user has selected the option to display a lower level of contrast.\n\n![](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/macos-preference-contrast.png?resize=1560%2C1176&ssl=1)\n\nAt the moment of writing this feature is not supported by any browser. Microsoft has done a\u00a0[non-standard earlier implementation](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/-ms-high-contrast)\u00a0with the`-ms-high-contrast`\u00a0feature that works only on Microsoft Edge v18 or earlier\u00a0(but not\u00a0Chromium-based versions).\n\n```\n.button {\n  background-color: #0958d8;\n  color: #fff;\n}\n\n@media (prefers-contrast: high) {\n  .button {\n    background-color: #0a0db7;\n  }\n}\n```\n\nThis example is increasing the contrast of a the class button from AA to AAA when the user has high contrast on.\n\n#### `inverted-colors`\n\nThe\u00a0`inverted-colors`\u00a0feature informs whether the user has chosen to invert the colors on their system preferences or the browser settings. Sometimes this option is used as an alternative to high contrast. It takes two values:\n\n- `none`:\u00a0When colors are displayed normally\n- `inverted`:\u00a0When a user has selected the option\u00a0to invert colors\n\n![MacOS accessibility preferences.](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/macos-preference-invert-colors.png?resize=1560%2C1176&ssl=1)\n\nThe problem with inverted colors is that it\u2019ll also invert the colors of images and videos, making them look like x-ray images. By using a CSS invert filter you can select all images and videos and invert them back.\n\n```\n@media (inverted-colors) {\n  img, video { \n    filter: invert(100%);\n  }\n}\n```\n\nAt the time of writing this feature is only supported by Safari.\n\n#### `prefers-color-scheme`\n\nHaving a \u201cdark mode\u201d color scheme is something we\u2019re seeing a lot more of these days, and thanks to the\u00a0`prefers-color-scheme`\u00a0feature, we can tap into a user\u2019s system or browser preferences to determine whether we serve a \u201cdark\u201d or a \u201clight\u201d theme based on the ir preferences.\n\nIt takes two values:\n\n- `light`:\u00a0When a user has selected that they prefer a light theme or has no active preferences\n- `dark`:\u00a0When a user has selected a dark display in their settings\n\n![](https://paper-attachments.dropbox.com/s_0BFBF55A2024DE950EFA25781444032C5BBE17E7EC9DD277E9E0361558E9B210_1595791834440_Screen+Shot+2020-07-26+at+4.28.13+PM.png)\n\n```\nbody {\n  --bg-color: white; \n  --text-color: black;\n\n  background-color: var(--bg-color);\n  color: var(--text-color);\n}\n\n@media screen and (prefers-color-scheme: dark) {\n  body {\n    --bg-color: black;\n    --text-color: white;\n  }\n}\n```\n\nAs Adhuham explains in the\u00a0[complete guide to Dark Mode](https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/)\u00a0there is way more to it than just changing the color of the background. Before you jump into doing dark mode remember that if you don\u2019t have a very smart implementation strategy you might end up with a code base that\u2019s really hard to maintain.\u00a0[CSS variables](https://css-tricks.com/theming-with-variables-globals-and-locals/)\u00a0can do wonders for it but that\u2019s a subject for another article.\n\n---\n\n### What lies ahead?\n\n[Media Queries Level 5](https://www.w3.org/TR/mediaqueries-5/) is currently in Working Draft status, which means a lot can change between now and when it becomes a recommendation. But it includes interesting features that are worth mentioning because they open up new ways to target screens and adapt designs to very specific conditions.\n\n#### User preference media features\n\nHey, we just covered these in the last section! Oh well. These features are exciting because they\u2019re informed by a user\u2019s actual settings, whether they are from the user agent or even at the operating system level.\n\n#### Detecting a forced color palette\n\nThis is neat. Some browsers will limit the number of available colors that can be used to render styles. This is called [\u201cforced colors mode\u201d](https://www.w3.org/TR/css-color-adjust-1/#forced-colors-mode) and, if enabled in the browser settings, the user can choose a limited set of colors to use on a page. As a result, the user is able to define color combinations and contrasts that make content more comfortable to read.\n\nThe `forced-colors` feature allows us to detect if a forced color palette is in use with the `active` value. If matched, the browser must provide the required color palette through the CSS system colors. The browser is also given the leeway to determine if the background color of the page is light or dark and, if appropriate, trigger the appropriate `prefers-color-scheme` value so we can adjust the page.\n\n#### Detecting the maximum brightness, color depth, and contrast ratio\n\nSome devices (and browsers) are capable of super bright displays, rendering a wide range of colors, and high contrast ratios between colors. We can detect those devices using the `dynamic-range` feature, where the `high` keyword matches these devices and `standard` matches everything else.\n\nWe\u2019re likely to see changes to this because, as of right now, there\u2019s still uncertainty about what measurements constitute \u201chigh\u201d levels of brightness and contrast. The browser may get to make that determination.\n\n#### Video prefixed features\n\nThe spec talks about some screens, like TVs, that are capable of displaying video and graphics on separate \u201cplanes\u201d which might be a way of distinguishing the video frame from other elements on the screen. As such, Media Queries Level 5 is proposing a new set of media features aimed at [detecting video characteristics](https://www.w3.org/TR/mediaqueries-5/#video-prefixed-features), including color gamut and dynamic range.\n\nThere are also proposals to detect video height, width and resolution, but [the jury\u2019s still out](https://github.com/w3c/csswg-drafts/issues/5044) on whether those are the right ways to address video.\n\n---\n\n### Browser support\n\nBrowsers keep evolving and since by the time you are reading this post chances are that browser support for this feature might change, please check [MDN updated browser compatibility table](https://developer.mozilla.org/en-US/docs/Web/CSS/@media).\n\n---\n\n### A note on container queries\n\nWouldn\u2019t be cool if components could adapt themselves on their own size instead of the browser\u2019s? That\u2019s what the concept of [CSS Container Queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries) is all about. We currently only have the browser screen to make those changes via media queries.\n\nThat\u2019s unfortunate, as the viewport isn\u2019t always a direct relationship to how big the element itself is. Imagine a widget that renders in many different contexts on a site: sometimes in a sidebar, sometimes in a full-width footer, sometimes in a grid with unknown columns.\n\nThis is the problem that container queries try to solve. Ideally we could adapt styles of an element according to the size of itself instead of of the size of the viewport. Chrome 105 released support for CSS Container Queries. Same deal with Safari 16.1. Firefox is all we\u2019re really waiting at the time of writing to get broad support.\n\nThis browser support data is from [Caniuse](http://caniuse.com/#feat=css-container-queries), which has more detail. A number indicates that browser supports the feature at that version and up.\n\n#### Desktop\n\n| Chrome | Firefox | IE | Edge | Safari |\n| --- | --- | --- | --- | --- |\n| 106 | 110 | No | 106 | 16.0 |\n\n#### Mobile / Tablet\n\n| Android Chrome | Android Firefox | Android | iOS Safari |\n| --- | --- | --- | --- |\n| 144 | 147 | 144 | 16.0 |\n\n---\n\n### Examples\n\nLet\u2019s look at a bunch of media query examples. There are so many combinations of media types, features, and operators that the number of possibilities we could show would be exhaustive. Instead, we\u2019ll highlight a handful based on specific media features.\n\n#### Adjust layout at different viewport widths\n\nMore info \n\nThis is the probably the most widely used media feature. It informs the width of the browser\u2019s viewport including the scrollbar. It unlocked the CSS implementation of what Ethan Marcotte famously coined [*responsive design*](https://alistapart.com/article/responsive-web-design/): a process by which a design responds to the size of the viewport using a combination of a fluid grid, flexible images, and responsive typesetting.\n\nLater, Luke Wroblewski evolved the concept of responsive design by introducing the term [*mobile-first*](https://abookapart.com/products/mobile-first), encouraging designers and developers to start with the small-screen experience first then progressively enhance the experience as the screen width and device capabilities expand.\n\nA mobile-first can usually be spotted by it\u2019s use of `min-width` instead of `max-width`. If we start with `min-width`, we\u2019re essentially saying, *\u201chey, browser, start here and work up.\u201d* On the flip side, `max-width` is sort of like prioritizing larger screens.\n\nOne approach for defining breakpoints by width is using the dimensions of [standard devices](https://css-tricks.com/snippets/css/media-queries-for-standard-devices/), like the *exact* pixel width of an iPhone. But there are many, many (many), many different phones, tables, laptops, and desktops. Looking at Android alone, there are more than 24,000 variations of viewport sizes, resolutions, operating systems, and browsers, as of August 2015.\n\nSo, while targeting the precise width of a specific device might be helpful for troubleshooting or one-off fixes, it\u2019s probably not the most robust solution for maintaining a responsive architecture. This isn\u2019t a new idea by any stretch. Brad Frost was already preaching the virtues of letting content \u2014 not devices \u2014 determine breakpoints in his post [\u201c7 habits of highly effective media queries\u201d](https://bradfrost.com/blog/post/7-habits-of-highly-effective-media-queries/) published back in 2013.\n\nAnd even though media queries are still a valid tool to create responsive interfaces, there are many situations where it\u2019s possible to avoid using width at all. Modern CSS allow us to create flexible layouts with CSS grid and flex that adapts our content to the viewport size without a need to add breakpoints. For example, here is a grid layout that adapts how many columns it will have [without any media queries at all](https://css-tricks.com/books/greatest-css-tricks/flexible-grids/).\n\n```\n.container {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n}\n```\n\nThere are many articles about thinking beyond width, [I wrote about it a few years ago](https://css-tricks.com/mobile-small-portrait-slow-interlace-monochrome-coarse-non-hover-first/) and I recommend checking out Una Kravet\u2019s [Ten modern layouts in one line of CSS](https://web.dev/one-line-layouts/).\n\n---\n\n#### Dark mode\n\nMore info \n\nThis example is pulled straight from our [Guide to Dark Mode on the Web](https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/). The idea is that we can detect whether a user\u2019s system settings are configured to light or dark mode using the `prefers-color-scheme` feature and then define an alternate set of colors for the rendered UI.\n\nCombining this technique with CSS custom properties makes things even easier because they act like variables that we only need to define once, then use throughout the code. Need to swap colors? Change the custom property value and it updates everywhere. That\u2019s exactly what `prefers-color-scheme` does. We define a set of colors as custom properties, then redefine them inside a media query using the `prefer-color-scheme` feature to change colors based on the user\u2019s settings.\n\n---\n\n#### Detecting orientation, hover and motion on a responsive card gallery\n\nMore info \n\nThis gallery is responsive without using the `width` feature.\n\nIt detects the `orientation` of the viewport. If it\u2019s a `portrait` viewport, the sidebar will became a header; if it\u2019s `landscape` it stays off to the side.\n\nUsing the `pointer` media feature, it decides if the main input device is `coarse` \u2014 like a finger \u2014 or `fine` \u2014 like a mouse cursor \u2014 to set the size of the clickable areas of the checkboxes.\n\nThen, by using the `hover` media feature, the example checks if the device is capable of hovering (like a mouse cursor) and display a checkbox in each card.\n\nThe animations are removed when `prefers-reduced-motion` is set to `reduce`.\n\nAnd did you notice something? We\u2019re actually *not* using media queries for the actual layout and sizing of the cards! That\u2019s handled using the `minmax()` function on the `.container` element to show how responsive design doesn\u2019t always mean using media queries.\n\nIn short, this is a fully responsive app without ever measuring `width` or making assumptions.\n\n#### Target an iPhone in landscape mode\n\n```\n/* iPhone X Landscape */\n@media only screen \n  and (min-device-width: 375px) \n  and (max-device-width: 812px) \n  and (-webkit-min-device-pixel-ratio: 3)\n  and (orientation: landscape) { \n  /* Styles! */\n}\n```\n\nMore info \n\nThe `orientation` media feature tests whether a device is rotated the wide way (landscape) or the tall way (portrait).\n\n![](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/portrait-landscape-1024x595.jpg?resize=1024%2C595&ssl=1)\n\nWhile media queries are unable to know exactly which device is being used, we can use the exact dimensions of a specific device. The snippet above is targets the iPhone X.\n\n#### Apply a sticky header for large viewports\n\nMore info \n\nIn the example above, we\u2019re using `height` to detached fixed elements and avoid taking up too much screen real estate when the screen is too short. A horizontal navigation bar is in a fixed position when the screen is tall, but detaches itself on shorter screens.\n\nLike the `width` feature, `height` detects the height of the viewport, including the scrollbar. Many of us browse the web on small devices with narrow viewports, making designing for different heights more relevant than ever. Anthony Colangelo describes [how Apple uses the `height` media feature](https://cognition.happycog.com/article/go-vertical/) in a meaningful way to deal with the size of the hero image as the viewport\u2019s height changes.\n\n---\n\n#### Responsive (fluid) typography\n\nMore info \n\nA font can look either too big or too small, depending on the size of the screen that\u2019s showing it. If we\u2019re working on a small screen, then chances are that we\u2019ll want to use smaller type than what we\u2019d use on a much larger screen.\n\nThe idea here is that we\u2019re using the browser\u2019s width to scale the font size. We set a default font size on the `<html>` that acts as the \u201csmall\u201d font size, then set another font size using a media query that acts as the \u201clarge\u201d font size. In the middle? We set the font size again, but inside another media query that calculates a size based on the browser width.\n\nThe beauty of this is that it allows the font size to adjust based on the browser width, but never go above or below certain sizes. However, there is a [much simpler way to go about this](https://css-tricks.com/simplified-fluid-typography/) that requires no media queries at all, thanks to newer CSS features, like `min()`, `max()`, and `clamp()`.\n\n---\n\n#### Provide bigger touch targets when devices have a `course` pointer\n\nMore info \n\nHave you ever visited a site that had *super* tiny buttons? Some of us have fat fingers making it tough to tap an object accurately without inadvertently tapping something else instead.\n\nSure, we can rely on the `width` feature to tell if we\u2019re dealing with a small screen, but we can also detect if the device is capable of hovering over elements. If it isn\u2019t then it\u2019s probably a touch device, or perhaps a device that supports both, like the Microsoft Surface.\n\nThe demo above uses checkboxes as an example. Checkboxes can be a pain to tap on when viewing them on a small screen, so we\u2019re increasing the size and not requiring a hover if the device is incapable of `hover` events.\n\nAgain, this approach isn\u2019t always accurate. Check out [Patrick Lauke\u2019s thorough article](https://css-tricks.com/interaction-media-features-and-their-potential-(for-incorrect-assumptions)) that details potential issues working with `hover`, `pointer`, `any-hover` and `any-pointer`.\n\n### Specifications\n\n- [Media Queries Level 4](https://www.w3.org/TR/mediaqueries-4/) (Candidate Recommendation)\n- [Media Queries Level 5](https://www.w3.org/TR/mediaqueries-5/) (Working Draft)\n\n---\n\nSpecial thanks to Sarah Rambacher who helped to review this guide.",
  "tags": [
    "css-tricks",
    "guides",
    "css",
    "snippets"
  ],
  "extracted_at": "2026-02-03T12:46:38.307468+00:00",
  "content_length": 35538,
  "content_hash": "4ad461f787712580"
}