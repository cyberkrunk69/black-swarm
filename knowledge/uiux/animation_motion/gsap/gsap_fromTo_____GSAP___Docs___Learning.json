{
  "id": "gsap__docs_v3_GSAP_gsap_fromTo___",
  "source_id": "gsap",
  "source_name": "GSAP",
  "category": "animation_motion",
  "url": "https://gsap.com/docs/v3/GSAP/gsap.fromTo()/",
  "title": "gsap.fromTo() | GSAP | Docs & Learning",
  "content": "On this page\nReturns :\nTween\n\u00e2\u0080\u008b\nfrom() and fromTo()\nFor a quick overview, check out this video from the\n\"GSAP 3 Express\" course\nby Snorkl.tv - one of the best ways to learn the basics.\nA\ngsap.fromTo()\ntween lets you define\nBOTH\nthe starting and ending values for an animation (as opposed to\nfrom()\nand\nto()\ntweens which use the current state as either the start or end). This is great for having full control over an animation, especially when it is chained with other animations. For example:\n//animate \".box\" from an opacity of 0 to an opacity of 0.5\ngsap\n.\nfromTo\n(\n\".box\"\n,\n{\nopacity\n:\n0\n}\n,\n{\nopacity\n:\n0.5\n,\nduration\n:\n1\n}\n)\n;\nloading...\nSince GSAP can animate\nany\nproperty of\nany\nobject, you are\nNOT\nlimited to CSS properties or DOM objects. Go crazy. You may be surprised by how many things can be animated withGSAP and it \"just works\".\nTo control the Tween instance later, assign it to a variable (GSAP is conveniently object-oriented):\nlet\ntween\n=\ngsap\n.\nfromTo\n(\n\".class\"\n,\n{\nopacity\n:\n0\n}\n,\n{\nopacity\n:\n0.8\n,\nduration\n:\n1\n,\nease\n:\n\"elastic\"\n}\n)\n;\n//now we can control it!\ntween\n.\npause\n(\n)\n;\ntween\n.\nseek\n(\n2\n)\n;\ntween\n.\nprogress\n(\n0.5\n)\n;\ntween\n.\nplay\n(\n)\n;\n...\nTo simply fire off animations and let them run, there's no need to use variables. Tweens play immediately by default (though you can set a\ndelay\nor\npaused\nvalue) and when they finish, they automatically dispose of themselves. Call\ngsap.fromTo()\nas much as you want without worrying about cleanup.\nOther types of tweens:\nto()\n- You define the\nend\nvalues to animate\nto\n, GSAP uses the current values as the start values.\nfrom()\n- You define the\nstarting\nvalues to animate\n\"from\"\n, GSAP uses the current values as the destinations (like a tween running backwards).\nParameters\n\u00e2\u0080\u008b\ntargets\n- The object(s) whose properties you want to animate. This can be selector text like\n\".class\"\n,\n\"#id\"\n, etc. (GSAP uses\ndocument.querySelectorAll()\ninternally) or it can be direct references to elements,  generic objects, or even an array of objects.\nfromVars\n- An object containing the initial (starting) property/value pairs. You do\nNOT\nput special properties here like duration, delay, etc. - those go in the\ntoVars\ntoVars\n- An object containing the destination properties/values to animate to, along with any special properties like\nease\n,\nduration\n,\ndelay\n, or\nonComplete\n(listed below).\nSpecial Properties\n\u00e2\u0080\u008b\nAdd any of these to your\nvars\nobject to give your animation special powers:\nProperty\nDescription\ncallbackScope\nThe scope to be used for all of the callbacks (onStart, onUpdate, onComplete, etc.).\ndata\nAssign arbitrary data to this property (a string, a reference to an object, whatever) and it gets attached to the tween instance itself so that you can reference it later like\nyourTween.data\n.\ndelay\nAmount of delay before the animation should begin (in seconds).\nduration\nThe duration of the animation (in seconds). Default:\n0.5\nease\nControls the rate of change during the animation, giving it a specific feel. For example,\n\"elastic\"\nor\n\"strong.inOut\"\n. See the\nEase Visualizer\nfor a list of all of the options.\nease\ncan be a String (most common) or a function that accepts a progress value between 0 and 1 and returns a converted, similarly normalized value. Default:\n\"power1.out\"\nid\nAllows you to (optionally) assign a unique identifier to your tween instance so that you can find it later with\ngsap.getById()\nand it will show up in\nGSDevTools\nwith that id.\nimmediateRender\nNormally a tween waits to render for the first time until the very next tick (update cycle) unless you specify a delay. Set\nimmediateRender: true\nto force it to render immediately upon instantiation. Default:\nfalse\nfor\nto()\ntweens,\ntrue\nfor\nfrom()\nand\nfromTo()\ntweens or anything with a\nscrollTrigger\napplied.\ninherit\nNormally tweens inherit from their parent timeline's\ndefaults\nobject (if one is defined), but you can disable this on a per-tween basis by setting\ninherit: false\n.\nlazy\nWhen a tween renders for the very first time and reads its starting values, GSAP will try to delay writing of values until the very end of the current \"tick\" which can improve performance because it avoids the read/write/read/write layout thrashing that browsers dislike. To disable lazy rendering for a particular tween, set\nlazy: false\n. In most cases, there's no need to set\nlazy\n. To learn more, watch\nthis video\n.\nDefault:\ntrue\n(except for zero-duration tweens)\nonComplete\nA function to call when the animation has completed\nonCompleteParams\nAn Array of parameters to pass the onComplete function. For example,\ngsap.to(\".class\", {x:100, onComplete:myFunction, onCompleteParams:[\"param1\", \"param2\"]});\nonInterrupt\nA function to call when the animation is interrupted, meaning if/when the tween is killed before it completes. This could happen because its kill() method is called or due to overwriting.\nonInterruptParams\nAn Array of parameters to pass the onInterrupt function. For example,\ngsap.to(\".class\", {x:100, onInterrupt:myFunction, onInterruptParams:[\"param1\", \"param2\"]});\n.\nonRepeat\nA function to call each time the animation enters a new iteration cycle (repeats). Obviously this only occurs if you set a non-zero\nrepeat\n.\nonRepeatParams\nAn Array of parameters to pass the onRepeat function.\nonReverseComplete\nA function to call when the animation has reached its beginning again from the reverse direction (excluding repeats).\nonReverseCompleteParams\nAn Array of parameters to pass the onReverseComplete function.\nonStart\nA function to call when the animation begins (when its time changes from 0 to some other value which can happen more than once if the tween is restarted multiple times).\nonStartParams\nAn Array of parameters to pass the onStart function.\nonUpdate\nA function to call every time the animation updates (on each \"tick\" that moves its playhead).\nonUpdateParams\nAn Array of parameters to pass the onUpdate function.\noverwrite\nIf\ntrue\n, all tweens of the same targets will be killed immediately regardless of what properties they affect. If\n\"auto\"\n, when the tween renders for the first time it hunt down any conflicts in active animations (animating the same properties of the same targets) and kill\nonly those parts\nof the other tweens. Non-conflicting parts remain intact. If\nfalse\n, no overwriting strategies will be employed.\nDefault:\nfalse\npaused\nIf\ntrue\n, the animation will pause itself immediately upon creation.\nDefault:\nfalse\nrepeat\nHow many times the animation should repeat. So\nrepeat: 1\nwould play a total of two iterations. Use -1 to repeat infinitely.\nDefault:\n0\nrepeatDelay\nAmount of time to wait between repeats (in seconds).\nDefault:\n0\nrepeatRefresh\nSetting\nrepeatRefresh: true\ncauses a repeating tween to\ninvalidate()\nand re-record its starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example,\nx: \"random(-100, 100)\"\nwould get a new random x value on each repeat.\nduration\n,\ndelay\n, and\nstagger\ndo\nNOT\nrefresh.\nreversed\nIf\ntrue\n, the animation will start out with its playhead reversed, meaning it will be oriented to move toward its start. Since the playhead begins at a time of 0 anyway, a reversed tween will\nappear\npaused initially because its playhead cannot move backward past the start.\nrunBackwards\nIf\ntrue\n, the animation will invert its starting and ending values (this is what a\nfrom()\ntween does internally), though the ease doesn't get flipped. In other words, you can make a\nto()\ntween into a\nfrom()\nby setting\nrunBackwards: true\n.\nstagger\nIf multiple targets are defined, you can easily\nstagger\nthe start times for each by setting a value like\nstagger: 0.1\n(for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see\nthe stagger documentation\n.\nstartAt\nDefines starting values for any properties (even if they're not animating). For example,\nstartAt: {x: -100, opacity: 0}\nyoyo\nIf\ntrue\n, every other\nrepeat\niteration will run in the opposite direction so that the tween appears to go back and forth. This has no affect on the\nreversed\nproperty though. So if\nrepeat\nis\n2\nand\nyoyo\nis\nfalse\n, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if\nyoyo\nis\ntrue\n, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end.\nDefault:\nfalse\nyoyoEase\nAllows you to alter the ease in the tween's\nyoyo\nphase. Set it to a specific ease like\n\"power2.in\"\nor set it to\ntrue\nto simply invert the tween's normal\nease\n. Note: GSAP is smart enough to automatically set\nyoyo: true\nif you define any\nyoyoEase\n, so there's less code for you to write.\nDefault:\nfalse\nkeyframes\nTo animate the targets to various states, use\nkeyframes\n- an array of vars objects that serve as\nto()\ntweens. For example,\nkeyframes: [{x:100, duration:1}, {y:100, duration:0.5}]\n. All keyframes will be perfectly sequenced back-to-back, but you can define a\ndelay\nvalue to add spacing between each step (or a negative delay would create an overlap). Keyframes are only to be used in\nto()\ntweens.\nPlugins\n\u00e2\u0080\u008b\nA plugin adds extra capabilities to GSAP's core. Some plugins make it easier to work with rendering libraries like PIXI.js or EaselJS while other plugins add superpowers like\nmorphing\nSVG shapes, adding\ndrag and drop\nfunctionality, etc. This allows the GSAP core to remain relatively small and lets you add features only when you need them.\nSee the full list of plugins here\n.\nFunction-based values\n\u00e2\u0080\u008b\nGet incredibly dynamic animations by using a function for any value, and it will get called\nonce for each target\nthe first time the tween renders, and whatever is returned by that function will be used as the value. This can be very useful for applying conditional logic or randomizing things (though GSAP has baked-in randomizing capabilities too...scroll down for that).\ngsap\n.\nfromTo\n(\n\".class\"\n,\n{\nx\n:\n100\n,\n//normal value\ny\n:\nfunction\n(\nindex\n,\ntarget\n,\ntargets\n)\n{\n//function-based value\nreturn\nindex \\\n*\n50\n;\n}\n}\n,\n{\nx\n:\n50\n,\ny\n:\n0\n,\nduration\n:\n1\n}\n)\n;\nThe function is passed three parameters:\nindex - The index of the target in the array. For example, if there are 3\n<div>\nelements with the class \".box\", and you\ngsap.from(\".box\", ...)\n, the function gets called 3 times (once for each target); the index would be\n0\nfirst, then\n1\n, and finally\n2\n.\ntarget - The target itself (the\n<div>\nelement in this example).\ntargets - The array of targets (same as\ntween.targets()\n).\nRandom values\n\u00e2\u0080\u008b\nDefine random values as a string like\n\"random(-100, 100)\"\nfor a range or like\n\"random([red, blue, green])\"\nfor an array and GSAP will swap in a random value\nfor each target\naccordingly! This makes advanced randomized effects simple. You can even have the random number rounded to the closest increment of any number! For example:\ngsap\n.\nfromTo\n(\n\".class\"\n,\n{\nx\n:\n\"random(-100, 100, 5)\"\n,\n//chooses a random number between -100 and 100 for each target, rounding to the closest 5!\n}\n,\n{\nx\n:\n50\n,\n}\n)\n;\nOr use an array-like value and GSAP will randomly select one of those:\ngsap\n.\nfromTo\n(\n\".class\"\n,\n{\nx\n:\n\"random([0, 100, 200, 500])\"\n,\n//randomly selects one of the values (0, 100, 200, or 500)\n}\n,\n{\nx\n:\n150\n,\n}\n)\n;\nThere's also a\ngsap.utils.random()\nfunction that you can use directly if you prefer.\nStaggers\n\u00e2\u0080\u008b\nIf multiple targets are defined, you can easily\nstagger\n(offset) the start times for each by setting a value like\nstagger: 0.1\n(for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see\nthe stagger documentation\n.\nSequencing\n\u00e2\u0080\u008b\nFor basic sequencing, you could use a\ndelay\non each tween (like\ngsap.fromTo(\".class\", {x: 50}, {delay: 0.5, duration: 1, x: 100})\n), but we\nstrongly\nrecommended using a\nTimeline\nfor all but the simplest sequencing tasks because it gives you much greater flexibility, especially when you're experimenting with timing. It allows you to append tweens one-after-the-other and then control the entire sequence as a whole. You can even have the tweens overlap as much as you want,  nest timelines as deeply as you want, and much, much more.\nTimelines have convenient\nto()\n,\nfrom()\n, and\nfromTo()\nmethods as well so you can very easily chain them together and build complex sequences:\n0\n1\n2\nblueSpin\n3\n4\nPlay\nnote\nBy default,\nimmediateRender\nis\ntrue\nin\nfromTo()\ntweens, meaning that they immediately render their starting state regardless of any delay that is specified. You can override this behavior by passing\nimmediateRender: false\nin the\nvars\nparameter so that it will wait to render until the tween actually begins (often the desired behavior when inserting into Timelines). So the following code will immediately set the\nopacity\nof\nobj\nto 0 and then wait 2 seconds before tweening the opacity back to 1 over the course of 1.5 seconds:\ngsap\n.\nfromTo\n(\nobj\n,\n{\nopacity\n:\n0\n}\n,\n{\nduration\n:\n1.5\n,\nopacity\n:\n1\n,\ndelay\n:\n2\n}\n)\n;\nCallbacks\n\u00e2\u0080\u008b\nCallbacks are functions that are called after certain events happen in a tween or timeline like when they start, complete, repeat, reverse complete, or update. They can be very useful for debugging, keeping different parts of your project in sync, and many other things.\nCallbacks\nTo learn more about GSAP's callbacks, check out this video from the\n\"GSAP 3 Express\" course\nby Snorkl.tv - one of the best ways to learn the basics of GSAP 3.\nContents\nReturns : Tween\nParameters\nSpecial Properties\nPlugins\nFunction-based values\nRandom values\nStaggers\nSequencing\nCallbacks",
  "content_markdown": "On this page\n\n### Returns : [Tween](/docs/v3/GSAP/Tween)[\u00e2\u0080\u008b](#returns--tween \"Direct link to returns--tween\")\n\nfrom() and fromTo()\n\nFor a quick overview, check out this video from the [\"GSAP 3 Express\" course](https://courses.snorkl.tv/courses/gsap-3-express?ref=44f484) by Snorkl.tv - one of the best ways to learn the basics.\n\nA `gsap.fromTo()` tween lets you define **BOTH** the starting and ending values for an animation (as opposed to [from()](/docs/v3/GSAP/gsap.from()) and [to()](/docs/v3/GSAP/gsap.to()) tweens which use the current state as either the start or end). This is great for having full control over an animation, especially when it is chained with other animations. For example:\n\n```\n//animate \".box\" from an opacity of 0 to an opacity of 0.5  \ngsap.fromTo(\".box\", { opacity: 0 }, { opacity: 0.5, duration: 1 });\n```\n\n#### loading...\n\nSince GSAP can animate **any** property of **any** object, you are *NOT* limited to CSS properties or DOM objects. Go crazy. You may be surprised by how many things can be animated withGSAP and it \"just works\".\n\nTo control the Tween instance later, assign it to a variable (GSAP is conveniently object-oriented):\n\n```\nlet tween = gsap.fromTo(\".class\", {opacity: 0}, {opacity: 0.8, duration: 1, ease: \"elastic\"});  \n  \n//now we can control it!  \ntween.pause();  \ntween.seek(2);  \ntween.progress(0.5);  \ntween.play();  \n...\n```\n\nTo simply fire off animations and let them run, there's no need to use variables. Tweens play immediately by default (though you can set a `delay` or `paused` value) and when they finish, they automatically dispose of themselves. Call `gsap.fromTo()` as much as you want without worrying about cleanup.\n\nOther types of tweens:\n\n- [to()](/docs/v3/GSAP/gsap.to()) - You define the **end** values to animate *to*, GSAP uses the current values as the start values.\n- [from()](/docs/v3/GSAP/gsap.from()) - You define the **starting** values to animate *\"from\"*, GSAP uses the current values as the destinations (like a tween running backwards).\n\n## Parameters[\u00e2\u0080\u008b](#parameters \"Direct link to Parameters\")\n\n1. **targets** - The object(s) whose properties you want to animate. This can be selector text like `\".class\"`, `\"#id\"`, etc. (GSAP uses [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) internally) or it can be direct references to elements, generic objects, or even an array of objects.\n2. **fromVars** - An object containing the initial (starting) property/value pairs. You do **NOT** put special properties here like duration, delay, etc. - those go in the `toVars`\n3. **toVars** - An object containing the destination properties/values to animate to, along with any special properties like `ease`, `duration`, `delay`, or `onComplete` (listed below).\n\n## Special Properties[\u00e2\u0080\u008b](#special-properties \"Direct link to Special Properties\")\n\nAdd any of these to your `vars` object to give your animation special powers:\n\n### Property\n\n### Description\n\n- #### callbackScope\n\n  The scope to be used for all of the callbacks (onStart, onUpdate, onComplete, etc.).\n- #### data\n\n  Assign arbitrary data to this property (a string, a reference to an object, whatever) and it gets attached to the tween instance itself so that you can reference it later like `yourTween.data`.\n- #### delay\n\n  Amount of delay before the animation should begin (in seconds).\n- #### duration\n\n  The duration of the animation (in seconds). Default: `0.5`\n- #### ease\n\n  Controls the rate of change during the animation, giving it a specific feel. For example, `\"elastic\"` or `\"strong.inOut\"`. See the [Ease Visualizer](/docs/v3/Eases) for a list of all of the options. `ease` can be a String (most common) or a function that accepts a progress value between 0 and 1 and returns a converted, similarly normalized value. Default: `\"power1.out\"`\n- #### id\n\n  Allows you to (optionally) assign a unique identifier to your tween instance so that you can find it later with `gsap.getById()` and it will show up in [GSDevTools](/docs/v3/Plugins/GSDevTools/) with that id.\n- #### immediateRender\n\n  Normally a tween waits to render for the first time until the very next tick (update cycle) unless you specify a delay. Set `immediateRender: true` to force it to render immediately upon instantiation. Default: `false` for [to()](/docs/v3/GSAP/gsap.to()) tweens, `true` for [from()](/docs/v3/GSAP/gsap.from()) and [fromTo()](/docs/v3/GSAP/gsap.fromTo()) tweens or anything with a [scrollTrigger](/docs/v3/Plugins/ScrollTrigger) applied.\n- #### inherit\n\n  Normally tweens inherit from their parent timeline's `defaults` object (if one is defined), but you can disable this on a per-tween basis by setting `inherit: false`.\n- #### lazy\n\n  When a tween renders for the very first time and reads its starting values, GSAP will try to delay writing of values until the very end of the current \"tick\" which can improve performance because it avoids the read/write/read/write layout thrashing that browsers dislike. To disable lazy rendering for a particular tween, set `lazy: false`. In most cases, there's no need to set `lazy`. To learn more, watch [this video](https://www.youtube.com/watch?v=TMHJptqnDpU). Default: `true` (except for zero-duration tweens)\n- #### onComplete\n\n  A function to call when the animation has completed\n- #### onCompleteParams\n\n  An Array of parameters to pass the onComplete function. For example, `gsap.to(\".class\", {x:100, onComplete:myFunction, onCompleteParams:[\"param1\", \"param2\"]});`\n- #### onInterrupt\n\n  A function to call when the animation is interrupted, meaning if/when the tween is killed before it completes. This could happen because its kill() method is called or due to overwriting.\n- #### onInterruptParams\n\n  An Array of parameters to pass the onInterrupt function. For example, `gsap.to(\".class\", {x:100, onInterrupt:myFunction, onInterruptParams:[\"param1\", \"param2\"]});`.\n- #### onRepeat\n\n  A function to call each time the animation enters a new iteration cycle (repeats). Obviously this only occurs if you set a non-zero `repeat`.\n- #### onRepeatParams\n\n  An Array of parameters to pass the onRepeat function.\n- #### onReverseComplete\n\n  A function to call when the animation has reached its beginning again from the reverse direction (excluding repeats).\n- #### onReverseCompleteParams\n\n  An Array of parameters to pass the onReverseComplete function.\n- #### onStart\n\n  A function to call when the animation begins (when its time changes from 0 to some other value which can happen more than once if the tween is restarted multiple times).\n- #### onStartParams\n\n  An Array of parameters to pass the onStart function.\n- #### onUpdate\n\n  A function to call every time the animation updates (on each \"tick\" that moves its playhead).\n- #### onUpdateParams\n\n  An Array of parameters to pass the onUpdate function.\n- #### overwrite\n\n  If `true`, all tweens of the same targets will be killed immediately regardless of what properties they affect. If `\"auto\"`, when the tween renders for the first time it hunt down any conflicts in active animations (animating the same properties of the same targets) and kill **only those parts** of the other tweens. Non-conflicting parts remain intact. If `false`, no overwriting strategies will be employed. Default: `false`\n- #### paused\n\n  If `true`, the animation will pause itself immediately upon creation. Default: `false`\n- #### repeat\n\n  How many times the animation should repeat. So `repeat: 1` would play a total of two iterations. Use -1 to repeat infinitely. Default: `0`\n- #### repeatDelay\n\n  Amount of time to wait between repeats (in seconds). Default: `0`\n- #### repeatRefresh\n\n  Setting `repeatRefresh: true` causes a repeating tween to `invalidate()` and re-record its starting/ending values internally on each full iteration (not including yoyo's). This is useful when you use dynamic values (relative, random, or function-based). For example, `x: \"random(-100, 100)\"` would get a new random x value on each repeat. `duration`, `delay`, and `stagger` do **NOT** refresh.\n- #### reversed\n\n  If `true`, the animation will start out with its playhead reversed, meaning it will be oriented to move toward its start. Since the playhead begins at a time of 0 anyway, a reversed tween will *appear* paused initially because its playhead cannot move backward past the start.\n- #### runBackwards\n\n  If `true`, the animation will invert its starting and ending values (this is what a [from()](/docs/v3/GSAP/gsap.from()) tween does internally), though the ease doesn't get flipped. In other words, you can make a `to()` tween into a `from()` by setting `runBackwards: true`.\n- #### stagger\n\n  If multiple targets are defined, you can easily [stagger](https://codepen.io/GreenSock/pen/938f5cd34818443c43af9ba2692137a5) the start times for each by setting a value like `stagger: 0.1` (for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see [the stagger documentation](/resources/getting-started/Staggers).\n- #### startAt\n\n  Defines starting values for any properties (even if they're not animating). For example, `startAt: {x: -100, opacity: 0}`\n- #### yoyo\n\n  If `true`, every other `repeat` iteration will run in the opposite direction so that the tween appears to go back and forth. This has no affect on the `reversed` property though. So if `repeat` is `2` and `yoyo` is `false`, it will look like: start - 1 - 2 - 3 - 1 - 2 - 3 - 1 - 2 - 3 - end. But if `yoyo` is `true`, it will look like: start - 1 - 2 - 3 - 3 - 2 - 1 - 1 - 2 - 3 - end. Default: `false`\n- #### yoyoEase\n\n  Allows you to alter the ease in the tween's `yoyo` phase. Set it to a specific ease like `\"power2.in\"` or set it to `true` to simply invert the tween's normal `ease`. Note: GSAP is smart enough to automatically set `yoyo: true` if you define any `yoyoEase`, so there's less code for you to write. Default: `false`\n- #### keyframes\n\n  To animate the targets to various states, use `keyframes` - an array of vars objects that serve as `to()` tweens. For example, `keyframes: [{x:100, duration:1}, {y:100, duration:0.5}]`. All keyframes will be perfectly sequenced back-to-back, but you can define a `delay` value to add spacing between each step (or a negative delay would create an overlap). Keyframes are only to be used in `to()` tweens.\n\n## Plugins[\u00e2\u0080\u008b](#plugins \"Direct link to Plugins\")\n\nA plugin adds extra capabilities to GSAP's core. Some plugins make it easier to work with rendering libraries like PIXI.js or EaselJS while other plugins add superpowers like [morphing](/docs/v3/Plugins/MorphSVGPlugin) SVG shapes, adding [drag and drop](/docs/v3/Plugins/Draggable) functionality, etc. This allows the GSAP core to remain relatively small and lets you add features only when you need them. [See the full list of plugins here](/docs/v3/Plugins).\n\n## Function-based values[\u00e2\u0080\u008b](#function-based-values \"Direct link to Function-based values\")\n\nGet incredibly dynamic animations by using a function for any value, and it will get called **once for each target** the first time the tween renders, and whatever is returned by that function will be used as the value. This can be very useful for applying conditional logic or randomizing things (though GSAP has baked-in randomizing capabilities too...scroll down for that).\n\n```\ngsap.fromTo(\".class\", {  \n  x: 100, //normal value  \n  y: function(index, target, targets) { //function-based value  \n    return index \\* 50;  \n  }  \n},  \n{  \n  x: 50,  \n  y: 0,  \n  duration: 1  \n});\n```\n\nThe function is passed three parameters:\n\n1. index - The index of the target in the array. For example, if there are 3 `<div>` elements with the class \".box\", and you `gsap.from(\".box\", ...)`, the function gets called 3 times (once for each target); the index would be `0` first, then `1`, and finally `2`.\n2. target - The target itself (the `<div>` element in this example).\n3. targets - The array of targets (same as `tween.targets()`).\n\n## Random values[\u00e2\u0080\u008b](#random-values \"Direct link to Random values\")\n\nDefine random values as a string like `\"random(-100, 100)\"` for a range or like `\"random([red, blue, green])\"` for an array and GSAP will swap in a random value **for each target** accordingly! This makes advanced randomized effects simple. You can even have the random number rounded to the closest increment of any number! For example:\n\n```\ngsap.fromTo(\".class\",{  \n  x: \"random(-100, 100, 5)\", //chooses a random number between -100 and 100 for each target, rounding to the closest 5!  \n},  \n{  \n  x: 50,  \n});\n```\n\nOr use an array-like value and GSAP will randomly select one of those:\n\n```\ngsap.fromTo(  \n  \".class\",  \n  {  \n    x: \"random([0, 100, 200, 500])\", //randomly selects one of the values (0, 100, 200, or 500)  \n  },  \n  {  \n    x: 150,  \n  }  \n);\n```\n\nThere's also a [`gsap.utils.random()`](/docs/v3/GSAP/UtilityMethods/random()) function that you can use directly if you prefer.\n\n## Staggers[\u00e2\u0080\u008b](#staggers \"Direct link to Staggers\")\n\nIf multiple targets are defined, you can easily [stagger](https://codepen.io/GreenSock/pen/938f5cd34818443c43af9ba2692137a5) (offset) the start times for each by setting a value like `stagger: 0.1` (for 0.1 seconds between each start time). Or you can get much more advanced staggers by using a stagger object. For more information, see [the stagger documentation](/resources/getting-started/Staggers).\n\n## Sequencing[\u00e2\u0080\u008b](#sequencing \"Direct link to Sequencing\")\n\nFor basic sequencing, you could use a `delay` on each tween (like `gsap.fromTo(\".class\", {x: 50}, {delay: 0.5, duration: 1, x: 100})`), but we **strongly** recommended using a [`Timeline`](/docs/v3/GSAP/Timeline) for all but the simplest sequencing tasks because it gives you much greater flexibility, especially when you're experimenting with timing. It allows you to append tweens one-after-the-other and then control the entire sequence as a whole. You can even have the tweens overlap as much as you want, nest timelines as deeply as you want, and much, much more.\n\nTimelines have convenient [to()](/docs/v3/GSAP/Timeline/to()), [from()](/docs/v3/GSAP/Timeline/from()), and [fromTo()](/docs/v3/GSAP/Timeline/fromTo()) methods as well so you can very easily chain them together and build complex sequences:\n\n0\n\n1\n\n2blueSpin\n\n3\n\n4\n\nPlay\n\nnote\n\nBy default, `immediateRender` is `true` in `fromTo()` tweens, meaning that they immediately render their starting state regardless of any delay that is specified. You can override this behavior by passing `immediateRender: false` in the `vars` parameter so that it will wait to render until the tween actually begins (often the desired behavior when inserting into Timelines). So the following code will immediately set the `opacity` of `obj` to 0 and then wait 2 seconds before tweening the opacity back to 1 over the course of 1.5 seconds:\n\n```\ngsap.fromTo(obj, { opacity: 0 }, { duration: 1.5, opacity: 1, delay: 2 });\n```\n\n## Callbacks[\u00e2\u0080\u008b](#callbacks \"Direct link to Callbacks\")\n\nCallbacks are functions that are called after certain events happen in a tween or timeline like when they start, complete, repeat, reverse complete, or update. They can be very useful for debugging, keeping different parts of your project in sync, and many other things.\n\nCallbacks\n\nTo learn more about GSAP's callbacks, check out this video from the [\"GSAP 3 Express\" course](https://courses.snorkl.tv/courses/gsap3-beyond-the-basics?ref=44f484) by Snorkl.tv - one of the best ways to learn the basics of GSAP 3.\n\n## Contents\n\n- [Returns : Tween](#returns--tween)\n- [Parameters](#parameters)\n- [Special Properties](#special-properties)\n- [Plugins](#plugins)\n- [Function-based values](#function-based-values)\n- [Random values](#random-values)\n- [Staggers](#staggers)\n- [Sequencing](#sequencing)\n- [Callbacks](#callbacks)",
  "tags": [
    "gsap",
    "animation",
    "javascript",
    "scrolltrigger"
  ],
  "extracted_at": "2026-02-03T12:48:46.310217+00:00",
  "content_length": 13524,
  "content_hash": "ef2c7cd053f98f6e"
}