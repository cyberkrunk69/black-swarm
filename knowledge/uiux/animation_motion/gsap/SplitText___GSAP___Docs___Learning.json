{
  "id": "gsap__docs_v3_Plugins_SplitText_",
  "source_id": "gsap",
  "source_name": "GSAP",
  "category": "animation_motion",
  "url": "https://gsap.com/docs/v3/Plugins/SplitText/",
  "title": "SplitText | GSAP | Docs & Learning",
  "content": "On this page\nSplitText is a small JavaScript library that splits an HTML element's text into individual characters, words, and/or lines (each in its own, newly-created element), allowing you to create gorgeous staggered animations. It's highly configurable and smarter than other text splitting tools thanks to features like automatic screen reader accessibility, masking for reveal effects, responsive re-splitting, and much more.\nDetailed Walkthrough - Major rewrite in\nv3.13.0\n- half the size, 14 new features!\nFeatures\n\u00e2\u0080\u008b\nFeature Highlights\nThe new v3.13.0+ features are marked below with \"*\"\nScreen reader Accessibility\n* - Adds\naria-label\nto the split element(s) and\naria-hidden\nto the freshly-created line/word/character elements.\nResponsive re-splitting\n* - Avoid funky line breaks when resizing or when fonts load with\nautoSplit\nand\nonSplit()\n. Offers automatic cleanup and resuming of animations too!\nSlice right through nested elements\n* - Elements like\n<span>\n,\n<strong>\n, and\n<a>\nthat span multiple lines are handled effortlessly with\ndeepSlice\nso they don't stretch lines vertically.\nMasking\n* - Wrap characters, words or lines with an extra clipping element for easy mask/reveal effects.\nIntegrates seamlessly\nwith GSAP's\ncontext()\n,\nmatchMedia()\nand\nuseGSAP()\nFlexible targeting\n- Apply your own class names to characters, words, or lines. Append\n\"++\"\nto auto-increment them (e.g.\nword1\n,\nword2\n, etc.). Enable\npropIndex\n* to apply CSS variables like\n--word: 3\n.\nIgnore certain elements\n* - Perhaps you'd like to leave\n<sup>\nelements unsplit, for example.\nSupports emojis & more\n- SplitText does an excellent job with foreign characters too.\nRevert anytime\n- Restore the element's original\ninnerHTML\nanytime with\nrevert()\nHandle complex edge cases\nwith custom\nRegExp\n* or\nprepareText()\n*\nSplitting\n\u00e2\u0080\u008b\nBasic Usage\n\u00e2\u0080\u008b\nFeed\nSplitText.create()\nthe element(s) you'd like to split and it'll return a SplitText instance with\nchars\n,\nwords\n, and\nlines\nproperties where you can access the resulting elements.\n// the target can be selector text, an element, or an Array of elements\nlet\nsplit\n=\nSplitText\n.\ncreate\n(\n\".headline\"\n)\n;\n// Array of characters\nsplit\n.\nchars\n// Array of words\nsplit\n.\nwords\n// Array of lines\nsplit\n.\nlines\nConfiguration\n\u0000\u00e2\u0080\u008b\nBy default, SplitText will split by\ntype: \"lines, words, chars\"\n(meaning lines, words,\nand\ncharacters) but to maximize performance you should really only split what you need. Use the configuration object to control exactly which components are split apart, or to adjust accessibility settings, or apply your own classes or even apply masking effects.\nlet\nsplit\n=\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words, lines\"\n,\n// only split into words and lines (not characters)\nmask\n:\n\"lines\"\n,\n// adds extra wrapper element around lines with overflow: clip (v3.13.0+)\nlinesClass\n:\n\"line++\"\n,\n// adds \"line\" class to each line element, plus an incremented one too (\"line1\", \"line2\", \"line3\", etc.)\n// there are many other options - see below for a complete list\n}\n)\n;\nConfig Object\n\u00e2\u0080\u008b\nProperty\nDescription\naria*\n\"auto\" | \"hidden\" | \"none\"\n- SplitText can automatically add\naria\nattributes to the split element(s) as well as the line/word/character elements to improve accessibility. The options are:\n\"auto\"\n(the default) - adds an\naria label\nto the split element(s), populated by its\ntextContent\n, and also adds\naria hidden\nto the line/word/character elements inside the split. This ensures that the text is accessible to the majority of screen readers.\nThis approach will not honor the semantics or functionality of nested elements.\nIf you need to ensure that links inside your text content are visible to screen readers, we recommend enabling\naria: \"hidden\"\nand creating a duplicate screen reader-only copy of your text.\n\"hidden\"\n: adds\naria hidden\nto the split element and all of the line/word/character elements inside the split.\n\"none\"\n- does not add any\naria\nattributes to the split element or the line/word/character elements inside the split.\nDefault:\n\"auto\"\nautoSplit*\nBoolean\n- Helps avoid odd line breaks due to text reflow after the fonts finish loading or if the element's width changes. If\ntrue\n, SplitText will revert and re-split whenever the fonts finish loading or when\nboth\nof the following conditions apply:\nThe width of the split element(s) changes\n\"lines\"\nare split.\nSplitText will even\nconsole.warn()\nyou if you try splitting before the fonts finish loading and you didn't set\nautoSplit: true\nCaution\nWhen using\nautoSplit: true\n, make sure to create any animations in an\nonSplit()\ncallback so that the freshly-split line/word/character elements are the ones being animated. If you\nreturn\nthe animation in the\nonSplit()\n, SplitText will automatically clean up and synchronize the animation on each re-split.\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"lines\"\n,\nautoSplit\n:\ntrue\n,\nonSplit\n:\n(\nself\n)\n=>\n{\nreturn\ngsap\n.\nfrom\n(\nself\n.\nlines\n,\n{\ny\n:\n100\n,\nopacity\n:\n0\n,\nstagger\n:\n0.05\n}\n)\n;\n}\n}\n)\n;\nDefault:\nfalse\ncharsClass\nString\n- A CSS class applied to each character's\n<div>\n, making it easy to select. If you add\n\"++\"\nto the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if\ncharsClass\nis\n\"char++\"\n, the the first character would have\nclass=\"char char1\"\n, the next would have\nclass=\"char char2\"\n, then\nclass=\"char char3\"\n, etc. Default:\nundefined\n.\ndeepSlice*\nBoolean\n- If a nested element like\n<strong>\nwraps onto multiple lines, SplitText subdivides it accordingly so that it doesn't expand the line vertically. So technically one nested element could be split up into multiple elements. This is only effective for splitting\nlines\n. Default:\ntrue\n.\nignore*\nString | Element\n- Descendant elements to ignore when splitting (you may use selector text like\n\".split\"\nor an Array of elements). They will still exist - they simply won't be split\nDemo here\nDefault:\nundefined\nlinesClass\nString\n- A CSS class applied to each line's\n<div>\n, making it easy to select. If you add\n\"++\"\nto the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if\nlinesClass\nis\n\"line++\"\n, the the first line would have\nclass=\"line line1\"\n, the next would have\nclass=\"line line2\"\n, then\nclass=\"line line3\"\n, etc. Default:\nundefined\n.\nmask*\n\"lines\" | \"words\" | \"chars\"\n- wraps every line or word or character in an\nextra\nelement with\nvisibility: clip\nfor much simpler reveal effects. Access them in a \"masks\" Array on the SplitText instance. If you set a class name for the lines/words/chars, it'll append\n\"-mask\"\nfor easy selecting. You cannot mask multiple types, so this value should be either \"lines\" or \"words\" or \"chars\" but not a combination. Default:\nundefined\nonRevert*\nFunction\n- A function that gets called whenever the SplitText instance reverts\nonSplit*\nFunction\n- A function that gets called whenever the SplitText instance finishes splitting, including when\nautoSplit: true\ncauses it to re-split, like when the fonts finish loading or when the width of the split element(s) changes (which often makes lines reflow). If you return a GSAP animation (tween or timeline), it will automatically save its\ntotalTime()\nand\nrevert()\nit when the SplitText reverts, and set the new animation's\ntotalTime()\nthat's returned in the\nonSplit\n, making it appear relatively seamless!\nprepareText*\nFunction\n- A function that gets called for each block of text as the split occurs, allowing you to modify each chunk of text right before SplitText runs its splitting logic. For example, you might want to insert some special characters marking where word breaks should occur. The\nprepareText()\nfunction receives the raw text as the first argument, and the parent element as the second argument. You should\nreturn\nthe modified text. This can be useful for non-Latin languages like Chinese, where there are no spaces between words.\nDemo here\npropIndex*\nBoolean\n- adds a CSS variable to each split element with its index, like\n--word: 1\n,\n--word: 2\n, etc. It works for all types (line, word, and char). Default:\nfalse\nreduceWhiteSpace\nBoolean\n- Collapses consecutivewhite space characters into one, as most browsers typically do. Set to\nfalse\nif you prefer to maintain multiple consecutive white space characters. Since\nv3.13.0\nreduceWhiteSpace will honor extra spaces and automatically insert\n<br>\ntags for line breaks which is useful for\n<pre>\ncontent. Default:\ntrue\nsmartWrap*\nBoolean\n- If you split by\n\"chars\"\nonly, you can end up with odd breaks at the very end of lines when characters in the middle of a word flow onto the next line, untethered by natural word-grouping.\nsmartWrap: true\nwill wrap words in a\n<span>\nthat has\nwhite-space: nowrap\nto keep them grouped (only when you're not splitting by words or lines). This will be ignored if you're splitting by\n\"words\"\nor\n\"lines\"\n, as it's unnecessary. Default:\nfalse\ntag\nString\n- By default, SplitText wraps things in\n<div>\nelements, but you can define any tag like\ntag: \"span\"\n. Note that browsers won't render transforms like rotation, scale, skew, etc. on inline elements.\ntype\nString\n- A comma-delimited list of the split type(s) which can be any combination of the following:\nchars\n,\nwords\n, or\nlines\n. This indicates the type of components you\u00e2\u0080\u0099d like split apart into distinct elements. For example, to split apart the characters and words (not lines), you\u00e2\u0080\u0099d use\ntype: \"chars,words\"\nor to only split apart lines, you\u00e2\u0080\u0099d do\ntype: \"lines\"\n. In order to avoid odd line breaks, it is best to not split by chars alone (always include words or lines too if you're splitting by characters) or just set\nsmartWrap: true\n. Note: spaces are not considered characters. Default:\n\"chars,words,lines\"\n.\nwordDelimiter\nRegExp | \"string\" | Object\n- Normally, words are split at every space character. The\nwordDelimiter\nproperty allows you to specify your own custom delimiter for words. For example, if you want to split a hashtag like\n#IReallyLoveGSAP\ninto words, you could insert a zero-width word joiner character (\n&#8205;\n) between each word like:\n#&#8205;I&#8205;Really&#8205;Love&#8205;GSAP\nand then set\nwordDelimiter: String.fromCharCode(8205)\nin the SplitText config object. Since\nv3.13.0\n, you can specify where to split using a RegExp and also what text to swap in at those spots for ultimate flexibility like\nwordDelimiter\n:\n{\ndelimiter\n:\nyourRegExp\n,\nreplaceWith\n:\n\"yourReplacement\"\n}\nDefault:\n\" \"\n(space)\nwordsClass\nString\n- A CSS class applied to each word's\n<div>\n, making it easy to select. If you add\n\"++\"\nto the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if\nwordsClass\nis\n\"word++\"\n, the the first word would have\nclass=\"word word1\"\n, the next would have\nclass=\"word word2\"\n, then\nclass=\"word word3\"\n, etc. Default:\nundefined\n.\nAnimating\n\u00e2\u0080\u008b\nloading...\nOnce your text is split, you can animate each line, word, or character using GSAP:\n// split all elements with the class \"split\" into words and characters\nlet\nsplit\n=\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words, chars\"\n}\n)\n;\n// now animate the characters in a staggered fashion\ngsap\n.\nfrom\n(\nsplit\n.\nchars\n,\n{\nduration\n:\n1\n,\ny\n:\n100\n,\n// animate from 100px below\nautoAlpha\n:\n0\n,\n// fade in from opacity: 0 and visibility: hidden\nstagger\n:\n0.05\n,\n// 0.05 seconds between each\n}\n)\n;\nOr use the new\nonSplit()\nsyntax available in v3.13.0+ to do the exact same thing - the main benefit is that the code inside\nonSplit()\nwill execute anytime the SplitText instance\nre-splits\nin the future (like if you set\nautoSplit: true\nor if you manually call\nsplit()\n):\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words, chars\"\n,\nonSplit\n(\nself\n)\n{\n// runs every time it splits\ngsap\n.\nfrom\n(\nself\n.\nchars\n,\n{\nduration\n:\n1\n,\ny\n:\n100\n,\nautoAlpha\n:\n0\n,\nstagger\n:\n0.05\n}\n)\n;\n}\n}\n)\n;\nResponsive Line Splitting*\n\u00e2\u0080\u008b\nIf\nonly\nwords and/or characters are split, they reflow naturally when the container resizes but if you split by\nlines\n, each line element encloses around a specific set of words/characters. If the container then resizes narrower\nor\nif the font loads after the split, for example, the text may reflow causing some of the words to belong in\ndifferent\nlines (the last word in a line may shift down to the next). The only way to avoid strange line breaks is to re-split (restore the original\ninnerHTML\nand have SplitText run its splitting logic again) so that the line elements enclose the proper words.\nDon't worry! SplitText's\nautoSplit\nsaves the day! \u00f0\u009f\u00a5\u00b3 When enabled, it will revert and re-split when fonts finish loading or when\nboth\nof the following conditions apply:\nThe width of the split element(s) changes\n\"lines\" are split.\nWith\nautoSplit\nenabled, you should\nalways\ncreate your animations in the\nonSplit()\ncallback so that if it re-splits later, the resulting animations affect the freshly-created line/word/character elements instead of the ones from the previous split. If you\nreturn\nyour\ntween\nor\ntimeline\ninside the\nonSplit()\ncallback, your old animation will be safely\nreverted()\nbefore the new one is created and SplitText will automatically save the previous animation's\ntotalTime()\nbefore reverting it, and apply it to the new one so that everything appears relatively seamless! The SplitText instance is passed to the\nonSplit()\n(below, we call it\nself\n) so you can access its properties:\n// whenever you use autoSplit: true, ALWAYS create your animations in the onSplit()\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words,lines\"\n,\nautoSplit\n:\ntrue\n,\nonSplit\n(\nself\n)\n{\nreturn\ngsap\n.\nfrom\n(\nself\n.\nlines\n,\n{\n// a returned animation gets cleaned up and time-synced on each onSplit() call\nyPercent\n:\n20\n,\nopacity\n:\n0\n,\nstagger\n:\n1\n,\nduration\n:\n3\n,\nonComplete\n:\n(\n)\n=>\nself\n.\nrevert\n(\n)\n// revert the element to its original (unsplit) state\n}\n)\n;\n}\n}\n)\n;\nloading...\nMasking*\n\u00e2\u0080\u008b\nMasking wraps each line, word or character in an\nextra\nelement with\nvisibility: clip\nfor fun reveal effects.\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words,lines\"\n,\nmask\n:\n\"words\"\n,\n// <-- this can be \"lines\" or \"words\" or \"chars\"\n}\n)\n;\nloading...\nScreen Reader Accessibility\n\u00e2\u0080\u008b\nPeople who are blind or partially-sighted might use a screen reader which analyzes the content of a site and converts it into speech to help them navigate a website. A screen reader would see the following heading tag and read it out loud.\n<\nh1\n>\nHeading\n</\nh1\n>\nMost text splitting libraries simply divide the text into divs which screen readers verbalize\npainfully\nslowly, letter by letter...\n<\nh1\n>\n<\ndiv\n>\nH\n</\ndiv\n>\n<\ndiv\n>\ne\n</\ndiv\n>\n<\ndiv\n>\na\n</\ndiv\n>\n<\ndiv\n>\nd\n</\ndiv\n>\n<\ndiv\n>\ni\n</\ndiv\n>\n<\ndiv\n>\nn\n</\ndiv\n>\n<\ndiv\n>\ng\n</\ndiv\n>\n</\nh1\n>\nBuilt-in Aria*\n\u00e2\u0080\u008b\nTo get around this issue, SplitText adds an\naria-label\nto the parent element and then hides the child elements with\naria-hidden\n. This ensures that when visually impaired people navigate your site, screen readers will read the\naria-label\ninstead of the contents of the split elements. \u00f0\u009f\u00a5\u00b3 This approach works for the majority of use-cases and is enabled by default.\n<\nh2\naria-label\n=\n\"\nMy Accessible Heading\n\"\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\nMy\n</\ndiv\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\nAccessible\n</\ndiv\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\nHeading\n</\ndiv\n>\n</\nh2\n>\nAlternate Strategy for Maximizing Nested Element Accessibility\n\u00e2\u0080\u008b\nSplitText's built in\naria: \"auto\"\nsolution is ideal for most common scenarios, but it won't surface the functionality and meaning of nested elements (like links) to screen readers. If you have complex nested text, you can use the duplication approach described below. Exercise restraint here as duplicating lots of DOM elements can lead to performance lags.\nTreat text splitting with care and ensure you test thoroughly!\nIn the example below, the link may not be recognized as such by some screen readers:\n<\nh2\naria-label\n=\n\"\nThis link isn't accessible\n\"\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\nThis\n</\ndiv\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\n<\na\nhref\n=\n\"\n#\n\"\n>\nlink\n</\na\n>\n</\ndiv\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\nisn't\n</\ndiv\n>\n<\ndiv\naria-hidden\n=\n\"\ntrue\n\"\n>\naccessible\n</\ndiv\n>\n</\nh2\n>\nIf you need to preserve the semantics and functionality of nested elements - like links,\n<strong>\ntags or\n<em>\ntags - we recommend disabling the default aria settings for the SplitText with\naria: \"none\"\n*, and creating a\nscreen reader-only\nduplicate of your element instead. This way, sighted users will see the animated text, while visually impaired people will get the screenreader-only content announced to them.\nloading...\nReverting\n\u00e2\u0080\u008b\nPerformance-wise, it can be expensive for browsers to render a lot of nodes/elements, so it's often a good idea to\nrevert()\nyour split elements to their original state when you're done animating them. Simply call\nrevert()\non the SplitText instance to restore the original\ninnerHTML\n:\nlet\nsplit\n=\nSplitText\n.\ncreate\n(\n\".split\"\n,\n{\ntype\n:\n\"words\"\n}\n)\n;\ngsap\n.\nfrom\n(\nsplit\n.\nwords\n,\n{\nx\n:\n\"random(-100, 100)\"\n,\ny\n:\n\"random(-100, 100)\"\n,\nstagger\n:\n0.1\n,\nonComplete\n:\n(\n)\n=>\nsplit\n.\nrevert\n(\n)\n// <-- restores original innerHTML\n}\n)\nTips & Limitations\n\u00e2\u0080\u008b\nTips & Limitations\nCharacters shift slightly when splitting?\n- Some browsers apply kerning between certain characters which is lost when each character is put into its own element, thus the spacing shifts slightly. You can typically eliminate that shift by disabling the kerning with this CSS:\nfont-kerning\n:\nnone\n;\ntext-rendering\n:\noptimizeSpeed\n;\nCustom Fonts\n- If you split before your web fonts are ready, the layout may shift or misalign. To avoid this, either:\nWait for the fonts to load before splitting by placing your code inside\ndocument.fonts.ready.then(() => {...your code here...})\n, or\nSet\nautoSplit: true\nto have SplitText re-split once fonts finish loading. Don't forget to put your animation code inside the\nonSplit()\ncallback!\nOnly split what you need\n- Splitting thousands of elements can be expensive. If you\u00e2\u0080\u0099re only animating words or lines, skip splitting characters for better performance.\nSEO\n- If you split your main\n<h1/>\nelement, ensure that your page has the appropriate title and description meta tags and your SplitText has\naria: \"auto\"\n(default) enabled. Without these your split heading may appear in google search results in it's composite parts.\nAvoid text-wrap: balance\n- it interferes with clean text splitting.\nSVG\n- SplitText is not designed to work with SVG\n<text>\nnodes.\nStandalone plugin\n- SplitText is one of the only GSAP plugins that\ncan\nbe used\nwithout\nloading GSAP's core.\nDemos\n\u00e2\u0080\u008b\nCheck out the full collection of\ntext animation demos\non CodePen.\nContents\nFeatures\nSplitting\nBasic Usage\nConfiguration\nConfig Object\nAnimating\nResponsive Line Splitting*\nMasking*\nScreen Reader Accessibility\nBuilt-in Aria*\nAlternate Strategy for Maximizing Nested Element Accessibility\nReverting\nTips & Limitations\nDemos",
  "content_markdown": "On this page\n\nSplitText is a small JavaScript library that splits an HTML element's text into individual characters, words, and/or lines (each in its own, newly-created element), allowing you to create gorgeous staggered animations. It's highly configurable and smarter than other text splitting tools thanks to features like automatic screen reader accessibility, masking for reveal effects, responsive re-splitting, and much more.\n\nDetailed Walkthrough - Major rewrite in `v3.13.0` - half the size, 14 new features!\n\n## Features[\u00e2\u0080\u008b](#features \"Direct link to Features\")\n\nFeature Highlights\n\nThe new v3.13.0+ features are marked below with \"\\*\"\n\n- **Screen reader Accessibility**\\* - Adds `aria-label` to the split element(s) and `aria-hidden` to the freshly-created line/word/character elements.\n- **Responsive re-splitting**\\* - Avoid funky line breaks when resizing or when fonts load with `autoSplit` and `onSplit()`. Offers automatic cleanup and resuming of animations too!\n- **Slice right through nested elements**\\* - Elements like `<span>`, `<strong>`, and `<a>` that span multiple lines are handled effortlessly with `deepSlice` so they don't stretch lines vertically.\n- **Masking**\\* - Wrap characters, words or lines with an extra clipping element for easy mask/reveal effects.\n- **Integrates seamlessly** with GSAP's [`context()`](/docs/v3/GSAP/gsap.context()/), [`matchMedia()`](/docs/v3/GSAP/gsap.matchMedia()) and [`useGSAP()`](/resources/React)\n- **Flexible targeting** - Apply your own class names to characters, words, or lines. Append `\"++\"` to auto-increment them (e.g. `word1`, `word2`, etc.). Enable `propIndex`\\* to apply CSS variables like `--word: 3`.\n- **Ignore certain elements**\\* - Perhaps you'd like to leave `<sup>` elements unsplit, for example.\n- **Supports emojis & more** - SplitText does an excellent job with foreign characters too.\n- **Revert anytime** - Restore the element's original `innerHTML` anytime with `revert()`\n- **Handle complex edge cases** with custom `RegExp`\\* or `prepareText()`\\*\n\n## Splitting[\u00e2\u0080\u008b](#splitting \"Direct link to Splitting\")\n\n### Basic Usage[\u00e2\u0080\u008b](#basic-usage \"Direct link to Basic Usage\")\n\nFeed `SplitText.create()` the element(s) you'd like to split and it'll return a SplitText instance with `chars`, `words`, and `lines` properties where you can access the resulting elements.\n\n```\n// the target can be selector text, an element, or an Array of elements  \nlet split = SplitText.create(\".headline\");  \n  \n// Array of characters  \nsplit.chars  \n  \n// Array of words  \nsplit.words  \n  \n// Array of lines  \nsplit.lines\n```\n\n### Configuration[\u0000\u00e2\u0080\u008b](#configuration \"Direct link to Configuration\")\n\nBy default, SplitText will split by `type: \"lines, words, chars\"` (meaning lines, words, **and** characters) but to maximize performance you should really only split what you need. Use the configuration object to control exactly which components are split apart, or to adjust accessibility settings, or apply your own classes or even apply masking effects.\n\n```\nlet split = SplitText.create(\".split\", {  \n  type: \"words, lines\", // only split into words and lines (not characters)  \n  mask: \"lines\", // adds extra wrapper element around lines with overflow: clip (v3.13.0+)  \n  linesClass: \"line++\", // adds \"line\" class to each line element, plus an incremented one too (\"line1\", \"line2\", \"line3\", etc.)  \n  \n  // there are many other options - see below for a complete list  \n});\n```\n\n## **Config Object**[\u00e2\u0080\u008b](#config-object \"Direct link to config-object\")\n\n### Property\n\n### Description\n\n- #### aria\\*\n\n  \"auto\" | \"hidden\" | \"none\" - SplitText can automatically add `aria` attributes to the split element(s) as well as the line/word/character elements to improve accessibility. The options are: \n  - `\"auto\"` (the default) - adds an [aria label](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) to the split element(s), populated by its `textContent`, and also adds [aria hidden](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden) to the line/word/character elements inside the split. This ensures that the text is accessible to the majority of screen readers. **This approach will not honor the semantics or functionality of nested elements.** If you need to ensure that links inside your text content are visible to screen readers, we recommend enabling `aria: \"hidden\"` and creating a duplicate screen reader-only copy of your text.\n  - `\"hidden\"`: adds [aria hidden](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden) to the split element and all of the line/word/character elements inside the split.\n  - `\"none\"` - does not add any `aria` attributes to the split element or the line/word/character elements inside the split. Default: `\"auto\"`\n- #### autoSplit\\*\n\n  Boolean - Helps avoid odd line breaks due to text reflow after the fonts finish loading or if the element's width changes. If `true`, SplitText will revert and re-split whenever the fonts finish loading or when **both** of the following conditions apply: \n  1. The width of the split element(s) changes\n  2. `\"lines\"` are split. SplitText will even `console.warn()` you if you try splitting before the fonts finish loading and you didn't set `autoSplit: true`\n\n  #### Caution\n\n  When using `autoSplit: true`, make sure to create any animations in an `onSplit()` callback so that the freshly-split line/word/character elements are the ones being animated. If you `return` the animation in the `onSplit()`, SplitText will automatically clean up and synchronize the animation on each re-split.\n\n   \n\n  ```\n  SplitText.create(\".split\", {  \n    type: \"lines\",  \n    autoSplit: true,  \n    onSplit: (self) => {  \n      return gsap.from(self.lines, {  \n        y: 100,  \n        opacity: 0,  \n        stagger: 0.05  \n      });  \n    }  \n  });\n  ```\n\n   Default: `false`\n- #### charsClass\n\n  String - A CSS class applied to each character's `<div>`, making it easy to select. If you add `\"++\"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `charsClass` is `\"char++\"`, the the first character would have `class=\"char char1\"`, the next would have `class=\"char char2\"`, then `class=\"char char3\"`, etc. Default: `undefined`.\n- #### deepSlice\\*\n\n  Boolean - If a nested element like `<strong>` wraps onto multiple lines, SplitText subdivides it accordingly so that it doesn't expand the line vertically. So technically one nested element could be split up into multiple elements. This is only effective for splitting `lines`. Default: `true`.\n- #### ignore\\*\n\n  String | Element - Descendant elements to ignore when splitting (you may use selector text like `\".split\"` or an Array of elements). They will still exist - they simply won't be split [Demo here](https://codepen.io/GreenSock/pen/JojaebV) Default: `undefined`\n- #### linesClass\n\n  String - A CSS class applied to each line's `<div>`, making it easy to select. If you add `\"++\"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `linesClass` is `\"line++\"`, the the first line would have `class=\"line line1\"`, the next would have `class=\"line line2\"`, then `class=\"line line3\"`, etc. Default: `undefined`.\n- #### mask\\*\n\n  \"lines\" | \"words\" | \"chars\" - wraps every line or word or character in an *extra* element with `visibility: clip` for much simpler reveal effects. Access them in a \"masks\" Array on the SplitText instance. If you set a class name for the lines/words/chars, it'll append `\"-mask\"` for easy selecting. You cannot mask multiple types, so this value should be either \"lines\" or \"words\" or \"chars\" but not a combination. Default: `undefined`\n- #### onRevert\\*\n\n  Function - A function that gets called whenever the SplitText instance reverts\n- #### onSplit\\*\n\n  Function - A function that gets called whenever the SplitText instance finishes splitting, including when `autoSplit: true` causes it to re-split, like when the fonts finish loading or when the width of the split element(s) changes (which often makes lines reflow). If you return a GSAP animation (tween or timeline), it will automatically save its `totalTime()` and `revert()` it when the SplitText reverts, and set the new animation's `totalTime()` that's returned in the `onSplit`, making it appear relatively seamless!\n- #### prepareText\\*\n\n  Function - A function that gets called for each block of text as the split occurs, allowing you to modify each chunk of text right before SplitText runs its splitting logic. For example, you might want to insert some special characters marking where word breaks should occur. The `prepareText()` function receives the raw text as the first argument, and the parent element as the second argument. You should **return** the modified text. This can be useful for non-Latin languages like Chinese, where there are no spaces between words. [Demo here](https://codepen.io/GreenSock/pen/VYYvwoq/f30d0213097fe1c8c5a0a09215a5568f)\n- #### propIndex\\*\n\n  Boolean - adds a CSS variable to each split element with its index, like `--word: 1`, `--word: 2`, etc. It works for all types (line, word, and char). Default: `false`\n- #### reduceWhiteSpace\n\n  Boolean - Collapses consecutivewhite space characters into one, as most browsers typically do. Set to `false` if you prefer to maintain multiple consecutive white space characters. Since **v3.13.0** reduceWhiteSpace will honor extra spaces and automatically insert `<br>` tags for line breaks which is useful for `<pre>` content. Default: `true`\n- #### smartWrap\\*\n\n  Boolean - If you split by `\"chars\"` only, you can end up with odd breaks at the very end of lines when characters in the middle of a word flow onto the next line, untethered by natural word-grouping. `smartWrap: true` will wrap words in a `<span>` that has `white-space: nowrap` to keep them grouped (only when you're not splitting by words or lines). This will be ignored if you're splitting by `\"words\"` or `\"lines\"`, as it's unnecessary. Default: `false`\n- #### tag\n\n  String - By default, SplitText wraps things in `<div>` elements, but you can define any tag like `tag: \"span\"`. Note that browsers won't render transforms like rotation, scale, skew, etc. on inline elements.\n- #### type\n\n  String - A comma-delimited list of the split type(s) which can be any combination of the following: `chars`, `words`, or `lines`. This indicates the type of components you\u00e2\u0080\u0099d like split apart into distinct elements. For example, to split apart the characters and words (not lines), you\u00e2\u0080\u0099d use `type: \"chars,words\"` or to only split apart lines, you\u00e2\u0080\u0099d do `type: \"lines\"`. In order to avoid odd line breaks, it is best to not split by chars alone (always include words or lines too if you're splitting by characters) or just set `smartWrap: true`. Note: spaces are not considered characters. Default: `\"chars,words,lines\"`.\n- #### wordDelimiter\n\n  RegExp | \"string\" | Object - Normally, words are split at every space character. The `wordDelimiter` property allows you to specify your own custom delimiter for words. For example, if you want to split a hashtag like **#IReallyLoveGSAP** into words, you could insert a zero-width word joiner character (`&#8205;`) between each word like: `#&#8205;I&#8205;Really&#8205;Love&#8205;GSAP` and then set `wordDelimiter: String.fromCharCode(8205)` in the SplitText config object. Since **v3.13.0**, you can specify where to split using a RegExp and also what text to swap in at those spots for ultimate flexibility like \n\n  ```\n  wordDelimiter: {delimiter: yourRegExp, replaceWith: \"yourReplacement\"}\n  ```\n\n   Default: `\" \"` (space)\n- #### wordsClass\n\n  String - A CSS class applied to each word's `<div>`, making it easy to select. If you add `\"++\"` to the end of the class name, SplitText will also add a second class of that name but with an incremented number appended, starting at 1. For example, if `wordsClass` is `\"word++\"`, the the first word would have `class=\"word word1\"`, the next would have `class=\"word word2\"`, then `class=\"word word3\"`, etc. Default: `undefined`.\n\n## Animating[\u00e2\u0080\u008b](#animating \"Direct link to Animating\")\n\n#### loading...\n\nOnce your text is split, you can animate each line, word, or character using GSAP:\n\n```\n// split all elements with the class \"split\" into words and characters  \nlet split = SplitText.create(\".split\", { type: \"words, chars\" });  \n  \n// now animate the characters in a staggered fashion  \ngsap.from(split.chars, {  \n  duration: 1,   \n  y: 100,         // animate from 100px below  \n  autoAlpha: 0,   // fade in from opacity: 0 and visibility: hidden  \n  stagger: 0.05,  // 0.05 seconds between each  \n});\n```\n\nOr use the new `onSplit()` syntax available in v3.13.0+ to do the exact same thing - the main benefit is that the code inside `onSplit()` will execute anytime the SplitText instance **re-splits** in the future (like if you set `autoSplit: true` or if you manually call `split()`):\n\n```\nSplitText.create(\".split\", {  \n  type: \"words, chars\",  \n  onSplit(self) { // runs every time it splits  \n    gsap.from(self.chars, {  \n      duration: 1,   \n      y: 100,   \n      autoAlpha: 0,   \n      stagger: 0.05  \n    });  \n  }  \n});\n```\n\n### Responsive Line Splitting\\*[\u00e2\u0080\u008b](#responsive-line-splitting \"Direct link to Responsive Line Splitting*\")\n\nIf *only* words and/or characters are split, they reflow naturally when the container resizes but if you split by **lines**, each line element encloses around a specific set of words/characters. If the container then resizes narrower *or* if the font loads after the split, for example, the text may reflow causing some of the words to belong in *different* lines (the last word in a line may shift down to the next). The only way to avoid strange line breaks is to re-split (restore the original `innerHTML` and have SplitText run its splitting logic again) so that the line elements enclose the proper words.\n\nDon't worry! SplitText's `autoSplit` saves the day! \u00f0\u009f\u00a5\u00b3 When enabled, it will revert and re-split when fonts finish loading or when **both** of the following conditions apply:\n\n- The width of the split element(s) changes\n- \"lines\" are split.\n\nWith `autoSplit` enabled, you should **always** create your animations in the `onSplit()` callback so that if it re-splits later, the resulting animations affect the freshly-created line/word/character elements instead of the ones from the previous split. If you **return** your [`tween`](/docs/v3/Plugins/SplitText/docs/v3/GSAP/Tween/) or [`timeline`](/docs/v3/Plugins/SplitText/docs/v3/GSAP/Timeline/) inside the `onSplit()` callback, your old animation will be safely `reverted()` before the new one is created and SplitText will automatically save the previous animation's `totalTime()` before reverting it, and apply it to the new one so that everything appears relatively seamless! The SplitText instance is passed to the `onSplit()` (below, we call it `self`) so you can access its properties:\n\n```\n// whenever you use autoSplit: true, ALWAYS create your animations in the onSplit()  \nSplitText.create(\".split\", {  \n    type: \"words,lines\",  \n    autoSplit: true,  \n    onSplit(self) {  \n      return gsap.from(self.lines, { // a returned animation gets cleaned up and time-synced on each onSplit() call  \n        yPercent: 20,  \n        opacity: 0,  \n        stagger: 1,  \n        duration: 3,  \n        onComplete: () => self.revert() // revert the element to its original (unsplit) state  \n      });  \n    }  \n  });\n```\n\n#### loading...\n\n### Masking\\*[\u00e2\u0080\u008b](#masking \"Direct link to Masking*\")\n\nMasking wraps each line, word or character in an *extra* element with `visibility: clip` for fun reveal effects.\n\n```\nSplitText.create(\".split\", {  \n    type: \"words,lines\",  \n    mask: \"words\", // <-- this can be \"lines\" or \"words\" or \"chars\"  \n});\n```\n\n#### loading...\n\n## Screen Reader Accessibility[\u00e2\u0080\u008b](#screen-reader-accessibility \"Direct link to Screen Reader Accessibility\")\n\nPeople who are blind or partially-sighted might use a screen reader which analyzes the content of a site and converts it into speech to help them navigate a website. A screen reader would see the following heading tag and read it out loud.\n\n```\n<h1>Heading</h1>\n```\n\nMost text splitting libraries simply divide the text into divs which screen readers verbalize **painfully** slowly, letter by letter...\n\n```\n<h1>  \n  <div>H</div>  \n  <div>e</div>  \n  <div>a</div>  \n  <div>d</div>  \n  <div>i</div>  \n  <div>n</div>  \n  <div>g</div>  \n</h1>\n```\n\n### Built-in Aria\\*[\u00e2\u0080\u008b](#built-in-aria \"Direct link to Built-in Aria*\")\n\nTo get around this issue, SplitText adds an [`aria-label`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-label) to the parent element and then hides the child elements with [`aria-hidden`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-hidden). This ensures that when visually impaired people navigate your site, screen readers will read the `aria-label` instead of the contents of the split elements. \u00f0\u009f\u00a5\u00b3 This approach works for the majority of use-cases and is enabled by default.\n\n```\n<h2 aria-label=\"My Accessible Heading\">  \n  <div aria-hidden=\"true\">My</div>  \n  <div aria-hidden=\"true\">Accessible</div>  \n  <div aria-hidden=\"true\">Heading</div>  \n</h2>\n```\n\n### Alternate Strategy for Maximizing Nested Element Accessibility[\u00e2\u0080\u008b](#alternate-strategy-for-maximizing-nested-element-accessibility \"Direct link to Alternate Strategy for Maximizing Nested Element Accessibility\")\n\nSplitText's built in `aria: \"auto\"` solution is ideal for most common scenarios, but it won't surface the functionality and meaning of nested elements (like links) to screen readers. If you have complex nested text, you can use the duplication approach described below. Exercise restraint here as duplicating lots of DOM elements can lead to performance lags.\n\nTreat text splitting with care and ensure you test thoroughly!\n\nIn the example below, the link may not be recognized as such by some screen readers:\n\n```\n<h2 aria-label=\"This link isn't accessible\">  \n  <div aria-hidden=\"true\">This</div>  \n  <div aria-hidden=\"true\"><a href=\"#\">link</a></div>  \n  <div aria-hidden=\"true\">isn't</div>  \n  <div aria-hidden=\"true\">accessible</div>  \n</h2>\n```\n\nIf you need to preserve the semantics and functionality of nested elements - like links, `<strong>` tags or `<em>` tags - we recommend disabling the default aria settings for the SplitText with `aria: \"none\"`\\*, and creating a [screen reader-only](https://css-tricks.com/inclusively-hidden/) duplicate of your element instead. This way, sighted users will see the animated text, while visually impaired people will get the screenreader-only content announced to them.\n\n#### loading...\n\n## Reverting[\u00e2\u0080\u008b](#reverting \"Direct link to Reverting\")\n\nPerformance-wise, it can be expensive for browsers to render a lot of nodes/elements, so it's often a good idea to `revert()` your split elements to their original state when you're done animating them. Simply call `revert()` on the SplitText instance to restore the original `innerHTML`:\n\n```\nlet split = SplitText.create(\".split\", {type: \"words\"});  \ngsap.from(split.words, {  \n  x: \"random(-100, 100)\",  \n  y: \"random(-100, 100)\",  \n  stagger: 0.1,  \n  onComplete: () => split.revert() // <-- restores original innerHTML  \n})\n```\n\n## Tips & Limitations[\u00e2\u0080\u008b](#tips--limitations \"Direct link to Tips & Limitations\")\n\nTips & Limitations\n\n- **Characters shift slightly when splitting?** - Some browsers apply kerning between certain characters which is lost when each character is put into its own element, thus the spacing shifts slightly. You can typically eliminate that shift by disabling the kerning with this CSS:\n\n  ```\n  font-kerning: none;   \n  text-rendering: optimizeSpeed;\n  ```\n- **Custom Fonts** - If you split before your web fonts are ready, the layout may shift or misalign. To avoid this, either:\n\n  - Wait for the fonts to load before splitting by placing your code inside `document.fonts.ready.then(() => {...your code here...})`, or\n  - Set `autoSplit: true` to have SplitText re-split once fonts finish loading. Don't forget to put your animation code inside the `onSplit()` callback!\n- **Only split what you need** - Splitting thousands of elements can be expensive. If you\u00e2\u0080\u0099re only animating words or lines, skip splitting characters for better performance.\n- **SEO** - If you split your main `<h1/>` element, ensure that your page has the appropriate title and description meta tags and your SplitText has `aria: \"auto\"` (default) enabled. Without these your split heading may appear in google search results in it's composite parts.\n- **Avoid text-wrap: balance** - it interferes with clean text splitting.\n- **SVG** - SplitText is not designed to work with SVG `<text>` nodes.\n- **Standalone plugin** - SplitText is one of the only GSAP plugins that *can* be used **without** loading GSAP's core.\n\n## **Demos**[\u00e2\u0080\u008b](#demos \"Direct link to demos\")\n\nCheck out the full collection of [text animation demos](https://codepen.io/collection/ExBwoK) on CodePen.\n\n## Contents\n\n- [Features](#features)\n- [Splitting](#splitting)\n  - [Basic Usage](#basic-usage)\n  - [Configuration](#configuration)\n- [**Config Object**](#config-object)\n- [Animating](#animating)\n  - [Responsive Line Splitting\\*](#responsive-line-splitting)\n  - [Masking\\*](#masking)\n- [Screen Reader Accessibility](#screen-reader-accessibility)\n  - [Built-in Aria\\*](#built-in-aria)\n  - [Alternate Strategy for Maximizing Nested Element Accessibility](#alternate-strategy-for-maximizing-nested-element-accessibility)\n- [Reverting](#reverting)\n- [Tips & Limitations](#tips--limitations)\n- [**Demos**](#demos)",
  "tags": [
    "gsap",
    "animation",
    "javascript",
    "scrolltrigger"
  ],
  "extracted_at": "2026-02-03T12:48:59.418322+00:00",
  "content_length": 18929,
  "content_hash": "a98dbaf5aecb8469"
}