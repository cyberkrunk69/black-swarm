{
  "id": "gsap__docs_v3_Plugins_Flip_",
  "source_id": "gsap",
  "source_name": "GSAP",
  "category": "animation_motion",
  "url": "https://gsap.com/docs/v3/Plugins/Flip/",
  "title": "Flip | GSAP | Docs & Learning",
  "content": "On this page\ninfo\nFlip involves a whole different way of thinking about animation. Once you get it, you'll be wowed.\nFlip plugin lets you seamlessly transition between two states even if there are sweeping changes to the structure of the DOM that would normally cause elements to jump.\nFlip records the current position/size/rotation of your elements, you make whatever changes you want, and then Flip applies offsets to make them\nlook\nlike they never moved... Lastly FLIP animates the\nremoval\nof those offsets! UI transitions become remarkably simple to code. Flip does all the heavy lifting.\nWhat people are saying:\nExperimenting more with GSAP's flip plugin and I'm blown away by how much this accelerates development! What a powerful tool!\n\u00f0\u009f\u0092\u00aa\n\"\n- Manoela Ilic, Codrops\n\"HOW DOES IT KNOW WHAT TO DO?\n\u00f0\u009f\u00a4\u00af\n\"\n- @georgedoescode\n\"I'm truly amazed at the power of GSAP and FLIP.\"\n- @Alex.Marti\n\"My 'Wow' of the week goes to the Flip Plugin. Star-struck. It's soooo smart!\"\n- @PeHaa\nVideo\n\u00e2\u0080\u008b\nDetailed walkthrough\nOf course like all GreenSock tools, there's a rich API for finessing effects and getting exactly the look you want.\n\"\nFLIP\n\" is an animation technique that stands for \"\nF\nirst\", \"\nL\nast\", \"\nI\nnvert\", \"\nP\nlay\" and was coined\nby Paul Lewis\n. Here's a demo of how it works:\nloading...\nFeatures\n\u00e2\u0080\u008b\nFeature Highlights\nNested transforms? No problem!\nMost FLIP libraries only calculate basic offsets assuming no transforms beyond x/y, so a scaled parent breaks things. Rotations certainly aren't allowed. GSAP's Flip plugin\njust works\n!\nSet\nabsolute: true\nto\nmake elements use\nposition: absolute\nduring the flip\n. This solves layout challenges with flexbox, grid, etc. You can even define a subset of targets, like\nabsolute: \".box\"\nOne flip can handle\nmultiple elements\nand even stagger them.\nResize via width/height properties\n(default)\nor scaleX/scaleY\n(\nscale: true\n)\nYou get the\nfull power of GSAP under the hood\n, so you can use any\nease\n, define special properties like\nonComplete\n,\nonUpdate\n,\nrepeat\n,\nyoyo\n, and even\nadd()\nother animations with total control of timing, etc.\nread more...\nApply a CSS class during the flip with\ntoggleClass\n. It'll be removed at the end of the flip.\nFlip.fit()\nrepositions/resizes one element to fit perfectly on top another (or even a previous state of the same element)\n.\nCompensate for nested offsets\n. If a container element is getting flipped along with some of its children, set\nnested: true\nto prevent the offsets from compounding.\nSmoothly handles interruptions\n.\nFlip one element to another\n; even have them cross-fade (\nfade: true\n). Just give them the same\ndata-flip-id\nattribute to correlate them.\nonEnter\nand\nonLeave\ncallbacks\nfor when elements enter or leave (like if the flip senses a\ndisplay: none\ntoggle and there's no matching target to swap), making it easy to elegantly animate on/off elements.\nBatch\nmultiple Flip animations so they don't step on each other's toes, like in a React app with multiple independent components that need to work together.\nHow does Flip work?\n\u00e2\u0080\u008b\nThere are typically 3 steps to a \"FLIP\" animation:\nGet the current state\n\u00e2\u0080\u008b\n// returns a state object containing data about the elements' current position/size/rotation in the viewport\nconst\nstate\n=\nFlip\n.\ngetState\n(\n\".targets\"\n)\n;\nThis merely captures some data about the current state. Use selector text, an Element, an Array of Elements, or NodeList.\nFlip.getState()\ndoesn't alter anything (unless there's an active flip animation affecting any of the targets in which case it will force it to completion to capture the final state accurately). By default, Flip only concerns itself with position, size, rotation, and skew. If you want your Flip animations to affect other CSS properties, you can define a configuration object with a comma-delimited list of\nprops\n, like:\n// record some extra properties (optional)\nconst\nstate\n=\nFlip\n.\ngetState\n(\n\".targets\"\n,\n{\nprops\n:\n\"backgroundColor,color\"\n}\n)\n;\nMake your state changes\n\u00e2\u0080\u008b\nPerform DOM edits, styling updates, add/remove classes, or whatever is necessary to get things in their final state. There's no need to do that through the plugin (unless you're\nbatching\n). For example, we'll toggle a class:\n// make state changes. We'll toggle a class, for example:\nelement\n.\nclassList\n.\ntoggle\n(\n\"full-screen\"\n)\n;\nCall\nFlip.from(state, options)\n\u00e2\u0080\u008b\nFlip will look at the\nstate\nobject, compare the recorded positions/sizes to the current ones, immediately reposition/resize them to\nappear\nwhere they were in that previous state, and then animate the\nremoval\nof those offsets. You can specify almost any standard tween special properties like\nduration\n,\nease\n,\nonComplete\n, etc.\nFlip.from()\nreturns a timeline that you can\nadd()\nthings to or control in any way:\n// animate from the previous state to the current one:\nFlip\n.\nfrom\n(\nstate\n,\n{\nduration\n:\n1\n,\nease\n:\n\"power1.inOut\"\n,\nabsolute\n:\ntrue\n,\nonComplete\n:\nmyFunc\n,\n}\n)\n;\nThat's it!\nSimple example\n\u00e2\u0080\u008b\nloading...\nFlex example\n\u00e2\u0080\u008b\nloading...\nAdvanced example\n\u00e2\u0080\u008b\nloading...\nConfig Object\n\u00e2\u0080\u008b\nThe\nFlip.from()\noptions object (2nd parameter) can contain any of the following optional properties\nin addition to any standard tween properties like\nduration\n,\nease\n,\nonComplete\n, etc. as described\nhere\n:\nProperty\nDescription\nabsolute\nBoolean | String | Array | NodeList | Element\n- specifies which of the targets should have\nposition: absolute\napplied during the course of the FLIP animation. If\ntrue\n,\nall\nof the targets are affected, or use selector text like\n\".box\"\n(or an Array/NodeList of Elements, or even a single Element) to specify a subset of the targets. This can solve layout challenges with flex and grid layouts, for example. If things aren't behaving in a seamless way, try setting\nabsolute: true\n. Beware, that\nposition: absolute\nremoves the elements from document flow, so things below can collapse. In that case, just define a subset that doesn't include the container element so it props the layout open.\n(added in 3.9.0)\nabsoluteOnLeave\nBoolean\n- if\ntrue\n, any \"leaving\" Elements (ones passed to the\nonLeave()\n) will be set to\nposition: absolute\nduring the flip animation. This can be very useful when you set elements to\ndisplay: none\nto hide them in the final state, but you want to animate them out (fade, scale, whatever). It's critical that they not affect layout but you still want them visible during the animation.\n(added in 3.9.0)\nfade\nBoolean\n- by default, if the target element associated with a particular\ndata-flip-id\nin the previous state is a\ndifferent element\nthan the one with the same\ndata-flip-id\nin the end state, it will get swapped immediately but if you'd prefer that they cross-fade, set\nfade: true\n. Again, this only applies when swapping elements. If the \"swapping out\" (leaving) element is\ndisplay: none\n(CSS), obviously it won't be visible for fading but if you set the Flip to\nabsolute: true\n, it will force the element to the previous display state\nduring\nthe flip so that it can cross-fade. The reason\nabsolute: true\nis necessary in this case is because otherwise the element would affect document flow and throw off the positioning of other elements but if it is\nposition: absolute\n(CSS), it's removed from the document flow and won't contaminate positioning.\nnested\nBoolean\n- if the Flip has any\nnested\ntargets (like a parent and its child are both in the\ntargets\n), set\nnested: true\nto have Flip perform extra calculations to prevent those movements from compounding. A parent's movement affects its children, so if both are mapped to end up 200px from their original position and Flip moves them both 200px, the child would end up moving 400px unless\nnested: true\nis set.\nonEnter\nFunction\n- A callback that's called if/when a target either isn't found in the original\nstate\nor it was not in the document flow in that original state (like\ndisplay: none\n), but it\nIS\nin the document flow in the\nend\nstate. Since there is no position/size data to compare to in the original state, it won't be included in the flip animation, but the callback receives an Array of the entering elements as a parameter so that you can animate them as you please (like fade them in). Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example:\nonEnter\n:\nelements\n=>\ngsap\n.\nfromTo\n(\nelements\n,\n{\nopacity\n:\n0\n}\n,\n{\nopacity\n:\n1\n}\n)\nonLeave\nFunction\n- A callback that's called if/when a target is in the original\nstate\nbut not the end state, or if it isn't in the document flow in the end state (like\ndisplay: none\n). Since there is no position/size data to compare to in the end state, it won't be included in the flip animation, but the callback receives an Array of the leaving elements as a parameter so that you can animate them as you please (like fade them out).\nIMPORTANT:\nthese elements won't be visible unless you also set\nabsolute: true\n(otherwise, it'd throw off document flow). If\nabsolute: true\nis set, it will force\ndisplay\nto whatever it was in the previous state and then revert it back at the end of the flip. Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example:\nonLeave\n:\nelements\n=>\ngsap\n.\nfromTo\n(\nelements\n,\n{\nopacity\n:\n1\n}\n,\n{\nopacity\n:\n0\n}\n)\nprops\nString\n- a comma-delimited list of\ncamelCased\nCSS properties that should be included in the flip animation beyond the standard positioning/size/rotation/skew ones. For example,\n\"backgroundColor,color\"\n. This will only work, however, if the props exist in the\nstate\nobject (first parameter) because otherwise there's no corresponding data to pull from. By default, Flip will use the\nprops\nthat were captured in the state with\nFlip.getState(targets, props)\n, so it's very rare that you'd need to define\nprops\nin\nFlip.from()\n. It's only useful if you want to\nLIMIT\nthem to a subset of the ones captured in the state.\nprune\nBoolean\n- if\ntrue\n, Flip will remove any targets from the animation that match the previous state (position/size) in order to conserve resources. This requires a little more processing up-front, but it may improve performance during the animation when several get removed, plus it also makes staggering more intuitive since you may not want non-animating targets to be factored into the staggering.\n(added in 3.9.0)\nscale\nBoolean\n- by default, Flip will affect the\nwidth\nand\nheight\nCSS properties to alter the size, but if you'd rather scale the element instead (typically better performance), set\nscale: true\n.\nsimple\nBoolean\n- if\ntrue\n, Flip will skip the extra calculations that would be necessary to accommodate rotation/scale/skew in determining positions. It's like telling Flip\n\"I promise that there aren't any rotated/scaled/skewed containers for the Flipping elements\"\nwhich makes things\nfaster\n. In most cases, the performance difference isn't noticeable, but if you're flipping a lot of elements it can help keep things snappy.\nspin\nBoolean | Number | Function\n-\nif\ntrue\n, the elements will spin an extra 360 degrees during the flip animation which makes it look a little more fun. Or you can define a\nnumber\nof full rotations, including a negative number, so\n-1\nwould spin in the opposite direction once. If you provide a\nfunction\n, it will be called once for each target so that you can return whatever value you'd like for each individual element's spin. This allows you to, for example, have certain targets spin one direction, other elements spin another direction, or return 0 to not spin at all. Sample code: ...\nFlip\n.\nfrom\n(\nstate\n,\n{\nspin\n:\n(\nindex\n,\ntarget\n)\n=>\n{\nif\n(\ntarget\n.\nclassList\n.\ncontains\n(\n\"clockwise\"\n)\n)\n{\nreturn\n1\n;\n}\nelse\nif\n(\ntarget\n.\nclassList\n.\ncontains\n(\n\"counter-clockwise\"\n)\n)\n{\nreturn\n-\n1\n;\n}\nelse\n{\nreturn\n0\n;\n}\n}\n,\n}\n)\ntargets\nString | Element | Array | NodeList\n- by default, Flip will use the targets from the\nstate\nobject (first parameter), but you can specify a subset of those as either selector text (\n\".class, #id\"\n), an Element, an Array of Elements, or a NodeList. If any of the targets provided is NOT found in the\nstate\nobject, it will be passed to the\nonEnter\nand\nnot\nincluded in the flip animation because there's no previous state from which to pull position/size data.\ntoggleClass\nString\n- adds a CSS class to the targets while the flip animation is in progress. For example\n\"flipping\"\n.\nzIndex\nNumber\n- immediately sets the zIndex CSS property to this value for the entire course of the flip animation and then reverts at the end. This makes it easy to ensure that your flipping elements are on top of other elements during the animation, for example.\nHow do I flip between two\ndifferent\nelements?\n\u00e2\u0080\u008b\nFlip looks for a\ndata-flip-id\nattribute on every element it interacts with (via\nFlip.getState()\nor\nFlip.from()\n, etc.) and if one isn't found, Flip assigns an incremented one automatically (\"auto-1\", \"auto-2\", etc.). It lets you correlate targets (the target with the\ndata-flip-id\nof\n\"5\"\nin the \"from\" state gets matched up with the target with a\ndata-flip-id\nof\n\"5\"\nin the end state). The\ndata-flip-id\ncan be any string, not just a number.\nSo if you want to flip between two different targets, make sure the data-flip-id attribute in the end state matches the one in the \"from\" state. When Flip sees that there are two with the same value in the from/end state, it will automatically figure out which one is disappearing (typically with\ndisplay: none\n) and base things off of that to \"swap\" the elements. If you want them to crossfade, simply set\nfade: true\n, otherwise they'll immediately swap. And it is typically best to set\nabsolute: true\nso that when Flip alters the\ndisplay\nvalue, it doesn't affect the document flow.\nloading...\nBatching\n\u00e2\u0080\u008b\nWhat if you need to create\nmultiple\ncoordinated Flip animations (perhaps in various React components)? They'd need to all\n.getState()\nBEFORE\nany of them make their changes to the DOM/styling because doing so could alter the position/size of the other elements. See the docs for\nFlip.batch()\nfor details.\nCaveats & Tips\n\u00e2\u0080\u008b\nwarning\nFlip does not accommodate 3D transforms (like rotationX, rotationY, or z).\nIt is strongly recommended that you use\nbox-sizing: border-box\non your elements to ensure accurate width/height calculations.\nWhen\nabsolute: true\nis set, remember that coordinates will be calculated based on the current viewport, so if the viewport size changes or the user scrolls DURING the flip, it may affect positioning (but once the flip is done and the offsets are removed, things will be where they should be). In other words, in-progress flipping isn't always responsive.\nSet any transform-related values (x, y, scale, rotation, etc.)\ndirectly via GSAP\nwhenever possible (instead of just in CSS classes or inline) because GSAP caches transform-related data to supercharge performance and maximize accuracy. To clear GSAP's cache on a particular element (which you'd never need to do if you're making all your changes via GSAP),\ngsap.set(element, {clearProps: \"transform\"});\nDeep Dive - Using a framework like Vue, React or Angular?\nBeware that frameworks often\nDON'T\nrender changes immediately, so you should wait until the render occurs\nbefore\ninitiating the\nFlip.from()\n.\nBatching\nmay be an excellent option because you can\nbatch.getState(true)\nand then perhaps a\nuseLayoutEffect(() => batch.run(true), [...])\nin React. Another hack would be to use requestAnimationFrame() to wait one tick:\nrequestAnimationFrame(() => Flip.from(...));\nWhen you\nFlip.getState(\".your-class\")\n, it records position/size data for the elements with \".your-class\" at that time, remembering\nthose particular elements\nand their\ndata-flip-id\nattribute values. Then, if you\nFlip.from(yourState)\n, and don't specify any\ntargets\n, it will default to using the elements that were captured in the getState() but your framework may have re-rendered entirely new element instances (even if they look the same), thus they won't animate because Flip doesn't know to look at those new elements. The original ones were completely removed from the DOM, hence the need to tell the Flip\n\"use these new targets and search the state object for the IDs that match...\"\n. So make sure you define\ntargets\nlike this:\n// BAD\nFlip\n.\nfrom\n(\nstate\n,\n{\nduration\n:\n1\n,\n}\n)\n;\n// GOOD\nFlip\n.\nfrom\n(\nstate\n,\n{\ntargets\n:\n\".your-class\"\n,\n// <-- BINGO!\nduration\n:\n1\n,\n}\n)\n;\nAnd don't forget that you'll probably need to set a\ndata-flip-id\non those elements to make sure Flip knows which target matches up with which one from the captured state.\nMethods\n\u00e2\u0080\u008b\nFlip\n.batch\n( id:String ) : FlipBatch\nCoordinates the creation of multiple Flip animations in the properly sequenced set of steps to avoid cross-contamination.\nFlip\n.fit\n( targetToResize:String | Element, destinationTargetOrState:String | Element | FlipState, vars:Object ) ;\nRepositions/resizes one element so that it appears to fit exactly into the same area as another element. Using the\nfitChild\nspecial property, you can even scale/reposition an element so that one if its\nchild\nelements is used for the fitting calculations instead! By default it alters the transforms (x, y, rotation, and skewX) as well as the width and height of the element, but if you set\nscale: true\nit will use scaleX and scaleY instead of width and height.\nFlip\n.from\n( state:FlipState, vars:Object ) : Timeline\nImmediately moves/resizes the targets to match the provided\nstate\nobject, and then animates backwards to remove those offsets to end up at the current state. By default,\nwidth\nand\nheight\nproperties are used for the resizing, but you can set\nscale: true\nto scale instead (transform). It returns a timeline animation, so you can control it or add() other animations.\nFlip\n.getState\n( targets:String | Element | Array, vars:Object ) : Object\nCaptures information about the current state of the\ntargets\nso that they can be Flipped later. By default, this information includes the dimensions, rotation, skew, opacity, and the position of the targets in the viewport. Other properties can be captured by configuring the\nvars\nparameter.\nFlip\n.isFlipping\n( target:String | Element ) : Boolean\nReturns\ntrue\nif the given target is currently being Flipped. Otherwise returns\nfalse\n.\nFlip\n.killFlipsOf\n( targets:String | Array | NodeList | Element, complete:boolean ) ;\nImmediately kills the Flip animation associated with any of the targets provided.\nFlip\n.makeAbsolute\n( targets:String | Element | Array | NodeList | FlipState ) : Array\nSets all of the provided target elements to\nposition: absolute\nwhile retaining their current positioning.\nFlip\n.to\n( state:FlipState, vars:Object ) : Timeline\nIdentical to\nFlip.from()\nexcept inverted, so this would animate\nto\nthe provided state (from the current one).\nDemos\n\u00e2\u0080\u008b\nCheck out the full collection of\nHow-to demos\nand our favourite\ninspiring community demos\non CodePen.\nContents\nVideo\nFeatures\nHow does Flip work?\nGet the current state\nMake your state changes\nCall\nFlip.from(state, options)\nSimple example\nFlex example\nAdvanced example\nConfig Object\nHow do I flip between two\ndifferent\nelements?\nBatching\nCaveats & Tips\nMethods\nDemos",
  "content_markdown": "On this page\n\ninfo\n\nFlip involves a whole different way of thinking about animation. Once you get it, you'll be wowed.\n\nFlip plugin lets you seamlessly transition between two states even if there are sweeping changes to the structure of the DOM that would normally cause elements to jump.\n\nFlip records the current position/size/rotation of your elements, you make whatever changes you want, and then Flip applies offsets to make them ***look*** like they never moved... Lastly FLIP animates the **removal** of those offsets! UI transitions become remarkably simple to code. Flip does all the heavy lifting.\n\n## What people are saying:\n\n> *Experimenting more with GSAP's flip plugin and I'm blown away by how much this accelerates development! What a powerful tool!*\u00f0\u009f\u0092\u00aa*\"* - Manoela Ilic, Codrops\n\n> *\"HOW DOES IT KNOW WHAT TO DO?* \u00f0\u009f\u00a4\u00af*\"* - @georgedoescode\n\n> *\"I'm truly amazed at the power of GSAP and FLIP.\"* - @Alex.Marti\n\n> *\"My 'Wow' of the week goes to the Flip Plugin. Star-struck. It's soooo smart!\"* - @PeHaa\n\n## Video[\u00e2\u0080\u008b](#video \"Direct link to Video\")\n\nDetailed walkthrough\n\nOf course like all GreenSock tools, there's a rich API for finessing effects and getting exactly the look you want.\n\n\"**FLIP**\" is an animation technique that stands for \"**F**irst\", \"**L**ast\", \"**I**nvert\", \"**P**lay\" and was coined [by Paul Lewis](https://aerotwist.com/blog/flip-your-animations/). Here's a demo of how it works:\n\n#### loading...\n\n## Features[\u00e2\u0080\u008b](#features \"Direct link to Features\")\n\nFeature Highlights\n\n- **Nested transforms? No problem!** Most FLIP libraries only calculate basic offsets assuming no transforms beyond x/y, so a scaled parent breaks things. Rotations certainly aren't allowed. GSAP's Flip plugin **just works**!\n- Set `absolute: true` to **make elements use `position: absolute` during the flip**. This solves layout challenges with flexbox, grid, etc. You can even define a subset of targets, like `absolute: \".box\"`\n- One flip can handle **multiple elements** and even stagger them.\n- **Resize via width/height properties** (default) **or scaleX/scaleY** (`scale: true`)\n- You get the **full power of GSAP under the hood**, so you can use any `ease`, define special properties like `onComplete`, `onUpdate`, `repeat`, `yoyo`, and even `add()` other animations with total control of timing, etc.\n\n**read more...**\n\n- **Apply a CSS class during the flip with `toggleClass`**. It'll be removed at the end of the flip.\n- **[Flip.fit()](/docs/v3/Plugins/Flip/static.fit()) repositions/resizes one element to fit perfectly on top another (or even a previous state of the same element)**.\n- **Compensate for nested offsets**. If a container element is getting flipped along with some of its children, set `nested: true` to prevent the offsets from compounding.\n- **Smoothly handles interruptions**.\n- **Flip one element to another**; even have them cross-fade (`fade: true`). Just give them the same `data-flip-id` attribute to correlate them.\n- **`onEnter` and `onLeave` callbacks** for when elements enter or leave (like if the flip senses a `display: none` toggle and there's no matching target to swap), making it easy to elegantly animate on/off elements.\n- **Batch** multiple Flip animations so they don't step on each other's toes, like in a React app with multiple independent components that need to work together.\n\n## How does Flip work?[\u00e2\u0080\u008b](#how-does-flip-work \"Direct link to How does Flip work?\")\n\nThere are typically 3 steps to a \"FLIP\" animation:\n\n1. ### Get the current state[\u00e2\u0080\u008b](#get-the-current-state \"Direct link to Get the current state\")\n\n   ```\n   // returns a state object containing data about the elements' current position/size/rotation in the viewport  \n   const state = Flip.getState(\".targets\");\n   ```\n\n   This merely captures some data about the current state. Use selector text, an Element, an Array of Elements, or NodeList. [Flip.getState()](/docs/v3/Plugins/Flip/static.getState()) doesn't alter anything (unless there's an active flip animation affecting any of the targets in which case it will force it to completion to capture the final state accurately). By default, Flip only concerns itself with position, size, rotation, and skew. If you want your Flip animations to affect other CSS properties, you can define a configuration object with a comma-delimited list of `props`, like:\n\n   ```\n   // record some extra properties (optional)  \n   const state = Flip.getState(\".targets\", { props: \"backgroundColor,color\" });\n   ```\n2. ### Make your state changes[\u00e2\u0080\u008b](#make-your-state-changes \"Direct link to Make your state changes\")\n\n   Perform DOM edits, styling updates, add/remove classes, or whatever is necessary to get things in their final state. There's no need to do that through the plugin (unless you're [batching](/docs/v3/Plugins/Flip/static.batch())). For example, we'll toggle a class:\n\n   ```\n   // make state changes. We'll toggle a class, for example:  \n   element.classList.toggle(\"full-screen\");\n   ```\n3. ### Call `Flip.from(state, options)`[\u00e2\u0080\u008b](#call-flipfromstate-options \"Direct link to call-flipfromstate-options\")\n\n   Flip will look at the `state` object, compare the recorded positions/sizes to the current ones, immediately reposition/resize them to *appear* where they were in that previous state, and then animate the *removal* of those offsets. You can specify almost any standard tween special properties like `duration`, `ease`, `onComplete`, etc. [Flip.from()](/docs/v3/Plugins/Flip/static.from()) returns a timeline that you can `add()` things to or control in any way:\n\n   ```\n   // animate from the previous state to the current one:  \n   Flip.from(state, {  \n     duration: 1,  \n     ease: \"power1.inOut\",  \n     absolute: true,  \n     onComplete: myFunc,  \n   });\n   ```\n\n   ***That's it!***\n\n## Simple example[\u00e2\u0080\u008b](#simple-example \"Direct link to Simple example\")\n\n#### loading...\n\n## Flex example[\u00e2\u0080\u008b](#flex-example \"Direct link to Flex example\")\n\n#### loading...\n\n## Advanced example[\u00e2\u0080\u008b](#advanced-example \"Direct link to Advanced example\")\n\n#### loading...\n\n## **Config Object**[\u00e2\u0080\u008b](#config-object \"Direct link to config-object\")\n\nThe [Flip.from()](/docs/v3/Plugins/Flip/static.from()) options object (2nd parameter) can contain any of the following optional properties **in addition to any standard tween properties like `duration`, `ease`, `onComplete`**, etc. as described [here](/docs/v3/GSAP/gsap.to()):\n\n### Property\n\n### Description\n\n- #### absolute\n\n  Boolean | String | Array | NodeList | Element - specifies which of the targets should have `position: absolute` applied during the course of the FLIP animation. If `true`, **all** of the targets are affected, or use selector text like `\".box\"` (or an Array/NodeList of Elements, or even a single Element) to specify a subset of the targets. This can solve layout challenges with flex and grid layouts, for example. If things aren't behaving in a seamless way, try setting `absolute: true`. Beware, that `position: absolute` removes the elements from document flow, so things below can collapse. In that case, just define a subset that doesn't include the container element so it props the layout open. *(added in 3.9.0)*\n- #### absoluteOnLeave\n\n  Boolean - if `true`, any \"leaving\" Elements (ones passed to the `onLeave()`) will be set to `position: absolute` during the flip animation. This can be very useful when you set elements to `display: none` to hide them in the final state, but you want to animate them out (fade, scale, whatever). It's critical that they not affect layout but you still want them visible during the animation. *(added in 3.9.0)*\n- #### fade\n\n  Boolean - by default, if the target element associated with a particular `data-flip-id` in the previous state is a **different element** than the one with the same `data-flip-id` in the end state, it will get swapped immediately but if you'd prefer that they cross-fade, set `fade: true`. Again, this only applies when swapping elements. If the \"swapping out\" (leaving) element is `display: none` (CSS), obviously it won't be visible for fading but if you set the Flip to `absolute: true`, it will force the element to the previous display state *during* the flip so that it can cross-fade. The reason `absolute: true` is necessary in this case is because otherwise the element would affect document flow and throw off the positioning of other elements but if it is `position: absolute` (CSS), it's removed from the document flow and won't contaminate positioning.\n- #### nested\n\n  Boolean - if the Flip has any *nested* targets (like a parent and its child are both in the `targets`), set `nested: true` to have Flip perform extra calculations to prevent those movements from compounding. A parent's movement affects its children, so if both are mapped to end up 200px from their original position and Flip moves them both 200px, the child would end up moving 400px unless `nested: true` is set.\n- #### onEnter\n\n  Function - A callback that's called if/when a target either isn't found in the original `state` or it was not in the document flow in that original state (like `display: none`), but it *IS* in the document flow in the **end** state. Since there is no position/size data to compare to in the original state, it won't be included in the flip animation, but the callback receives an Array of the entering elements as a parameter so that you can animate them as you please (like fade them in). Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example: \n\n  ```\n  onEnter: elements => gsap.fromTo(elements, {opacity: 0}, {opacity: 1})\n  ```\n- #### onLeave\n\n  Function - A callback that's called if/when a target is in the original `state` but not the end state, or if it isn't in the document flow in the end state (like `display: none`). Since there is no position/size data to compare to in the end state, it won't be included in the flip animation, but the callback receives an Array of the leaving elements as a parameter so that you can animate them as you please (like fade them out). **IMPORTANT:** these elements won't be visible unless you also set `absolute: true` (otherwise, it'd throw off document flow). If `absolute: true` is set, it will force `display` to whatever it was in the previous state and then revert it back at the end of the flip. Any animation returned by this callback will get added to the flip timeline so that it gets forced to completion if a competing flip interrupts it. For example:\n\n  ```\n  onLeave: elements => gsap.fromTo(elements, {opacity: 1}, {opacity: 0})\n  ```\n- #### props\n\n  String - a comma-delimited list of *camelCased* CSS properties that should be included in the flip animation beyond the standard positioning/size/rotation/skew ones. For example, `\"backgroundColor,color\"`. This will only work, however, if the props exist in the `state` object (first parameter) because otherwise there's no corresponding data to pull from. By default, Flip will use the `props` that were captured in the state with [Flip.getState(targets, props)](/docs/v3/Plugins/Flip/static.getState()), so it's very rare that you'd need to define `props` in [Flip.from()](/docs/v3/Plugins/Flip/static.from()). It's only useful if you want to *LIMIT* them to a subset of the ones captured in the state.\n- #### prune\n\n  Boolean - if `true`, Flip will remove any targets from the animation that match the previous state (position/size) in order to conserve resources. This requires a little more processing up-front, but it may improve performance during the animation when several get removed, plus it also makes staggering more intuitive since you may not want non-animating targets to be factored into the staggering. *(added in 3.9.0)*\n- #### scale\n\n  Boolean - by default, Flip will affect the `width` and `height` CSS properties to alter the size, but if you'd rather scale the element instead (typically better performance), set `scale: true`.\n- #### simple\n\n  Boolean - if `true`, Flip will skip the extra calculations that would be necessary to accommodate rotation/scale/skew in determining positions. It's like telling Flip *\"I promise that there aren't any rotated/scaled/skewed containers for the Flipping elements\"* which makes things **faster**. In most cases, the performance difference isn't noticeable, but if you're flipping a lot of elements it can help keep things snappy.\n- #### spin\n\n  Boolean | Number | Function - \n\n  if `true`, the elements will spin an extra 360 degrees during the flip animation which makes it look a little more fun. Or you can define a **number** of full rotations, including a negative number, so `-1` would spin in the opposite direction once. If you provide a **function**, it will be called once for each target so that you can return whatever value you'd like for each individual element's spin. This allows you to, for example, have certain targets spin one direction, other elements spin another direction, or return 0 to not spin at all. Sample code: ...\n\n   \n\n  ```\n  Flip.from(state, {  \n    spin: (index, target) => {  \n      if (target.classList.contains(\"clockwise\")) {  \n        return 1;  \n      } else if (target.classList.contains(\"counter-clockwise\")) {  \n        return -1;  \n      } else {  \n        return 0;  \n      }  \n    },  \n  })\n  ```\n- #### targets\n\n  String | Element | Array | NodeList - by default, Flip will use the targets from the `state` object (first parameter), but you can specify a subset of those as either selector text (`\".class, #id\"`), an Element, an Array of Elements, or a NodeList. If any of the targets provided is NOT found in the `state` object, it will be passed to the `onEnter` and *not* included in the flip animation because there's no previous state from which to pull position/size data.\n- #### toggleClass\n\n  String - adds a CSS class to the targets while the flip animation is in progress. For example `\"flipping\"`.\n- #### zIndex\n\n  Number - immediately sets the zIndex CSS property to this value for the entire course of the flip animation and then reverts at the end. This makes it easy to ensure that your flipping elements are on top of other elements during the animation, for example.\n\n## How do I flip between two *different* elements?[\u00e2\u0080\u008b](#how-do-i-flip-between-two-different-elements \"Direct link to how-do-i-flip-between-two-different-elements\")\n\nFlip looks for a `data-flip-id` attribute on every element it interacts with (via [Flip.getState()](/docs/v3/Plugins/Flip/static.getState()) or [Flip.from()](/docs/v3/Plugins/Flip/static.from()), etc.) and if one isn't found, Flip assigns an incremented one automatically (\"auto-1\", \"auto-2\", etc.). It lets you correlate targets (the target with the `data-flip-id` of `\"5\"` in the \"from\" state gets matched up with the target with a `data-flip-id` of `\"5\"` in the end state). The `data-flip-id` can be any string, not just a number.\n\nSo if you want to flip between two different targets, make sure the data-flip-id attribute in the end state matches the one in the \"from\" state. When Flip sees that there are two with the same value in the from/end state, it will automatically figure out which one is disappearing (typically with `display: none`) and base things off of that to \"swap\" the elements. If you want them to crossfade, simply set `fade: true`, otherwise they'll immediately swap. And it is typically best to set `absolute: true` so that when Flip alters the `display` value, it doesn't affect the document flow.\n\n#### loading...\n\n## Batching[\u00e2\u0080\u008b](#batching \"Direct link to Batching\")\n\nWhat if you need to create **multiple** coordinated Flip animations (perhaps in various React components)? They'd need to all [.getState()](/docs/v3/Plugins/Flip/static.getState()) *BEFORE* any of them make their changes to the DOM/styling because doing so could alter the position/size of the other elements. See the docs for [Flip.batch()](/docs/v3/Plugins/Flip/static.batch()) for details.\n\n## Caveats & Tips[\u00e2\u0080\u008b](#caveats--tips \"Direct link to Caveats & Tips\")\n\nwarning\n\n- Flip does not accommodate 3D transforms (like rotationX, rotationY, or z).\n- It is strongly recommended that you use `box-sizing: border-box` on your elements to ensure accurate width/height calculations.\n- When `absolute: true` is set, remember that coordinates will be calculated based on the current viewport, so if the viewport size changes or the user scrolls DURING the flip, it may affect positioning (but once the flip is done and the offsets are removed, things will be where they should be). In other words, in-progress flipping isn't always responsive.\n- Set any transform-related values (x, y, scale, rotation, etc.) [directly via GSAP](/resources/mistakes#transforms) whenever possible (instead of just in CSS classes or inline) because GSAP caches transform-related data to supercharge performance and maximize accuracy. To clear GSAP's cache on a particular element (which you'd never need to do if you're making all your changes via GSAP), `gsap.set(element, {clearProps: \"transform\"});`\n\n Deep Dive - Using a framework like Vue, React or Angular? \n\nBeware that frameworks often **DON'T** render changes immediately, so you should wait until the render occurs *before* initiating the [Flip.from()](/docs/v3/Plugins/Flip/static.from()). [Batching](/docs/v3/Plugins/Flip/static.batch()) may be an excellent option because you can `batch.getState(true)` and then perhaps a `useLayoutEffect(() => batch.run(true), [...])` in React. Another hack would be to use requestAnimationFrame() to wait one tick: `requestAnimationFrame(() => Flip.from(...));`\n\nWhen you `Flip.getState(\".your-class\")`, it records position/size data for the elements with \".your-class\" at that time, remembering **those particular elements** and their `data-flip-id` attribute values. Then, if you `Flip.from(yourState)`, and don't specify any `targets`, it will default to using the elements that were captured in the getState() but your framework may have re-rendered entirely new element instances (even if they look the same), thus they won't animate because Flip doesn't know to look at those new elements. The original ones were completely removed from the DOM, hence the need to tell the Flip *\"use these new targets and search the state object for the IDs that match...\"*. So make sure you define `targets` like this:\n\n```\n// BAD  \nFlip.from(state, {  \n  duration: 1,  \n});  \n  \n// GOOD  \nFlip.from(state, {  \n  targets: \".your-class\", // <-- BINGO!  \n  duration: 1,  \n});\n```\n\nAnd don't forget that you'll probably need to set a `data-flip-id` on those elements to make sure Flip knows which target matches up with which one from the captured state.\n\n## **Methods**[\u00e2\u0080\u008b](#methods \"Direct link to methods\")\n\n|  |  |\n| --- | --- |\n| [Flip.batch](/docs/v3/Plugins/Flip/static.batch())( id:String ) : FlipBatch | Coordinates the creation of multiple Flip animations in the properly sequenced set of steps to avoid cross-contamination. |\n| [Flip.fit](/docs/v3/Plugins/Flip/static.fit())( targetToResize:String | Element, destinationTargetOrState:String | Element | FlipState, vars:Object ) ; | Repositions/resizes one element so that it appears to fit exactly into the same area as another element. Using the `fitChild` special property, you can even scale/reposition an element so that one if its *child* elements is used for the fitting calculations instead! By default it alters the transforms (x, y, rotation, and skewX) as well as the width and height of the element, but if you set `scale: true` it will use scaleX and scaleY instead of width and height. |\n| [Flip.from](/docs/v3/Plugins/Flip/static.from())( state:FlipState, vars:Object ) : Timeline | Immediately moves/resizes the targets to match the provided `state` object, and then animates backwards to remove those offsets to end up at the current state. By default, `width` and `height` properties are used for the resizing, but you can set `scale: true` to scale instead (transform). It returns a timeline animation, so you can control it or add() other animations. |\n| [Flip.getState](/docs/v3/Plugins/Flip/static.getState())( targets:String | Element | Array, vars:Object ) : Object | Captures information about the current state of the `targets` so that they can be Flipped later. By default, this information includes the dimensions, rotation, skew, opacity, and the position of the targets in the viewport. Other properties can be captured by configuring the `vars` parameter. |\n| [Flip.isFlipping](/docs/v3/Plugins/Flip/static.isFlipping())( target:String | Element ) : Boolean | Returns `true` if the given target is currently being Flipped. Otherwise returns `false`. |\n| [Flip.killFlipsOf](/docs/v3/Plugins/Flip/static.killFlipsOf())( targets:String | Array | NodeList | Element, complete:boolean ) ; | Immediately kills the Flip animation associated with any of the targets provided. |\n| [Flip.makeAbsolute](/docs/v3/Plugins/Flip/static.makeAbsolute())( targets:String | Element | Array | NodeList | FlipState ) : Array | Sets all of the provided target elements to `position: absolute` while retaining their current positioning. |\n| [Flip.to](/docs/v3/Plugins/Flip/static.to())( state:FlipState, vars:Object ) : Timeline | Identical to [Flip.from()](/docs/v3/Plugins/Flip/static.from()) except inverted, so this would animate **to** the provided state (from the current one). |\n\n## **Demos**[\u00e2\u0080\u008b](#demos \"Direct link to demos\")\n\nCheck out the full collection of [How-to demos](https://codepen.io/collection/4a605f253549434210c139fa331704cb) and our favourite [inspiring community demos](https://codepen.io/collection/d725bcacb2f44bbdf0f44718f7ebbf55) on CodePen.\n\n## Contents\n\n- [Video](#video)\n- [Features](#features)\n- [How does Flip work?](#how-does-flip-work)\n  - [Get the current state](#get-the-current-state)\n  - [Make your state changes](#make-your-state-changes)\n  - [Call `Flip.from(state, options)`](#call-flipfromstate-options)\n- [Simple example](#simple-example)\n- [Flex example](#flex-example)\n- [Advanced example](#advanced-example)\n- [**Config Object**](#config-object)\n- [How do I flip between two *different* elements?](#how-do-i-flip-between-two-different-elements)\n- [Batching](#batching)\n- [Caveats & Tips](#caveats--tips)\n- [**Methods**](#methods)\n- [**Demos**](#demos)",
  "tags": [
    "gsap",
    "animation",
    "javascript",
    "scrolltrigger"
  ],
  "extracted_at": "2026-02-03T12:48:55.772691+00:00",
  "content_length": 19159,
  "content_hash": "cde9de7dcd5fdc02"
}