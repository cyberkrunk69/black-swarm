{
  "id": "gsap__docs_v3_Plugins_ScrollTrigger_",
  "source_id": "gsap",
  "source_name": "GSAP",
  "category": "animation_motion",
  "url": "https://gsap.com/docs/v3/Plugins/ScrollTrigger/",
  "title": "ScrollTrigger | GSAP | Docs & Learning",
  "content": "On this page\nScrollTrigger enables anyone to create\njaw-dropping scroll-based animations\nwith minimal code. Infinitely flexible. Scrub, pin, snap, or just trigger anything scroll-related, even if it has nothing to do with animation.\nDetailed walkthrough\nGet ahead of the game by also learning about\nthe most common ScrollTrigger mistakes.\nSimple example\n\u00e2\u0080\u008b\ngsap\n.\nto\n(\n'.box'\n,\n{\nscrollTrigger\n:\n'.box'\n,\n// start the animation when \".box\" enters the viewport (once)\nx\n:\n500\n}\n)\n;\nAdvanced example\n\u00e2\u0080\u008b\nlet\ntl\n=\ngsap\n.\ntimeline\n(\n{\n// yes, we can add it to an entire timeline!\nscrollTrigger\n:\n{\ntrigger\n:\n'.container'\n,\npin\n:\ntrue\n,\n// pin the trigger element while active\nstart\n:\n'top top'\n,\n// when the top of the trigger hits the top of the viewport\nend\n:\n'+=500'\n,\n// end after scrolling 500px beyond the start\nscrub\n:\n1\n,\n// smooth scrubbing, takes 1 second to \"catch up\" to the scrollbar\nsnap\n:\n{\nsnapTo\n:\n'labels'\n,\n// snap to the closest label in the timeline\nduration\n:\n{\nmin\n:\n0.2\n,\nmax\n:\n3\n}\n,\n// the snap animation should be at least 0.2 seconds, but no more than 3 seconds (determined by velocity)\ndelay\n:\n0.2\n,\n// wait 0.2 seconds from the last scroll event before doing the snapping\nease\n:\n'power1.inOut'\n// the ease of the snap animation (\"power3\" by default)\n}\n}\n}\n)\n;\n// add animations and labels to the timeline\ntl\n.\naddLabel\n(\n'start'\n)\n.\nfrom\n(\n'.box p'\n,\n{\nscale\n:\n0.3\n,\nrotation\n:\n45\n,\nautoAlpha\n:\n0\n}\n)\n.\naddLabel\n(\n'color'\n)\n.\nfrom\n(\n'.box'\n,\n{\nbackgroundColor\n:\n'#28a92b'\n}\n)\n.\naddLabel\n(\n'spin'\n)\n.\nto\n(\n'.box'\n,\n{\nrotation\n:\n360\n}\n)\n.\naddLabel\n(\n'end'\n)\n;\nStandalone/Custom example\n\u00e2\u0080\u008b\nYou don't need to put ScrollTriggers directly into animations (though that's probably the most common use case). Use the callbacks for anything...\nScrollTrigger\n.\ncreate\n(\n{\ntrigger\n:\n'#id'\n,\nstart\n:\n'top top'\n,\nendTrigger\n:\n'#otherID'\n,\nend\n:\n'bottom 50%+=100px'\n,\nonToggle\n:\n(\nself\n)\n=>\nconsole\n.\nlog\n(\n'toggled, isActive:'\n,\nself\n.\nisActive\n)\n,\nonUpdate\n:\n(\nself\n)\n=>\n{\nconsole\n.\nlog\n(\n'progress:'\n,\nself\n.\nprogress\n.\ntoFixed\n(\n3\n)\n,\n'direction:'\n,\nself\n.\ndirection\n,\n'velocity'\n,\nself\n.\ngetVelocity\n(\n)\n)\n;\n}\n}\n)\n;\nFeatures\n\u00e2\u0080\u008b\nFeature Highlights\nLink any animation to a particular element\nso that it only plays when that element is in the viewport. This improves performance and ensures that your beautiful animations actually get seen!\nScrollTriggers can perform an actions on an animation (play, pause, resume, restart, reverse, complete, reset) when entering/leaving the defined area or link it directly to the scrollbar so that it acts like a\nscrubber\n(\nscrub: true\n).\nSoften the link between the animation and the the scrollbar\nso that takes a certain amount of time to \"catch up\", like\nscrub: 1\nwould take one second to catch up.\nIntegrated with\nScrollSmoother\n, GreenSock's smooth-scrolling tool built on native scroll technology (members-only benefit).\nread more...\nSnap to certain points in the animation\nbased on velocity. In fact, you can\ngetVelocity()\nof the scrolling anytime. Snap to the closest label in a timeline or progress value in an Array, or run your own custom function-based logic for snapping\nEmbed scroll triggers directly into any GSAP animation\n(including timelines) or create\nstandalone instances\nand tap into the rich callback system to do anything you want.\nAdvanced pinning\ncapabilities can lock an element in place between certain scroll positions. Padding is automatically added to push other elements down accordingly, so they catch up when the element gets unpinned (disable this with\npinSpacing: false\n). You can even pin the same element multiple times at different points.\nIncredible flexibility for defining scroll positions\n- like\n\"start when the center of this element hits the center of the viewport, and end when the bottom of that other element hits the bottom of the viewport\"\n, use keywords (top, center, bottom, left, right), percentages, pixels, or even relative values like\n\"+=300px\"\n. Once you get the hang of the syntax, it's remarkably intuitive.\nAccommodates\nvertical or horizontal scrolling\n.\nRich callback system\nincluding onEnter, onLeave, onEnterBack, onLeaveBack, onToggle, onUpdate, onScrubComplete, and onRefresh.\nAutomatically recalculates positions\nwhen the window resizes.\nEnable visual markers\nduring development to see exactly where the start/end/trigger points are. Customization options abound, like\nmarkers: {startColor:\"green\", endColor:\"red\", fontSize:\"12px\"}\n.\nToggle a CSS class\n. For example,\ntoggleClass: \"active\"\nadds the \"active\" class to the trigger element while the ScrollTrigger is active. You can affect other elements too.\nResponsive\n- use the\nmatchMedia()\nmethod to create different setups for various screen sizes using standard media queries.\nCustom containers\n- you don't need to use the viewport; define a custom scroller like a\n<div>\ninstead.\nHighly optimized for maximum performance\n- scroll events are debounced, updates are synchronized with GSAP and screen refreshes, resize recalculations are throttled, etc.\nNo scroll-jacking\n, so it can be combined with native technologies like CSS scroll snapping. If you want scroll-smoothing, you can use\nScrollSmoother\nwhich integrates seamlessly with ScrollTrigger, or use the\nscrollerProxy()\nmethod to integrate with a 3rd party smooth-scrolling library.\nConfig Object\n\u00e2\u0080\u008b\nscrollTrigger\ncan be used as either a shorthand for the\ntrigger\n(described below) or as a configuration object with any of the following properties:\nProperty\nDescription\nanimation\nTween | Timeline\n- A GSAP\nTween\nor\nTimeline\ninstance that should be controlled by the ScrollTrigger. Only one animation is controlled per ScrollTrigger, but you can wrap all your animations in a single Timeline (recommended) or create multiple ScrollTriggers if you prefer.\nanticipatePin\nNumber\n- If you pin large sections/panels you may notice what looks like a slight delay in pinning when you scroll quickly. That's caused by the fact that most modern browsers handle scroll repaints on a separate thread, so at the moment of pinning the browser may have already painted the pre-pinned content, making it visible for perhaps 1/60th of a second. The only way to counteract that is to have ScrollTrigger monitor the scroll velocity and anticipate the pin, applying it slightly early to avoid that flash of unpinned content. A value of\nanticipatePin: 1\nis typically fine, but you can reduce or increase that number to control how early it does the pinning. In many cases, however, you don't need any anticipatePin (the default is 0).\ncontainerAnimation\nTween | Timeline\nEasily trigger animations inside 'horizontally' scrolling sections that are controlled by vertical scrolling\nView More details\nA popular effect is to create horizontally-moving sections that are tied to vertical scrolling but since that horizontal movement isn't a native scroll, a regular ScrollTrigger can't know when, for example, an element comes into view horizontally, so you must tell ScrollTrigger to monitor the container's [horizontal] animation to know when to trigger, like\ncontainerAnimation: yourTween\n.\nCaveats\n:\nthe container's animation must use a linear ease (\nease: \"none\"\n). Also, pinning and snapping aren't available on containerAnimation-based ScrollTriggers. You should avoid animating the\ntrigger\nelement horizontally or if you do, just offset the start/end values according to how far you're animating the trigger.\nmore information here\n.\nend\nString | Number | Function\n- Determines the ending position of the ScrollTrigger.\nView More details\nIt can be any of the following:\nString\n- Describes a place on the\nendTrigger\n(or trigger if one isn't defined) and a place on the\nscroller\nthat must meet in order to end the ScrollTrigger. So, for example,\n\"bottom center\"\nmeans\n\"when the bottom of the endTrigger hits the center of the scroller\"\n.\n\"center 100px\"\nmeans\n\"when the center of the endTrigger hits 100px down from the top of the scroller\"\n(assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\" if\nhorizontal: true\n) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/viewport. You can also define a single relative value like \"+=300\" which means\n\"300px beyond where the start is\"\n, or \"+=100%\" means\n\"the height of the scroller beyond where the start is\".\n\"max\"\nis a special keyword indicating the maximum scroll position.\nNumber\n- An exact scroll value, so\n200\nwould trigger when the viewport/scroller scrolls by exactly 200 pixels.\nFunction\n- A function that gets called whenever the ScrollTrigger refreshes and calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter.\nThis is a\nstatic\nposition that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call\nScrollTrigger.refresh()\nto force things to be recalculated. The default is\n\"bottom top\"\n.\nclamp() the value\n(version 3.12+)\nWrap your end value in\n\"clamp()\"\nto tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any trigger elements toward the very bottom of the page won't end with partially-scrubbed animations. For example,\nend: \"clamp(bottom top)\"\n- any normal string-based value can be inside the clamp(). Like\n\"clamp(20px 80%)\"\n. Here's a video explaining further:\nendTrigger\nString | Element\n- The element (or selector text for the element) whose position in the normal document flow is used for calculating where the ScrollTrigger ends. You don't need to define an\nendTrigger\nunless it's DIFFERENT than the\ntrigger\nelement because that's the default.\nfastScrollEnd\nBoolean | Number\n- if\ntrue\n, it will force the current ScrollTrigger's animation to completion if you\nleave\nits trigger area faster than a certain velocity (default 2500px/s). This helps avoid overlapping animations when the user scrolls quickly. You can specify a number for the minimum velocity, so\nfastScrollEnd: 3000\nwould only activate if the velocity exceeds 3000px/s. See a\ndemo here\n.\nhorizontal\nBoolean\n- By default, it assumes your setup uses vertical scrolling but simply set\nhorizontal: true\nif your setup uses horizontal scrolling instead.\nid\nString\n- An arbitrary unique identifier for the ScrollTrigger instance which can be used with\nScrollTrigger.getById()\n. This id is also added to the markers.\ninvalidateOnRefresh\nBoolean\n- If\ntrue\n, the animation associated with the ScrollTrigger will have its\ninvalidate()\nmethod called whenever a refresh() occurs (typically on resize). This flushes out any internally-recorded starting values.\nmarkers\nObject | Boolean\n- Adds markers that are helpful during development/troubleshooting.\nmarkers: true\nadds them with the defaults (startColor: \"green\", endColor: \"red\", fontSize: \"16px\", fontWeight: \"normal\", indent: 0) but you can customize them by using an object like\nmarkers\n:\n{\nstartColor\n:\n\"white\"\n,\nendColor\n:\n\"white\"\n,\nfontSize\n:\n\"18px\"\n,\nfontWeight\n:\n\"bold\"\n,\nindent\n:\n20\n}\nonce\nBoolean\n- If\ntrue\n, the ScrollTrigger will kill() itself as soon as the end position is reached once. This causes it to stop listening for scroll events and it becomes eligible for garbage collection. This will only call onEnter a maximum of one time as well. It does\nnot\nkill the associated animation. It's perfect for times when you only want an animation to play once when scrolling forward and never get reset or replayed. It also sets the toggleActions to \"play none none none\".\nonEnter\nFunction\n- A callback for when the scroll position moves forward past the \"start\" (typically when the trigger is scrolled into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonEnter\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonEnterBack\nFunction\n- A callback for when the scroll position moves backward past the \"end\" (typically when the trigger is scrolled back into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonEnterBack\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonLeave\nFunction\n- A callback for when the scroll position moves forward past the \"end\" (typically when the trigger is scrolled out of view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonLeave\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonLeaveBack\nFunction\n- A callback for when the scroll position moves backward past the \"start\" (typically when the trigger is scrolled all the way backward past the start). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonLeaveBack\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonRefresh\nFunction\n- A callback for when the a refresh occurs (typically a resize event) which forces the ScrollTrigger to recalculate all of its positioning. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonRefresh\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonUpdate\nFunction\n- A callback that gets called every time the progress of the ScrollTrigger changes (meaning the scroll position changed). If you have a numeric\nscrub\napplied, keep in mind that the associated animation will keep scrubbing for a little while after the scroll position stops, so if your goal is to update something whenever the animation updates, it's best to apply an\nonUpdate\nto the animation itself rather than the ScrollTrigger.\nSee a demo here\n.\nThe onUpdate callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n.\nExample:\nonUpdate\n:\nself\n=>\nconsole\n.\nlog\n(\n\"progress\"\n,\nself\n.\nprogress\n)\nonScrubComplete\nFunction\n- A callback for when a numerical scrub has completed. This is only useful when a numerical scrub (like\nscrub: 1\n) is applied. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonScrubComplete\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonSnapComplete\nFunction\n- A callback for when the snapping has completed. This only applies when there's a\nsnap\ndefined. A snap will be cancelled if/when the user (or anything else) interacts in any way with scrolling, so the onSnapComplete would not be triggered at all in that case. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonSnapComplete\n:\n(\n{\nprogress\n,\ndirection\n,\nisActive\n}\n)\n=>\nconsole\n.\nlog\n(\nprogress\n,\ndirection\n,\nisActive\n)\nonToggle\nFunction\n- A callback for when the ScrollTrigger toggles from inactive to active\nor\nthe other way around. This is typically when the scroll position moves past the \"start\" or \"end\" in either direction, but if it shoots past BOTH on the same tick, like if the user scrolls extremely fast, onToggle won't fire because the state hasn't changed. You can often use this one callback in the place of onEnter, onLeave, onEnterBack, and onLeaveBack by just checking the isActive property for toggling things. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\nprogress\n,\ndirection\n,\nisActive\n, and\ngetVelocity()\n. Example:\nonToggle\n:\nself\n=>\nconsole\n.\nlog\n(\n\"toggled to active:\"\n,\nisActive\n)\npin\nBoolean | String | Element\n- An element (or selector text for the element) that should be pinned during the time that the ScrollTrigger is active, meaning it will appear to \"stick\" in its starting position while the rest of the content continues scrolling underneath it. Only one pinned element is allowed, but it can contain as many elements as you want. Setting\npin: true\nwill cause it to pin the\ntrigger\nelement.\nWarning\ndon't animate the pinned element itself because that will throw off the measurements (ScrollTrigger is highly optimized for performance and pre-calculates as much as possible). Instead, you could nest things such that you're animating only elements INSIDE the pinned element.\nNote:\nif you are pinning something that is nested\ninside\nanother element that\nalso\ngets pinned, make sure you define a\npinnedContainer\nso that ScrollTrigger knows to offset the start/end positions accordingly.\nUsing React? Make sure to do proper cleanup - read\nthis article\n.\npinnedContainer\nElement | String\n- If your ScrollTrigger's\ntrigger\n/\nendTrigger\nelement is\nINSIDE\nan element that gets pinned by\nanother\nScrollTrigger (pretty uncommon), that would cause the start/end positions to be thrown off by however long that pin lasts, so you can set the\npinnedContainer\nto that parent/container element to have ScrollTrigger calculate those offsets accordingly. Again, this is very rarely needed.\nImportant\n: nested pinning is not supported, so this feature is only for non-pinning ScrollTriggers\n(added in 3.7.0)\npinReparent\nBoolean\n- If\ntrue\n, the pinned element will be reparented to the\n<body>\nwhile it is actively pinned so that it can escape any ancestor containing blocks. If you notice odd behavior while pinning (like the pinned element suddenly shifting and then moving with the scroll), you probably have a\ntransform\nor\nwill-change\non an ancestor element which\nbreaks\nposition: fixed\nbehavior (it's a browser thing, not ScrollTrigger). It's best to set up your project to avoid those because reparenting can be expensive, but\npinReparent: true\ncan bail you out if you can't avoid them. Only use this feature if you must.\nWarning:\nif you have CSS rules that rely on specific nesting that'd be affected by the reparenting, they'll break. For example, a CSS rule like\n.section .panel p {color: white}\nwouldn't apply to the nested\n<p>\nanymore if you pin the\n.panel\nelement with\npinReparent: true\nbecause during the pin, it would no longer be inside the\n<section>\n, so make sure you write your CSS rules to accommodate the reparenting.\npinSpacer\nElement | String\n- normally ScrollTrigger creates a\n<div>\ninternally to wrap around pinned elements but in the\nextremely\nrare scenario where you're loading an iframe into the pinned element, it can cause the iframe to refresh when ScrollTrigger refreshes (like on window resize), so this feature allows you to specify an element that should be used as the spacer instead of the internally-created one. That way, ScrollTrigger won't remove/add it during its refresh, keeping iframe content intact.\npinSpacing\nBoolean | String\n- By default, padding will be added to the bottom (or right for\nhorizontal: true\n) to push other elements down so that when the pinned element gets unpinned, the following content catches up perfectly. Otherwise, things may scroll UNDER the pinned element. You can tell ScrollTrigger not to add any padding by setting\npinSpacing: false\n.\nView More details\nIf you'd rather it use margin instead of padding, you can set\npinSpacing: \"margin\"\n.\nNote:\npinSpacing works in most cases, but it really depends on the way you set up your DOM and CSS. For example, if you pin something in a parent that has display: flex or position: absolute, the extra padding won't push other elements down/right so you may need to manually space things out. pinSpacing is just a convenience that works in most situations.\nImportant\n: if the container is\ndisplay: flex\n,\npinSpacing\nis set to\nfalse\nby default because that's typically what is desired since padding works differently in that context.\nThis video on pinning that's part of SnorklTV's\nScrollTrigger Express course\nmay help your understanding.\npinType\n\"fixed\" | \"transform\"\n- by default,\nposition: fixed\nis used for pinning only if the scroller is the\n<body>\n, otherwise transforms are used (because\nposition: fixed\nwon't work in various nested scenarios), but you can\nforce\nScrollTrigger to use\nposition: fixed\nby setting\npinType: \"fixed\"\n. Typically this isn't necessary or helpful. Beware that if you set the CSS property\nwill-change: transform\n, browsers treat it just like having a transform applied, breaking\nposition: fixed\nelements (this is unrelated to ScrollTrigger/GSAP).\npreventOverlaps\nBoolean | String\n- this feature activates as a ScrollTrigger is about to trigger an animation; it finds preceding scrollTrigger-based animations and forces those previous animations to their end state \u00e2\u0080\u0093 avoiding unsightly overlaps. if\ntrue\n, it will affect all preceding ScrollTriggers. You can use an arbitrary string to limit their effect to only others with a matching string. So\npreventOverlaps: \"group1\"\nwould only affect other ScrollTriggers with\npreventOverlaps: \"group1\"\n. See a\ndemo here\n.\nrefreshPriority\nnumber\n- it's\nVERY\nunlikely that you'd need to define a\nrefreshPriority\nas long as you create your ScrollTriggers in the order they'd happen on the page (top-to-bottom or left-to-right)...which we\nstrongly\nrecommend doing. Otherwise, use\nrefreshPriority\nto influence the order in which ScrollTriggers get refreshed to ensure that the pinning distance gets added to the start/end values of subsequent ScrollTriggers further down the page (that's why order matters). See the\nsort()\nmethod for details. A ScrollTrigger with\nrefreshPriority: 1\nwill get refreshed earlier than one with\nrefreshPriority: 0\n(the default). You're welcome to use negative numbers too, and you can assign the same number to multiple ScrollTriggers.\nscroller\nString | Element\n- By default, the\nscroller\nis the\nviewport\nitself, but if you'd like to add a ScrollTrigger to a scrollable\n<div>\n, for example, just define that as the scroller. You can use selector text like \"#elementID\" or the element itself.\nscrub\nBoolean | Number\n- Links the progress of the animation directly to the scrollbar so it acts like a scrubber. You can apply smoothing so that it takes a little time for the playhead to catch up with the scrollbar's position! It can be any of the following\nBoolean\n-\nscrub: true\nlinks the animation's progress directly to the ScrollTrigger's progress.\nNumber\n- The amount of time (in seconds) that the playhead should take to \"catch up\", so\nscrub: 0.5\nwould cause the animation's playhead to take 0.5 seconds to catch up with the scrollbar's position. It's great for smoothing things out.\nsnap\nNumber | Array | Function | Object | \"labels\" | \"labelsDirectional\"\n- Allows you to snap to certain progress values (between 0 and 1) after the user stops scrolling. So\nsnap: 0.1\nwould snap in increments of 0.1 (10%, 20%, 30%, etc.).\nsnap: [0, 0.1, 0.5, 0.8, 1]\nwould only let it come to rest on one of those specific progress values. It can be any of the following...\nView More details\nNumber\n-\nsnap: 0.1\nsnaps in increments of 0.1 (10%, 20%, 30%, etc.). If you have a certain number of sections, simply do\n1 / (sections - 1)\n.\nArray\n-\nsnap: [0, 0.1, 0.5, 0.8, 1]\nsnaps to the closest progress value in the Array in the direction of the last scroll (unless you set\ndirectional: false\n).\nFunction\n-\nsnap: (value) => Math.round(value / 0.2) * 0.2\nfeeds the natural destination value (based on velocity) into the function and uses whatever is returned as the final progress value (in this case increments of 0.2), so you can run whatever logic you want. These values should always be between 0 and 1 indicating the progress of the animation, so 0.5 would be in the middle.\n\"labels\"\n-\nsnap: \"labels\"\nsnaps to the closest label in the timeline (animation must be a timeline with labels, of course)\n\"labelsDirectional\"\n-\nsnap: \"labelsDirectional\"\nsnaps to the closest label in the timeline that's in the direction of the most recent scroll. So if you scroll a little bit toward the next label (and stop), even if the current scroll position is technically closest to the current/last label, it'll snap to the next one in that direction instead. This can make it feel more intuitive for users.\nObject\n- Like\nsnap: {snapTo: \"labels\", duration: 0.3, delay: 0.1, ease: \"power1.inOut\"}\n, fully customizable with any of the following properties (only \"snapTo\" is required):\nsnapTo\n[Number | Array | Function | \"labels\"] - determines the snapping logic (described above)\ndelay\n[Number] - the delay (in seconds) between the last scroll event and the start of the snapping animation. Default is half the scrub amount (or 0.1 if scrub isn't a number)\ndirectional\n[Boolean] - by default (as of version 3.8.0), snapping is directional by default meaning it'll go in the direction the user last scrolled, but you can disable this by setting\ndirectional: false\n.\nduration\n[Number | Object] - the duration of the snapping animation (in seconds).\nduration: 0.3\nwould always take 0.3 seconds, but you can also define a range as an object like\nduration: {min: 0.2, max: 3}\nto clamp it within the provided range, based on the velocity. That way, if the user stops scrolling close to a snapping point, it'd take less time to snap than if the natural stopping point is far from a snapping point.\nease\n[String | Function] - the\nease\nthat the snapping animation should use. The default is \"power3\".\ninertia\n[Boolean] - to tell ScrollTrigger\nnot\nto factor in the inertia, set\ninertia: false\nonStart\n[Function] - a function that should be called when snapping starts\nonInterrupt\n[Function] - a function that should be called when snapping gets interrupted (like if the user starts scrolling mid-snap)\nonComplete\n[Function] - a function that should be called when snapping completes\nstart\nString | Number | Function\n- Determines the starting position of the ScrollTrigger.\nView More details\nIt can be any of the following:\nString\n- Describes a place on the\ntrigger\nand a place on the\nscroller\nthat must meet in order to start the ScrollTrigger. So, for example,\n\"top center\"\nmeans\n\"when the top of the trigger hits the center of the scroller\"\n(and the scroller is the viewport by default).\n\"bottom 80%\"\nmeans\n\"when the bottom of the trigger hits 80% down from the top of the viewport\" (assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\"\nif\nhorizontal: true\n) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/scroller. You can even use a complex relative value like\n\"top bottom-=100px\"\nwhich means\n\"when the top of the trigger hits 100px above the bottom of the viewport/scroller\"\nNumber\n- An exact scroll value, so\n200\nwould trigger when the viewport/scroller scrolls by exactly 200 pixels.\nFunction\n- A function that gets called whenever the ScrollTrigger calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter, so you can, for example, base the position on the previous ScrollTrigger's end like\nstart: self => self.previous().end\nThis is a\nstatic\nposition that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call\nScrollTrigger.refresh()\nto force things to be recalculated. The default is\n\"top bottom\"\nunless\npin: true\nis set in which case the default value is\n\"top top\"\n.\nclamp() the value\n(version 3.12+)\nWrap your start value in\n\"clamp()\"\nto tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any \"above the fold\" (triggers inside the viewport at the top of the page) won't start out with partially-scrubbed animations. For example,\nstart: \"clamp(top bottom)\"\n- any normal string-based value can be inside the clamp(). Like\n\"clamp(20px 80%)\"\n. Here's a video explaining further:\ntoggleActions\nString\n- Determines how the linked animation is controlled at the 4 distinct toggle places -\nonEnter\n,\nonLeave\n,\nonEnterBack\n, and\nonLeaveBack\n, in that order. The default is\nplay none none none\n. So\ntoggleActions: \"play pause resume reset\"\nwill play the animation when entering, pause it when leaving, resume it when entering again backwards, and reset (rewind back to the beginning) when scrolling all the way back past the beginning. You can use any of the following keywords for each action: \"play\", \"pause\", \"resume\", \"reset\", \"restart\", \"complete\", \"reverse\", and \"none\".\ntoggleClass\nString | Object\n- Adds/removes a class to an element (or multiple elements) when the ScrollTrigger toggles active/inactive. It can be either of the following:\nString\n- The name of the class to add to the\ntrigger\nelement, like\ntoggleClass: \"active\"\nObject\n- To toggle a class for elements other than just the trigger, use the object syntax like\ntoggleClass: {targets: \".my-selector\", className: \"active\"}\n. The \"targets\" can be selector text, a direct reference to an element, or an Array of elements.\nNote that\ntoggleActions\ndon't apply to\ntoggleClass\n. To have toggle class names in a different way, use the callback functions (onEnter, onLeave, onLeaveBack, and onEnterBack).\ntrigger\nString | Element\n- The element (or selector text for the element) whose position in the normal document flow is used to calculate where the ScrollTrigger starts.\nLooking for Smooth Scrolling?\nGSAP's own\nScrollSmoother\ntool is built on top of ScrollTrigger, so it is totally integrated and super easy to use. Built on native scroll technology, it avoids most of the accessibility issues that plague other smooth-scrolling libraries.\nProperties\n\u00e2\u0080\u008b\n.animation\n: Tween | Timeline | undefined\n[read-only] The\nTween\nor\nTimeline\nassociated with the ScrollTrigger instance (if any).\n.direction\n: Number\n[read-only] Reflects the moment-by-moment direction of scrolling where\n1\nis forward and\n-1\nis backward.\n.end\n: Number\n[read-only] The ScrollTrigger's ending scroll position (numeric, in pixels).\n.isActive\n: Boolean\n[read-only] Only\ntrue\nif the scroll position is between the start and end positions of the ScrollTrigger instance.\nScrollTrigger\n.isTouch\n: Number\nA way to discern the touch capabilities of the current device -\n0\nis mouse/pointer only (no touch),\n1\nis touch-only,\n2\naccommodates both.\n.pin\n: Element | undefined\n[read-only] The pin element (if one was defined). If selector text was used, like \".pin\", the\npin\nwill be the element itself (not selector text)\nprogress\n: Number\n[read-only] The overall progress of the ScrollTrigger instance where 0 is at the start, 0.5 is in the middle, and 1 is at the end.\nscroller\n: Element | window\n[read-only] The scroller element (or window) associated with the ScrollTrigger. It's the thing whose scrollbar is linked to the ScrollTrigger. By default, it's the window (viewport).\nstart\n: Number\n[read-only] The ScrollTrigger's starting scroll position (numeric, in pixels).\n.trigger\n: Element | undefined\n[read-only] The trigger element (if one was defined). If selector text was used, like \".trigger\", the\ntrigger\nwill be the element itself (not selector text)\n.vars\n: Object\n[read-only] The vars configuration object used to create the ScrollTrigger instance\nMethods\n\u00e2\u0080\u008b\n.disable\n( revert:boolean, allowAnimation:Boolean )\nDisables the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger.\n.enable\n( reset:Boolean )\nEnables the ScrollTrigger instance\n.getTween\n( snap:Boolean ) : Tween\nReturns the\nscrub\ntween (default) or the snapping tween (\ngetTween(true)\n)\n.getVelocity\n(  ) : Number\nGets the scroll velocity in pixels-per-second\n.kill\n( revert:boolean, allowAnimation:Boolean )\nKills the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger and removing all scroll-related listeners, etc. so that the instance is eligible for garbage collection. If you only want to temporarily disable the ScrollTrigger, use the\ndisable()\nmethod instead.\n.labelToScroll\n( label:String ) : Number\nConverts a timeline label into the associated scroll position (only applicable to ScrollTriggers whose \"animation\" is a timeline)\n.next\n(  ) : ScrollTrigger instance\nReturns the next ScrollTrigger in the refresh order.\n.previous\n(  ) : ScrollTrigger instance\nReturns the previous ScrollTrigger in the refresh order.\n.refresh\n()\nForces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated).\n.scroll\n( position:Number ) : Number | null\nGets/Sets the scroll position of the associated scroller (numeric).\nScrollTrigger\n.addEventListener\n( type:String, callback:Function ) : null\nAdd a listener for any of the following events: \"scrollStart\", \"scrollEnd\", \"refreshInit\", \"revert\", \"matchMedia\", or\"refresh\" which get dispatched globally when\nany\nsuch ScrollTrigger-related event occurs (it is not tied to a particular instance).\nScrollTrigger\n.batch\n( triggers:Selector text | Array, vars:Object ) : Array\nCreates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks (onEnter, onLeave, etc.) within a certain interval, delivering a neat Array so that you can easily do something like create a staggered animation of all the elements that enter the viewport around the same time.\nScrollTrigger\n.clearMatchMedia\n( query:String )\nScrollTrigger\n.clearScrollMemory\n( scrollRestoration:String )\nClears any recorded scroll positions in ScrollTrigger so that no scroll positions get restored after a refresh(). Normally, this isn't necessary but in some frameworks that handle routing in unconventional ways, it can be useful.\nScrollTrigger\n.config\n( vars:Object )\nAllows you to configure certain global behaviors of ScrollTrigger like\nlimitCallbacks\nScrollTrigger\n.create\n( vars:Object ) : ScrollTrigger\nCreates a standalone ScrollTrigger instance\nScrollTrigger\n.defaults\n( config:Object ) : null\nAllows you to set the default values that apply to every ScrollTrigger upon creation, like\ntoggleActions\n,\nmarkers\n, etc.\nScrollTrigger\n.getAll\n(  ) : Array\nReturns an Array of all ScrollTrigger instances\nScrollTrigger\n.getById\n( id:String ) : ScrollTrigger\nReturns the ScrollTrigger that was assigned the corresponding\nid\nScrollTrigger\n.isInViewport\n( Element:Element | String, proportion:Number, horizontal:Boolean ) : Boolean\nReturns\ntrue\nif the element is in the viewport. You can optionally specify a minimum proportion, like\nScrollTrigger.isInViewport(element, 0.2)\nwould only return\ntrue\nif at least 20% of the element is in the viewport.\nScrollTrigger\n.isScrolling\n(  ) : Boolean\nIndicates whether or not any ScrollTrigger-related scroller is in the process of scrolling.\nScrollTrigger\n.killAll\n(  ) ;\nImmediately calls\nkill()\non\nall\nScrollTriggers (except the main ScrollSmoother one if it exists).\nScrollTrigger\n.matchMedia\n( vars:Object )\n[DEPRECATED] Allows you to set up ScrollTriggers that only apply to certain viewport sizes (using media queries).\nScrollTrigger\n.maxScroll\n( scroller:Element | window, horizontal:Boolean ) : Number\nA utility function for getting the maximum scroll value for a particular element/scroller. For example, if the element/scroller is 500px tall and contains 800px of content, maxScroll() would return 300.\nScrollTrigger\n.normalizeScroll\n( normalize:Boolean | Object ) : ScrollObserver | null\nForces scrolling to be done on the JavaScript thread, ensuring screen updates are synchronized and the address bar doesn't show/hide on [most] mobile devices.\nScrollTrigger\n.observe\n( config:Object ) : Observer\nSuper-flexible, unified way to sense meaningful events across all (touch/mouse/pointer) devices without wrestling with all the implementation details. Trigger simple callbacks like onUp, onDown, onLeft, onRight, onChange, onHover, onDrag, etc. Functionally identical to\nObserver.create()\nScrollTrigger\n.positionInViewport\n( element:Element | String, referencePoint:String | Number, horizontal:Boolean ) : Number\nReturns a normalized value representing the element's position in relation to the viewport where 0 is at the top of the viewport, 0.5 is in the center, and 1 is at the bottom. So, for example, if the top of the element is 80% down from the top of the viewport, the following code would return 0.8:\nScrollTrigger.positionInViewport(element, \"top\");\nScrollTrigger\n.refresh\n( safe:Boolean )\nRecalculates the positioning of all of the ScrollTriggers on the page; this typically happens automatically when the window/scroller resizes but you can force it by calling\nScrollTrigger.refresh()\nScrollTrigger\n.removeEventListener\n( type:String, callback:Function ) : null\nRemoves an event listener\nScrollTrigger\n.saveStyles\n( targets:String | Element | Array )\nInternally records the current inline CSS styles for the given elements so that when ScrollTrigger reverts (typically for a refresh() or matchMedia() change) those elements will be reverted accordingly even if they had animations that added/changed inline styles. Think of it like taking a snapshot of the inline CSS and telling ScrollTrigger \"re-apply these inline styles only and dump all others when you revert internally\".\nScrollTrigger\n.scrollerProxy\n( scroller:String | Element, vars:Object )\nAllows you to hijack the\nscrollTop\nand/or\nscrollLeft\ngetters/setters for a particular scroller element so that you can implement things like smooth scrolling or other custom effects.\nScrollTrigger\n.snapDirectional\n( incrementOrArray:Number | Array ) : Function\nReturns a snapping function to which you can feed any value to snap, along with a direction where\n1\nis forward (greater than) and\n-1\nis backward (less than).\nScrollTrigger\n.sort\n( func:Function ) : Array\nSorts the internal Array of ScrollTrigger instances to control the order in which they\nrefresh()\n(calculate their start/end values).\nScrollTrigger\n.update\n(  )\nChecks where the scrollbar is and updates all ScrollTrigger instances'\nprogress\nand\ndirection\nvalues accordingly, controls the animation (if necessary) and fires the appropriate callbacks.\nFAQs\n\u00e2\u0080\u008b\nHow does ScrollTrigger work? Is it just like IntersectionObserver?\nScrollTrigger does\nNOT\nconstantly watch every element and check its positioning in the viewport on each tick. We're obsessed with performance and that'd be far too costly. Instead, ScrollTrigger does the processing up-front to figure out where the start/end points are\nin the natural document flow\n. In other words,\n\"this ScrollTrigger will be active when the scrollbar is between ___ and ____\"\n. Then, it debounces the \"scroll\" events and only updates things on the next requestAnimationFrame, perfectly synced with GSAP and screen refreshes. It\nONLY\nwatches the scroll position.\nPeriod.\nThat means it's\nFAST\n.\nScrollTrigger automatically listens for viewport/scroller \"resize\" events and recalculates all the start/end positions accordingly (\nonRefresh\n). In fact, since resizing/refreshing is CPU-intensive, it waits until there's a 200ms gap in resize events before starting its work. Yeah, we looked for every opportunity to maximize performance.\nIntersectionObserver\nis a native feature in most modern browsers that's different in the following ways:\nIt constantly \"watches\" elements to sense when they enter/leave regardless of scrolling.\nIt's\nnot\nhelpful for tracking an element's position between two points, like for scrubbing an animation accordingly.\nIt does let you watch multiple elements and have a single callback triggered that could loop through and fire a staggered animation on just the elements that entered, for example.\nScrollTrigger does not use IntersectionObserver under the hood because it lacks the necessary functionality and compatibility. You can certainly use IntersectionObserver and ScrollTrigger together.\nHow does pinning work under the hood?\nThe pinned element gets immediately wrapped in a\n<div>\nwith a\nfixed\nwidth/height to match. A class of \"pin-spacer\" is added to that wrapper. Think of it like a proxy element that props open the space where the pinned element was in the DOM so that when it flips to\nposition: fixed\nthings don't collapse.\nBy default, padding will be added to the bottom (or right for horizontal: true) of the pin-spacer so that [in most cases] things get pushed further down/right. When the pinned element gets unpinned, the content below/right will have caught up. So if, for example, the pinned element stays pinned for 300px, there would be padding of 300px added.\nwalkthrough\nThis video on pinning that's part of SnorklTV's\nScrollTrigger Express course\nmay help your understanding.\nWhen the ScrollTrigger is active (when the scroll position is between the start and end), it sets the pinned element to\nposition: fixed\nand positions it with fixed top/left/width/height values...unless the scroller isn't the viewport in which case it never uses\nposition: fixed\nbecause that'd break sub-scrolling, so it uses pure transforms. If\npinReparent\nis set to\ntrue\n(we recommend avoiding that if you can), the pinned element will get reparented to the\n<body>\nand styles will be moved inline to ensure appearance is maintained.\nWhen the ScrollTrigger becomes inactive, the pinned element reverts to its original\nposition\nvalue and a\ntransform\nis applied to place it correctly.\nWhen the window/scroller gets resized, all ScrollTriggers re-calculate their start/end positions (\nonRefresh\n). As a part of that process, the pin-spacer is removed from the DOM and the pinned element is swapped back in so that measurements are accurate with the original CSS. Then the pin-spacer is swapped back in as a wrapper.\nWhy not just use transforms and avoid\nposition: fixed\n? Many browsers don't render consistently using that technique. There are annoying visual glitches due to the fact that scroll repaints are handled on a different thread in most modern browsers. Surprisingly,\nposition: fixed\nseemed to deliver better performance overall. And performance is EXTREMELY important for scrolling.\nHow does duration work with scrub: true?\nIf you have a ScrollTrigger\nscrub: true\nand that ScrollTrigger has a timeline or tween animation associated with it, the durations of tweens within that animation serve as proportions for the total amount of distance that the tween will play. The proportion of how much distance it's animated between is in regards to the total duration of the animation. It's easiest to understand with an example:\nSay you have a timeline with three sequenced tweens: a 1 second tween, a 3 second tween, and then another 1 second tween. And the ScrollTrigger applied to it will animate for a full viewport height's distance (perhaps the trigger uses the values of\nstart: \"center bottom\"\nand\nend: \"center top\"\n).\nIf\nscrub: true\n(or a number) is applied, then the first tween will be animated between when the center of the trigger element is between the 100% mark (from the top; the bottom of the viewport) and the 80% mark (from the top) of the viewport. The second tween will fire when the center of the element is at the 80% mark until the 20% mark. And the third tween will fire when the center of the element is between the 20% mark and the 0% mark. This is because the total duration of the timeline is 5 seconds. So \u00e2\u0085\u0095 is 20% and \u00e2\u0085\u0097 is 60%.\nloading...\nIf you change the duration of all the tweens to the same number, say 1, then the percentages would all be equal: 100% -> 66%, 66% -> 33%, 33% -> 0%. This is because the total duration is 3, so \u00e2\u0085\u0093 is 33%.\nIn other words, the duration values don't matter as much as the proportions of the duration of each tween compared to the total time of the timeline.\nIf you want to make the animation take a longer distance of scroll to complete, affect the distance from start to end longer. For example you could set\nend: \"+=4000\"\nto make it take a lot of scrolling to complete.\nHow do I include undefined in my project?\nSee the\ninstallation page\nfor all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to\nregister undefined\nlike this in your project:\ngsap\n.\nregisterPlugin\n(\nundefined\n)\nIs this included in the GSAP core?\nNo, you must load/import it separately\nIt works fine during development, but suddenly stops working in the production build! What do I do?\nYour build tool is probably dropping the plugin when\ntree shaking\nand you forgot to\nregister undefined\n(which protects it from tree shaking). Just register the plugin like this:\ngsap\n.\nregisterPlugin\n(\nundefined\n)\nIs it bad to register a plugin multiple times?\nNo, it's perfectly fine. It doesn't help anything, nor does it hurt.\nHow do I include ScrollTrigger in my project?\nSee the\ninstallation page\nfor all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to\nregister ScrollTrigger\nlike this in your project:\ngsap\n.\nregisterPlugin\n(\nScrollTrigger\n)\nIs this included in the GSAP core?\nNo, you must load/import it separately\nIt works fine during development, but suddenly stops working in the production build! What do I do?\nYour build tool is probably dropping the plugin when\ntree shaking\nand you forgot to\nregister ScrollTrigger\n(which protects it from tree shaking). Just register the plugin like this:\ngsap\n.\nregisterPlugin\n(\nScrollTrigger\n)\nIs it bad to register a plugin multiple times?\nNo, it's perfectly fine. It doesn't help anything, nor does it hurt.\nDemos\n\u00e2\u0080\u008b\nCheck out the full collection of\nScroll animation demos\non CodePen.\nContents\nSimple example\nAdvanced example\nStandalone/Custom example\nFeatures\nConfig Object\nProperties\nMethods\nFAQs\nDemos",
  "content_markdown": "On this page\n\nScrollTrigger enables anyone to create [jaw-dropping scroll-based animations](https://youtu.be/uYMYlipIReA) with minimal code. Infinitely flexible. Scrub, pin, snap, or just trigger anything scroll-related, even if it has nothing to do with animation.\n\nDetailed walkthrough\n\nGet ahead of the game by also learning about [the most common ScrollTrigger mistakes.](/resources/st-mistakes)\n\n## Simple example[\u00e2\u0080\u008b](#simple-example \"Direct link to Simple example\")\n\n```\ngsap.to('.box', {  \n\tscrollTrigger: '.box', // start the animation when \".box\" enters the viewport (once)  \n\tx: 500  \n});\n```\n\n## Advanced example[\u00e2\u0080\u008b](#advanced-example \"Direct link to Advanced example\")\n\n```\nlet tl = gsap.timeline({  \n\t// yes, we can add it to an entire timeline!  \n\tscrollTrigger: {  \n\t\ttrigger: '.container',  \n\t\tpin: true, // pin the trigger element while active  \n\t\tstart: 'top top', // when the top of the trigger hits the top of the viewport  \n\t\tend: '+=500', // end after scrolling 500px beyond the start  \n\t\tscrub: 1, // smooth scrubbing, takes 1 second to \"catch up\" to the scrollbar  \n\t\tsnap: {  \n\t\t\tsnapTo: 'labels', // snap to the closest label in the timeline  \n\t\t\tduration: { min: 0.2, max: 3 }, // the snap animation should be at least 0.2 seconds, but no more than 3 seconds (determined by velocity)  \n\t\t\tdelay: 0.2, // wait 0.2 seconds from the last scroll event before doing the snapping  \n\t\t\tease: 'power1.inOut' // the ease of the snap animation (\"power3\" by default)  \n\t\t}  \n\t}  \n});  \n  \n// add animations and labels to the timeline  \ntl.addLabel('start')  \n\t.from('.box p', { scale: 0.3, rotation: 45, autoAlpha: 0 })  \n\t.addLabel('color')  \n\t.from('.box', { backgroundColor: '#28a92b' })  \n\t.addLabel('spin')  \n\t.to('.box', { rotation: 360 })  \n\t.addLabel('end');\n```\n\n## Standalone/Custom example[\u00e2\u0080\u008b](#standalonecustom-example \"Direct link to Standalone/Custom example\")\n\nYou don't need to put ScrollTriggers directly into animations (though that's probably the most common use case). Use the callbacks for anything...\n\n```\nScrollTrigger.create({  \n\ttrigger: '#id',  \n\tstart: 'top top',  \n\tendTrigger: '#otherID',  \n\tend: 'bottom 50%+=100px',  \n\tonToggle: (self) => console.log('toggled, isActive:', self.isActive),  \n\tonUpdate: (self) => {  \n\t\tconsole.log(  \n\t\t\t'progress:',  \n\t\t\tself.progress.toFixed(3),  \n\t\t\t'direction:',  \n\t\t\tself.direction,  \n\t\t\t'velocity',  \n\t\t\tself.getVelocity()  \n\t\t);  \n\t}  \n});\n```\n\n## Features[\u00e2\u0080\u008b](#features \"Direct link to Features\")\n\nFeature Highlights\n\n- **Link any animation to a particular element** so that it only plays when that element is in the viewport. This improves performance and ensures that your beautiful animations actually get seen!\n- ScrollTriggers can perform an actions on an animation (play, pause, resume, restart, reverse, complete, reset) when entering/leaving the defined area or link it directly to the scrollbar so that it acts like a **scrubber** (`scrub: true`).\n- **Soften the link between the animation and the the scrollbar** so that takes a certain amount of time to \"catch up\", like `scrub: 1` would take one second to catch up.\n- **Integrated with [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother)**, GreenSock's smooth-scrolling tool built on native scroll technology (members-only benefit).\n\n**read more...**\n\n- **Snap to certain points in the animation** based on velocity. In fact, you can `getVelocity()` of the scrolling anytime. Snap to the closest label in a timeline or progress value in an Array, or run your own custom function-based logic for snapping\n- **Embed scroll triggers directly into any GSAP animation** (including timelines) or create **standalone instances** and tap into the rich callback system to do anything you want.\n- **Advanced pinning** capabilities can lock an element in place between certain scroll positions. Padding is automatically added to push other elements down accordingly, so they catch up when the element gets unpinned (disable this with `pinSpacing: false`). You can even pin the same element multiple times at different points.\n- **Incredible flexibility for defining scroll positions** - like *\"start when the center of this element hits the center of the viewport, and end when the bottom of that other element hits the bottom of the viewport\"*, use keywords (top, center, bottom, left, right), percentages, pixels, or even relative values like `\"+=300px\"`. Once you get the hang of the syntax, it's remarkably intuitive.\n- Accommodates **vertical or horizontal scrolling**.\n- **Rich callback system** including onEnter, onLeave, onEnterBack, onLeaveBack, onToggle, onUpdate, onScrubComplete, and onRefresh.\n- **Automatically recalculates positions** when the window resizes.\n- **Enable visual markers** during development to see exactly where the start/end/trigger points are. Customization options abound, like `markers: {startColor:\"green\", endColor:\"red\", fontSize:\"12px\"}`.\n- **Toggle a CSS class**. For example, `toggleClass: \"active\"` adds the \"active\" class to the trigger element while the ScrollTrigger is active. You can affect other elements too.\n- **Responsive** - use the [matchMedia()](/docs/v3/GSAP/gsap.matchMedia()) method to create different setups for various screen sizes using standard media queries.\n- **Custom containers** - you don't need to use the viewport; define a custom scroller like a `<div>` instead.\n- **Highly optimized for maximum performance** - scroll events are debounced, updates are synchronized with GSAP and screen refreshes, resize recalculations are throttled, etc.\n- **No scroll-jacking**, so it can be combined with native technologies like CSS scroll snapping. If you want scroll-smoothing, you can use [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother) which integrates seamlessly with ScrollTrigger, or use the [scrollerProxy()](/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy()) method to integrate with a 3rd party smooth-scrolling library.\n\n## **Config Object**[\u00e2\u0080\u008b](#config-object \"Direct link to config-object\")\n\n`scrollTrigger` can be used as either a shorthand for the `trigger` (described below) or as a configuration object with any of the following properties:\n\n### Property\n\n### Description\n\n- #### animation\n\n  Tween | Timeline - A GSAP [Tween](/docs/v3/GSAP/Tween) or [Timeline](/docs/v3/GSAP/Timeline) instance that should be controlled by the ScrollTrigger. Only one animation is controlled per ScrollTrigger, but you can wrap all your animations in a single Timeline (recommended) or create multiple ScrollTriggers if you prefer.\n- #### anticipatePin\n\n  Number - If you pin large sections/panels you may notice what looks like a slight delay in pinning when you scroll quickly. That's caused by the fact that most modern browsers handle scroll repaints on a separate thread, so at the moment of pinning the browser may have already painted the pre-pinned content, making it visible for perhaps 1/60th of a second. The only way to counteract that is to have ScrollTrigger monitor the scroll velocity and anticipate the pin, applying it slightly early to avoid that flash of unpinned content. A value of `anticipatePin: 1` is typically fine, but you can reduce or increase that number to control how early it does the pinning. In many cases, however, you don't need any anticipatePin (the default is 0).\n- #### containerAnimation\n\n  Tween | Timeline Easily trigger animations inside 'horizontally' scrolling sections that are controlled by vertical scrolling\n\n  View More details\n\n  A popular effect is to create horizontally-moving sections that are tied to vertical scrolling but since that horizontal movement isn't a native scroll, a regular ScrollTrigger can't know when, for example, an element comes into view horizontally, so you must tell ScrollTrigger to monitor the container's [horizontal] animation to know when to trigger, like `containerAnimation: yourTween`.\n\n   \n\n  **Caveats****:** the container's animation must use a linear ease ( `ease: \"none\"`). Also, pinning and snapping aren't available on containerAnimation-based ScrollTriggers. You should avoid animating the `trigger` element horizontally or if you do, just offset the start/end values according to how far you're animating the trigger.\n\n  [more information here](/blog/3-8/#containeranimation).\n- #### end\n\n  String | Number | Function - Determines the ending position of the ScrollTrigger.\n\n  View More details\n\n  It can be any of the following:\n\n  - **String** - Describes a place on the **endTrigger** (or trigger if one isn't defined) and a place on the **scroller** that must meet in order to end the ScrollTrigger. So, for example, `\"bottom center\"` means *\"when the bottom of the endTrigger hits the center of the scroller\"*. `\"center 100px\"` means *\"when the center of the endTrigger hits 100px down from the top of the scroller\"* (assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\" if `horizontal: true`) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/viewport. You can also define a single relative value like \"+=300\" which means *\"300px beyond where the start is\"*, or \"+=100%\" means *\"the height of the scroller beyond where the start is\".* `\"max\"` is a special keyword indicating the maximum scroll position.\n  - **Number** - An exact scroll value, so `200` would trigger when the viewport/scroller scrolls by exactly 200 pixels.\n  - **Function** - A function that gets called whenever the ScrollTrigger refreshes and calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter. \n\n  This is a *static* position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call `ScrollTrigger.refresh()` to force things to be recalculated. The default is `\"bottom top\"`.\n  **clamp() the value** *(version 3.12+)*Wrap your end value in `\"clamp()\"` to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any trigger elements toward the very bottom of the page won't end with partially-scrubbed animations. For example, `end: \"clamp(bottom top)\"` - any normal string-based value can be inside the clamp(). Like `\"clamp(20px 80%)\"`. Here's a video explaining further:\n- #### endTrigger\n\n  String | Element - The element (or selector text for the element) whose position in the normal document flow is used for calculating where the ScrollTrigger ends. You don't need to define an `endTrigger` unless it's DIFFERENT than the `trigger` element because that's the default.\n- #### fastScrollEnd\n\n  Boolean | Number - if `true`, it will force the current ScrollTrigger's animation to completion if you **leave** its trigger area faster than a certain velocity (default 2500px/s). This helps avoid overlapping animations when the user scrolls quickly. You can specify a number for the minimum velocity, so `fastScrollEnd: 3000` would only activate if the velocity exceeds 3000px/s. See a [demo here](https://codepen.io/GreenSock/pen/7d22c763b9edd0c0c48150ecd1c921c9).\n- #### horizontal\n\n  Boolean - By default, it assumes your setup uses vertical scrolling but simply set `horizontal: true` if your setup uses horizontal scrolling instead.\n- #### id\n\n  String - An arbitrary unique identifier for the ScrollTrigger instance which can be used with `ScrollTrigger.getById()`. This id is also added to the markers.\n- #### invalidateOnRefresh\n\n  Boolean - If `true`, the animation associated with the ScrollTrigger will have its [invalidate()](/docs/v3/GSAP/Tween/invalidate()) method called whenever a refresh() occurs (typically on resize). This flushes out any internally-recorded starting values.\n- #### markers\n\n  Object | Boolean - Adds markers that are helpful during development/troubleshooting. `markers: true` adds them with the defaults (startColor: \"green\", endColor: \"red\", fontSize: \"16px\", fontWeight: \"normal\", indent: 0) but you can customize them by using an object like \n\n  ```\n  markers: {startColor: \"white\", endColor: \"white\", fontSize: \"18px\", fontWeight: \"bold\", indent: 20}\n  ```\n- #### once\n\n  Boolean - If `true`, the ScrollTrigger will kill() itself as soon as the end position is reached once. This causes it to stop listening for scroll events and it becomes eligible for garbage collection. This will only call onEnter a maximum of one time as well. It does **not** kill the associated animation. It's perfect for times when you only want an animation to play once when scrolling forward and never get reset or replayed. It also sets the toggleActions to \"play none none none\".\n- #### onEnter\n\n  Function - A callback for when the scroll position moves forward past the \"start\" (typically when the trigger is scrolled into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onEnter: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onEnterBack\n\n  Function - A callback for when the scroll position moves backward past the \"end\" (typically when the trigger is scrolled back into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onEnterBack: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onLeave\n\n  Function - A callback for when the scroll position moves forward past the \"end\" (typically when the trigger is scrolled out of view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onLeave: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onLeaveBack\n\n  Function - A callback for when the scroll position moves backward past the \"start\" (typically when the trigger is scrolled all the way backward past the start). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onLeaveBack: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onRefresh\n\n  Function - A callback for when the a refresh occurs (typically a resize event) which forces the ScrollTrigger to recalculate all of its positioning. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onRefresh: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onUpdate\n\n  Function - A callback that gets called every time the progress of the ScrollTrigger changes (meaning the scroll position changed). If you have a numeric `scrub` applied, keep in mind that the associated animation will keep scrubbing for a little while after the scroll position stops, so if your goal is to update something whenever the animation updates, it's best to apply an `onUpdate` to the animation itself rather than the ScrollTrigger. [See a demo here](https://codepen.io/osublake/pen/2152a28cffe2c2c0cca8a3e47f7b21c6?editors=0010).\n\n  The onUpdate callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`.\n\n   Example: \n\n  ```\n  onUpdate: self => console.log(\"progress\", self.progress)\n  ```\n- #### onScrubComplete\n\n  Function - A callback for when a numerical scrub has completed. This is only useful when a numerical scrub (like `scrub: 1`) is applied. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onScrubComplete: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onSnapComplete\n\n  Function - A callback for when the snapping has completed. This only applies when there's a `snap` defined. A snap will be cancelled if/when the user (or anything else) interacts in any way with scrolling, so the onSnapComplete would not be triggered at all in that case. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onSnapComplete: ({progress, direction, isActive}) => console.log(progress, direction, isActive)\n  ```\n- #### onToggle\n\n  Function - A callback for when the ScrollTrigger toggles from inactive to active **or** the other way around. This is typically when the scroll position moves past the \"start\" or \"end\" in either direction, but if it shoots past BOTH on the same tick, like if the user scrolls extremely fast, onToggle won't fire because the state hasn't changed. You can often use this one callback in the place of onEnter, onLeave, onEnterBack, and onLeaveBack by just checking the isActive property for toggling things. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like `progress`, `direction`, `isActive`, and `getVelocity()`. Example: \n\n  ```\n  onToggle: self => console.log(\"toggled to active:\", isActive)\n  ```\n- #### pin\n\n  Boolean | String | Element - An element (or selector text for the element) that should be pinned during the time that the ScrollTrigger is active, meaning it will appear to \"stick\" in its starting position while the rest of the content continues scrolling underneath it. Only one pinned element is allowed, but it can contain as many elements as you want. Setting `pin: true` will cause it to pin the `trigger` element.\n\n  **Warning** don't animate the pinned element itself because that will throw off the measurements (ScrollTrigger is highly optimized for performance and pre-calculates as much as possible). Instead, you could nest things such that you're animating only elements INSIDE the pinned element.\n\n  **Note:** if you are pinning something that is nested *inside* another element that *also* gets pinned, make sure you define a `pinnedContainer` so that ScrollTrigger knows to offset the start/end positions accordingly.\n\n  Using React? Make sure to do proper cleanup - read [this article](/resources/React).\n- #### pinnedContainer\n\n  Element | String - If your ScrollTrigger's `trigger`/`endTrigger` element is **INSIDE** an element that gets pinned by *another* ScrollTrigger (pretty uncommon), that would cause the start/end positions to be thrown off by however long that pin lasts, so you can set the `pinnedContainer` to that parent/container element to have ScrollTrigger calculate those offsets accordingly. Again, this is very rarely needed. **Important**: nested pinning is not supported, so this feature is only for non-pinning ScrollTriggers\n\n  *(added in 3.7.0)*\n- #### pinReparent\n\n  Boolean - If `true`, the pinned element will be reparented to the `<body>` while it is actively pinned so that it can escape any ancestor containing blocks. If you notice odd behavior while pinning (like the pinned element suddenly shifting and then moving with the scroll), you probably have a `transform` or `will-change` on an ancestor element which [breaks](https://stackoverflow.com/questions/15194313/transform3d-not-working-with-position-fixed-children) `position: fixed` behavior (it's a browser thing, not ScrollTrigger). It's best to set up your project to avoid those because reparenting can be expensive, but `pinReparent: true` can bail you out if you can't avoid them. Only use this feature if you must. \n\n  **Warning:** if you have CSS rules that rely on specific nesting that'd be affected by the reparenting, they'll break. For example, a CSS rule like `.section .panel p {color: white}` wouldn't apply to the nested `<p>` anymore if you pin the `.panel` element with `pinReparent: true` because during the pin, it would no longer be inside the `<section>`, so make sure you write your CSS rules to accommodate the reparenting.\n- #### pinSpacer\n\n  Element | String - normally ScrollTrigger creates a `<div>` internally to wrap around pinned elements but in the *extremely* rare scenario where you're loading an iframe into the pinned element, it can cause the iframe to refresh when ScrollTrigger refreshes (like on window resize), so this feature allows you to specify an element that should be used as the spacer instead of the internally-created one. That way, ScrollTrigger won't remove/add it during its refresh, keeping iframe content intact.\n- #### pinSpacing\n\n  Boolean | String - By default, padding will be added to the bottom (or right for `horizontal: true`) to push other elements down so that when the pinned element gets unpinned, the following content catches up perfectly. Otherwise, things may scroll UNDER the pinned element. You can tell ScrollTrigger not to add any padding by setting `pinSpacing: false`.\n\n  View More details\n\n  If you'd rather it use margin instead of padding, you can set `pinSpacing: \"margin\"`.\n\n  **Note:** pinSpacing works in most cases, but it really depends on the way you set up your DOM and CSS. For example, if you pin something in a parent that has display: flex or position: absolute, the extra padding won't push other elements down/right so you may need to manually space things out. pinSpacing is just a convenience that works in most situations.\n\n  **Important**: if the container is `display: flex`, `pinSpacing` is set to `false` by default because that's typically what is desired since padding works differently in that context.\n\n  This video on pinning that's part of SnorklTV's [ScrollTrigger Express course](https://www.creativecodingclub.com/courses/scrolltrigger-express?ref=44f484) may help your understanding.\n- #### pinType\n\n  \"fixed\" | \"transform\" - by default, `position: fixed` is used for pinning only if the scroller is the `<body>`, otherwise transforms are used (because `position: fixed` won't work in various nested scenarios), but you can **force** ScrollTrigger to use `position: fixed` by setting `pinType: \"fixed\"`. Typically this isn't necessary or helpful. Beware that if you set the CSS property `will-change: transform`, browsers treat it just like having a transform applied, breaking `position: fixed` elements (this is unrelated to ScrollTrigger/GSAP).\n- #### preventOverlaps\n\n  Boolean | String - this feature activates as a ScrollTrigger is about to trigger an animation; it finds preceding scrollTrigger-based animations and forces those previous animations to their end state \u00e2\u0080\u0093 avoiding unsightly overlaps. if `true`, it will affect all preceding ScrollTriggers. You can use an arbitrary string to limit their effect to only others with a matching string. So `preventOverlaps: \"group1\"` would only affect other ScrollTriggers with `preventOverlaps: \"group1\"`. See a [demo here](https://codepen.io/GreenSock/pen/7d22c763b9edd0c0c48150ecd1c921c9).\n- #### refreshPriority\n\n  number - it's **VERY** unlikely that you'd need to define a `refreshPriority` as long as you create your ScrollTriggers in the order they'd happen on the page (top-to-bottom or left-to-right)...which we *strongly* recommend doing. Otherwise, use `refreshPriority` to influence the order in which ScrollTriggers get refreshed to ensure that the pinning distance gets added to the start/end values of subsequent ScrollTriggers further down the page (that's why order matters). See the [sort()](/docs/v3/Plugins/ScrollTrigger/static.sort()) method for details. A ScrollTrigger with `refreshPriority: 1` will get refreshed earlier than one with `refreshPriority: 0` (the default). You're welcome to use negative numbers too, and you can assign the same number to multiple ScrollTriggers.\n- #### scroller\n\n  String | Element - By default, the `scroller` is the **viewport** itself, but if you'd like to add a ScrollTrigger to a scrollable `<div>`, for example, just define that as the scroller. You can use selector text like \"#elementID\" or the element itself.\n- #### scrub\n\n  Boolean | Number - Links the progress of the animation directly to the scrollbar so it acts like a scrubber. You can apply smoothing so that it takes a little time for the playhead to catch up with the scrollbar's position! It can be any of the following \n  - **Boolean** - `scrub: true` links the animation's progress directly to the ScrollTrigger's progress.\n  - **Number** - The amount of time (in seconds) that the playhead should take to \"catch up\", so `scrub: 0.5` would cause the animation's playhead to take 0.5 seconds to catch up with the scrollbar's position. It's great for smoothing things out.\n- #### snap\n\n  Number | Array | Function | Object | \"labels\" | \"labelsDirectional\" - Allows you to snap to certain progress values (between 0 and 1) after the user stops scrolling. So `snap: 0.1` would snap in increments of 0.1 (10%, 20%, 30%, etc.). `snap: [0, 0.1, 0.5, 0.8, 1]` would only let it come to rest on one of those specific progress values. It can be any of the following...\n\n  View More details\n\n  - **Number** - `snap: 0.1` snaps in increments of 0.1 (10%, 20%, 30%, etc.). If you have a certain number of sections, simply do `1 / (sections - 1)`.\n  - **Array** - `snap: [0, 0.1, 0.5, 0.8, 1]` snaps to the closest progress value in the Array in the direction of the last scroll (unless you set `directional: false`).\n  - **Function** - `snap: (value) => Math.round(value / 0.2) * 0.2` feeds the natural destination value (based on velocity) into the function and uses whatever is returned as the final progress value (in this case increments of 0.2), so you can run whatever logic you want. These values should always be between 0 and 1 indicating the progress of the animation, so 0.5 would be in the middle.\n  - **\"labels\"** - `snap: \"labels\"` snaps to the closest label in the timeline (animation must be a timeline with labels, of course)\n  - **\"labelsDirectional\"** - `snap: \"labelsDirectional\"` snaps to the closest label in the timeline that's in the direction of the most recent scroll. So if you scroll a little bit toward the next label (and stop), even if the current scroll position is technically closest to the current/last label, it'll snap to the next one in that direction instead. This can make it feel more intuitive for users.\n  - **Object** - Like `snap: {snapTo: \"labels\", duration: 0.3, delay: 0.1, ease: \"power1.inOut\"}`, fully customizable with any of the following properties (only \"snapTo\" is required):\n    - **snapTo** [Number | Array | Function | \"labels\"] - determines the snapping logic (described above)\n    - **delay** [Number] - the delay (in seconds) between the last scroll event and the start of the snapping animation. Default is half the scrub amount (or 0.1 if scrub isn't a number)\n    - **directional** [Boolean] - by default (as of version 3.8.0), snapping is directional by default meaning it'll go in the direction the user last scrolled, but you can disable this by setting `directional: false`.\n    - **duration** [Number | Object] - the duration of the snapping animation (in seconds). `duration: 0.3` would always take 0.3 seconds, but you can also define a range as an object like `duration: {min: 0.2, max: 3}` to clamp it within the provided range, based on the velocity. That way, if the user stops scrolling close to a snapping point, it'd take less time to snap than if the natural stopping point is far from a snapping point.\n    - **ease** [String | Function] - the [ease](/docs/v3/Eases) that the snapping animation should use. The default is \"power3\".\n    - **inertia** [Boolean] - to tell ScrollTrigger **not** to factor in the inertia, set `inertia: false`\n    - **onStart** [Function] - a function that should be called when snapping starts\n    - **onInterrupt** [Function] - a function that should be called when snapping gets interrupted (like if the user starts scrolling mid-snap)\n    - **onComplete** [Function] - a function that should be called when snapping completes\n- #### start\n\n  String | Number | Function - Determines the starting position of the ScrollTrigger.\n\n  View More details\n\n  It can be any of the following:\n  - **String** - Describes a place on the **trigger** and a place on the **scroller** that must meet in order to start the ScrollTrigger. So, for example, `\"top center\"` means *\"when the top of the trigger hits the center of the scroller\"* (and the scroller is the viewport by default). `\"bottom 80%\"` means *\"when the bottom of the trigger hits 80% down from the top of the viewport\" (assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\"* if `horizontal: true`) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/scroller. You can even use a complex relative value like `\"top bottom-=100px\"` which means *\"when the top of the trigger hits 100px above the bottom of the viewport/scroller\"*\n  - **Number** - An exact scroll value, so `200` would trigger when the viewport/scroller scrolls by exactly 200 pixels.\n  - **Function** - A function that gets called whenever the ScrollTrigger calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter, so you can, for example, base the position on the previous ScrollTrigger's end like `start: self => self.previous().end`\n\n  This is a *static* position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call `ScrollTrigger.refresh()` to force things to be recalculated. The default is `\"top bottom\"` unless `pin: true` is set in which case the default value is `\"top top\"`.\n  **clamp() the value** *(version 3.12+)*Wrap your start value in `\"clamp()\"` to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any \"above the fold\" (triggers inside the viewport at the top of the page) won't start out with partially-scrubbed animations. For example, `start: \"clamp(top bottom)\"` - any normal string-based value can be inside the clamp(). Like `\"clamp(20px 80%)\"`. Here's a video explaining further:\n- #### toggleActions\n\n  String - Determines how the linked animation is controlled at the 4 distinct toggle places - **onEnter**, **onLeave**, **onEnterBack**, and **onLeaveBack**, in that order. The default is `play none none none`. So `toggleActions: \"play pause resume reset\"` will play the animation when entering, pause it when leaving, resume it when entering again backwards, and reset (rewind back to the beginning) when scrolling all the way back past the beginning. You can use any of the following keywords for each action: \"play\", \"pause\", \"resume\", \"reset\", \"restart\", \"complete\", \"reverse\", and \"none\".\n- #### toggleClass\n\n  String | Object - Adds/removes a class to an element (or multiple elements) when the ScrollTrigger toggles active/inactive. It can be either of the following: \n  - **String** - The name of the class to add to the `trigger` element, like `toggleClass: \"active\"`\n  - **Object** - To toggle a class for elements other than just the trigger, use the object syntax like `toggleClass: {targets: \".my-selector\", className: \"active\"}`. The \"targets\" can be selector text, a direct reference to an element, or an Array of elements. Note that `toggleActions` don't apply to `toggleClass`. To have toggle class names in a different way, use the callback functions (onEnter, onLeave, onLeaveBack, and onEnterBack).\n- #### trigger\n\n  String | Element - The element (or selector text for the element) whose position in the normal document flow is used to calculate where the ScrollTrigger starts.\n\nLooking for Smooth Scrolling?\n\nGSAP's own [ScrollSmoother](/docs/v3/Plugins/ScrollSmoother) tool is built on top of ScrollTrigger, so it is totally integrated and super easy to use. Built on native scroll technology, it avoids most of the accessibility issues that plague other smooth-scrolling libraries.\n\n## **Properties**[\u00e2\u0080\u008b](#properties \"Direct link to properties\")\n\n|  |  |\n| --- | --- |\n| [.animation](/docs/v3/Plugins/ScrollTrigger/animation) : Tween | Timeline | undefined | [read-only] The [Tween](/docs/v3/GSAP/Tween) or [Timeline](/docs/v3/GSAP/Timeline) associated with the ScrollTrigger instance (if any). |\n| [.direction](/docs/v3/Plugins/ScrollTrigger/direction) : Number | [read-only] Reflects the moment-by-moment direction of scrolling where `1` is forward and `-1` is backward. |\n| [.end](/docs/v3/Plugins/ScrollTrigger/end) : Number | [read-only] The ScrollTrigger's ending scroll position (numeric, in pixels). |\n| [.isActive](/docs/v3/Plugins/ScrollTrigger/isActive) : Boolean | [read-only] Only `true` if the scroll position is between the start and end positions of the ScrollTrigger instance. |\n| [ScrollTrigger.isTouch](/docs/v3/Plugins/ScrollTrigger/static.isTouch) : Number | A way to discern the touch capabilities of the current device - `0` is mouse/pointer only (no touch), `1` is touch-only, `2` accommodates both. |\n| [.pin](/docs/v3/Plugins/ScrollTrigger/pin) : Element | undefined | [read-only] The pin element (if one was defined). If selector text was used, like \".pin\", the `pin` will be the element itself (not selector text) |\n| [progress](/docs/v3/Plugins/ScrollTrigger/progress) : Number | [read-only] The overall progress of the ScrollTrigger instance where 0 is at the start, 0.5 is in the middle, and 1 is at the end. |\n| [scroller](/docs/v3/Plugins/ScrollTrigger/scroller) : Element | window | [read-only] The scroller element (or window) associated with the ScrollTrigger. It's the thing whose scrollbar is linked to the ScrollTrigger. By default, it's the window (viewport). |\n| [start](/docs/v3/Plugins/ScrollTrigger/start) : Number | [read-only] The ScrollTrigger's starting scroll position (numeric, in pixels). |\n| [.trigger](/docs/v3/Plugins/ScrollTrigger/trigger) : Element | undefined | [read-only] The trigger element (if one was defined). If selector text was used, like \".trigger\", the `trigger` will be the element itself (not selector text) |\n| [.vars](/docs/v3/Plugins/ScrollTrigger/vars) : Object | [read-only] The vars configuration object used to create the ScrollTrigger instance |\n\n## **Methods**[\u00e2\u0080\u008b](#methods \"Direct link to methods\")\n\n|  |  |\n| --- | --- |\n| [.disable](/docs/v3/Plugins/ScrollTrigger/disable())( revert:boolean, allowAnimation:Boolean ) | Disables the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger. |\n| [.enable](/docs/v3/Plugins/ScrollTrigger/enable())( reset:Boolean ) | Enables the ScrollTrigger instance |\n| [.getTween](/docs/v3/Plugins/ScrollTrigger/getTween())( snap:Boolean ) : Tween | Returns the `scrub` tween (default) or the snapping tween (`getTween(true)`) |\n| [.getVelocity](/docs/v3/Plugins/ScrollTrigger/getVelocity())( ) : Number | Gets the scroll velocity in pixels-per-second |\n| [.kill](/docs/v3/Plugins/ScrollTrigger/kill())( revert:boolean, allowAnimation:Boolean ) | Kills the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger and removing all scroll-related listeners, etc. so that the instance is eligible for garbage collection. If you only want to temporarily disable the ScrollTrigger, use the [disable()](/docs/v3/Plugins/ScrollTrigger/disable()) method instead. |\n| [.labelToScroll](/docs/v3/Plugins/ScrollTrigger/labelToScroll())( label:String ) : Number | Converts a timeline label into the associated scroll position (only applicable to ScrollTriggers whose \"animation\" is a timeline) |\n| [.next](/docs/v3/Plugins/ScrollTrigger/next())( ) : ScrollTrigger instance | Returns the next ScrollTrigger in the refresh order. |\n| [.previous](/docs/v3/Plugins/ScrollTrigger/previous())( ) : ScrollTrigger instance | Returns the previous ScrollTrigger in the refresh order. |\n| [.refresh](/docs/v3/Plugins/ScrollTrigger/refresh())() | Forces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated). |\n| [.scroll](/docs/v3/Plugins/ScrollTrigger/scroll())( position:Number ) : Number | null | Gets/Sets the scroll position of the associated scroller (numeric). |\n| [ScrollTrigger.addEventListener](/docs/v3/Plugins/ScrollTrigger/static.addEventListener())( type:String, callback:Function ) : null | Add a listener for any of the following events: \"scrollStart\", \"scrollEnd\", \"refreshInit\", \"revert\", \"matchMedia\", or\"refresh\" which get dispatched globally when **any** such ScrollTrigger-related event occurs (it is not tied to a particular instance). |\n| [ScrollTrigger.batch](/docs/v3/Plugins/ScrollTrigger/static.batch())( triggers:Selector text | Array, vars:Object ) : Array | Creates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks (onEnter, onLeave, etc.) within a certain interval, delivering a neat Array so that you can easily do something like create a staggered animation of all the elements that enter the viewport around the same time. |\n| [ScrollTrigger.clearMatchMedia](/docs/v3/Plugins/ScrollTrigger/static.clearMatchMedia())( query:String ) |  |\n| [ScrollTrigger.clearScrollMemory](/docs/v3/Plugins/ScrollTrigger/static.clearScrollMemory())( scrollRestoration:String ) | Clears any recorded scroll positions in ScrollTrigger so that no scroll positions get restored after a refresh(). Normally, this isn't necessary but in some frameworks that handle routing in unconventional ways, it can be useful. |\n| [ScrollTrigger.config](/docs/v3/Plugins/ScrollTrigger/static.config())( vars:Object ) | Allows you to configure certain global behaviors of ScrollTrigger like `limitCallbacks` |\n| [ScrollTrigger.create](/docs/v3/Plugins/ScrollTrigger/static.create())( vars:Object ) : ScrollTrigger | Creates a standalone ScrollTrigger instance |\n| [ScrollTrigger.defaults](/docs/v3/Plugins/ScrollTrigger/static.defaults())( config:Object ) : null | Allows you to set the default values that apply to every ScrollTrigger upon creation, like `toggleActions`, `markers`, etc. |\n| [ScrollTrigger.getAll](/docs/v3/Plugins/ScrollTrigger/static.getAll())( ) : Array | Returns an Array of all ScrollTrigger instances |\n| [ScrollTrigger.getById](/docs/v3/Plugins/ScrollTrigger/static.getById())( id:String ) : ScrollTrigger | Returns the ScrollTrigger that was assigned the corresponding `id` |\n| [ScrollTrigger.isInViewport](/docs/v3/Plugins/ScrollTrigger/static.isInViewport())( Element:Element | String, proportion:Number, horizontal:Boolean ) : Boolean | Returns `true` if the element is in the viewport. You can optionally specify a minimum proportion, like `ScrollTrigger.isInViewport(element, 0.2)` would only return `true` if at least 20% of the element is in the viewport. |\n| [ScrollTrigger.isScrolling](/docs/v3/Plugins/ScrollTrigger/static.isScrolling())( ) : Boolean | Indicates whether or not any ScrollTrigger-related scroller is in the process of scrolling. |\n| [ScrollTrigger.killAll](/docs/v3/Plugins/ScrollTrigger/static.killAll())( ) ; | Immediately calls `kill()` on **all** ScrollTriggers (except the main ScrollSmoother one if it exists). |\n| [ScrollTrigger.matchMedia](/docs/v3/Plugins/ScrollTrigger/static.matchMedia())( vars:Object ) | [DEPRECATED] Allows you to set up ScrollTriggers that only apply to certain viewport sizes (using media queries). |\n| [ScrollTrigger.maxScroll](/docs/v3/Plugins/ScrollTrigger/static.maxScroll())( scroller:Element | window, horizontal:Boolean ) : Number | A utility function for getting the maximum scroll value for a particular element/scroller. For example, if the element/scroller is 500px tall and contains 800px of content, maxScroll() would return 300. |\n| [ScrollTrigger.normalizeScroll](/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll())( normalize:Boolean | Object ) : ScrollObserver | null | Forces scrolling to be done on the JavaScript thread, ensuring screen updates are synchronized and the address bar doesn't show/hide on [most] mobile devices. |\n| [ScrollTrigger.observe](/docs/v3/Plugins/ScrollTrigger/static.observe())( config:Object ) : Observer | Super-flexible, unified way to sense meaningful events across all (touch/mouse/pointer) devices without wrestling with all the implementation details. Trigger simple callbacks like onUp, onDown, onLeft, onRight, onChange, onHover, onDrag, etc. Functionally identical to [Observer.create()](/docs/v3/Plugins/Observer/static.create()) |\n| [ScrollTrigger.positionInViewport](/docs/v3/Plugins/ScrollTrigger/static.positionInViewport())( element:Element | String, referencePoint:String | Number, horizontal:Boolean ) : Number | Returns a normalized value representing the element's position in relation to the viewport where 0 is at the top of the viewport, 0.5 is in the center, and 1 is at the bottom. So, for example, if the top of the element is 80% down from the top of the viewport, the following code would return 0.8: `ScrollTrigger.positionInViewport(element, \"top\");` |\n| [ScrollTrigger.refresh](/docs/v3/Plugins/ScrollTrigger/static.refresh())( safe:Boolean ) | Recalculates the positioning of all of the ScrollTriggers on the page; this typically happens automatically when the window/scroller resizes but you can force it by calling `ScrollTrigger.refresh()` |\n| [ScrollTrigger.removeEventListener](/docs/v3/Plugins/ScrollTrigger/static.removeEventListener())( type:String, callback:Function ) : null | Removes an event listener |\n| [ScrollTrigger.saveStyles](/docs/v3/Plugins/ScrollTrigger/static.saveStyles())( targets:String | Element | Array ) | Internally records the current inline CSS styles for the given elements so that when ScrollTrigger reverts (typically for a refresh() or matchMedia() change) those elements will be reverted accordingly even if they had animations that added/changed inline styles. Think of it like taking a snapshot of the inline CSS and telling ScrollTrigger \"re-apply these inline styles only and dump all others when you revert internally\". |\n| [ScrollTrigger.scrollerProxy](/docs/v3/Plugins/ScrollTrigger/static.scrollerProxy())( scroller:String | Element, vars:Object ) | Allows you to hijack the `scrollTop` and/or `scrollLeft` getters/setters for a particular scroller element so that you can implement things like smooth scrolling or other custom effects. |\n| [ScrollTrigger.snapDirectional](/docs/v3/Plugins/ScrollTrigger/static.snapDirectional())( incrementOrArray:Number | Array ) : Function | Returns a snapping function to which you can feed any value to snap, along with a direction where `1` is forward (greater than) and `-1` is backward (less than). |\n| [ScrollTrigger.sort](/docs/v3/Plugins/ScrollTrigger/static.sort())( func:Function ) : Array | Sorts the internal Array of ScrollTrigger instances to control the order in which they [refresh()](/docs/v3/Plugins/ScrollTrigger/static.refresh()) (calculate their start/end values). |\n| [ScrollTrigger.update](/docs/v3/Plugins/ScrollTrigger/static.update())( ) | Checks where the scrollbar is and updates all ScrollTrigger instances' `progress` and `direction` values accordingly, controls the animation (if necessary) and fires the appropriate callbacks. |\n\n## FAQs[\u00e2\u0080\u008b](#faqs \"Direct link to FAQs\")\n\n#### How does ScrollTrigger work? Is it just like IntersectionObserver?\n\nScrollTrigger does **NOT** constantly watch every element and check its positioning in the viewport on each tick. We're obsessed with performance and that'd be far too costly. Instead, ScrollTrigger does the processing up-front to figure out where the start/end points are *in the natural document flow*. In other words, *\"this ScrollTrigger will be active when the scrollbar is between \\_\\_\\_ and \\_\\_\\_\\_\"*. Then, it debounces the \"scroll\" events and only updates things on the next requestAnimationFrame, perfectly synced with GSAP and screen refreshes. It **ONLY** watches the scroll position. **Period.** That means it's ***FAST***.\n\nScrollTrigger automatically listens for viewport/scroller \"resize\" events and recalculates all the start/end positions accordingly (`onRefresh`). In fact, since resizing/refreshing is CPU-intensive, it waits until there's a 200ms gap in resize events before starting its work. Yeah, we looked for every opportunity to maximize performance.\n\n[IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) is a native feature in most modern browsers that's different in the following ways:\n\n- It constantly \"watches\" elements to sense when they enter/leave regardless of scrolling.\n- It's **not** helpful for tracking an element's position between two points, like for scrubbing an animation accordingly.\n- It does let you watch multiple elements and have a single callback triggered that could loop through and fire a staggered animation on just the elements that entered, for example.\n\nScrollTrigger does not use IntersectionObserver under the hood because it lacks the necessary functionality and compatibility. You can certainly use IntersectionObserver and ScrollTrigger together.\n\n#### How does pinning work under the hood?\n\n- The pinned element gets immediately wrapped in a `<div>` with a **fixed** width/height to match. A class of \"pin-spacer\" is added to that wrapper. Think of it like a proxy element that props open the space where the pinned element was in the DOM so that when it flips to `position: fixed` things don't collapse.\n- By default, padding will be added to the bottom (or right for horizontal: true) of the pin-spacer so that [in most cases] things get pushed further down/right. When the pinned element gets unpinned, the content below/right will have caught up. So if, for example, the pinned element stays pinned for 300px, there would be padding of 300px added.\n\nwalkthrough\n\nThis video on pinning that's part of SnorklTV's [ScrollTrigger Express course](https://www.creativecodingclub.com/courses/scrolltrigger-express?ref=44f484) may help your understanding.\n\n- When the ScrollTrigger is active (when the scroll position is between the start and end), it sets the pinned element to `position: fixed` and positions it with fixed top/left/width/height values...unless the scroller isn't the viewport in which case it never uses `position: fixed` because that'd break sub-scrolling, so it uses pure transforms. If `pinReparent` is set to `true` (we recommend avoiding that if you can), the pinned element will get reparented to the `<body>` and styles will be moved inline to ensure appearance is maintained.\n- When the ScrollTrigger becomes inactive, the pinned element reverts to its original `position` value and a **transform** is applied to place it correctly.\n- When the window/scroller gets resized, all ScrollTriggers re-calculate their start/end positions (`onRefresh`). As a part of that process, the pin-spacer is removed from the DOM and the pinned element is swapped back in so that measurements are accurate with the original CSS. Then the pin-spacer is swapped back in as a wrapper.\n\nWhy not just use transforms and avoid `position: fixed`? Many browsers don't render consistently using that technique. There are annoying visual glitches due to the fact that scroll repaints are handled on a different thread in most modern browsers. Surprisingly, `position: fixed` seemed to deliver better performance overall. And performance is EXTREMELY important for scrolling.\n\n#### How does duration work with scrub: true?\n\nIf you have a ScrollTrigger `scrub: true` and that ScrollTrigger has a timeline or tween animation associated with it, the durations of tweens within that animation serve as proportions for the total amount of distance that the tween will play. The proportion of how much distance it's animated between is in regards to the total duration of the animation. It's easiest to understand with an example:\n\nSay you have a timeline with three sequenced tweens: a 1 second tween, a 3 second tween, and then another 1 second tween. And the ScrollTrigger applied to it will animate for a full viewport height's distance (perhaps the trigger uses the values of `start: \"center bottom\"` and `end: \"center top\"`).\n\nIf `scrub: true` (or a number) is applied, then the first tween will be animated between when the center of the trigger element is between the 100% mark (from the top; the bottom of the viewport) and the 80% mark (from the top) of the viewport. The second tween will fire when the center of the element is at the 80% mark until the 20% mark. And the third tween will fire when the center of the element is between the 20% mark and the 0% mark. This is because the total duration of the timeline is 5 seconds. So \u00e2\u0085\u0095 is 20% and \u00e2\u0085\u0097 is 60%.\n\n#### loading...\n\nIf you change the duration of all the tweens to the same number, say 1, then the percentages would all be equal: 100% -> 66%, 66% -> 33%, 33% -> 0%. This is because the total duration is 3, so \u00e2\u0085\u0093 is 33%.\n\nIn other words, the duration values don't matter as much as the proportions of the duration of each tween compared to the total time of the timeline.\n\nIf you want to make the animation take a longer distance of scroll to complete, affect the distance from start to end longer. For example you could set `end: \"+=4000\"` to make it take a lot of scrolling to complete.\n\n#### How do I include undefined in my project?\n\nSee the [installation page](/docs/v3/Installation) for all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to [register undefined](/docs/v3/GSAP/gsap.registerPlugin()) like this in your project:\n\n```\ngsap.registerPlugin(undefined)\n```\n\n#### Is this included in the GSAP core?\n\nNo, you must load/import it separately\n\n#### It works fine during development, but suddenly stops working in the production build! What do I do?\n\nYour build tool is probably dropping the plugin when [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) and you forgot to [register undefined](/docs/v3/GSAP/gsap.registerPlugin()) (which protects it from tree shaking). Just register the plugin like this:\n\n```\ngsap.registerPlugin(undefined)\n```\n\n#### Is it bad to register a plugin multiple times?\n\nNo, it's perfectly fine. It doesn't help anything, nor does it hurt.\n\n#### How do I include ScrollTrigger in my project?\n\nSee the [installation page](/docs/v3/Installation) for all the options (CDN, NPM, download, etc.) where there's even an interactive helper that provides the necessary code. Easy peasy. Don't forget to [register ScrollTrigger](/docs/v3/GSAP/gsap.registerPlugin()) like this in your project:\n\n```\ngsap.registerPlugin(ScrollTrigger)\n```\n\n#### Is this included in the GSAP core?\n\nNo, you must load/import it separately\n\n#### It works fine during development, but suddenly stops working in the production build! What do I do?\n\nYour build tool is probably dropping the plugin when [tree shaking](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) and you forgot to [register ScrollTrigger](/docs/v3/GSAP/gsap.registerPlugin()) (which protects it from tree shaking). Just register the plugin like this:\n\n```\ngsap.registerPlugin(ScrollTrigger)\n```\n\n#### Is it bad to register a plugin multiple times?\n\nNo, it's perfectly fine. It doesn't help anything, nor does it hurt.\n\n## **Demos**[\u00e2\u0080\u008b](#demos \"Direct link to demos\")\n\nCheck out the full collection of [Scroll animation demos](https://codepen.io/collection/bNPYOw) on CodePen.\n\n## Contents\n\n- [Simple example](#simple-example)\n- [Advanced example](#advanced-example)\n- [Standalone/Custom example](#standalonecustom-example)\n- [Features](#features)\n- [**Config Object**](#config-object)\n- [**Properties**](#properties)\n- [**Methods**](#methods)\n- [FAQs](#faqs)\n- [**Demos**](#demos)",
  "tags": [
    "gsap",
    "animation",
    "javascript",
    "scrolltrigger"
  ],
  "extracted_at": "2026-02-03T12:48:50.061380+00:00",
  "content_length": 46979,
  "content_hash": "9d320484da7bfbcb"
}