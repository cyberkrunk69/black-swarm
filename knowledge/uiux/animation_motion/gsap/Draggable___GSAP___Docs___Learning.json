{
  "id": "gsap__docs_v3_Plugins_Draggable_",
  "source_id": "gsap",
  "source_name": "GSAP",
  "category": "animation_motion",
  "url": "https://gsap.com/docs/v3/Plugins/Draggable/",
  "title": "Draggable | GSAP | Docs & Learning",
  "content": "On this page\nProvides a surprisingly simple way to make virtually any DOM element draggable, spinnable, tossable, and even flick-scrollable using mouse and/or touch events\nInertia effects Draggable integrates beautifully with\nInertiaPlugin\nso that the user can flick and have the motion decelerate smoothly based on momentum. :::\nloading...\nFeatures\n\u00e2\u0080\u008b\nFeature Highlights\nTouch enabled\n- Works great on tablets, phones, and desktop browsers.\nIncredibly smooth\n- GPU-accelerated and\nrequestAnimationFrame\n-driven for ultimate performance. Compared to other options out there, Draggable just feels far more natural and fluid, particularly when imposing bounds and momentum.\nMomentum-based animation\n- If you have InertiaPlugin loaded, you can simply set\ninertia: true\nin the\nconfig\nobject and it'll automatically apply natural, momentum-based movement after the mouse/touch is released, causing the object to glide gracefully to a stop. You can even control the amount of\nresistance\n, maximum or minimum\nduration\n, etc.\nread more...\nImpose bounds\n- Tell a draggable element to stay within the bounds of another DOM element (a container) as in\nbounds: \"#container\"\nor define bounds as coordinates like\nbounds: {top: 100, left: 0, width: 1000, height: 800}\nor specific maximum and minimum values like\nbounds: {minRotation: 0, maxRotation: 270}\n.\nSense overlaps with\nhitTest()\n- See if one element is overlapping another and even set a tolerance threshold (like at least 20 pixels or 25% of either element's total surface area) using the super-flexible\nDraggable.hitTest()\nmethod. Feed it a mouse event and it'll tell you if the mouse is over the element. See\nthis CodePen\nfor a simple example.\nDefine a trigger element\n- Maybe you want only a certain area to trigger the dragging (like the top bar of a window) - it's as simple as\ntrigger: \"#topBar\"\n, for example.\n**Drag position or rotation **- Lots of drag types to choose from: [\n\"x,y\"\n|\n\"top,left\"\n|\n\"rotation\"\n|\n\"x\"\n|\n\"y\"\n|\n\"top\"\n|\n\"left\"\n]\nLock movement along a certain axis\n- Set\nlockAxis: true\nand Draggable will watch the direction the user starts to drag and then restrict it to that axis. Or if you only want to allow vertical or horizontal movement, that's easy using the type (\n\"top\"\nor\n\"y\"\nto only allow vertical movement;\n\"x\"\n, or\n\"left\"\nto only allow horizontal movement).\nRotation honors transform origin\n- By default, spinnable elements will rotate around their center, but you can set\ntransformOrigin\nto something else to make the pivot point be elsewhere. For example, if you call\ngsap.set(yourElement, {transformOrigin: \"top left\"})\nbefore dragging, it will rotate around its top left corner. Or use\n%\nor\npx\n. Whatever is set in the element's CSS will be honored.\nRich callback system and event dispatching\n- You can use any of the following callbacks:\nonPress\n,\nonDragStart\n,\nonDrag\n,\nonDragEnd\n,\nonRelease\n,\nonLockAxis\n, and\nonClick\n. Inside the callbacks,\nthis\nrefers to the Draggable instance itself, so you can easily access its\ntarget\nor\nbounds\n, etc. If you prefer event listeners instead, Draggable dispatches events too so you can do things like\nyourDraggable.addEventListener(\"dragend\", yourFunc);\nWorks great with SVG.\nEven works in transformed containers!\n- Got a Draggable inside a rotated or scaled container? No problem. No other tool handles this properly that we've seen.\nAuto-scrolling, even in multiple containers\n- Set\nautoScroll: 1\nfor normal-speed auto scrolling, or\nautoScroll: 2\nwould scroll twice as fast, etc. The closer you move toward the edge, the faster scrolling gets. See a\ndemo here\n.\nSense clicks when the element moves less than 3 pixels\n- A common challenge is figuring out when a user is trying to click or tap an object rather than drag it, so if the mouse/touch moves less than 3 pixels from its starting position, it will be interpreted as a click and the\nonClick\ncallback will be called (and a\n\"click\"\nevent dispatched) without actually moving the element. You can define a different threshold using\nminimumMovement\nconfig property, like\nminimumMovement: 6\nfor 6 pixels.\nUsage\n\u00e2\u0080\u008b\nIn its simplest form, you can make an element draggable (vertically and horizontally) like this:\nDraggable\n.\ncreate\n(\n'#yourID'\n)\n;\nThis will simply find the element with the ID\n\"yourID\"\nand make it draggable with no bounds or any kinetic motion after release. You don't need to use selector text either - you can pass the element itself or even an array of objects.\nUse the\nvars\nparameter to define various other configuration options. For example, to make the object scroll only vertically using the\ny\ntransform and stay within the bounds of a DOM element with an ID of\n\"container\"\n, and call a function when clicked and another when the drag ends and make it have momentum-based motion (assuming you loaded InertiaPlugin), do this:\nDraggable\n.\ncreate\n(\n'#yourID'\n,\n{\ntype\n:\n'y'\n,\nbounds\n:\ndocument\n.\ngetElementById\n(\n'container'\n)\n,\ninertia\n:\ntrue\n,\nonClick\n:\nfunction\n(\n)\n{\nconsole\n.\nlog\n(\n'clicked'\n)\n;\n}\n,\nonDragEnd\n:\nfunction\n(\n)\n{\nconsole\n.\nlog\n(\n'drag ended'\n)\n;\n}\n}\n)\n;\nOr to make something\nspinnable\n(dragging rotates the element), you could simply do:\nDraggable\n.\ncreate\n(\n'#yourID'\n,\n{\ntype\n:\n'rotation'\n,\ninertia\n:\ntrue\n}\n)\n;\nAnd to add the ability to snap to 90-degree increments after the mouse/touch is released (like flick-spinning that always lands on 90-degree increments), use the snap option:\nDraggable\n.\ncreate\n(\n'#yourID'\n,\n{\ntype\n:\n'rotation'\n,\ninertia\n:\ntrue\n,\nsnap\n:\nfunction\n(\nvalue\n)\n{\n//this function gets called by InertiaPlugin when the mouse/finger is released and it plots where rotation\n//should normally end and we can alter that value and return a new one instead. This gives us an easy way to\n//apply custom snapping behavior with any logic we want. In this case, we'll just make sure the end value snaps\n//to 90-degree increments but only when the \"snap\" checkbox is selected.\nreturn\nMath\n.\nround\n(\nvalue\n/\n90\n)\n*\n90\n;\n}\n}\n)\n;\nConfig Object\n\u00e2\u0080\u008b\nProperty\nDescription\nactiveCursor\nString\n- The cursor\u00e2\u0080\u0099s CSS value that should be used between the time they press and then release the pointer/mouse. This can be different than the regular\ncursor\nvalue, like:\ncursor: \"grab\", activeCursor: \"grabbing\"\n.\nallowContextMenu\nBoolean\n- If\ntrue\n, Draggable will allow context menus (like if a user right-clicks or long-touches). Normally this is suppressed because it can get in the way of dragging (especially on touch devices). Default:\nfalse\n.\nallowEventDefault\nBoolean\n- If\ntrue\n,\npreventDefault()\nwon\u00e2\u0080\u0099t be called on the original mouse/pointer/touch event. This can be useful if you want to permit the default behavior like touch-scrolling. Typically, however, it\u00e2\u0080\u0099s best to let Draggable call\npreventDefault()\non the events in order to deliver the best usability with dragging. Default:\nfalse\n.\nallowNativeTouchScrolling\nBoolean\n- By default, allows you to native touch-scroll in the opposite direction as Draggables that are limited to one axis . For example, a Draggable of\ntype: \"x\"\nor\n\"left\"\nwould permit native touch-scrolling in the vertical direction, and\ntype: \"y\"\nor\n\"top\"\nwould permit native horizontal touch-scrolling. Default:\ntrue\n.\nautoScroll\nNumber\n- To enable auto-scrolling when a Draggable is dragged within 40px of an edge of a scrollable container, set autoScroll to a non-zero value, where 1 is normal speed, 2 is double-speed, etc. (you can use any number). For a more intuitive or natural feel, it will scroll faster as the mouse/touch gets closer to the edge. The default value is 0 (no auto-scrolling). See\nthis CodePen\nfor a demo.\nbounds\n[\nElement\n|\nString\n|\nObject\n]\n- To cause the draggable element to stay within the bounds of another DOM element (like a container), you can pass the element like\nbounds: document.getElementById(\"container\")\nor even selector text like\n\"#container\"\n. If you prefer, you can define bounds as a rectangle instead, like\nbounds: {top: 100, left: 0, width: 1000, height: 800}\nwhich is based on the parent\u00e2\u0080\u0099s coordinate system (top and left would be from the upper left corner of the parent). Or you can define specific maximum and minimum values like\nbounds: {minX: 10, maxX: 300, minY: 50, maxY: 500}\nor\nbounds: {minRotation: 0, maxRotation: 270}\n.\ncallbackScope\nObject\n- The scope to be used for all of the callbacks (\nonDrag\n,\nonDragEnd\n,\nonDragStart\n, etc). The scope is what\nthis\nrefers to inside any of the callbacks. The older callback-specific scope properties are deprecated but still work.\nclickableTest\nFunction\n- Your Draggable may contain child elements that are \u00e2\u0080\u009cclickable\u00e2\u0080\u009d, like links\n<a>\ntags,\n<button/>\nor\n<input>\nelements, etc. By default, it treats clicks and taps on those elements differently, not allowing the user to drag them. You can set\ndragClickables: true\nto override that, but it still may be handy to control exactly what Draggable considers to be a \u00e2\u0080\u009cclickable\u00e2\u0080\u009d element, so you can use your own function that accepts the clicked-on element as the only parameter and returns true or false accordingly. Draggable will call this function whenever the user presses their mouse or finger down on a Draggable, and the target of that event will be passed to your clickableTest function.\ncursor\nString\n- By default (except for\ntype: \"rotation\"\n), the cursor CSS property of the element is set to\nmove\nso that when the mouse rolls over it, there\u00e2\u0080\u0099s a visual cue indicating that it\u00e2\u0080\u0099s moveable, but you may define a different cursor if you prefer (as described at\nhttps://devdocs.io/css/cursor\n) like\ncursor: \"pointer\"\n.\ndragClickables\nBoolean\n- By default, Draggable will work on pretty much any element, but sometimes you might want clicks on\n<a>\n,\n<input>\n,\n<select>\n,\n<button>\n, and\n<textarea>\nelements (as well as any element that has a\ndata-clickable=\"true\"\nattribute) NOT to trigger dragging so that the browser\u00e2\u0080\u0099s default behavior fires (like clicking on an input would give it focus and drop the cursor there to begin typing), so if you want Draggable to ignore those clicks and allow the default behavior instead, set\ndragClickables: false\n.\ndragResistance\nNumber\n- A number between 0 and 1 that controls the degree to which resistance is constantly applied to the element as it is dragged, where 1 won\u00e2\u0080\u0099t allow it to be dragged at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed), and 0.5 would be half-speed, etc. This can even apply to rotation.\nedgeResistance\nNumber\n- A number between 0 and 1 that controls the degree to which resistance is applied to the element as it goes outside the bounds (if any are applied), where 1 won\u00e2\u0080\u0099t allow it to be dragged past the bounds at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed beyond the border while dragging), and 0.5 would be half-speed beyond the border, etc. This can even apply to rotation.\nforce3D\nBoolean\n- By default, 3D transforms are used (when the browser supports them) in order to force the element onto its own layer on the GPU, thus speeding compositing. Typically this provides the best performance, but you can disable it by setting\nforce3D: false\n. This may be a good idea if the element that you\u00e2\u0080\u0099re dragging contains child elements that are animating.\ninertia\n[\nBoolean\n|\nObject\n]\n- InertiaPlugin is the key to getting the momentum-based motion after the users\u00e2\u0080\u0099 mouse (or touch) is released. To have Draggable auto-apply an InertiaPlugin tween to the element when the mouse is released (or touch ends), you can set\ninertia: true\n(\ninertia\nalso works). Or for advanced effects, you can define the actual inertia object that will get fed into tween, like\ninertia: {top: {min: 0, max: 1000, end: [0,200,400,600]}}\n. However, if you want ultimate control over the InertiaPlugin tween, you can simply use an\nonDragEnd\nto call your own function that creates the tween. If\ninertia: true\nis defined, you may also use any of the following configuration properties that apply to the movement after the mouse/touch is released...\nView More details\nsnap\n: [\nFunction\n|\nObject\n|\nArray\n] - Allows you to define rules for where the element can land after it gets released. For example, maybe you want the rotation to always end at a 90-degree increment or you want the\nx\nand\ny\nvalues to be exactly on a grid (whichever cell is closest to the natural landing spot) or maybe you want it to land on a very specific value. You can define the snap in any of the following ways:\nAs a function\n- This function will be passed one numeric parameter, the natural ending value. The function must return whatever the new ending value should be (you run whatever logic you want inside the function and spit back the value). For example, to make the value snap to the closest increment of 50, you\u00e2\u0080\u0099d do\nsnap: function(endValue) { return Math.round(endValue / 50) * 50; }\n.\nAs an Array\n- If you use an array of values, InertiaPlugin will first plot the natural landing position and then loop through the array and find the closest number (as long as it\u00e2\u0080\u0099s not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you\u00e2\u0080\u0099d do\nsnap: [10,50,200,450]\n.\nAs an object\n- If you\u00e2\u0080\u0099d like to use different logic for each property, like if\ntype\nis\n\"x,y\"\nand you\u00e2\u0080\u0099d like to have the\nx\npart snap to one set of values, and the\ny\npart snap to a different set of values, you can use an object that has matching properties, like:\nsnap:{x: [5,20,80,400], y: [10,60,80,500]}\nor if\ntype\nis\n\"top,left\"\nand you want to use a different function for each, you could do something like\nsnap: {top: function(endValue) { return Math.round(endValue / 50) * 50; }, left: function(endValue) { return Math.round(endValue / 100) * 100; }}\n. You can define a points property inside this object that combines both\nx\nand\ny\n, like\nliveSnap: {points: [{x: 0, y: 0},{x: 100, y: 0}], radius: 20}\nwhich will snap to any point in the array when it\u00e2\u0080\u0099s within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like\nliveSnap: {points: function(point) { //run custom logic and return a new point }}\n. See the\nsnapping section\nof this page for examples.\nonThrowUpdate\n:\nFunction\n- A function that should be called each time the InertiaPlugin tween updates/renders (basically on each \u00e2\u0080\u009ctick\u00e2\u0080\u009d of the engine while the tween is active). This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called while the user is dragging the element (that\u00e2\u0080\u0099s what\nonDrag\nis for). By default, the scope of the\nonThrowUpdate\nis the Draggable instance itself, but you may define an\ncallbackScope\nif you prefer, just like any other tween.\nonThrowComplete\n:\nFunction\n- A function that should be called when the InertiaPlugin tween finishes. This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called immediately when the user releases their mouse/touch - that\u00e2\u0080\u0099s what\nonDragEnd\nis for. By default, the scope of the\nonThrowComplete\nis the Draggable instance itself, but you may define an\ncallbackScope\nif you prefer, just like any other tween.\nthrowResistance\n:\nNumber\n- A number (\n1000\nby default) that controls how much resistance or friction there is when the mouse/touch is released and momentum-based motion is enabled (by setting\ninertia: true\n). The larger the number, the more resistance and the quicker the motion decelerates. (requires InertiaPlugin and setting\ninertia: true\n, otherwise\nthrowResistance\nwill simply be ignored.)\nmaxDuration\n:\nNumber\n- The maximum duration (in seconds) that the kinetic-based inertia tween can last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can cap the duration by defining a\nmaxDuration\n. The default is 10 seconds. This has nothing to do with the maximum amount of time that the user can drag the object - it\u00e2\u0080\u0099s only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting\ninertia: true\n, otherwise\nmaxDuration\nwill simply be ignored.)\nminDuration\n:\nNumber\n- The minimum duration (in seconds) that the kinetic-based inertia tween should last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can force the tween to take at least a certain amount of time by defining a\nminDuration\n. The default is 0.2 seconds. This has nothing to do with the minimum amount of time that the user can drag the object - it\u00e2\u0080\u0099s only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting\ninertia: true\n, otherwise minDuration will simply be ignored.)\novershootTolerance\n:\nNumber\n- Affects how much overshooting is allowed before smoothly returning to the resting position at the end of the tween. This can happen when the initial velocity from the flick would normally cause it to exceed the bounds/min/max. The larger the\novershootTolerance\nthe more leeway the tween has to temporarily shoot past the max/min if necessary. The default is\n1\n. If you don\u00e2\u0080\u0099t want to allow any overshooting, you can set it to\n0\n.\nliveSnap\n[\nFunction\n|\nBoolean\n|\nArray\n|\nObject\n]\n- Allows you to define rules that get applied\nWHILE\nthe element is being dragged (whereas regular snap affects only the end value(s), where the element lands after the drag is released). For example, maybe you want the rotation to snap to 10-degree increments while dragging or you want the x and y values to snap to a grid (whichever cell is closest). You can define the\nliveSnap\nin any of the following ways:\nView More details\nAs  a function\n- This function will be passed one numeric parameter, the natural (unaltered) value. The function must return whatever the new value should be (you run whatever logic you want inside your function and spit back the value). For example, to make the value snap to the closest increment of 50, you\u00e2\u0080\u0099d do\nliveSnap: function(value) { return Math.round(value / 50) * 50; }\n.\nAs an array\n- If you use an array of values, Draggable will loop through the array and find the closest number (as long as it\u00e2\u0080\u0099s not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you\u00e2\u0080\u0099d do\nliveSnap: [10,50,200,450]\n.\nAs an object\n- If you\u00e2\u0080\u0099d like to use different logic for each property, like if\ntype\nis\n\"x,y\"\nand you\u00e2\u0080\u0099d like to have the \u00e2\u0080\u009cx\u00e2\u0080\u009d part snap to one set of values, and the \u00e2\u0080\u009cy\u00e2\u0080\u009d part snap to a different set of values, you can use an object that has matching properties, like:\nliveSnap: {x: [5,20,80,400], y: [10,60,80,500]}\n. Or if\ntype\nis\n\"top,left\"\nand you want to use a different function for each, you\u00e2\u0080\u0099d do something like\nliveSnap: {top: function(value) { return Math.round(value / 50) * 50; }, left: function(value) { return Math.round(value / 100) * 100; }}\n. You can define a\npoints\nproperty inside this object that combines both x and y, like\nliveSnap: {points:[{x: 0, y: 0}, {x: 100, y: 0}], radius: 20}\nwhich will snap to any point in the array when it\u00e2\u0080\u0099s within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like\nliveSnap: {points: function(point) { //run custom logic and return a new point }}\n. See the\nsnapping section\nof this page for examples.\nAs a boolean (\ntrue\n)\n- Live snapping will use whatever is defined for the\nsnap\n(so that instead of only applying to the end value(s), it will apply it \u00e2\u0080\u009clive\u00e2\u0080\u009d while dragging too).\nlockAxis\nBoolean\n- If\ntrue\n, dragging more than 2 pixels in either direction (horizontally or vertically) will lock movement into that axis so that the element can only be dragged that direction (horizontally or vertically, whichever had the most initial movement) during that drag. No diagonal movement will be allowed. Obviously this is only applicable for Draggables with a\ntype\nof\n\"x,y\"\n, or\n\"top,left\"\n. If you only want to allow vertical movement, you should set the\ntype\nto\n\"y\"\nor\n\"top\"\n. If you only want to allow horizontal movement, you should set the\ntype\nto\n\"x\"\nor\n\"left\"\n.\nminimumMovement\nNumber\n- By default, Draggable requires that the Draggable element moves more than 2 pixels in order to be interpreted as a drag, but you can change that threshold using\nminimumMovement\n. So\nminimumMovement: 6\nwould require that the Draggable element moves more than 6 pixels to be interpreted as a drag.\nonClick\nFunction\n- A function that should be called only when the mouse/touch is pressed on the element and released without moving 3 pixels or more. This makes it easier to discern the user\u00e2\u0080\u0099s intent (click or drag). Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonClickParams\nArray\n- An optional array of parameters to feed the\nonClick\ncallback. For example,\nonClickParams: [\"clicked\", 5]\nwould work with this code:\nonClick: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\nonDrag\nFunction\n- A function that should be called every time the mouse (or touch) moves during the drag. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc. This is only called once per requestAnimationFrame.\nonDragParams\nArray\n- An optional array of parameters to feed the\nonDrag\ncallback. For example,\nonDragParams: [\"dragged\", 5]\nwould work with this code:\nonDrag: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\nonDragEnd\nFunction\n- A function that should be called as soon as the mouse (or touch) is\nreleased\nafter the drag. Even if nothing is moved, the\nonDragEnd\nwill always fire, whereas the\nonClick\ncallback only fires if the mouse/touch moves is less than 3 pixels. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonDragEndParams\nArray\n- An optional array of parameters to feed the\nonDragEnd\ncallback. For example,\nonDragEndParams: [\"drag ended\", 5]\nwould work with this code:\nonDragEnd: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\nonDragStart\nFunction\n- A function that should be called as soon as the mouse (or touch) moves more than 2 pixels, meaning that dragging has begun. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonDragStartParams\nArray\n- An optional array of parameters to feed the\nonDragStart\ncallback. For example,\nonDragStartParams: [\"drag started\", 5]\nwould work with this code:\nonDragStart: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\nonLockAxis\nFunction\n- A function that should be called as soon as movement is locked into the horizontal or vertical axis. This happens when\nlockAxis\nis\ntrue\nand the user drags enough for Draggable to determine which axis to lock. It also happens on touch-enabled devices when you have a Draggable whose type only permits it to drag along one axis (like\ntype: \"x\"\n,\ntype: \"y\"\n,\ntype: \"left\"\n, or\ntype: \"top\"\n) and the user touch-drags and Draggable determines the direction, either allowing native touch-scrolling or Draggable-induced dragging. Inside the function,\nthis\nrefers to the Draggable instance, making it easy to access the locked axis (\nthis.lockedAxis\nwhich will either be\n\"x\"\nor\n\"y\"\n), or the target element (\nthis.target\n), etc. By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonMove\nFunction\n- A function that should be called every time the mouse (or touch) moves during the drag. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc. This is different than\nonDrag\nin that it can fire multiple times per requestAnimationFrame. In general, it is better to use\nonDrag\n, but this is available if, for some reason, need to\n.stopPropogation\nor\n.stopImmediatePropogation\non the drag event.\nonPress\nFunction\n- A function that should be called as soon as the mouse (or touch) presses down on the element. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonPressInit\nFunction\n- A function that should be called before the starting values are recorded in the\nonPress\n, allowing you to make changes before any dragging occurs.\nonPressInit\nalways fires BEFORE\nonPress\n.\nSee demo\n.\nonPressParams\nArray\n- An optional array of parameters to feed the\nonPress\ncallback. For example,\nonPressParams: [\"drag started\", 5]\nwould work with this code:\nonPress: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\nonRelease\nFunction\n- A function that should be called as soon as the mouse (or touch) is released after having been pressed on the target element, regardless of whether or not anything was dragged. Inside that function,\nthis\nrefers to the Draggable instance (unless you specifically set the scope using\ncallbackScope\n), making it easy to access the target element (\nthis.target\n) or the boundary coordinates (\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n). By default, the\npointerEvent\n(last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access\npageX\n,\npageY\n,\ntarget\n,\ncurrentTarget\n, etc.\nonReleaseParams\nArray\n- An optional array of parameters to feed the\nonRelease\ncallback. For example,\nonReleaseParams: [\"drag ended\", 5]\nwould work with this code:\nonRelease: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }\n.\ntrigger\n[\nElement\n|\nString\n|\nObject\n]\n- If you want only a certain area to trigger the dragging (like the top bar of a window) instead of the entire element, you can define a child element as the trigger, like\ntrigger: yourElement\n,\ntrigger: \"#topBar\"\n, or\ntrigger: $(\"#yourID\")\n. You may define the trigger as an element or a selector string\ntype\nString\n- Indicates the type of dragging (the properties that the dragging should affect). Any of the following work: [\n\"x,y\"\n(basically the\ntranslateX\nand\ntranslateY\nof transform) |\n\"left,top\"\n|\n\"rotation\"\n|\n\"x\"\n|\n\"y\"\n|\n\"top\"\n|\n\"left\"\n]. The default is\n\"x,y\"\n.\nzIndexBoost\nBoolean\n- By default, for vertical or horizontal dragging, when an element is pressed/touched, it has its\nzIndex\nset to a high value (\n1000\nby default) and that number gets incremented and applied to each new element that gets pressed/touched so that the stacking order looks correct (newly pressed objects rise to the top), but if you prefer to skip this behavior set\nzIndexBoost: false\n.\nSnapping\n\u00e2\u0080\u008b\nDraggable has advanced snapping capabilities. You can define a\nsnap\nvalue in the\nconfig\nobject to control where the Draggable will snap\nAFTER\nit is released, or you can define a\nliveSnap\nvalue where the Draggable should snap\nWHILE\ndragging. You can define these values in any of the following ways:\nAs an array of snap-to values\n\u00e2\u0080\u008b\nDraggable\n.\ncreate\n(\n'#id'\n,\n{\ntype\n:\n'x,y'\n,\nliveSnap\n:\n{\n//snaps to the closest point in the array, but only when it's within 15px (new in GSAP 1.20.0 release):\npoints\n:\n[\n{\nx\n:\n0\n,\ny\n:\n0\n}\n,\n{\nx\n:\n100\n,\ny\n:\n0\n}\n,\n{\nx\n:\n200\n,\ny\n:\n50\n}\n]\n,\nradius\n:\n15\n}\n}\n)\n;\npoints\nis a special property that allows you to combine both\nx\nand\ny\nlogic into a single place. You can also use separate per-property arrays:\nDraggable\n.\ncreate\n(\n'#id'\n,\n{\ntype\n:\n'x,y'\n,\nliveSnap\n:\n{\n//x and y (or top and left) can each have their own array of values to snap to:\nx\n:\n[\n0\n,\n100\n,\n200\n,\n300\n]\n,\ny\n:\n[\n0\n,\n50\n,\n100\n,\n150\n]\n}\n}\n)\n;\nAs a function with custom logic\n\u00e2\u0080\u008b\nDraggable\n.\ncreate\n(\n'#id'\n,\n{\ntype\n:\n'x,y'\n,\nliveSnap\n:\n{\npoints\n:\nfunction\n(\npoint\n)\n{\n//if it's within 100px, snap exactly to 500,250\nvar\ndx\n=\npoint\n.\nx\n-\n500\n;\nvar\ndy\n=\npoint\n.\ny\n-\n250\n;\nif\n(\nMath\n.\nsqrt\n(\ndx\n*\ndx\n+\ndy\n*\ndy\n)\n<\n100\n)\n{\nreturn\n{\nx\n:\n500\n,\ny\n:\n250\n}\n;\n}\nreturn\npoint\n;\n//otherwise don't change anything.\n}\n}\n}\n)\n;\nOr use separate per-property functions:\nDraggable\n.\ncreate\n(\n'#id'\n,\n{\ntype\n:\n'x,y'\n,\nliveSnap\n:\n{\nx\n:\nfunction\n(\nvalue\n)\n{\n//snap to the closest increment of 50.\nreturn\nMath\n.\nround\n(\nvalue\n/\n50\n)\n*\n50\n;\n}\n,\ny\n:\nfunction\n(\nvalue\n)\n{\n//snap to the closest increment of 25.\nreturn\nMath\n.\nround\n(\nvalue\n/\n25\n)\n*\n25\n;\n}\n}\n}\n)\n;\nIt's just as simple for a rotation Draggable:\nDraggable\n.\ncreate\n(\n'#id'\n,\n{\ntype\n:\n'rotation'\n,\nliveSnap\n:\n{\nrotation\n:\nfunction\n(\nvalue\n)\n{\n//snap to the closest increment of 10.\nreturn\nMath\n.\nround\n(\nvalue\n/\n10\n)\n*\n10\n;\n}\n}\n}\n)\n;\nGetting the velocity\n\u00e2\u0080\u008b\nAs long as you've loaded InertiaPlugin and set\ninertia: true\non your Draggable, you can tap into the\nInertiaPlugin.getVelocity()\nmethod. Draggable will automatically start tracking the velocity of the necessary properties based on whatever its\ntype\nis (\ntype: \"x,y\"\nwill track\nx\nand\ny\n,\ntype: \"rotation\"\nwill track rotation, etc.).\n//positional velocity\nDraggable\n.\ncreate\n(\n'#movableID'\n,\n{\ntype\n:\n'x,y'\n,\ninertia\n:\ntrue\n,\nonDragEnd\n:\nfunction\n(\n)\n{\nconsole\n.\nlog\n(\n'x velocity is: '\n+\nInertiaPlugin\n.\ngetVelocity\n(\nthis\n.\ntarget\n,\n'x'\n)\n+\n' and the duration is '\n+\nthis\n.\ntween\n.\nduration\n(\n)\n+\n' seconds.'\n)\n;\n}\n}\n)\n;\nNotes, dependencies, and limitations\n\u00e2\u0080\u008b\nIn most cases,\n.pointerX\nand\n.pointerY\nshould be used instead of using the event's positioning (like\n.pageX\n/\n.pageY\nor something like that) because GSAP tries to normalize positioning across all browsers.\nIf you want a particular element to be \"clickable\", thus ignored by Draggable, simply add a\ndata-clickable=\"true\"\nattribute to it, or an\nonclick\n. By default, Draggable automatically ignores clicks on\n<a>\n,\n<input>\n,\n<select>\n,\n<button>\n, and\n<textarea>\nelements. If you prefer to run your own logic to determine if an object should be considered \"clickable\", you can set the\nclickableTest\nconfig property to a function of your choosing that returns\ntrue\nor\nfalse\n.\nDraggable can be used without InertiaPlugin, but doing so will disable any momentum-based motion (like being able to flick objects and have them continue while decelerating). These two tools go together perfectly \u00f0\u009f\u00ab\u00b6.\nIn order to make things moveable via their\ntop\nand\nleft\nCSS properties, you must make sure that the elements have their\nposition\nCSS property set to either\nrelative\nor\nabsolute\n(that's just how CSS works).\nBy default, all callback functions and\nsnap\nfunctions and\nliveSnap\nfunctions are scoped to the associated Draggable instance, so\nthis\nrefers to the Draggable instance. You can get the current horizontal or vertical values using\nthis.x\nand\nthis.y\ninside those functions. And if you applied bounds, you can also get the maximum and minimum \"legal\" values for that particular instance using\nthis.maxX\n,\nthis.minX\n,\nthis.maxY\n, and\nthis.minY\n.\nHaving trouble with momentum-based motion? Make sure you have\nInertiaPlugin\nloaded! To use it, set\ninertia: true\nin the\nvars\nconfig object, like\nDraggable.create(yourObject, {inertia: true});\n.\nIf you use an element for the bounds, it should not be rotated differently than the target element.\nIf you are mixing timelines and draggable, you may need to use a proxy element. For more information see\nthis demo\n.\nProperties\n\u00e2\u0080\u008b\nautoScroll\n: Number\nHow fast to scroll the container element when\nautoScroll\nis\ntrue\n.\ndeltaX\n: Number\nThe change in the x-related value since the last drag event.\ndeltaY\n: Number\nThe change in the y-related value since the last drag event.\nendRotation\n: Number\n[read-only] [only applies to type:\"rotation\"] The ending rotation of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a\ninertia\nflick.\nendX\n: Number\n[read-only] The ending x (horizontal) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after an\ninertia\nflick.\nendY\n: Number\n[read-only] The ending y (vertical) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a\ninertia\nflick.\nisPressed\n: Boolean\nIf the Draggable is being pressed, this will be\ntrue\nisThrowing\n: Boolean\nReports if the target of a Draggable is being thrown using a InertiaPlugin tween.\nlockAxis\n: Boolean\nLocks movement to one axis based on the how it is moved initially.\nlockedAxis\n: String\nmaxRotation\n: Number\nWhen bounds are applied,\nmaxRotation\nrefers to the maximum \"legal\" rotation.\nmaxX\n: Number\nWhen bounds are applied,\nmaxX\nrefers to the maximum \"legal\" horizontal property.\nmaxY\n: Number\nWhen bounds are applied,\nmaxY\nrefers to the maximum \"legal\" vertical property.\nminRotation\n: Number\nWhen bounds are applied,\nminRotation\nrefers to the minimum \"legal\" rotation property.\nminX\n: Number\nWhen bounds are applied,\nminX\nrefers to the minimum \"legal\" horizontal property.\nminY\n: Number\nWhen bounds are applied,\nminY\nrefers to the minimum \"legal\" vertical property.\npointerEvent\n: Object\n[read-only] The last pointer event (either a mouse event or touch event) that affected the Draggable instance.\npointerX\n: Number\n[read-only] The x (horizontal) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageX).\npointerY\n: Number\n[read-only] The y (vertical) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageY).\nrotation\n: Number\n[read-only] [only applies to\ntype: \"rotation\"\n] The current rotation (in degrees) of the Draggable instance.\nstartX\n: Number\n[read-only] The starting\nx\n(horizontal) position of the Draggable instance when the most recent drag began.\nstartY\n: Number\n[read-only] The starting\ny\n(vertical) position of the Draggable instance when the most recent drag began.\ntarget\n: Object\nThe object that is being dragged.\ntween\n: Tween\n[read-only] The Tween instance that gets created as soon as the mouse (or touch) is released (when\ninertia\nis\ntrue\n). This allows you to check its\nduration\n,\n.pause()\nor\n.resume()\nit, change its\ntimeScale\n, or whatever you want.\nvars\n: Object\nThe\nvars\nobject passed into the constructor which stores configuration variables like\ntype\n,\nbounds\n,\nonPress\n,\nonDrag\n, etc.\nx\n: Number\n[read-only] The current x (horizontal) position of the Draggable instance.\ny\n: Number\n[read-only] The current y (vertical) position of the Draggable instance.\nzIndex\n: Number\n[static] The starting zIndex that gets applied by default when an element is pressed/touched (for positional types, like\n\"x,y\"\n,\n\"top,left\"\n, etc.\nMethods\n\u00e2\u0080\u008b\naddEventListener\n(  ) ;\napplyBounds\n( bounds:Element | String | Object ) ;\nApplies new bounds to the Draggable.\nDraggable.create\n( target:Object, vars:Object ) : Array\n[static] A more flexible way to create Draggable instances than the constructor (\nnew Draggable(...)\n).\ndisable\n(  ) : Draggable\nDisables the Draggable instance so that it cannot be dragged anymore (unless\nenable()\nis called).\nenable\n(  ) : Draggable\nEnables the Draggable instance.\nenabled\n( value:Boolean ) : Boolean\nGets or sets the enabled state.\nendDrag\n( event:Object ) : void\nYou may force the Draggable to immediately stop interactively dragging by calling\nendDrag()\nand passing it the original mouse or touch event that initiated the stop - this is necessary because Draggable must inspect that event for various information like\npageX\n,\npageY\n,\ntarget\n, etc.\nDraggable.get\n( target:Object ) : Draggable\n[static] Provides an easy way to get the Draggable instance that's associated with a particular DOM element.\ngetDirection\n( from:String | Element ) : String\nReturns the\ndirection\n(\n\"right\"\n|\n\"left\"\n|\n\"up\"\n|\n\"down\"\n|\n\"left-up\"\n|\n\"left-down\"\n|\n\"right-up\"\n|\n\"right-down\"\n) as measured from either where the drag started (the default) or the moment-by-moment velocity, or its proximity to another element that you define.\nDraggable.hitTest\n( testObject:Object, threshold:[Number | String] ) : Boolean\nProvides an easy way to test whether or not the target element overlaps with a particular element (or the mouse position) according to whatever threshold you [optionally] define.\nkill\n(  ) : Draggable\nDisables the Draggable instance and removes it from the internal lookup table so that it is made eligible for garbage collection and it cannot be dragged anymore (unless\nenable()\nis called).\nstartDrag\n( event:Object, align:Boolean ) : void\nForces the Draggable to begin dragging.\nDraggable.timeSinceDrag\n(  ) : Number\nReturns the time (in seconds) that has elapsed since the last drag ended.\nupdate\n( applyBounds:Boolean, sticky:Boolean ) : Draggable\nUpdates the Draggable's x/y properties to reflect the target element's current position.\nDemos\n\u00e2\u0080\u008b\nCheck out the full collection of\nHow-to demos\nand our favourite\ninspiring community demos\non CodePen.\nContents\nFeatures\nUsage\nConfig Object\nSnapping\nAs an array of snap-to values\nAs a function with custom logic\nGetting the velocity\nNotes, dependencies, and limitations\nProperties\nMethods\nDemos",
  "content_markdown": "On this page\n\nProvides a surprisingly simple way to make virtually any DOM element draggable, spinnable, tossable, and even flick-scrollable using mouse and/or touch events\n\nInertia effects Draggable integrates beautifully with [InertiaPlugin](/docs/v3/Plugins/InertiaPlugin) so that the user can flick and have the motion decelerate smoothly based on momentum. :::\n\n#### loading...\n\n## Features[\u00e2\u0080\u008b](#features \"Direct link to Features\")\n\nFeature Highlights\n\n- **Touch enabled** - Works great on tablets, phones, and desktop browsers.\n- **Incredibly smooth** - GPU-accelerated and `requestAnimationFrame`-driven for ultimate performance. Compared to other options out there, Draggable just feels far more natural and fluid, particularly when imposing bounds and momentum.\n- **Momentum-based animation** - If you have InertiaPlugin loaded, you can simply set `inertia: true` in the `config` object and it'll automatically apply natural, momentum-based movement after the mouse/touch is released, causing the object to glide gracefully to a stop. You can even control the amount of `resistance`, maximum or minimum `duration`, etc.\n\n**read more...**\n\n- **Impose bounds** - Tell a draggable element to stay within the bounds of another DOM element (a container) as in `bounds: \"#container\"` or define bounds as coordinates like `bounds: {top: 100, left: 0, width: 1000, height: 800}` or specific maximum and minimum values like `bounds: {minRotation: 0, maxRotation: 270}`.\n- **Sense overlaps with `hitTest()`** - See if one element is overlapping another and even set a tolerance threshold (like at least 20 pixels or 25% of either element's total surface area) using the super-flexible `Draggable.hitTest()` method. Feed it a mouse event and it'll tell you if the mouse is over the element. See [this CodePen](https://codepen.io/GreenSock/pen/GFBvn) for a simple example.\n- **Define a trigger element** - Maybe you want only a certain area to trigger the dragging (like the top bar of a window) - it's as simple as `trigger: \"#topBar\"`, for example.\n- \\*\\*Drag position or rotation \\*\\*- Lots of drag types to choose from: [`\"x,y\"` | `\"top,left\"` | `\"rotation\"` | `\"x\"` | `\"y\"` | `\"top\"` | `\"left\"`]\n- **Lock movement along a certain axis** - Set `lockAxis: true` and Draggable will watch the direction the user starts to drag and then restrict it to that axis. Or if you only want to allow vertical or horizontal movement, that's easy using the type (`\"top\"` or `\"y\"` to only allow vertical movement; `\"x\"`, or `\"left\"` to only allow horizontal movement).\n- **Rotation honors transform origin** - By default, spinnable elements will rotate around their center, but you can set `transformOrigin` to something else to make the pivot point be elsewhere. For example, if you call `gsap.set(yourElement, {transformOrigin: \"top left\"})` before dragging, it will rotate around its top left corner. Or use `%` or `px`. Whatever is set in the element's CSS will be honored.\n- **Rich callback system and event dispatching** - You can use any of the following callbacks: `onPress`, `onDragStart`, `onDrag`, `onDragEnd`, `onRelease`, `onLockAxis`, and `onClick`. Inside the callbacks, `this` refers to the Draggable instance itself, so you can easily access its `target` or `bounds`, etc. If you prefer event listeners instead, Draggable dispatches events too so you can do things like `yourDraggable.addEventListener(\"dragend\", yourFunc);`\n- **Works great with SVG.**\n- **Even works in transformed containers!** - Got a Draggable inside a rotated or scaled container? No problem. No other tool handles this properly that we've seen.\n- **Auto-scrolling, even in multiple containers** - Set `autoScroll: 1` for normal-speed auto scrolling, or `autoScroll: 2` would scroll twice as fast, etc. The closer you move toward the edge, the faster scrolling gets. See a [demo here](https://codepen.io/GreenSock/pen/YPvdYv/?editors=001).\n- **Sense clicks when the element moves less than 3 pixels** - A common challenge is figuring out when a user is trying to click or tap an object rather than drag it, so if the mouse/touch moves less than 3 pixels from its starting position, it will be interpreted as a click and the `onClick` callback will be called (and a `\"click\"` event dispatched) without actually moving the element. You can define a different threshold using `minimumMovement` config property, like `minimumMovement: 6` for 6 pixels.\n\n## Usage[\u00e2\u0080\u008b](#usage \"Direct link to Usage\")\n\nIn its simplest form, you can make an element draggable (vertically and horizontally) like this:\n\n```\nDraggable.create('#yourID');\n```\n\nThis will simply find the element with the ID `\"yourID\"` and make it draggable with no bounds or any kinetic motion after release. You don't need to use selector text either - you can pass the element itself or even an array of objects.\n\nUse the `vars` parameter to define various other configuration options. For example, to make the object scroll only vertically using the `y` transform and stay within the bounds of a DOM element with an ID of `\"container\"`, and call a function when clicked and another when the drag ends and make it have momentum-based motion (assuming you loaded InertiaPlugin), do this:\n\n```\nDraggable.create('#yourID', {  \n\ttype: 'y',  \n\tbounds: document.getElementById('container'),  \n\tinertia: true,  \n\tonClick: function () {  \n\t\tconsole.log('clicked');  \n\t},  \n\tonDragEnd: function () {  \n\t\tconsole.log('drag ended');  \n\t}  \n});\n```\n\nOr to make something **spinnable** (dragging rotates the element), you could simply do:\n\n```\nDraggable.create('#yourID', {  \n\ttype: 'rotation',  \n\tinertia: true  \n});\n```\n\nAnd to add the ability to snap to 90-degree increments after the mouse/touch is released (like flick-spinning that always lands on 90-degree increments), use the snap option:\n\n```\nDraggable.create('#yourID', {  \n\ttype: 'rotation',  \n\tinertia: true,  \n\tsnap: function (value) {  \n\t\t//this function gets called by InertiaPlugin when the mouse/finger is released and it plots where rotation  \n\t\t//should normally end and we can alter that value and return a new one instead. This gives us an easy way to  \n\t\t//apply custom snapping behavior with any logic we want. In this case, we'll just make sure the end value snaps  \n\t\t//to 90-degree increments but only when the \"snap\" checkbox is selected.  \n\t\treturn Math.round(value / 90) * 90;  \n\t}  \n});\n```\n\n## **Config Object**[\u00e2\u0080\u008b](#config-object \"Direct link to config-object\")\n\n### Property\n\n### Description\n\n- #### activeCursor\n\n  String - The cursor\u00e2\u0080\u0099s CSS value that should be used between the time they press and then release the pointer/mouse. This can be different than the regular `cursor` value, like: `cursor: \"grab\", activeCursor: \"grabbing\"`.\n- #### allowContextMenu\n\n  Boolean - If `true`, Draggable will allow context menus (like if a user right-clicks or long-touches). Normally this is suppressed because it can get in the way of dragging (especially on touch devices). Default: `false`.\n- #### allowEventDefault\n\n  Boolean - If `true`, `preventDefault()` won\u00e2\u0080\u0099t be called on the original mouse/pointer/touch event. This can be useful if you want to permit the default behavior like touch-scrolling. Typically, however, it\u00e2\u0080\u0099s best to let Draggable call `preventDefault()` on the events in order to deliver the best usability with dragging. Default: `false`.\n- #### allowNativeTouchScrolling\n\n  Boolean - By default, allows you to native touch-scroll in the opposite direction as Draggables that are limited to one axis . For example, a Draggable of `type: \"x\"` or `\"left\"` would permit native touch-scrolling in the vertical direction, and `type: \"y\"` or `\"top\"` would permit native horizontal touch-scrolling. Default: `true`.\n- #### autoScroll\n\n  Number - To enable auto-scrolling when a Draggable is dragged within 40px of an edge of a scrollable container, set autoScroll to a non-zero value, where 1 is normal speed, 2 is double-speed, etc. (you can use any number). For a more intuitive or natural feel, it will scroll faster as the mouse/touch gets closer to the edge. The default value is 0 (no auto-scrolling). See [this CodePen](//codepen.io/GreenSock/pen/YPvdYv/?editors=001) for a demo.\n- #### bounds\n\n  [*Element* | *String* | *Object*] - To cause the draggable element to stay within the bounds of another DOM element (like a container), you can pass the element like `bounds: document.getElementById(\"container\")` or even selector text like `\"#container\"`. If you prefer, you can define bounds as a rectangle instead, like `bounds: {top: 100, left: 0, width: 1000, height: 800}` which is based on the parent\u00e2\u0080\u0099s coordinate system (top and left would be from the upper left corner of the parent). Or you can define specific maximum and minimum values like `bounds: {minX: 10, maxX: 300, minY: 50, maxY: 500}` or `bounds: {minRotation: 0, maxRotation: 270}`.\n- #### callbackScope\n\n  Object - The scope to be used for all of the callbacks (`onDrag`, `onDragEnd`, `onDragStart`, etc). The scope is what `this` refers to inside any of the callbacks. The older callback-specific scope properties are deprecated but still work.\n- #### clickableTest\n\n  Function - Your Draggable may contain child elements that are \u00e2\u0080\u009cclickable\u00e2\u0080\u009d, like links `<a>` tags, `<button/>` or `<input>` elements, etc. By default, it treats clicks and taps on those elements differently, not allowing the user to drag them. You can set `dragClickables: true` to override that, but it still may be handy to control exactly what Draggable considers to be a \u00e2\u0080\u009cclickable\u00e2\u0080\u009d element, so you can use your own function that accepts the clicked-on element as the only parameter and returns true or false accordingly. Draggable will call this function whenever the user presses their mouse or finger down on a Draggable, and the target of that event will be passed to your clickableTest function.\n- #### cursor\n\n  String - By default (except for `type: \"rotation\"`), the cursor CSS property of the element is set to `move` so that when the mouse rolls over it, there\u00e2\u0080\u0099s a visual cue indicating that it\u00e2\u0080\u0099s moveable, but you may define a different cursor if you prefer (as described at <https://devdocs.io/css/cursor>) like `cursor: \"pointer\"`.\n- #### dragClickables\n\n  Boolean - By default, Draggable will work on pretty much any element, but sometimes you might want clicks on `<a>`, `<input>`, `<select>`, `<button>`, and `<textarea>` elements (as well as any element that has a `data-clickable=\"true\"` attribute) NOT to trigger dragging so that the browser\u00e2\u0080\u0099s default behavior fires (like clicking on an input would give it focus and drop the cursor there to begin typing), so if you want Draggable to ignore those clicks and allow the default behavior instead, set `dragClickables: false`.\n- #### dragResistance\n\n  Number - A number between 0 and 1 that controls the degree to which resistance is constantly applied to the element as it is dragged, where 1 won\u00e2\u0080\u0099t allow it to be dragged at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed), and 0.5 would be half-speed, etc. This can even apply to rotation.\n- #### edgeResistance\n\n  Number - A number between 0 and 1 that controls the degree to which resistance is applied to the element as it goes outside the bounds (if any are applied), where 1 won\u00e2\u0080\u0099t allow it to be dragged past the bounds at all, 0.75 applies a lot of resistance (making the object travel at quarter-speed beyond the border while dragging), and 0.5 would be half-speed beyond the border, etc. This can even apply to rotation.\n- #### force3D\n\n  Boolean - By default, 3D transforms are used (when the browser supports them) in order to force the element onto its own layer on the GPU, thus speeding compositing. Typically this provides the best performance, but you can disable it by setting `force3D: false`. This may be a good idea if the element that you\u00e2\u0080\u0099re dragging contains child elements that are animating.\n- #### inertia\n\n  [*Boolean* | *Object*] - InertiaPlugin is the key to getting the momentum-based motion after the users\u00e2\u0080\u0099 mouse (or touch) is released. To have Draggable auto-apply an InertiaPlugin tween to the element when the mouse is released (or touch ends), you can set `inertia: true` (`inertia` also works). Or for advanced effects, you can define the actual inertia object that will get fed into tween, like `inertia: {top: {min: 0, max: 1000, end: [0,200,400,600]}}`. However, if you want ultimate control over the InertiaPlugin tween, you can simply use an `onDragEnd` to call your own function that creates the tween. If `inertia: true` is defined, you may also use any of the following configuration properties that apply to the movement after the mouse/touch is released...\n\n  View More details\n\n  - **snap** : [*Function* | *Object* | *Array*] - Allows you to define rules for where the element can land after it gets released. For example, maybe you want the rotation to always end at a 90-degree increment or you want the `x` and `y` values to be exactly on a grid (whichever cell is closest to the natural landing spot) or maybe you want it to land on a very specific value. You can define the snap in any of the following ways:\n    - **As a function** - This function will be passed one numeric parameter, the natural ending value. The function must return whatever the new ending value should be (you run whatever logic you want inside the function and spit back the value). For example, to make the value snap to the closest increment of 50, you\u00e2\u0080\u0099d do `snap: function(endValue) { return Math.round(endValue / 50) * 50; }`.\n    - **As an Array** - If you use an array of values, InertiaPlugin will first plot the natural landing position and then loop through the array and find the closest number (as long as it\u00e2\u0080\u0099s not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you\u00e2\u0080\u0099d do `snap: [10,50,200,450]`.\n    - **As an object** - If you\u00e2\u0080\u0099d like to use different logic for each property, like if `type` is `\"x,y\"` and you\u00e2\u0080\u0099d like to have the `x` part snap to one set of values, and the `y` part snap to a different set of values, you can use an object that has matching properties, like: `snap:{x: [5,20,80,400], y: [10,60,80,500]}` or if `type` is `\"top,left\"` and you want to use a different function for each, you could do something like `snap: {top: function(endValue) { return Math.round(endValue / 50) * 50; }, left: function(endValue) { return Math.round(endValue / 100) * 100; }}`. You can define a points property inside this object that combines both `x` and `y`, like `liveSnap: {points: [{x: 0, y: 0},{x: 100, y: 0}], radius: 20}` which will snap to any point in the array when it\u00e2\u0080\u0099s within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like `liveSnap: {points: function(point) { //run custom logic and return a new point }}`. See the [snapping section](#snapping) of this page for examples.\n  - **onThrowUpdate** : *Function* - A function that should be called each time the InertiaPlugin tween updates/renders (basically on each \u00e2\u0080\u009ctick\u00e2\u0080\u009d of the engine while the tween is active). This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called while the user is dragging the element (that\u00e2\u0080\u0099s what `onDrag` is for). By default, the scope of the `onThrowUpdate` is the Draggable instance itself, but you may define an `callbackScope` if you prefer, just like any other tween.\n  - **onThrowComplete** : *Function* - A function that should be called when the InertiaPlugin tween finishes. This only applies to the tween that gets generated after the user releases their mouse/touch - the function is not called immediately when the user releases their mouse/touch - that\u00e2\u0080\u0099s what `onDragEnd` is for. By default, the scope of the `onThrowComplete` is the Draggable instance itself, but you may define an `callbackScope` if you prefer, just like any other tween.\n  - **throwResistance** : *Number* - A number (`1000` by default) that controls how much resistance or friction there is when the mouse/touch is released and momentum-based motion is enabled (by setting `inertia: true`). The larger the number, the more resistance and the quicker the motion decelerates. (requires InertiaPlugin and setting `inertia: true`, otherwise `throwResistance` will simply be ignored.)\n  - **maxDuration** : *Number* - The maximum duration (in seconds) that the kinetic-based inertia tween can last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can cap the duration by defining a `maxDuration`. The default is 10 seconds. This has nothing to do with the maximum amount of time that the user can drag the object - it\u00e2\u0080\u0099s only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting `inertia: true`, otherwise `maxDuration` will simply be ignored.)\n  - **minDuration** : *Number* - The minimum duration (in seconds) that the kinetic-based inertia tween should last. InertiaPlugin will automatically analyze the velocity and bounds and determine an appropriate duration (faster movements would typically result in longer tweens to decelerate), but you can force the tween to take at least a certain amount of time by defining a `minDuration`. The default is 0.2 seconds. This has nothing to do with the minimum amount of time that the user can drag the object - it\u00e2\u0080\u0099s only the inertia tween that results after they release the mouse/touch. (requires InertiaPlugin and setting `inertia: true`, otherwise minDuration will simply be ignored.)\n  - **overshootTolerance** : *Number* - Affects how much overshooting is allowed before smoothly returning to the resting position at the end of the tween. This can happen when the initial velocity from the flick would normally cause it to exceed the bounds/min/max. The larger the `overshootTolerance` the more leeway the tween has to temporarily shoot past the max/min if necessary. The default is `1`. If you don\u00e2\u0080\u0099t want to allow any overshooting, you can set it to `0`.\n- #### liveSnap\n\n  [*Function* | *Boolean* | *Array* | *Object*] - Allows you to define rules that get applied **WHILE** the element is being dragged (whereas regular snap affects only the end value(s), where the element lands after the drag is released). For example, maybe you want the rotation to snap to 10-degree increments while dragging or you want the x and y values to snap to a grid (whichever cell is closest). You can define the `liveSnap` in any of the following ways:\n\n  View More details\n\n  - **As a function** - This function will be passed one numeric parameter, the natural (unaltered) value. The function must return whatever the new value should be (you run whatever logic you want inside your function and spit back the value). For example, to make the value snap to the closest increment of 50, you\u00e2\u0080\u0099d do `liveSnap: function(value) { return Math.round(value / 50) * 50; }`.\n  - **As an array** - If you use an array of values, Draggable will loop through the array and find the closest number (as long as it\u00e2\u0080\u0099s not outside any bounds you defined). For example, to have it choose the closest number from 10, 50, 200, and 450, you\u00e2\u0080\u0099d do `liveSnap: [10,50,200,450]`.\n  - **As an object** - If you\u00e2\u0080\u0099d like to use different logic for each property, like if `type` is `\"x,y\"` and you\u00e2\u0080\u0099d like to have the \u00e2\u0080\u009cx\u00e2\u0080\u009d part snap to one set of values, and the \u00e2\u0080\u009cy\u00e2\u0080\u009d part snap to a different set of values, you can use an object that has matching properties, like: `liveSnap: {x: [5,20,80,400], y: [10,60,80,500]}`. Or if `type` is `\"top,left\"` and you want to use a different function for each, you\u00e2\u0080\u0099d do something like `liveSnap: {top: function(value) { return Math.round(value / 50) * 50; }, left: function(value) { return Math.round(value / 100) * 100; }}`. You can define a `points` property inside this object that combines both x and y, like `liveSnap: {points:[{x: 0, y: 0}, {x: 100, y: 0}], radius: 20}` which will snap to any point in the array when it\u00e2\u0080\u0099s within 20px (distance). Or you can even use a function-based value to run your own snapping logic, like `liveSnap: {points: function(point) { //run custom logic and return a new point }}`. See the [snapping section](#snapping) of this page for examples.\n  - **As a boolean (`true`)** - Live snapping will use whatever is defined for the `snap` (so that instead of only applying to the end value(s), it will apply it \u00e2\u0080\u009clive\u00e2\u0080\u009d while dragging too).\n- #### lockAxis\n\n  Boolean - If `true`, dragging more than 2 pixels in either direction (horizontally or vertically) will lock movement into that axis so that the element can only be dragged that direction (horizontally or vertically, whichever had the most initial movement) during that drag. No diagonal movement will be allowed. Obviously this is only applicable for Draggables with a `type` of `\"x,y\"`, or `\"top,left\"`. If you only want to allow vertical movement, you should set the `type` to `\"y\"` or `\"top\"`. If you only want to allow horizontal movement, you should set the `type` to `\"x\"` or `\"left\"`.\n- #### minimumMovement\n\n  Number - By default, Draggable requires that the Draggable element moves more than 2 pixels in order to be interpreted as a drag, but you can change that threshold using `minimumMovement`. So `minimumMovement: 6` would require that the Draggable element moves more than 6 pixels to be interpreted as a drag.\n- #### onClick\n\n  Function - A function that should be called only when the mouse/touch is pressed on the element and released without moving 3 pixels or more. This makes it easier to discern the user\u00e2\u0080\u0099s intent (click or drag). Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onClickParams\n\n  Array - An optional array of parameters to feed the `onClick` callback. For example, `onClickParams: [\"clicked\", 5]` would work with this code: `onClick: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### onDrag\n\n  Function - A function that should be called every time the mouse (or touch) moves during the drag. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc. This is only called once per requestAnimationFrame.\n- #### onDragParams\n\n  Array - An optional array of parameters to feed the `onDrag` callback. For example, `onDragParams: [\"dragged\", 5]` would work with this code: `onDrag: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### onDragEnd\n\n  Function - A function that should be called as soon as the mouse (or touch) is **released** after the drag. Even if nothing is moved, the `onDragEnd` will always fire, whereas the `onClick` callback only fires if the mouse/touch moves is less than 3 pixels. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onDragEndParams\n\n  Array - An optional array of parameters to feed the `onDragEnd` callback. For example, `onDragEndParams: [\"drag ended\", 5]` would work with this code: `onDragEnd: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### onDragStart\n\n  Function - A function that should be called as soon as the mouse (or touch) moves more than 2 pixels, meaning that dragging has begun. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onDragStartParams\n\n  Array - An optional array of parameters to feed the `onDragStart` callback. For example, `onDragStartParams: [\"drag started\", 5]` would work with this code: `onDragStart: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### onLockAxis\n\n  Function - A function that should be called as soon as movement is locked into the horizontal or vertical axis. This happens when `lockAxis` is `true` and the user drags enough for Draggable to determine which axis to lock. It also happens on touch-enabled devices when you have a Draggable whose type only permits it to drag along one axis (like `type: \"x\"`, `type: \"y\"`, `type: \"left\"`, or `type: \"top\"`) and the user touch-drags and Draggable determines the direction, either allowing native touch-scrolling or Draggable-induced dragging. Inside the function, `this` refers to the Draggable instance, making it easy to access the locked axis (`this.lockedAxis` which will either be `\"x\"` or `\"y\"`), or the target element (`this.target`), etc. By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onMove\n\n  Function - A function that should be called every time the mouse (or touch) moves during the drag. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access its `pageX`, `pageY`, `target`, `currentTarget`, etc. This is different than `onDrag` in that it can fire multiple times per requestAnimationFrame. In general, it is better to use `onDrag`, but this is available if, for some reason, need to `.stopPropogation` or `.stopImmediatePropogation` on the drag event.\n- #### onPress\n\n  Function - A function that should be called as soon as the mouse (or touch) presses down on the element. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onPressInit\n\n  Function - A function that should be called before the starting values are recorded in the `onPress`, allowing you to make changes before any dragging occurs. `onPressInit` always fires BEFORE `onPress`. [See demo](//codepen.io/GreenSock/pen/62fd4014cf86a9a87e632c8b4f967ed4/?editors=0010).\n- #### onPressParams\n\n  Array - An optional array of parameters to feed the `onPress` callback. For example, `onPressParams: [\"drag started\", 5]` would work with this code: `onPress: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### onRelease\n\n  Function - A function that should be called as soon as the mouse (or touch) is released after having been pressed on the target element, regardless of whether or not anything was dragged. Inside that function, `this` refers to the Draggable instance (unless you specifically set the scope using `callbackScope`), making it easy to access the target element (`this.target`) or the boundary coordinates (`this.maxX`, `this.minX`, `this.maxY`, and `this.minY`). By default, the `pointerEvent` (last mouse or touch event related to the Draggable) will be passed as the only parameter to the callback so that you can, for example, access `pageX`, `pageY`, `target`, `currentTarget`, etc.\n- #### onReleaseParams\n\n  Array - An optional array of parameters to feed the `onRelease` callback. For example, `onReleaseParams: [\"drag ended\", 5]` would work with this code: `onRelease: function(message, num) { console.log(\"message: \" + message + \", num: \" + num); }`.\n- #### trigger\n\n  [*Element* | *String* | *Object*] - If you want only a certain area to trigger the dragging (like the top bar of a window) instead of the entire element, you can define a child element as the trigger, like `trigger: yourElement`, `trigger: \"#topBar\"`, or `trigger: $(\"#yourID\")`. You may define the trigger as an element or a selector string\n- #### type\n\n  String - Indicates the type of dragging (the properties that the dragging should affect). Any of the following work: [`\"x,y\"` (basically the `translateX` and `translateY` of transform) | `\"left,top\"` | `\"rotation\"` |`\"x\"` | `\"y\"` | `\"top\"` | `\"left\"`]. The default is `\"x,y\"`.\n- #### zIndexBoost\n\n  Boolean - By default, for vertical or horizontal dragging, when an element is pressed/touched, it has its `zIndex` set to a high value (`1000` by default) and that number gets incremented and applied to each new element that gets pressed/touched so that the stacking order looks correct (newly pressed objects rise to the top), but if you prefer to skip this behavior set `zIndexBoost: false`.\n\n## Snapping[\u00e2\u0080\u008b](#snapping \"Direct link to Snapping\")\n\nDraggable has advanced snapping capabilities. You can define a `snap` value in the `config` object to control where the Draggable will snap **AFTER** it is released, or you can define a `liveSnap` value where the Draggable should snap **WHILE** dragging. You can define these values in any of the following ways:\n\n### As an array of snap-to values[\u00e2\u0080\u008b](#as-an-array-of-snap-to-values \"Direct link to As an array of snap-to values\")\n\n```\nDraggable.create('#id', {  \n\ttype: 'x,y',  \n\tliveSnap: {  \n\t\t//snaps to the closest point in the array, but only when it's within 15px (new in GSAP 1.20.0 release):  \n\t\tpoints: [  \n\t\t\t{ x: 0, y: 0 },  \n\t\t\t{ x: 100, y: 0 },  \n\t\t\t{ x: 200, y: 50 }  \n\t\t],  \n\t\tradius: 15  \n\t}  \n});\n```\n\n`points` is a special property that allows you to combine both `x` and `y` logic into a single place. You can also use separate per-property arrays:\n\n```\nDraggable.create('#id', {  \n\ttype: 'x,y',  \n\tliveSnap: {  \n\t\t//x and y (or top and left) can each have their own array of values to snap to:  \n\t\tx: [0, 100, 200, 300],  \n\t\ty: [0, 50, 100, 150]  \n\t}  \n});\n```\n\n### As a function with custom logic[\u00e2\u0080\u008b](#as-a-function-with-custom-logic \"Direct link to As a function with custom logic\")\n\n```\nDraggable.create('#id', {  \n\ttype: 'x,y',  \n\tliveSnap: {  \n\t\tpoints: function (point) {  \n\t\t\t//if it's within 100px, snap exactly to 500,250  \n\t\t\tvar dx = point.x - 500;  \n\t\t\tvar dy = point.y - 250;  \n\t\t\tif (Math.sqrt(dx * dx + dy * dy) < 100) {  \n\t\t\t\treturn { x: 500, y: 250 };  \n\t\t\t}  \n\t\t\treturn point; //otherwise don't change anything.  \n\t\t}  \n\t}  \n});\n```\n\nOr use separate per-property functions:\n\n```\nDraggable.create('#id', {  \n\ttype: 'x,y',  \n\tliveSnap: {  \n\t\tx: function (value) {  \n\t\t\t//snap to the closest increment of 50.  \n\t\t\treturn Math.round(value / 50) * 50;  \n\t\t},  \n\t\ty: function (value) {  \n\t\t\t//snap to the closest increment of 25.  \n\t\t\treturn Math.round(value / 25) * 25;  \n\t\t}  \n\t}  \n});\n```\n\nIt's just as simple for a rotation Draggable:\n\n```\nDraggable.create('#id', {  \n\ttype: 'rotation',  \n\tliveSnap: {  \n\t\trotation: function (value) {  \n\t\t\t//snap to the closest increment of 10.  \n\t\t\treturn Math.round(value / 10) * 10;  \n\t\t}  \n\t}  \n});\n```\n\n## Getting the velocity[\u00e2\u0080\u008b](#getting-the-velocity \"Direct link to Getting the velocity\")\n\nAs long as you've loaded InertiaPlugin and set `inertia: true` on your Draggable, you can tap into the `InertiaPlugin.getVelocity()` method. Draggable will automatically start tracking the velocity of the necessary properties based on whatever its `type` is (`type: \"x,y\"` will track `x` and `y`, `type: \"rotation\"` will track rotation, etc.).\n\n```\n//positional velocity  \nDraggable.create('#movableID', {  \n\ttype: 'x,y',  \n\tinertia: true,  \n\tonDragEnd: function () {  \n\t\tconsole.log(  \n\t\t\t'x velocity is: ' +  \n\t\t\t\tInertiaPlugin.getVelocity(this.target, 'x') +  \n\t\t\t\t' and the duration is ' +  \n\t\t\t\tthis.tween.duration() +  \n\t\t\t\t' seconds.'  \n\t\t);  \n\t}  \n});\n```\n\n## Notes, dependencies, and limitations[\u00e2\u0080\u008b](#notes-dependencies-and-limitations \"Direct link to Notes, dependencies, and limitations\")\n\n- In most cases, [`.pointerX`](/docs/v3/Plugins/Draggable/pointerX) and [`.pointerY`](/docs/v3/Plugins/Draggable/pointerY) should be used instead of using the event's positioning (like `.pageX`/`.pageY` or something like that) because GSAP tries to normalize positioning across all browsers.\n- If you want a particular element to be \"clickable\", thus ignored by Draggable, simply add a `data-clickable=\"true\"` attribute to it, or an `onclick`. By default, Draggable automatically ignores clicks on `<a>`, `<input>`, `<select>`, `<button>`, and `<textarea>` elements. If you prefer to run your own logic to determine if an object should be considered \"clickable\", you can set the `clickableTest` config property to a function of your choosing that returns `true` or `false`.\n- Draggable can be used without InertiaPlugin, but doing so will disable any momentum-based motion (like being able to flick objects and have them continue while decelerating). These two tools go together perfectly \u00f0\u009f\u00ab\u00b6.\n- In order to make things moveable via their `top` and `left` CSS properties, you must make sure that the elements have their `position` CSS property set to either `relative` or `absolute` (that's just how CSS works).\n- By default, all callback functions and `snap` functions and `liveSnap` functions are scoped to the associated Draggable instance, so `this` refers to the Draggable instance. You can get the current horizontal or vertical values using `this.x` and `this.y` inside those functions. And if you applied bounds, you can also get the maximum and minimum \"legal\" values for that particular instance using `this.maxX`, `this.minX`, `this.maxY`, and `this.minY`.\n- Having trouble with momentum-based motion? Make sure you have [InertiaPlugin](/docs/v3/Plugins/InertiaPlugin/) loaded! To use it, set `inertia: true` in the `vars` config object, like `Draggable.create(yourObject, {inertia: true});`.\n- If you use an element for the bounds, it should not be rotated differently than the target element.\n- If you are mixing timelines and draggable, you may need to use a proxy element. For more information see [this demo](https://codepen.io/GreenSock/pen/WNedayo).\n\n## **Properties**[\u00e2\u0080\u008b](#properties \"Direct link to properties\")\n\n|  |  |\n| --- | --- |\n| [autoScroll](/docs/v3/Plugins/Draggable/autoScroll) : Number | How fast to scroll the container element when `autoScroll` is `true`. |\n| [deltaX](/docs/v3/Plugins/Draggable/deltaX) : Number | The change in the x-related value since the last drag event. |\n| [deltaY](/docs/v3/Plugins/Draggable/deltaY) : Number | The change in the y-related value since the last drag event. |\n| [endRotation](/docs/v3/Plugins/Draggable/endRotation) : Number | [read-only] [only applies to type:\"rotation\"] The ending rotation of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick. |\n| [endX](/docs/v3/Plugins/Draggable/endX) : Number | [read-only] The ending x (horizontal) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after an `inertia` flick. |\n| [endY](/docs/v3/Plugins/Draggable/endY) : Number | [read-only] The ending y (vertical) position of the Draggable instance which is calculated as soon as the mouse/touch is released after a drag, meaning you can use it to predict precisely where it'll land after a `inertia` flick. |\n| [isPressed](/docs/v3/Plugins/Draggable/isPressed) : Boolean | If the Draggable is being pressed, this will be `true` |\n| [isThrowing](/docs/v3/Plugins/Draggable/isThrowing) : Boolean | Reports if the target of a Draggable is being thrown using a InertiaPlugin tween. |\n| [lockAxis](/docs/v3/Plugins/Draggable/lockAxis) : Boolean | Locks movement to one axis based on the how it is moved initially. |\n| [lockedAxis](/docs/v3/Plugins/Draggable/lockedAxis) : String |  |\n| [maxRotation](/docs/v3/Plugins/Draggable/maxRotation) : Number | When bounds are applied, `maxRotation` refers to the maximum \"legal\" rotation. |\n| [maxX](/docs/v3/Plugins/Draggable/maxX) : Number | When bounds are applied, `maxX` refers to the maximum \"legal\" horizontal property. |\n| [maxY](/docs/v3/Plugins/Draggable/maxY) : Number | When bounds are applied, `maxY` refers to the maximum \"legal\" vertical property. |\n| [minRotation](/docs/v3/Plugins/Draggable/minRotation) : Number | When bounds are applied, `minRotation` refers to the minimum \"legal\" rotation property. |\n| [minX](/docs/v3/Plugins/Draggable/minX) : Number | When bounds are applied, `minX` refers to the minimum \"legal\" horizontal property. |\n| [minY](/docs/v3/Plugins/Draggable/minY) : Number | When bounds are applied, `minY` refers to the minimum \"legal\" vertical property. |\n| [pointerEvent](/docs/v3/Plugins/Draggable/pointerEvent) : Object | [read-only] The last pointer event (either a mouse event or touch event) that affected the Draggable instance. |\n| [pointerX](/docs/v3/Plugins/Draggable/pointerX) : Number | [read-only] The x (horizontal) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageX). |\n| [pointerY](/docs/v3/Plugins/Draggable/pointerY) : Number | [read-only] The y (vertical) position of the pointer (mouse or touch) associated with the Draggable's last event (like event.pageY). |\n| [rotation](/docs/v3/Plugins/Draggable/rotation) : Number | [read-only] [only applies to `type: \"rotation\"`] The current rotation (in degrees) of the Draggable instance. |\n| [startX](/docs/v3/Plugins/Draggable/startX) : Number | [read-only] The starting `x` (horizontal) position of the Draggable instance when the most recent drag began. |\n| [startY](/docs/v3/Plugins/Draggable/startY) : Number | [read-only] The starting `y` (vertical) position of the Draggable instance when the most recent drag began. |\n| [target](/docs/v3/Plugins/Draggable/target) : Object | The object that is being dragged. |\n| [tween](/docs/v3/Plugins/Draggable/tween) : Tween | [read-only] The Tween instance that gets created as soon as the mouse (or touch) is released (when `inertia` is `true`). This allows you to check its `duration`, `.pause()` or `.resume()` it, change its `timeScale`, or whatever you want. |\n| [vars](/docs/v3/Plugins/Draggable/vars) : Object | The `vars` object passed into the constructor which stores configuration variables like `type`, `bounds`, `onPress`, `onDrag`, etc. |\n| [x](/docs/v3/Plugins/Draggable/x) : Number | [read-only] The current x (horizontal) position of the Draggable instance. |\n| [y](/docs/v3/Plugins/Draggable/y) : Number | [read-only] The current y (vertical) position of the Draggable instance. |\n| [zIndex](/docs/v3/Plugins/Draggable/zIndex) : Number | [static] The starting zIndex that gets applied by default when an element is pressed/touched (for positional types, like `\"x,y\"`, `\"top,left\"`, etc. |\n\n## **Methods**[\u00e2\u0080\u008b](#methods \"Direct link to methods\")\n\n|  |  |\n| --- | --- |\n| [addEventListener](/docs/v3/Plugins/Draggable/addEventListener())( ) ; |  |\n| [applyBounds](/docs/v3/Plugins/Draggable/applyBounds())( bounds:Element | String | Object ) ; | Applies new bounds to the Draggable. |\n| [Draggable.create](/docs/v3/Plugins/Draggable/static.create())( target:Object, vars:Object ) : Array | [static] A more flexible way to create Draggable instances than the constructor (`new Draggable(...)`). |\n| [disable](/docs/v3/Plugins/Draggable/disable())( ) : Draggable | Disables the Draggable instance so that it cannot be dragged anymore (unless `enable()` is called). |\n| [enable](/docs/v3/Plugins/Draggable/enable())( ) : Draggable | Enables the Draggable instance. |\n| [enabled](/docs/v3/Plugins/Draggable/enabled())( value:Boolean ) : Boolean | Gets or sets the enabled state. |\n| [endDrag](/docs/v3/Plugins/Draggable/endDrag())( event:Object ) : void | You may force the Draggable to immediately stop interactively dragging by calling `endDrag()` and passing it the original mouse or touch event that initiated the stop - this is necessary because Draggable must inspect that event for various information like `pageX`, `pageY`, `target`, etc. |\n| [Draggable.get](/docs/v3/Plugins/Draggable/static.get())( target:Object ) : Draggable | [static] Provides an easy way to get the Draggable instance that's associated with a particular DOM element. |\n| [getDirection](/docs/v3/Plugins/Draggable/getDirection())( from:String | Element ) : String | Returns the `direction` (`\"right\"` | `\"left\"` | `\"up\"` | `\"down\"` | `\"left-up\"` | `\"left-down\"` | `\"right-up\"` | `\"right-down\"`) as measured from either where the drag started (the default) or the moment-by-moment velocity, or its proximity to another element that you define. |\n| [Draggable.hitTest](/docs/v3/Plugins/Draggable/static.hitTest())( testObject:Object, threshold:[Number | String] ) : Boolean | Provides an easy way to test whether or not the target element overlaps with a particular element (or the mouse position) according to whatever threshold you [optionally] define. |\n| [kill](/docs/v3/Plugins/Draggable/kill())( ) : Draggable | Disables the Draggable instance and removes it from the internal lookup table so that it is made eligible for garbage collection and it cannot be dragged anymore (unless `enable()` is called). |\n| [startDrag](/docs/v3/Plugins/Draggable/startDrag())( event:Object, align:Boolean ) : void | Forces the Draggable to begin dragging. |\n| [Draggable.timeSinceDrag](/docs/v3/Plugins/Draggable/static.timeSinceDrag())( ) : Number | Returns the time (in seconds) that has elapsed since the last drag ended. |\n| [update](/docs/v3/Plugins/Draggable/update())( applyBounds:Boolean, sticky:Boolean ) : Draggable | Updates the Draggable's x/y properties to reflect the target element's current position. |\n\n## **Demos**[\u00e2\u0080\u008b](#demos \"Direct link to demos\")\n\nCheck out the full collection of [How-to demos](https://codepen.io/collection/AtuHb) and our favourite [inspiring community demos](https://codepen.io/collection/DrQGpM) on CodePen.\n\n## Contents\n\n- [Features](#features)\n- [Usage](#usage)\n- [**Config Object**](#config-object)\n- [Snapping](#snapping)\n  - [As an array of snap-to values](#as-an-array-of-snap-to-values)\n  - [As a function with custom logic](#as-a-function-with-custom-logic)\n- [Getting the velocity](#getting-the-velocity)\n- [Notes, dependencies, and limitations](#notes-dependencies-and-limitations)\n- [**Properties**](#properties)\n- [**Methods**](#methods)\n- [**Demos**](#demos)",
  "tags": [
    "gsap",
    "animation",
    "javascript",
    "scrolltrigger"
  ],
  "extracted_at": "2026-02-03T12:48:53.773810+00:00",
  "content_length": 39520,
  "content_hash": "5940298ccdf38d9f"
}