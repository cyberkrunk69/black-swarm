{
  "id": "framer-motion__motion_use-animate_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/use-animate/",
  "title": "useAnimate \u00e2\u0080\u0094 Manual React animation controls | Motion",
  "content": "useAnimate\nprovides a way of using the\nanimate\nfunction\nthat is scoped to the elements within your component.\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\nIt provides a\nscope\nref, and an\nanimate\nfunction where every DOM selector is scoped to this ref.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// This \"li\" selector will only select children\n// of the element that receives `scope`.\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n}\n)\n}\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nAdditionally, when the component calling\nuseAnimate\nis removed, all animations started with its\nanimate\nfunction will be cleaned up automatically.\nUsage\nImport from Motion:\n// Mini\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react-mini\"\n// Hybrid\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react\"\nuseAnimate\nreturns two arguments, a\nscope\nref and an\nanimate\nfunction\n.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nThis\nscope\nref must be passed to either a regular HTML/SVG element or a\nmotion\ncomponent.\nfunction\nComponent\n(\n{\nchildren\n}\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nThis scoped\nanimate\nfunction can now be used in effects and event handlers to animate elements.\nWe can either use the scoped element directly:\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n,\n{\nduration\n:\n1\n}\n)\nOr by passing it a selector:\nanimate\n(\n\"li\"\n,\n{\nbackgroundColor\n:\n\"#000\"\n}\n,\n{\nease\n:\n\"linear\"\n}\n)\nThis selector is\n\"li\"\n, but we're not selecting all\nli\nelements on the page, only those that are a child of the scoped element.\nScroll-triggered animations\nAnimations can be triggered when the scope scrolls into view by combining\nuseAnimate\nwith\nuseInView\n.\nimport\n{\nuseAnimate\n,\nuseInView\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nconst\nisInView\n=\nuseInView\n(\nscope\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisInView\n)\n{\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\n}\n}\n,\n[\nisInView\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nExit animations\nIt's possible to compose your own exit animations when a component is removed using\nuseAnimate\nin conjunction with\nusePresence\n.\nimport\n{\nuseAnimate\n,\nusePresence\n}\nfrom\n\"framer-motion\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisPresent\n)\n{\nconst\nenterAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n)\n}\nenterAnimation\n(\n)\n}\nelse\n{\nconst\nexitAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n)\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n0\n}\n)\nsafeToRemove\n(\n)\n}\nexitAnimation\n(\n)\n}\n}\n,\n[\nisPresent\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nThis component can now be conditionally rendered as a child of\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n<\nComponent\nkey\n=\n\"dialog\"\n/>\n:\nnull\n}\n</\nAnimatePresence\n>\nuseAnimate\nprovides a way of using the\nanimate\nfunction\nthat is scoped to the elements within your component.\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\nIt provides a\nscope\nref, and an\nanimate\nfunction where every DOM selector is scoped to this ref.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// This \"li\" selector will only select children\n// of the element that receives `scope`.\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n}\n)\n}\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nAdditionally, when the component calling\nuseAnimate\nis removed, all animations started with its\nanimate\nfunction will be cleaned up automatically.\nUsage\nImport from Motion:\n// Mini\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react-mini\"\n// Hybrid\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react\"\nuseAnimate\nreturns two arguments, a\nscope\nref and an\nanimate\nfunction\n.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nThis\nscope\nref must be passed to either a regular HTML/SVG element or a\nmotion\ncomponent.\nfunction\nComponent\n(\n{\nchildren\n}\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nThis scoped\nanimate\nfunction can now be used in effects and event handlers to animate elements.\nWe can either use the scoped element directly:\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n,\n{\nduration\n:\n1\n}\n)\nOr by passing it a selector:\nanimate\n(\n\"li\"\n,\n{\nbackgroundColor\n:\n\"#000\"\n}\n,\n{\nease\n:\n\"linear\"\n}\n)\nThis selector is\n\"li\"\n, but we're not selecting all\nli\nelements on the page, only those that are a child of the scoped element.\nScroll-triggered animations\nAnimations can be triggered when the scope scrolls into view by combining\nuseAnimate\nwith\nuseInView\n.\nimport\n{\nuseAnimate\n,\nuseInView\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nconst\nisInView\n=\nuseInView\n(\nscope\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisInView\n)\n{\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\n}\n}\n,\n[\nisInView\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nExit animations\nIt's possible to compose your own exit animations when a component is removed using\nuseAnimate\nin conjunction with\nusePresence\n.\nimport\n{\nuseAnimate\n,\nusePresence\n}\nfrom\n\"framer-motion\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisPresent\n)\n{\nconst\nenterAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n)\n}\nenterAnimation\n(\n)\n}\nelse\n{\nconst\nexitAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n)\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n0\n}\n)\nsafeToRemove\n(\n)\n}\nexitAnimation\n(\n)\n}\n}\n,\n[\nisPresent\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nThis component can now be conditionally rendered as a child of\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n<\nComponent\nkey\n=\n\"dialog\"\n/>\n:\nnull\n}\n</\nAnimatePresence\n>\nuseAnimate\nprovides a way of using the\nanimate\nfunction\nthat is scoped to the elements within your component.\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\nIt provides a\nscope\nref, and an\nanimate\nfunction where every DOM selector is scoped to this ref.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// This \"li\" selector will only select children\n// of the element that receives `scope`.\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n}\n)\n}\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nAdditionally, when the component calling\nuseAnimate\nis removed, all animations started with its\nanimate\nfunction will be cleaned up automatically.\nUsage\nImport from Motion:\n// Mini\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react-mini\"\n// Hybrid\nimport\n{\nuseAnimate\n}\nfrom\n\"motion/react\"\nuseAnimate\nreturns two arguments, a\nscope\nref and an\nanimate\nfunction\n.\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nThis\nscope\nref must be passed to either a regular HTML/SVG element or a\nmotion\ncomponent.\nfunction\nComponent\n(\n{\nchildren\n}\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nreturn\n<\nul\nref\n=\n{\nscope\n}\n>\n{\nchildren\n}\n</\nul\n>\n}\nThis scoped\nanimate\nfunction can now be used in effects and event handlers to animate elements.\nWe can either use the scoped element directly:\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n,\n{\nduration\n:\n1\n}\n)\nOr by passing it a selector:\nanimate\n(\n\"li\"\n,\n{\nbackgroundColor\n:\n\"#000\"\n}\n,\n{\nease\n:\n\"linear\"\n}\n)\nThis selector is\n\"li\"\n, but we're not selecting all\nli\nelements on the page, only those that are a child of the scoped element.\nScroll-triggered animations\nAnimations can be triggered when the scope scrolls into view by combining\nuseAnimate\nwith\nuseInView\n.\nimport\n{\nuseAnimate\n,\nuseInView\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nconst\nisInView\n=\nuseInView\n(\nscope\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisInView\n)\n{\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\n}\n}\n,\n[\nisInView\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nExit animations\nIt's possible to compose your own exit animations when a component is removed using\nuseAnimate\nin conjunction with\nusePresence\n.\nimport\n{\nuseAnimate\n,\nusePresence\n}\nfrom\n\"framer-motion\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nif\n(\nisPresent\n)\n{\nconst\nenterAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n1\n}\n)\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n)\n}\nenterAnimation\n(\n)\n}\nelse\n{\nconst\nexitAnimation\n=\nasync\n(\n)\n=>\n{\nawait\nanimate\n(\n\"li\"\n,\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n)\nawait\nanimate\n(\nscope\n.\ncurrent\n,\n{\nopacity\n:\n0\n}\n)\nsafeToRemove\n(\n)\n}\nexitAnimation\n(\n)\n}\n}\n,\n[\nisPresent\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nThis component can now be conditionally rendered as a child of\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n<\nComponent\nkey\n=\n\"dialog\"\n/>\n:\nnull\n}\n</\nAnimatePresence\n>\nRelated topics\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nTransitions\nControl timing with duration/easing, springs, delay and stagger.\nTransitions\nControl timing with duration/easing, springs, delay and stagger.\nTransitions\nControl timing with duration/easing, springs, delay and stagger.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nuseAnimate examples\nSee all examples & tutorials, with full copy & paste source code.\nuseAnimate examples\nSee all examples & tutorials, with full copy & paste source code.\nuseAnimate examples\nSee all examples & tutorials, with full copy & paste source code.\nPrevious\nUpgrade guide\nNext\nuseAnimationFrame\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "`useAnimate` provides a way of using the `animate` [function](./animate) that is scoped to the elements within your component.\n\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\n\nIt provides a `scope` ref, and an `animate` function where every DOM selector is scoped to this ref.\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    // This \"li\" selector will only select children\n    // of the element that receives `scope`.\n    animate(\"li\", { opacity: 1 })\n  })\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nAdditionally, when the component calling `useAnimate` is removed, all animations started with its `animate` function will be cleaned up automatically.\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\n// Mini\nimport { useAnimate } from \"motion/react-mini\"\n\n// Hybrid\nimport { useAnimate } from \"motion/react\"\n```\n\n`useAnimate` returns two arguments, a `scope` ref and an `animate` [function](./animate).\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n```\n\nThis `scope` ref must be passed to either a regular HTML/SVG element or a `motion` component.\n\n```\nfunction Component({ children }) {\n  const [scope, animate] = useAnimate()\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nThis scoped `animate` function can now be used in effects and event handlers to animate elements.\n\nWe can either use the scoped element directly:\n\n```\nanimate(scope.current, { opacity: 1 }, { duration: 1 })\n```\n\nOr by passing it a selector:\n\n```\nanimate(\"li\", { backgroundColor: \"#000\" }, { ease: \"linear\" })\n```\n\nThis selector is `\"li\"`, but we're not selecting all `li` elements on the page, only those that are a child of the scoped element.\n\n### [Scroll-triggered animations](#scroll-triggered-animations)\n\nAnimations can be triggered when the scope scrolls into view by combining `useAnimate` with `useInView`.\n\n```\nimport { useAnimate, useInView } from \"motion/react\"\n\nfunction Component() {\n  const [scope, animate] = useAnimate()\n  const isInView = useInView(scope)\n  \n  useEffect(() => {\n     if (isInView) {\n       animate(scope.current, { opacity: 1 })\n     }\n  }, [isInView])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n### [Exit animations](#exit-animations)\n\nIt's possible to compose your own exit animations when a component is removed using `useAnimate` in conjunction with `usePresence`.\n\n```\nimport { useAnimate, usePresence } from \"framer-motion\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n  const [scope, animate] = useAnimate()\n  \n  useEffect(() => {\n     if (isPresent) {\n       const enterAnimation = async () => {\n         await animate(scope.current, { opacity: 1 })\n         await animate(\"li\", { opacity: 1, x: 0 })\n       }\n       enterAnimation()\n\n     } else {\n       const exitAnimation = async () => {\n         await animate(\"li\", { opacity: 0, x: -100 })\n         await animate(scope.current, { opacity: 0 })\n         safeToRemove()\n       }\n       \n       exitAnimation()\n     }\n  }, [isPresent])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\nThis component can now be conditionally rendered as a child of `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? <Component key=\"dialog\" /> : null}\n</AnimatePresence>\n```\n\n`useAnimate` provides a way of using the `animate` [function](./animate) that is scoped to the elements within your component.\n\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\n\nIt provides a `scope` ref, and an `animate` function where every DOM selector is scoped to this ref.\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    // This \"li\" selector will only select children\n    // of the element that receives `scope`.\n    animate(\"li\", { opacity: 1 })\n  })\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nAdditionally, when the component calling `useAnimate` is removed, all animations started with its `animate` function will be cleaned up automatically.\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\n// Mini\nimport { useAnimate } from \"motion/react-mini\"\n\n// Hybrid\nimport { useAnimate } from \"motion/react\"\n```\n\n`useAnimate` returns two arguments, a `scope` ref and an `animate` [function](./animate).\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n```\n\nThis `scope` ref must be passed to either a regular HTML/SVG element or a `motion` component.\n\n```\nfunction Component({ children }) {\n  const [scope, animate] = useAnimate()\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nThis scoped `animate` function can now be used in effects and event handlers to animate elements.\n\nWe can either use the scoped element directly:\n\n```\nanimate(scope.current, { opacity: 1 }, { duration: 1 })\n```\n\nOr by passing it a selector:\n\n```\nanimate(\"li\", { backgroundColor: \"#000\" }, { ease: \"linear\" })\n```\n\nThis selector is `\"li\"`, but we're not selecting all `li` elements on the page, only those that are a child of the scoped element.\n\n### [Scroll-triggered animations](#scroll-triggered-animations)\n\nAnimations can be triggered when the scope scrolls into view by combining `useAnimate` with `useInView`.\n\n```\nimport { useAnimate, useInView } from \"motion/react\"\n\nfunction Component() {\n  const [scope, animate] = useAnimate()\n  const isInView = useInView(scope)\n  \n  useEffect(() => {\n     if (isInView) {\n       animate(scope.current, { opacity: 1 })\n     }\n  }, [isInView])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n### [Exit animations](#exit-animations)\n\nIt's possible to compose your own exit animations when a component is removed using `useAnimate` in conjunction with `usePresence`.\n\n```\nimport { useAnimate, usePresence } from \"framer-motion\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n  const [scope, animate] = useAnimate()\n  \n  useEffect(() => {\n     if (isPresent) {\n       const enterAnimation = async () => {\n         await animate(scope.current, { opacity: 1 })\n         await animate(\"li\", { opacity: 1, x: 0 })\n       }\n       enterAnimation()\n\n     } else {\n       const exitAnimation = async () => {\n         await animate(\"li\", { opacity: 0, x: -100 })\n         await animate(scope.current, { opacity: 0 })\n         safeToRemove()\n       }\n       \n       exitAnimation()\n     }\n  }, [isPresent])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\nThis component can now be conditionally rendered as a child of `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? <Component key=\"dialog\" /> : null}\n</AnimatePresence>\n```\n\n`useAnimate` provides a way of using the `animate` [function](./animate) that is scoped to the elements within your component.\n\nThis allows you to use manual animation controls, timelines, selectors scoped to your component, and automatic cleanup.\n\nIt provides a `scope` ref, and an `animate` function where every DOM selector is scoped to this ref.\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    // This \"li\" selector will only select children\n    // of the element that receives `scope`.\n    animate(\"li\", { opacity: 1 })\n  })\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nAdditionally, when the component calling `useAnimate` is removed, all animations started with its `animate` function will be cleaned up automatically.\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\n// Mini\nimport { useAnimate } from \"motion/react-mini\"\n\n// Hybrid\nimport { useAnimate } from \"motion/react\"\n```\n\n`useAnimate` returns two arguments, a `scope` ref and an `animate` [function](./animate).\n\n```\nfunction Component() {\n  const [scope, animate] = useAnimate()\n```\n\nThis `scope` ref must be passed to either a regular HTML/SVG element or a `motion` component.\n\n```\nfunction Component({ children }) {\n  const [scope, animate] = useAnimate()\n  \n  return <ul ref={scope}>{children}</ul>\n}\n```\n\nThis scoped `animate` function can now be used in effects and event handlers to animate elements.\n\nWe can either use the scoped element directly:\n\n```\nanimate(scope.current, { opacity: 1 }, { duration: 1 })\n```\n\nOr by passing it a selector:\n\n```\nanimate(\"li\", { backgroundColor: \"#000\" }, { ease: \"linear\" })\n```\n\nThis selector is `\"li\"`, but we're not selecting all `li` elements on the page, only those that are a child of the scoped element.\n\n### [Scroll-triggered animations](#scroll-triggered-animations)\n\nAnimations can be triggered when the scope scrolls into view by combining `useAnimate` with `useInView`.\n\n```\nimport { useAnimate, useInView } from \"motion/react\"\n\nfunction Component() {\n  const [scope, animate] = useAnimate()\n  const isInView = useInView(scope)\n  \n  useEffect(() => {\n     if (isInView) {\n       animate(scope.current, { opacity: 1 })\n     }\n  }, [isInView])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n### [Exit animations](#exit-animations)\n\nIt's possible to compose your own exit animations when a component is removed using `useAnimate` in conjunction with `usePresence`.\n\n```\nimport { useAnimate, usePresence } from \"framer-motion\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n  const [scope, animate] = useAnimate()\n  \n  useEffect(() => {\n     if (isPresent) {\n       const enterAnimation = async () => {\n         await animate(scope.current, { opacity: 1 })\n         await animate(\"li\", { opacity: 1, x: 0 })\n       }\n       enterAnimation()\n\n     } else {\n       const exitAnimation = async () => {\n         await animate(\"li\", { opacity: 0, x: -100 })\n         await animate(scope.current, { opacity: 0 })\n         safeToRemove()\n       }\n       \n       exitAnimation()\n     }\n  }, [isPresent])\n  \n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\nThis component can now be conditionally rendered as a child of `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? <Component key=\"dialog\" /> : null}\n</AnimatePresence>\n```\n\n## Related topics\n\n- [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n- [### Transitions\n\n  Control timing with duration/easing, springs, delay and stagger.](./react-transitions)\n\n  [### Transitions\n\n  Control timing with duration/easing, springs, delay and stagger.](./react-transitions)\n\n  [### Transitions\n\n  Control timing with duration/easing, springs, delay and stagger.](./react-transitions)\n- [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n\n  [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n\n  [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n\n- [### useAnimate examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useanimate)\n\n- [### useAnimate examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useanimate)\n\n- [### useAnimate examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useanimate)\n\nPrevious\n\n[Upgrade guide](./react-upgrade-guide)\n\nNext\n\n[useAnimationFrame](./react-use-animation-frame)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:20.634129+00:00",
  "content_length": 10792,
  "content_hash": "4f63a9a249e642b1"
}