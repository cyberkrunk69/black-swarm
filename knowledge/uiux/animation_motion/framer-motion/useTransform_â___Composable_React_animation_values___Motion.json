{
  "id": "framer-motion__motion_use-transform_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/use-transform/",
  "title": "useTransform \u00e2\u0080\u0094 Composable React animation values | Motion",
  "content": "useTransform\ncreates a new motion value that transforms the output of one or more motion values.\nconst\nx\n=\nuseMotionValue\n(\n1\n)\nconst\ny\n=\nuseMotionValue\n(\n1\n)\nconst\nz\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n+\ny\n.\nget\n(\n)\n)\n// z.get() === 2\nUsage\nImport from Motion:\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\nuseTransform\ncan be used in two ways: with a transform function and via value maps:\n// Transform function\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\n// Value mapping\nconst\ncolor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"00f\"\n]\n)\nTransform function\nA transform function is a normal function that returns a value.\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\nAny motion values read in this function via the\nget()\nmethod will be automatically subscribed to.\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\nconst\ndistance\n=\n100\nconst\ntime\n=\nuseTime\n(\n)\nconst\ny\n=\nuseTransform\n(\n(\n)\n=>\nMath\n.\nsin\n(\ntime\n.\nget\n(\n)\n/\n1000\n)\n*\ndistance\n)\nValue mapping\nuseTransform\ncan also map a single motion value from one range of values to another.\nTo illustrate, look at this\nx\nmotion value:\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nWe can use\nuseTransform\nto create a new motion value called\nopacity\n.\nconst\nopacity\n=\nuseTransform\n(\nx\n,\ninput\n,\noutput\n)\nBy defining an\ninput\nrange and an\noutput\nrange, we can define relationships like \"when\nx\nis\n0\n,\nopacity\nshould be\n1\n. When\nx\nis\n100\npixels either side,\nopacity\nshould be\n0\n\".\nconst\ninput\n=\n[\n-\n100\n,\n0\n,\n100\n]\nconst\noutput\n=\n[\n0\n,\n1\n,\n0\n]\nBoth ranges can be\nany length\nbut must be the\nsame length\nas each other.\nThe input range must always be a series of increasing or decreasing numbers.\nThe output range must be values all of the same type, but can be in any order. It can also be any\nvalue type that Motion can animate\n, like numbers, units, colors and other strings.\nconst\nbackgroundColor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"#00f\"\n]\n)\nBy setting\nclamp: false\n, the ranges will map perpetually. For instance, in this example we're saying \"for every\n100px\nscrolled, rotate another\n360deg\n\":\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\nrotate\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n100\n]\n,\n[\n0\n,\n360\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nOutput multiple values\nIt's common to map a single motion value and input range into multiple motion values.\nconst\nopacity\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.4\n]\n)\nconst\nscale\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.6\n]\n)\nconst\nfilter\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nThis can lead to some repetition, so\nuseTransform\nalso supports mapping to multiple motion values in a single call, by providing a named map:\nconst\n{\nopacity\n,\nscale\n,\nfilter\n}\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n{\nopacity\n:\n[\n1\n,\n0.4\n]\n,\nscale\n:\n[\n1\n,\n0.6\n]\n,\nfilter\n:\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n,\n}\n)\nOptions\nWith value mapping, we can set some additional options.\nclamp\nDefault:\ntrue\nIf\ntrue\n, will clamp output to within the provided range. If\nfalse\n, will carry on mapping even when the input falls outside the provided range.\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nuseEffect\n(\n(\n)\n=>\n{\nx\n.\nset\n(\n2\n)\nconsole\n.\nlog\n(\ny\n.\nget\n(\n)\n)\n// 2, input clamped\nconsole\n.\nlog\n(\nz\n.\nget\n(\n)\n)\n// 4\n}\n)\nease\nAn easing function, or array of easing functions, to ease the mixing between each value.\nThese must be JavaScript functions.\nimport\n{\ncubicBezier\n,\ncircOut\n}\nfrom\n\"motion\"\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\n// In your component\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncircOut\n}\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncubicBezier\n(\n0.17\n,\n0.67\n,\n0.83\n,\n0.67\n)\n}\n)\nmixer\nA function to use to mix between each pair of output values.\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between\n0\nand\n1\nand returns the mixed value.\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance\nFlubber\nfor morphing SVG paths.\nuseTransform\ncreates a new motion value that transforms the output of one or more motion values.\nconst\nx\n=\nuseMotionValue\n(\n1\n)\nconst\ny\n=\nuseMotionValue\n(\n1\n)\nconst\nz\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n+\ny\n.\nget\n(\n)\n)\n// z.get() === 2\nUsage\nImport from Motion:\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\nuseTransform\ncan be used in two ways: with a transform function and via value maps:\n// Transform function\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\n// Value mapping\nconst\ncolor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"00f\"\n]\n)\nTransform function\nA transform function is a normal function that returns a value.\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\nAny motion values read in this function via the\nget()\nmethod will be automatically subscribed to.\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\nconst\ndistance\n=\n100\nconst\ntime\n=\nuseTime\n(\n)\nconst\ny\n=\nuseTransform\n(\n(\n)\n=>\nMath\n.\nsin\n(\ntime\n.\nget\n(\n)\n/\n1000\n)\n*\ndistance\n)\nValue mapping\nuseTransform\ncan also map a single motion value from one range of values to another.\nTo illustrate, look at this\nx\nmotion value:\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nWe can use\nuseTransform\nto create a new motion value called\nopacity\n.\nconst\nopacity\n=\nuseTransform\n(\nx\n,\ninput\n,\noutput\n)\nBy defining an\ninput\nrange and an\noutput\nrange, we can define relationships like \"when\nx\nis\n0\n,\nopacity\nshould be\n1\n. When\nx\nis\n100\npixels either side,\nopacity\nshould be\n0\n\".\nconst\ninput\n=\n[\n-\n100\n,\n0\n,\n100\n]\nconst\noutput\n=\n[\n0\n,\n1\n,\n0\n]\nBoth ranges can be\nany length\nbut must be the\nsame length\nas each other.\nThe input range must always be a series of increasing or decreasing numbers.\nThe output range must be values all of the same type, but can be in any order. It can also be any\nvalue type that Motion can animate\n, like numbers, units, colors and other strings.\nconst\nbackgroundColor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"#00f\"\n]\n)\nBy setting\nclamp: false\n, the ranges will map perpetually. For instance, in this example we're saying \"for every\n100px\nscrolled, rotate another\n360deg\n\":\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\nrotate\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n100\n]\n,\n[\n0\n,\n360\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nOutput multiple values\nIt's common to map a single motion value and input range into multiple motion values.\nconst\nopacity\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.4\n]\n)\nconst\nscale\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.6\n]\n)\nconst\nfilter\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nThis can lead to some repetition, so\nuseTransform\nalso supports mapping to multiple motion values in a single call, by providing a named map:\nconst\n{\nopacity\n,\nscale\n,\nfilter\n}\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n{\nopacity\n:\n[\n1\n,\n0.4\n]\n,\nscale\n:\n[\n1\n,\n0.6\n]\n,\nfilter\n:\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n,\n}\n)\nOptions\nWith value mapping, we can set some additional options.\nclamp\nDefault:\ntrue\nIf\ntrue\n, will clamp output to within the provided range. If\nfalse\n, will carry on mapping even when the input falls outside the provided range.\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nuseEffect\n(\n(\n)\n=>\n{\nx\n.\nset\n(\n2\n)\nconsole\n.\nlog\n(\ny\n.\nget\n(\n)\n)\n// 2, input clamped\nconsole\n.\nlog\n(\nz\n.\nget\n(\n)\n)\n// 4\n}\n)\nease\nAn easing function, or array of easing functions, to ease the mixing between each value.\nThese must be JavaScript functions.\nimport\n{\ncubicBezier\n,\ncircOut\n}\nfrom\n\"motion\"\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\n// In your component\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncircOut\n}\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncubicBezier\n(\n0.17\n,\n0.67\n,\n0.83\n,\n0.67\n)\n}\n)\nmixer\nA function to use to mix between each pair of output values.\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between\n0\nand\n1\nand returns the mixed value.\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance\nFlubber\nfor morphing SVG paths.\nuseTransform\ncreates a new motion value that transforms the output of one or more motion values.\nconst\nx\n=\nuseMotionValue\n(\n1\n)\nconst\ny\n=\nuseMotionValue\n(\n1\n)\nconst\nz\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n+\ny\n.\nget\n(\n)\n)\n// z.get() === 2\nUsage\nImport from Motion:\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\nuseTransform\ncan be used in two ways: with a transform function and via value maps:\n// Transform function\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\n// Value mapping\nconst\ncolor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"00f\"\n]\n)\nTransform function\nA transform function is a normal function that returns a value.\nconst\ndoubledX\n=\nuseTransform\n(\n(\n)\n=>\nx\n.\nget\n(\n)\n*\n2\n)\nAny motion values read in this function via the\nget()\nmethod will be automatically subscribed to.\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\nconst\ndistance\n=\n100\nconst\ntime\n=\nuseTime\n(\n)\nconst\ny\n=\nuseTransform\n(\n(\n)\n=>\nMath\n.\nsin\n(\ntime\n.\nget\n(\n)\n/\n1000\n)\n*\ndistance\n)\nValue mapping\nuseTransform\ncan also map a single motion value from one range of values to another.\nTo illustrate, look at this\nx\nmotion value:\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nWe can use\nuseTransform\nto create a new motion value called\nopacity\n.\nconst\nopacity\n=\nuseTransform\n(\nx\n,\ninput\n,\noutput\n)\nBy defining an\ninput\nrange and an\noutput\nrange, we can define relationships like \"when\nx\nis\n0\n,\nopacity\nshould be\n1\n. When\nx\nis\n100\npixels either side,\nopacity\nshould be\n0\n\".\nconst\ninput\n=\n[\n-\n100\n,\n0\n,\n100\n]\nconst\noutput\n=\n[\n0\n,\n1\n,\n0\n]\nBoth ranges can be\nany length\nbut must be the\nsame length\nas each other.\nThe input range must always be a series of increasing or decreasing numbers.\nThe output range must be values all of the same type, but can be in any order. It can also be any\nvalue type that Motion can animate\n, like numbers, units, colors and other strings.\nconst\nbackgroundColor\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n100\n]\n,\n[\n\"#f00\"\n,\n\"#00f\"\n]\n)\nBy setting\nclamp: false\n, the ranges will map perpetually. For instance, in this example we're saying \"for every\n100px\nscrolled, rotate another\n360deg\n\":\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\nrotate\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n100\n]\n,\n[\n0\n,\n360\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nOutput multiple values\nIt's common to map a single motion value and input range into multiple motion values.\nconst\nopacity\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.4\n]\n)\nconst\nscale\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n1\n,\n0.6\n]\n)\nconst\nfilter\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nThis can lead to some repetition, so\nuseTransform\nalso supports mapping to multiple motion values in a single call, by providing a named map:\nconst\n{\nopacity\n,\nscale\n,\nfilter\n}\n=\nuseTransform\n(\noffset\n,\n[\n100\n,\n600\n]\n,\n{\nopacity\n:\n[\n1\n,\n0.4\n]\n,\nscale\n:\n[\n1\n,\n0.6\n]\n,\nfilter\n:\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n,\n}\n)\nOptions\nWith value mapping, we can set some additional options.\nclamp\nDefault:\ntrue\nIf\ntrue\n, will clamp output to within the provided range. If\nfalse\n, will carry on mapping even when the input falls outside the provided range.\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nclamp\n:\nfalse\n}\n)\nuseEffect\n(\n(\n)\n=>\n{\nx\n.\nset\n(\n2\n)\nconsole\n.\nlog\n(\ny\n.\nget\n(\n)\n)\n// 2, input clamped\nconsole\n.\nlog\n(\nz\n.\nget\n(\n)\n)\n// 4\n}\n)\nease\nAn easing function, or array of easing functions, to ease the mixing between each value.\nThese must be JavaScript functions.\nimport\n{\ncubicBezier\n,\ncircOut\n}\nfrom\n\"motion\"\nimport\n{\nuseTransform\n}\nfrom\n\"motion/react\"\n// In your component\nconst\ny\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncircOut\n}\n)\nconst\nz\n=\nuseTransform\n(\nx\n,\n[\n0\n,\n1\n]\n,\n[\n0\n,\n2\n]\n,\n{\nease\n:\ncubicBezier\n(\n0.17\n,\n0.67\n,\n0.83\n,\n0.67\n)\n}\n)\nmixer\nA function to use to mix between each pair of output values.\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between\n0\nand\n1\nand returns the mixed value.\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance\nFlubber\nfor morphing SVG paths.\nRelated topics\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nuseTransform examples\nSee all examples & tutorials, with full copy & paste source code.\nuseTransform examples\nSee all examples & tutorials, with full copy & paste source code.\nuseTransform examples\nSee all examples & tutorials, with full copy & paste source code.\nPrevious\nuseTime\nNext\nuseVelocity\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "`useTransform` creates a new motion value that transforms the output of one or more motion values.\n\n```\nconst x = useMotionValue(1)\nconst y = useMotionValue(1)\n\nconst z = useTransform(() => x.get() + y.get()) // z.get() === 2\n```\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\nimport { useTransform } from \"motion/react\"\n```\n\n`useTransform` can be used in two ways: with a transform function and via value maps:\n\n```\n// Transform function\nconst doubledX = useTransform(() => x.get() * 2)\n\n// Value mapping\nconst color = useTransform(x, [0, 100], [\"#f00\", \"00f\"])\n```\n\n### [Transform function](#transform-function)\n\nA transform function is a normal function that returns a value.\n\n```\nconst doubledX = useTransform(() => x.get() * 2)\n```\n\nAny motion values read in this function via the `get()` method will be automatically subscribed to.\n\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\n\n```\nconst distance = 100\nconst time = useTime()\nconst y = useTransform(() => Math.sin(time.get() / 1000) * distance)\n```\n\n### [Value mapping](#value-mapping)\n\n`useTransform` can also map a single motion value from one range of values to another.\n\nTo illustrate, look at this `x` motion value:\n\n```\nconst x = useMotionValue(0)\n```\n\nWe can use `useTransform` to create a new motion value called `opacity`.\n\n```\nconst opacity = useTransform(x, input, output)\n```\n\nBy defining an `input` range and an `output` range, we can define relationships like \"when `x` is `0`, `opacity` should be `1`. When `x` is `100` pixels either side, `opacity` should be `0`\".\n\n```\nconst input = [-100, 0, 100]\nconst output = [0, 1, 0]\n```\n\nBoth ranges can be **any length** but must be the **same length** as each other.\n\nThe input range must always be a series of increasing or decreasing numbers.\n\nThe output range must be values all of the same type, but can be in any order. It can also be any [value type that Motion can animate](./react-animation#animatable-values), like numbers, units, colors and other strings.\n\n```\nconst backgroundColor = useTransform(\n  x,\n  [0, 100],\n  [\"#f00\", \"#00f\"]\n)\n```\n\nBy setting `clamp: false`, the ranges will map perpetually. For instance, in this example we're saying \"for every `100px` scrolled, rotate another `360deg`\":\n\n```\nconst { scrollY } = useScroll()\nconst rotate = useTransform(\n  scrollY,\n  [0, 100],\n  [0, 360],\n  { clamp: false }\n)\n```\n\n#### [Output multiple values](#output-multiple-values)\n\nIt's common to map a single motion value and input range into multiple motion values.\n\n```\nconst opacity = useTransform(offset, [100, 600], [1, 0.4])\nconst scale = useTransform(offset, [100, 600], [1, 0.6])\nconst filter = useTransform(offset, [100, 600], [\"blur(0px)\", \"blur(10px)\"])\n```\n\nThis can lead to some repetition, so `useTransform` also supports mapping to multiple motion values in a single call, by providing a named map:\n\n```\nconst { opacity, scale, filter } = useTransform(offset, [100, 600], {\n  opacity: [1, 0.4],\n  scale: [1, 0.6],\n  filter: [\"blur(0px)\", \"blur(10px)\"],\n})\n```\n\n## [Options](#options)\n\nWith value mapping, we can set some additional options.\n\n### [`clamp`](#clamp)\n\n**Default:** `true`\n\nIf `true`, will clamp output to within the provided range. If `false`, will carry on mapping even when the input falls outside the provided range.\n\n```\nconst y = useTransform(x, [0, 1], [0, 2])\nconst z = useTransform(x, [0, 1], [0, 2], { clamp: false })\n\nuseEffect(() => {\n  x.set(2)\n  console.log(y.get()) // 2, input clamped\n  console.log(z.get()) // 4\n})\n```\n\n### [`ease`](#ease)\n\nAn easing function, or array of easing functions, to ease the mixing between each value.\n\nThese must be JavaScript functions.\n\n```\nimport { cubicBezier, circOut } from \"motion\"\nimport { useTransform } from \"motion/react\"\n\n// In your component\nconst y = useTransform(x, [0, 1], [0, 2], { ease: circOut })\n\nconst z = useTransform(\n  x,\n  [0, 1],\n  [0, 2],\n  { ease: cubicBezier(0.17, 0.67, 0.83, 0.67) }\n)\n```\n\n### [`mixer`](#mixer)\n\nA function to use to mix between each pair of output values.\n\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between `0` and `1` and returns the mixed value.\n\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance [Flubber](https://github.com/veltman/flubber) for morphing SVG paths.\n\n`useTransform` creates a new motion value that transforms the output of one or more motion values.\n\n```\nconst x = useMotionValue(1)\nconst y = useMotionValue(1)\n\nconst z = useTransform(() => x.get() + y.get()) // z.get() === 2\n```\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\nimport { useTransform } from \"motion/react\"\n```\n\n`useTransform` can be used in two ways: with a transform function and via value maps:\n\n```\n// Transform function\nconst doubledX = useTransform(() => x.get() * 2)\n\n// Value mapping\nconst color = useTransform(x, [0, 100], [\"#f00\", \"00f\"])\n```\n\n### [Transform function](#transform-function)\n\nA transform function is a normal function that returns a value.\n\n```\nconst doubledX = useTransform(() => x.get() * 2)\n```\n\nAny motion values read in this function via the `get()` method will be automatically subscribed to.\n\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\n\n```\nconst distance = 100\nconst time = useTime()\nconst y = useTransform(() => Math.sin(time.get() / 1000) * distance)\n```\n\n### [Value mapping](#value-mapping)\n\n`useTransform` can also map a single motion value from one range of values to another.\n\nTo illustrate, look at this `x` motion value:\n\n```\nconst x = useMotionValue(0)\n```\n\nWe can use `useTransform` to create a new motion value called `opacity`.\n\n```\nconst opacity = useTransform(x, input, output)\n```\n\nBy defining an `input` range and an `output` range, we can define relationships like \"when `x` is `0`, `opacity` should be `1`. When `x` is `100` pixels either side, `opacity` should be `0`\".\n\n```\nconst input = [-100, 0, 100]\nconst output = [0, 1, 0]\n```\n\nBoth ranges can be **any length** but must be the **same length** as each other.\n\nThe input range must always be a series of increasing or decreasing numbers.\n\nThe output range must be values all of the same type, but can be in any order. It can also be any [value type that Motion can animate](./react-animation#animatable-values), like numbers, units, colors and other strings.\n\n```\nconst backgroundColor = useTransform(\n  x,\n  [0, 100],\n  [\"#f00\", \"#00f\"]\n)\n```\n\nBy setting `clamp: false`, the ranges will map perpetually. For instance, in this example we're saying \"for every `100px` scrolled, rotate another `360deg`\":\n\n```\nconst { scrollY } = useScroll()\nconst rotate = useTransform(\n  scrollY,\n  [0, 100],\n  [0, 360],\n  { clamp: false }\n)\n```\n\n#### [Output multiple values](#output-multiple-values)\n\nIt's common to map a single motion value and input range into multiple motion values.\n\n```\nconst opacity = useTransform(offset, [100, 600], [1, 0.4])\nconst scale = useTransform(offset, [100, 600], [1, 0.6])\nconst filter = useTransform(offset, [100, 600], [\"blur(0px)\", \"blur(10px)\"])\n```\n\nThis can lead to some repetition, so `useTransform` also supports mapping to multiple motion values in a single call, by providing a named map:\n\n```\nconst { opacity, scale, filter } = useTransform(offset, [100, 600], {\n  opacity: [1, 0.4],\n  scale: [1, 0.6],\n  filter: [\"blur(0px)\", \"blur(10px)\"],\n})\n```\n\n## [Options](#options)\n\nWith value mapping, we can set some additional options.\n\n### [`clamp`](#clamp)\n\n**Default:** `true`\n\nIf `true`, will clamp output to within the provided range. If `false`, will carry on mapping even when the input falls outside the provided range.\n\n```\nconst y = useTransform(x, [0, 1], [0, 2])\nconst z = useTransform(x, [0, 1], [0, 2], { clamp: false })\n\nuseEffect(() => {\n  x.set(2)\n  console.log(y.get()) // 2, input clamped\n  console.log(z.get()) // 4\n})\n```\n\n### [`ease`](#ease)\n\nAn easing function, or array of easing functions, to ease the mixing between each value.\n\nThese must be JavaScript functions.\n\n```\nimport { cubicBezier, circOut } from \"motion\"\nimport { useTransform } from \"motion/react\"\n\n// In your component\nconst y = useTransform(x, [0, 1], [0, 2], { ease: circOut })\n\nconst z = useTransform(\n  x,\n  [0, 1],\n  [0, 2],\n  { ease: cubicBezier(0.17, 0.67, 0.83, 0.67) }\n)\n```\n\n### [`mixer`](#mixer)\n\nA function to use to mix between each pair of output values.\n\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between `0` and `1` and returns the mixed value.\n\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance [Flubber](https://github.com/veltman/flubber) for morphing SVG paths.\n\n`useTransform` creates a new motion value that transforms the output of one or more motion values.\n\n```\nconst x = useMotionValue(1)\nconst y = useMotionValue(1)\n\nconst z = useTransform(() => x.get() + y.get()) // z.get() === 2\n```\n\n## [Usage](#usage)\n\nImport from Motion:\n\n```\nimport { useTransform } from \"motion/react\"\n```\n\n`useTransform` can be used in two ways: with a transform function and via value maps:\n\n```\n// Transform function\nconst doubledX = useTransform(() => x.get() * 2)\n\n// Value mapping\nconst color = useTransform(x, [0, 100], [\"#f00\", \"00f\"])\n```\n\n### [Transform function](#transform-function)\n\nA transform function is a normal function that returns a value.\n\n```\nconst doubledX = useTransform(() => x.get() * 2)\n```\n\nAny motion values read in this function via the `get()` method will be automatically subscribed to.\n\nWhen these motion values change, the function will be run again on the next animation frame to calculate a new value.\n\n```\nconst distance = 100\nconst time = useTime()\nconst y = useTransform(() => Math.sin(time.get() / 1000) * distance)\n```\n\n### [Value mapping](#value-mapping)\n\n`useTransform` can also map a single motion value from one range of values to another.\n\nTo illustrate, look at this `x` motion value:\n\n```\nconst x = useMotionValue(0)\n```\n\nWe can use `useTransform` to create a new motion value called `opacity`.\n\n```\nconst opacity = useTransform(x, input, output)\n```\n\nBy defining an `input` range and an `output` range, we can define relationships like \"when `x` is `0`, `opacity` should be `1`. When `x` is `100` pixels either side, `opacity` should be `0`\".\n\n```\nconst input = [-100, 0, 100]\nconst output = [0, 1, 0]\n```\n\nBoth ranges can be **any length** but must be the **same length** as each other.\n\nThe input range must always be a series of increasing or decreasing numbers.\n\nThe output range must be values all of the same type, but can be in any order. It can also be any [value type that Motion can animate](./react-animation#animatable-values), like numbers, units, colors and other strings.\n\n```\nconst backgroundColor = useTransform(\n  x,\n  [0, 100],\n  [\"#f00\", \"#00f\"]\n)\n```\n\nBy setting `clamp: false`, the ranges will map perpetually. For instance, in this example we're saying \"for every `100px` scrolled, rotate another `360deg`\":\n\n```\nconst { scrollY } = useScroll()\nconst rotate = useTransform(\n  scrollY,\n  [0, 100],\n  [0, 360],\n  { clamp: false }\n)\n```\n\n#### [Output multiple values](#output-multiple-values)\n\nIt's common to map a single motion value and input range into multiple motion values.\n\n```\nconst opacity = useTransform(offset, [100, 600], [1, 0.4])\nconst scale = useTransform(offset, [100, 600], [1, 0.6])\nconst filter = useTransform(offset, [100, 600], [\"blur(0px)\", \"blur(10px)\"])\n```\n\nThis can lead to some repetition, so `useTransform` also supports mapping to multiple motion values in a single call, by providing a named map:\n\n```\nconst { opacity, scale, filter } = useTransform(offset, [100, 600], {\n  opacity: [1, 0.4],\n  scale: [1, 0.6],\n  filter: [\"blur(0px)\", \"blur(10px)\"],\n})\n```\n\n## [Options](#options)\n\nWith value mapping, we can set some additional options.\n\n### [`clamp`](#clamp)\n\n**Default:** `true`\n\nIf `true`, will clamp output to within the provided range. If `false`, will carry on mapping even when the input falls outside the provided range.\n\n```\nconst y = useTransform(x, [0, 1], [0, 2])\nconst z = useTransform(x, [0, 1], [0, 2], { clamp: false })\n\nuseEffect(() => {\n  x.set(2)\n  console.log(y.get()) // 2, input clamped\n  console.log(z.get()) // 4\n})\n```\n\n### [`ease`](#ease)\n\nAn easing function, or array of easing functions, to ease the mixing between each value.\n\nThese must be JavaScript functions.\n\n```\nimport { cubicBezier, circOut } from \"motion\"\nimport { useTransform } from \"motion/react\"\n\n// In your component\nconst y = useTransform(x, [0, 1], [0, 2], { ease: circOut })\n\nconst z = useTransform(\n  x,\n  [0, 1],\n  [0, 2],\n  { ease: cubicBezier(0.17, 0.67, 0.83, 0.67) }\n)\n```\n\n### [`mixer`](#mixer)\n\nA function to use to mix between each pair of output values.\n\nThis function will be called with each pair of output values and must return a new function, that accepts a progress value between `0` and `1` and returns the mixed value.\n\nThis can be used to inject more advanced mixers than Framer Motion's default, for instance [Flubber](https://github.com/veltman/flubber) for morphing SVG paths.\n\n## Related topics\n\n- [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n- [### useTransform examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=usetransform)\n\n- [### useTransform examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=usetransform)\n\n- [### useTransform examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=usetransform)\n\nPrevious\n\n[useTime](./react-use-time)\n\nNext\n\n[useVelocity](./react-use-velocity)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:30.370695+00:00",
  "content_length": 13510,
  "content_hash": "853feacf5e286b4c"
}