{
  "id": "framer-motion__motion_animation_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/animation/",
  "title": "React animation \u00e2\u0080\u0094 Transforms, keyframes & transitions | Motion",
  "content": "New to Motion? Start with the\nMotion for React quickstart guide\nMotion for React\nis a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\nWhat you'll learn\nHow to create your first animation with the\n<motion.div />\ncomponent.\nWhich values and elements you can animate.\nHow to customise your animations with transition options.\nHow to animate elements as they enter and exit the DOM.\nHow to orchestrate animations with variants.\nIf you haven't installed Motion already, hop over to the\nquick start guide for full instructions\n.\nAnimate with\n<motion />\nMost animations in Motion are created with the\n<motion />\ncomponent\n. Import it from\n\"motion/react\"\n:\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\nEvery HTML & SVG element can be defined with a\nmotion\ncomponent:\n<\nmotion\n.\ndiv\n/>\n<\nmotion\n.\na\nhref\n=\n\"#\"\n/>\n<\nmotion\n.\ncircle\ncx\n=\n{\n0\n}\n/>\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of\nspecial animation props\n.\nThe most common animation prop is\nanimate\n. When values passed to\nanimate\nchange, the element will automatically animate to that value.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nEnter animations\nWe can set initial values for an element with the\ninitial\nprop. So an element defined like this will fade in when it enters the DOM:\n<\nmotion\n.\narticle\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimatable values\nMotion can animate any CSS value\n, like\nopacity\n,\nfilter\netc.\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nfilter\n:\n\"blur(10px)\"\n}\n}\nanimate\n=\n{\n{\nfilter\n:\n\"none\"\n}\n}\n/>\nIt can even animate values that aren't normally animatable by browsers, like\nbackground-image\nor\nmask-image\n:\n<\nmotion\n.\nnav\ninitial\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\"\n}\n}\nanimate\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\"\n}\n}\n/>\nTransforms\nUnlike CSS, Motion can animate every transform axis independently.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nIt supports the following special transform values:\nTranslate:\nx\n,\ny\n,\nz\nScale:\nscale\n,\nscaleX\n,\nscaleY\nRotate:\nrotate\n,\nrotateX\n,\nrotateY\n,\nrotateZ\nSkew:\nskewX\n,\nskewY\nPerspective:\ntransformPerspective\nmotion\ncomponents also have enhanced\nstyle\nprops, allowing you to use these shorthands statically:\n<\nmotion\n.\nsection\nstyle\n=\n{\n{\nx\n:\n-\n20\n}\n}\n/>\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\ny\n:\n10\n}\n}\nanimate\n=\n{\n{\ny\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nscale\n:\n1.1\n}\n}\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting\ntransform\ndirectly.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\ntransform\n:\n\"translateX(-100px)\"\n}\n}\nanimate\n=\n{\n{\ntransform\n:\n\"translateX(0px)\"\n}\n}\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n/>\nFor SVG components,\nx\nand\ny\nattributes\ncan be set using\nattrX\nand\nattrY\n.\nLearn more about SVG animations in React\n.\nSupported value types\nMotion can animate any of the following value types:\nNumbers:\n0\n,\n100\netc.\nStrings containing numbers:\n\"0vh\"\n,\n\"10px\"\netc.\nColors: Hex, RGBA, HSLA.\nComplex strings containing multiple numbers and/or colors (like\nbox-shadow\n).\ndisplay: \"none\"/\"block\"\nand\nvisibility: \"hidden\"/\"visible\"\n.\nValue type conversion\nIn general, values can only be animated between two of the same type (i.e\n\"0px\"\nto\n\"100px\"\n).\nColors can be freely animated between hex, RGBA and HSLA types.\nAdditionally,\nx\n,\ny\n,\nwidth\n,\nheight\n,\ntop\n,\nleft\n,\nright\nand\nbottom\ncan animate between different value types.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nx\n:\n\"100%\"\n}\n}\nanimate\n=\n{\n{\nx\n:\n\"calc(100vw - 50%)\"\n}\n}\n/>\nIt's also possible to animate\nwidth\nand\nheight\nin to/out of\n\"auto\"\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nheight\n:\n0\n}\n}\nanimate\n=\n{\n{\nheight\n:\n\"auto\"\n}\n}\n/>\nIf animating\nheight: auto\nwhile also animating\ndisplay\nin to/out of\n\"none\"\n, replace this with\nvisibility\n\"hidden\"\nas elements with\ndisplay: none\ncan't be measured.\nTransform origin\ntransform-origin\nhas three shortcut values that can be set and animated individually:\noriginX\noriginY\noriginZ\nIf set as numbers,\noriginX\nand\nY\ndefault to a progress value between\n0\nand\n1\n.\noriginZ\ndefaults to pixels.\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\noriginX\n:\n0.5\n}\n}\n/>\nCSS variables\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\nAnimating CSS variables\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n<\nmotion\n.\nul\ninitial\n=\n{\n{\n'--rotate'\n:\n'0deg'\n}\n}\nanimate\n=\n{\n{\n'--rotate'\n:\n'360deg'\n}\n}\ntransition\n=\n{\n{\nduration\n:\n2\n,\nrepeat\n:\nInfinity\n}\n}\n>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n</\nmotion\n.\nul\n>\nAnimating the value of a CSS variable\nalways triggers paint\n, therefore it can be more performant to use\nMotionValue\ns\nto setup this kind of animation.\nLearn more about web animation performance\n.\nCSS variables as animation targets\nHTML\nmotion\ncomponents accept animation targets with CSS variables:\n<\nmotion\n.\nli\nanimate\n=\n{\n{\nbackgroundColor\n:\n\"var(--action-bg)\"\n}\n}\n/>\nTransitions\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\nFor instance, physical properties like\nx\nor\nscale\nare animated with spring physics, whereas values like\nopacity\nor\ncolor\nare animated with duration-based easing curves.\nHowever, you can define your own animations via\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"easeOut\"\n,\nduration\n:\n2\n}\n}\n/>\nA default\ntransition\ncan be set for many components with the\nMotionConfig\ncomponent\n:\n<\nMotionConfig\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n>\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nOr you can set a specific\ntransition\non any animation prop:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nwhileHover\n=\n{\n{\nopacity\n:\n0.7\n,\n// Specific transitions override default transitions\ntransition\n:\n{\nduration\n:\n0.3\n}\n}\n}\ntransition\n=\n{\n{\nduration\n:\n0.5\n}\n}\n/>\nEnter animations\nWhen a\nmotion\ncomponent is first created, it'll automatically animate to the values in\nanimate\nif they're different from those initially rendered, which you can either do via CSS or via\nthe\ninitial\nprop.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nscale\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n,\nscale\n:\n1\n}\n}\n/>\nYou can also disable the enter animation entirely by setting\ninitial={false}\n. This will make the element render with the values defined in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\ny\n:\n100\n}\n}\n/>\nExit animations\nMotion for React can animate elements as they're removed from the DOM.\nIn React, when a component is removed, it's usually removed instantly. Motion provides\nthe\nAnimatePresence\ncomponent\nwhich keeps elements in the DOM while they perform an animation defined with the\nexit\nprop.\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n(\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nKeyframes\nSo far, we've set animation props like\nanimate\nand\nexit\nto single values, like\nopacity: 0\n.\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a\nseries of values\n. In animation terms, these are called\nkeyframes\n.\nAll animation props can accept keyframe arrays:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\n0\n]\n}\n}\n/>\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\nIn the previous example, we explicitly set the initial value as\n0\n. But we can also say \"use the current value\" by setting the first value to\nnull\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\nnull\n,\n100\n,\n0\n]\n}\n}\n/>\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\nWildcard keyframes\nThis\nnull\nkeyframe is called a\nwildcard keyframe\n. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\nnull\n,\n0\n]\n}\n}\n// same as x: [0, 100, 100, 0] but easier to maintain\n/>\nKeyframe timing\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting\nthe\ntimes\noption\nvia\ntransition\n.\ntimes\nis an array of progress values between\n0\nand\n1\n, defining where in the animation each keyframe should be positioned.\n<\nmotion\n.\ncircle\ncx\n=\n{\n500\n}\nanimate\n=\n{\n{\ncx\n:\n[\nnull\n,\n100\n,\n200\n]\n,\ntransition\n:\n{\nduration\n:\n3\n,\ntimes\n:\n[\n0\n,\n0.2\n,\n1\n]\n}\n}\n}\n/>\n0\nis the start of the animation, and\n1\nis the end of the animation. Therefore,\n0.2\nplaces this keyframe somewhere towards the start of the animation.\nGesture animations\nMotion for React has animation props that can define how an element animates when it\nrecognises a gesture\n.\nSupported gestures are:\nwhileHover\nwhileTap\nwhileFocus\nwhileDrag\nwhileInView\nWhen a gesture starts, it animates to the values defined in\nwhile-\n, and then when the gesture ends it animates back to the values in\ninitial\nor\nanimate\n.\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nbackgroundColor\n:\n\"rgba(220, 220, 220, 1)\"\n}\n}\nwhileTap\n=\n{\n{\nbackgroundColor\n:\n\"rgba(255, 255, 255, 1)\"\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nThe\ncustom Cursor component\navailable in\nMotion+\ntakes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n<\nCursor\nmagnetic\n/>\nVariants\nSetting\nanimate\nas a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\nVariants are a set of named targets. These names can be anything.\nconst\nvariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nVariants are passed to\nmotion\ncomponents via the\nvariants\nprop:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\n/>\nThese variants can now be referred to by a label, wherever you can define an animation target:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\nYou can also define multiple variants via an array:\nanimate\n=\n{\n[\n\"visible\"\n,\n\"danger\"\n]\n}\nPropagation\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\nVariants will flow down through\nmotion\ncomponents. So in this example when the\nul\nenters the viewport, all of its children with a \"visible\" variant will also animate in:\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nconst\nitem\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n,\n}\nreturn\n(\n<\nmotion\n.\nul\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nvariants\n=\n{\nlist\n}\n>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n</\nmotion\n.\nul\n>\n)\nOrchestration\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new\ntransition\nprops\nwhen\nand\ndelayChildren\n.\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n,\ndelayChildren\n:\nstagger\n(\n0.3\n)\n,\n// Stagger children by .3 seconds\n}\n,\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n,\n}\n,\n}\n,\n}\nDynamic variants\nEach variant can be defined as a function that resolves when a variant is made active.\nconst\nvariants\n=\n{\nhidden\n:\n{\nopacity\n:\n0\n}\n,\nvisible\n:\n(\nindex\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\nindex\n*\n0.3\n}\n}\n)\n}\nThese functions are provided a single argument, which is passed via the\ncustom\nprop:\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n<\nmotion\n.\ndiv\ncustom\n=\n{\nindex\n}\nvariants\n=\n{\nvariants\n}\n/>\n)\nThis way, variants can be resolved differently for each animating element.\nAnimation controls\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\nThe\nuseAnimate\nhook\ncan be used for:\nAnimating any HTML/SVG element (not just\nmotion\ncomponents).\nComplex animation sequences.\nControlling animations with\ntime\n,\nspeed\n,\nplay()\n,\npause()\nand other playback controls.\nfunction\nMyComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\n[\n[\nscope\n.\ncurrent\n,\n{\nx\n:\n\"100%\"\n}\n]\n,\n[\n\"li\"\n,\n{\nopacity\n:\n1\n}\n]\n]\n)\ncontrols\n.\nspeed\n=\n0.8\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nAnimate content\nBy passing\na\nMotionValue\nas the child of a\nmotion\ncomponent, it will render its latest value in the HTML.\nimport\n{\nuseMotionValue\n,\nmotion\n,\nanimate\n}\nfrom\n\"motion/react\"\nfunction\nCounter\n(\n)\n{\nconst\ncount\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\ncount\n,\n100\n,\n{\nduration\n:\n5\n}\n)\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\npre\n>\n{\ncount\n}\n</\nmotion\n.\npre\n>\n}\nThis is more performant than setting React state as the\nmotion\ncomponent will set\ninnerHTML\ndirectly.\nIt's also possible to\nanimate numbers\nwith a ticking counter effect using the\nAnimateNumber\ncomponent in\nMotion+\nby passing them directly to the component:\n<\nAnimateNumber\n>\n{\nvalue\n}\n</\nAnimateNumber\n>\nNext\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its\nanimation props\n. However, there's much more to discover.\nMost of the examples on this page have used HTML elements, but Motion also has unique\nSVG animation\nfeatures, like its simple line drawing API.\nWe've also only covered time-based animations, but Motion also provides powerful\nscroll animation\nfeatures like\nuseScroll\nand\nwhileInView\n.\nIt also provides a powerful\nlayout animation\nengine, that can animate between any two layouts using performant transforms.\nFinally, there's also a whole\nFundamentals examples category\nthat covers all the basics of animating with Motion for React with live demos and copy-paste code.\nMotion for React\nis a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\nWhat you'll learn\nHow to create your first animation with the\n<motion.div />\ncomponent.\nWhich values and elements you can animate.\nHow to customise your animations with transition options.\nHow to animate elements as they enter and exit the DOM.\nHow to orchestrate animations with variants.\nIf you haven't installed Motion already, hop over to the\nquick start guide for full instructions\n.\nAnimate with\n<motion />\nMost animations in Motion are created with the\n<motion />\ncomponent\n. Import it from\n\"motion/react\"\n:\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\nEvery HTML & SVG element can be defined with a\nmotion\ncomponent:\n<\nmotion\n.\ndiv\n/>\n<\nmotion\n.\na\nhref\n=\n\"#\"\n/>\n<\nmotion\n.\ncircle\ncx\n=\n{\n0\n}\n/>\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of\nspecial animation props\n.\nThe most common animation prop is\nanimate\n. When values passed to\nanimate\nchange, the element will automatically animate to that value.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nEnter animations\nWe can set initial values for an element with the\ninitial\nprop. So an element defined like this will fade in when it enters the DOM:\n<\nmotion\n.\narticle\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimatable values\nMotion can animate any CSS value\n, like\nopacity\n,\nfilter\netc.\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nfilter\n:\n\"blur(10px)\"\n}\n}\nanimate\n=\n{\n{\nfilter\n:\n\"none\"\n}\n}\n/>\nIt can even animate values that aren't normally animatable by browsers, like\nbackground-image\nor\nmask-image\n:\n<\nmotion\n.\nnav\ninitial\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\"\n}\n}\nanimate\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\"\n}\n}\n/>\nTransforms\nUnlike CSS, Motion can animate every transform axis independently.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nIt supports the following special transform values:\nTranslate:\nx\n,\ny\n,\nz\nScale:\nscale\n,\nscaleX\n,\nscaleY\nRotate:\nrotate\n,\nrotateX\n,\nrotateY\n,\nrotateZ\nSkew:\nskewX\n,\nskewY\nPerspective:\ntransformPerspective\nmotion\ncomponents also have enhanced\nstyle\nprops, allowing you to use these shorthands statically:\n<\nmotion\n.\nsection\nstyle\n=\n{\n{\nx\n:\n-\n20\n}\n}\n/>\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\ny\n:\n10\n}\n}\nanimate\n=\n{\n{\ny\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nscale\n:\n1.1\n}\n}\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting\ntransform\ndirectly.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\ntransform\n:\n\"translateX(-100px)\"\n}\n}\nanimate\n=\n{\n{\ntransform\n:\n\"translateX(0px)\"\n}\n}\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n/>\nFor SVG components,\nx\nand\ny\nattributes\ncan be set using\nattrX\nand\nattrY\n.\nLearn more about SVG animations in React\n.\nSupported value types\nMotion can animate any of the following value types:\nNumbers:\n0\n,\n100\netc.\nStrings containing numbers:\n\"0vh\"\n,\n\"10px\"\netc.\nColors: Hex, RGBA, HSLA.\nComplex strings containing multiple numbers and/or colors (like\nbox-shadow\n).\ndisplay: \"none\"/\"block\"\nand\nvisibility: \"hidden\"/\"visible\"\n.\nValue type conversion\nIn general, values can only be animated between two of the same type (i.e\n\"0px\"\nto\n\"100px\"\n).\nColors can be freely animated between hex, RGBA and HSLA types.\nAdditionally,\nx\n,\ny\n,\nwidth\n,\nheight\n,\ntop\n,\nleft\n,\nright\nand\nbottom\ncan animate between different value types.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nx\n:\n\"100%\"\n}\n}\nanimate\n=\n{\n{\nx\n:\n\"calc(100vw - 50%)\"\n}\n}\n/>\nIt's also possible to animate\nwidth\nand\nheight\nin to/out of\n\"auto\"\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nheight\n:\n0\n}\n}\nanimate\n=\n{\n{\nheight\n:\n\"auto\"\n}\n}\n/>\nIf animating\nheight: auto\nwhile also animating\ndisplay\nin to/out of\n\"none\"\n, replace this with\nvisibility\n\"hidden\"\nas elements with\ndisplay: none\ncan't be measured.\nTransform origin\ntransform-origin\nhas three shortcut values that can be set and animated individually:\noriginX\noriginY\noriginZ\nIf set as numbers,\noriginX\nand\nY\ndefault to a progress value between\n0\nand\n1\n.\noriginZ\ndefaults to pixels.\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\noriginX\n:\n0.5\n}\n}\n/>\nCSS variables\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\nAnimating CSS variables\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n<\nmotion\n.\nul\ninitial\n=\n{\n{\n'--rotate'\n:\n'0deg'\n}\n}\nanimate\n=\n{\n{\n'--rotate'\n:\n'360deg'\n}\n}\ntransition\n=\n{\n{\nduration\n:\n2\n,\nrepeat\n:\nInfinity\n}\n}\n>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n</\nmotion\n.\nul\n>\nAnimating the value of a CSS variable\nalways triggers paint\n, therefore it can be more performant to use\nMotionValue\ns\nto setup this kind of animation.\nLearn more about web animation performance\n.\nCSS variables as animation targets\nHTML\nmotion\ncomponents accept animation targets with CSS variables:\n<\nmotion\n.\nli\nanimate\n=\n{\n{\nbackgroundColor\n:\n\"var(--action-bg)\"\n}\n}\n/>\nTransitions\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\nFor instance, physical properties like\nx\nor\nscale\nare animated with spring physics, whereas values like\nopacity\nor\ncolor\nare animated with duration-based easing curves.\nHowever, you can define your own animations via\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"easeOut\"\n,\nduration\n:\n2\n}\n}\n/>\nA default\ntransition\ncan be set for many components with the\nMotionConfig\ncomponent\n:\n<\nMotionConfig\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n>\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nOr you can set a specific\ntransition\non any animation prop:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nwhileHover\n=\n{\n{\nopacity\n:\n0.7\n,\n// Specific transitions override default transitions\ntransition\n:\n{\nduration\n:\n0.3\n}\n}\n}\ntransition\n=\n{\n{\nduration\n:\n0.5\n}\n}\n/>\nEnter animations\nWhen a\nmotion\ncomponent is first created, it'll automatically animate to the values in\nanimate\nif they're different from those initially rendered, which you can either do via CSS or via\nthe\ninitial\nprop.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nscale\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n,\nscale\n:\n1\n}\n}\n/>\nYou can also disable the enter animation entirely by setting\ninitial={false}\n. This will make the element render with the values defined in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\ny\n:\n100\n}\n}\n/>\nExit animations\nMotion for React can animate elements as they're removed from the DOM.\nIn React, when a component is removed, it's usually removed instantly. Motion provides\nthe\nAnimatePresence\ncomponent\nwhich keeps elements in the DOM while they perform an animation defined with the\nexit\nprop.\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n(\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nKeyframes\nSo far, we've set animation props like\nanimate\nand\nexit\nto single values, like\nopacity: 0\n.\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a\nseries of values\n. In animation terms, these are called\nkeyframes\n.\nAll animation props can accept keyframe arrays:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\n0\n]\n}\n}\n/>\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\nIn the previous example, we explicitly set the initial value as\n0\n. But we can also say \"use the current value\" by setting the first value to\nnull\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\nnull\n,\n100\n,\n0\n]\n}\n}\n/>\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\nWildcard keyframes\nThis\nnull\nkeyframe is called a\nwildcard keyframe\n. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\nnull\n,\n0\n]\n}\n}\n// same as x: [0, 100, 100, 0] but easier to maintain\n/>\nKeyframe timing\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting\nthe\ntimes\noption\nvia\ntransition\n.\ntimes\nis an array of progress values between\n0\nand\n1\n, defining where in the animation each keyframe should be positioned.\n<\nmotion\n.\ncircle\ncx\n=\n{\n500\n}\nanimate\n=\n{\n{\ncx\n:\n[\nnull\n,\n100\n,\n200\n]\n,\ntransition\n:\n{\nduration\n:\n3\n,\ntimes\n:\n[\n0\n,\n0.2\n,\n1\n]\n}\n}\n}\n/>\n0\nis the start of the animation, and\n1\nis the end of the animation. Therefore,\n0.2\nplaces this keyframe somewhere towards the start of the animation.\nGesture animations\nMotion for React has animation props that can define how an element animates when it\nrecognises a gesture\n.\nSupported gestures are:\nwhileHover\nwhileTap\nwhileFocus\nwhileDrag\nwhileInView\nWhen a gesture starts, it animates to the values defined in\nwhile-\n, and then when the gesture ends it animates back to the values in\ninitial\nor\nanimate\n.\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nbackgroundColor\n:\n\"rgba(220, 220, 220, 1)\"\n}\n}\nwhileTap\n=\n{\n{\nbackgroundColor\n:\n\"rgba(255, 255, 255, 1)\"\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nThe\ncustom Cursor component\navailable in\nMotion+\ntakes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n<\nCursor\nmagnetic\n/>\nVariants\nSetting\nanimate\nas a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\nVariants are a set of named targets. These names can be anything.\nconst\nvariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nVariants are passed to\nmotion\ncomponents via the\nvariants\nprop:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\n/>\nThese variants can now be referred to by a label, wherever you can define an animation target:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\nYou can also define multiple variants via an array:\nanimate\n=\n{\n[\n\"visible\"\n,\n\"danger\"\n]\n}\nPropagation\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\nVariants will flow down through\nmotion\ncomponents. So in this example when the\nul\nenters the viewport, all of its children with a \"visible\" variant will also animate in:\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nconst\nitem\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n,\n}\nreturn\n(\n<\nmotion\n.\nul\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nvariants\n=\n{\nlist\n}\n>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n</\nmotion\n.\nul\n>\n)\nOrchestration\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new\ntransition\nprops\nwhen\nand\ndelayChildren\n.\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n,\ndelayChildren\n:\nstagger\n(\n0.3\n)\n,\n// Stagger children by .3 seconds\n}\n,\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n,\n}\n,\n}\n,\n}\nDynamic variants\nEach variant can be defined as a function that resolves when a variant is made active.\nconst\nvariants\n=\n{\nhidden\n:\n{\nopacity\n:\n0\n}\n,\nvisible\n:\n(\nindex\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\nindex\n*\n0.3\n}\n}\n)\n}\nThese functions are provided a single argument, which is passed via the\ncustom\nprop:\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n<\nmotion\n.\ndiv\ncustom\n=\n{\nindex\n}\nvariants\n=\n{\nvariants\n}\n/>\n)\nThis way, variants can be resolved differently for each animating element.\nAnimation controls\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\nThe\nuseAnimate\nhook\ncan be used for:\nAnimating any HTML/SVG element (not just\nmotion\ncomponents).\nComplex animation sequences.\nControlling animations with\ntime\n,\nspeed\n,\nplay()\n,\npause()\nand other playback controls.\nfunction\nMyComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\n[\n[\nscope\n.\ncurrent\n,\n{\nx\n:\n\"100%\"\n}\n]\n,\n[\n\"li\"\n,\n{\nopacity\n:\n1\n}\n]\n]\n)\ncontrols\n.\nspeed\n=\n0.8\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nAnimate content\nBy passing\na\nMotionValue\nas the child of a\nmotion\ncomponent, it will render its latest value in the HTML.\nimport\n{\nuseMotionValue\n,\nmotion\n,\nanimate\n}\nfrom\n\"motion/react\"\nfunction\nCounter\n(\n)\n{\nconst\ncount\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\ncount\n,\n100\n,\n{\nduration\n:\n5\n}\n)\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\npre\n>\n{\ncount\n}\n</\nmotion\n.\npre\n>\n}\nThis is more performant than setting React state as the\nmotion\ncomponent will set\ninnerHTML\ndirectly.\nIt's also possible to\nanimate numbers\nwith a ticking counter effect using the\nAnimateNumber\ncomponent in\nMotion+\nby passing them directly to the component:\n<\nAnimateNumber\n>\n{\nvalue\n}\n</\nAnimateNumber\n>\nNext\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its\nanimation props\n. However, there's much more to discover.\nMost of the examples on this page have used HTML elements, but Motion also has unique\nSVG animation\nfeatures, like its simple line drawing API.\nWe've also only covered time-based animations, but Motion also provides powerful\nscroll animation\nfeatures like\nuseScroll\nand\nwhileInView\n.\nIt also provides a powerful\nlayout animation\nengine, that can animate between any two layouts using performant transforms.\nFinally, there's also a whole\nFundamentals examples category\nthat covers all the basics of animating with Motion for React with live demos and copy-paste code.\nMotion for React\nis a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\nWhat you'll learn\nHow to create your first animation with the\n<motion.div />\ncomponent.\nWhich values and elements you can animate.\nHow to customise your animations with transition options.\nHow to animate elements as they enter and exit the DOM.\nHow to orchestrate animations with variants.\nIf you haven't installed Motion already, hop over to the\nquick start guide for full instructions\n.\nAnimate with\n<motion />\nMost animations in Motion are created with the\n<motion />\ncomponent\n. Import it from\n\"motion/react\"\n:\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\nEvery HTML & SVG element can be defined with a\nmotion\ncomponent:\n<\nmotion\n.\ndiv\n/>\n<\nmotion\n.\na\nhref\n=\n\"#\"\n/>\n<\nmotion\n.\ncircle\ncx\n=\n{\n0\n}\n/>\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of\nspecial animation props\n.\nThe most common animation prop is\nanimate\n. When values passed to\nanimate\nchange, the element will automatically animate to that value.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nEnter animations\nWe can set initial values for an element with the\ninitial\nprop. So an element defined like this will fade in when it enters the DOM:\n<\nmotion\n.\narticle\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimatable values\nMotion can animate any CSS value\n, like\nopacity\n,\nfilter\netc.\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nfilter\n:\n\"blur(10px)\"\n}\n}\nanimate\n=\n{\n{\nfilter\n:\n\"none\"\n}\n}\n/>\nIt can even animate values that aren't normally animatable by browsers, like\nbackground-image\nor\nmask-image\n:\n<\nmotion\n.\nnav\ninitial\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\"\n}\n}\nanimate\n=\n{\n{\nmaskImage\n:\n\"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\"\n}\n}\n/>\nTransforms\nUnlike CSS, Motion can animate every transform axis independently.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nIt supports the following special transform values:\nTranslate:\nx\n,\ny\n,\nz\nScale:\nscale\n,\nscaleX\n,\nscaleY\nRotate:\nrotate\n,\nrotateX\n,\nrotateY\n,\nrotateZ\nSkew:\nskewX\n,\nskewY\nPerspective:\ntransformPerspective\nmotion\ncomponents also have enhanced\nstyle\nprops, allowing you to use these shorthands statically:\n<\nmotion\n.\nsection\nstyle\n=\n{\n{\nx\n:\n-\n20\n}\n}\n/>\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\ny\n:\n10\n}\n}\nanimate\n=\n{\n{\ny\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nscale\n:\n1.1\n}\n}\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting\ntransform\ndirectly.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\ntransform\n:\n\"translateX(-100px)\"\n}\n}\nanimate\n=\n{\n{\ntransform\n:\n\"translateX(0px)\"\n}\n}\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n/>\nFor SVG components,\nx\nand\ny\nattributes\ncan be set using\nattrX\nand\nattrY\n.\nLearn more about SVG animations in React\n.\nSupported value types\nMotion can animate any of the following value types:\nNumbers:\n0\n,\n100\netc.\nStrings containing numbers:\n\"0vh\"\n,\n\"10px\"\netc.\nColors: Hex, RGBA, HSLA.\nComplex strings containing multiple numbers and/or colors (like\nbox-shadow\n).\ndisplay: \"none\"/\"block\"\nand\nvisibility: \"hidden\"/\"visible\"\n.\nValue type conversion\nIn general, values can only be animated between two of the same type (i.e\n\"0px\"\nto\n\"100px\"\n).\nColors can be freely animated between hex, RGBA and HSLA types.\nAdditionally,\nx\n,\ny\n,\nwidth\n,\nheight\n,\ntop\n,\nleft\n,\nright\nand\nbottom\ncan animate between different value types.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nx\n:\n\"100%\"\n}\n}\nanimate\n=\n{\n{\nx\n:\n\"calc(100vw - 50%)\"\n}\n}\n/>\nIt's also possible to animate\nwidth\nand\nheight\nin to/out of\n\"auto\"\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nheight\n:\n0\n}\n}\nanimate\n=\n{\n{\nheight\n:\n\"auto\"\n}\n}\n/>\nIf animating\nheight: auto\nwhile also animating\ndisplay\nin to/out of\n\"none\"\n, replace this with\nvisibility\n\"hidden\"\nas elements with\ndisplay: none\ncan't be measured.\nTransform origin\ntransform-origin\nhas three shortcut values that can be set and animated individually:\noriginX\noriginY\noriginZ\nIf set as numbers,\noriginX\nand\nY\ndefault to a progress value between\n0\nand\n1\n.\noriginZ\ndefaults to pixels.\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\noriginX\n:\n0.5\n}\n}\n/>\nCSS variables\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\nAnimating CSS variables\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n<\nmotion\n.\nul\ninitial\n=\n{\n{\n'--rotate'\n:\n'0deg'\n}\n}\nanimate\n=\n{\n{\n'--rotate'\n:\n'360deg'\n}\n}\ntransition\n=\n{\n{\nduration\n:\n2\n,\nrepeat\n:\nInfinity\n}\n}\n>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n<\nli\nstyle\n=\n{\n{\ntransform\n:\n'rotate(var(--rotate))'\n}\n}\n/>\n</\nmotion\n.\nul\n>\nAnimating the value of a CSS variable\nalways triggers paint\n, therefore it can be more performant to use\nMotionValue\ns\nto setup this kind of animation.\nLearn more about web animation performance\n.\nCSS variables as animation targets\nHTML\nmotion\ncomponents accept animation targets with CSS variables:\n<\nmotion\n.\nli\nanimate\n=\n{\n{\nbackgroundColor\n:\n\"var(--action-bg)\"\n}\n}\n/>\nTransitions\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\nFor instance, physical properties like\nx\nor\nscale\nare animated with spring physics, whereas values like\nopacity\nor\ncolor\nare animated with duration-based easing curves.\nHowever, you can define your own animations via\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"easeOut\"\n,\nduration\n:\n2\n}\n}\n/>\nA default\ntransition\ncan be set for many components with the\nMotionConfig\ncomponent\n:\n<\nMotionConfig\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n>\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nOr you can set a specific\ntransition\non any animation prop:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nwhileHover\n=\n{\n{\nopacity\n:\n0.7\n,\n// Specific transitions override default transitions\ntransition\n:\n{\nduration\n:\n0.3\n}\n}\n}\ntransition\n=\n{\n{\nduration\n:\n0.5\n}\n}\n/>\nEnter animations\nWhen a\nmotion\ncomponent is first created, it'll automatically animate to the values in\nanimate\nif they're different from those initially rendered, which you can either do via CSS or via\nthe\ninitial\nprop.\n<\nmotion\n.\nli\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nscale\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n,\nscale\n:\n1\n}\n}\n/>\nYou can also disable the enter animation entirely by setting\ninitial={false}\n. This will make the element render with the values defined in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\ny\n:\n100\n}\n}\n/>\nExit animations\nMotion for React can animate elements as they're removed from the DOM.\nIn React, when a component is removed, it's usually removed instantly. Motion provides\nthe\nAnimatePresence\ncomponent\nwhich keeps elements in the DOM while they perform an animation defined with the\nexit\nprop.\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n(\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nKeyframes\nSo far, we've set animation props like\nanimate\nand\nexit\nto single values, like\nopacity: 0\n.\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a\nseries of values\n. In animation terms, these are called\nkeyframes\n.\nAll animation props can accept keyframe arrays:\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\n0\n]\n}\n}\n/>\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\nIn the previous example, we explicitly set the initial value as\n0\n. But we can also say \"use the current value\" by setting the first value to\nnull\n.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\nnull\n,\n100\n,\n0\n]\n}\n}\n/>\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\nWildcard keyframes\nThis\nnull\nkeyframe is called a\nwildcard keyframe\n. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n<\nmotion\n.\ndiv\nanimate\n=\n{\n{\nx\n:\n[\n0\n,\n100\n,\nnull\n,\n0\n]\n}\n}\n// same as x: [0, 100, 100, 0] but easier to maintain\n/>\nKeyframe timing\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting\nthe\ntimes\noption\nvia\ntransition\n.\ntimes\nis an array of progress values between\n0\nand\n1\n, defining where in the animation each keyframe should be positioned.\n<\nmotion\n.\ncircle\ncx\n=\n{\n500\n}\nanimate\n=\n{\n{\ncx\n:\n[\nnull\n,\n100\n,\n200\n]\n,\ntransition\n:\n{\nduration\n:\n3\n,\ntimes\n:\n[\n0\n,\n0.2\n,\n1\n]\n}\n}\n}\n/>\n0\nis the start of the animation, and\n1\nis the end of the animation. Therefore,\n0.2\nplaces this keyframe somewhere towards the start of the animation.\nGesture animations\nMotion for React has animation props that can define how an element animates when it\nrecognises a gesture\n.\nSupported gestures are:\nwhileHover\nwhileTap\nwhileFocus\nwhileDrag\nwhileInView\nWhen a gesture starts, it animates to the values defined in\nwhile-\n, and then when the gesture ends it animates back to the values in\ninitial\nor\nanimate\n.\n<\nmotion\n.\nbutton\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileHover\n=\n{\n{\nbackgroundColor\n:\n\"rgba(220, 220, 220, 1)\"\n}\n}\nwhileTap\n=\n{\n{\nbackgroundColor\n:\n\"rgba(255, 255, 255, 1)\"\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nThe\ncustom Cursor component\navailable in\nMotion+\ntakes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n<\nCursor\nmagnetic\n/>\nVariants\nSetting\nanimate\nas a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\nVariants are a set of named targets. These names can be anything.\nconst\nvariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nVariants are passed to\nmotion\ncomponents via the\nvariants\nprop:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\n/>\nThese variants can now be referred to by a label, wherever you can define an animation target:\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\nYou can also define multiple variants via an array:\nanimate\n=\n{\n[\n\"visible\"\n,\n\"danger\"\n]\n}\nPropagation\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\nVariants will flow down through\nmotion\ncomponents. So in this example when the\nul\nenters the viewport, all of its children with a \"visible\" variant will also animate in:\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n}\n,\n}\nconst\nitem\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\nx\n:\n-\n100\n}\n,\n}\nreturn\n(\n<\nmotion\n.\nul\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nvariants\n=\n{\nlist\n}\n>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n<\nmotion\n.\nli\nvariants\n=\n{\nitem\n}\n/>\n</\nmotion\n.\nul\n>\n)\nOrchestration\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new\ntransition\nprops\nwhen\nand\ndelayChildren\n.\nconst\nlist\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n,\ndelayChildren\n:\nstagger\n(\n0.3\n)\n,\n// Stagger children by .3 seconds\n}\n,\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n,\n}\n,\n}\n,\n}\nDynamic variants\nEach variant can be defined as a function that resolves when a variant is made active.\nconst\nvariants\n=\n{\nhidden\n:\n{\nopacity\n:\n0\n}\n,\nvisible\n:\n(\nindex\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\nindex\n*\n0.3\n}\n}\n)\n}\nThese functions are provided a single argument, which is passed via the\ncustom\nprop:\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n<\nmotion\n.\ndiv\ncustom\n=\n{\nindex\n}\nvariants\n=\n{\nvariants\n}\n/>\n)\nThis way, variants can be resolved differently for each animating element.\nAnimation controls\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\nThe\nuseAnimate\nhook\ncan be used for:\nAnimating any HTML/SVG element (not just\nmotion\ncomponents).\nComplex animation sequences.\nControlling animations with\ntime\n,\nspeed\n,\nplay()\n,\npause()\nand other playback controls.\nfunction\nMyComponent\n(\n)\n{\nconst\n[\nscope\n,\nanimate\n]\n=\nuseAnimate\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\n[\n[\nscope\n.\ncurrent\n,\n{\nx\n:\n\"100%\"\n}\n]\n,\n[\n\"li\"\n,\n{\nopacity\n:\n1\n}\n]\n]\n)\ncontrols\n.\nspeed\n=\n0.8\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n(\n<\nul\nref\n=\n{\nscope\n}\n>\n<\nli\n/>\n<\nli\n/>\n<\nli\n/>\n</\nul\n>\n)\n}\nAnimate content\nBy passing\na\nMotionValue\nas the child of a\nmotion\ncomponent, it will render its latest value in the HTML.\nimport\n{\nuseMotionValue\n,\nmotion\n,\nanimate\n}\nfrom\n\"motion/react\"\nfunction\nCounter\n(\n)\n{\nconst\ncount\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\nconst\ncontrols\n=\nanimate\n(\ncount\n,\n100\n,\n{\nduration\n:\n5\n}\n)\nreturn\n(\n)\n=>\ncontrols\n.\nstop\n(\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\npre\n>\n{\ncount\n}\n</\nmotion\n.\npre\n>\n}\nThis is more performant than setting React state as the\nmotion\ncomponent will set\ninnerHTML\ndirectly.\nIt's also possible to\nanimate numbers\nwith a ticking counter effect using the\nAnimateNumber\ncomponent in\nMotion+\nby passing them directly to the component:\n<\nAnimateNumber\n>\n{\nvalue\n}\n</\nAnimateNumber\n>\nNext\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its\nanimation props\n. However, there's much more to discover.\nMost of the examples on this page have used HTML elements, but Motion also has unique\nSVG animation\nfeatures, like its simple line drawing API.\nWe've also only covered time-based animations, but Motion also provides powerful\nscroll animation\nfeatures like\nuseScroll\nand\nwhileInView\n.\nIt also provides a powerful\nlayout animation\nengine, that can animate between any two layouts using performant transforms.\nFinally, there's also a whole\nFundamentals examples category\nthat covers all the basics of animating with Motion for React with live demos and copy-paste code.\nRelated topics\nAI Context\nTurn your LLM into an animation expert with access to the latest Motion documentation & examples.\nAI Context\nTurn your LLM into an animation expert with access to the latest Motion documentation & examples.\nAI Context\nTurn your LLM into an animation expert with access to the latest Motion documentation & examples.\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nTutorial\nTransition options\nAn example of setting transition options in Motion for React.\nTutorial\nTransition options\nAn example of setting transition options in Motion for React.\nTutorial\nTransition options\nAn example of setting transition options in Motion for React.\nPrevious\nGet started with Motion for React\nNext\nLayout animation\nMotion+\nMotion+\nMotion+\nReady for the next step?\nLearn more by unlocking the full vault of Motion+ pre-built animation examples. Ready to copy-paste directly into your project.\nSee Motion+ features & pricing\nSee Motion+ features & pricing\nSee Motion+ features & pricing\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "New to Motion? Start with the [Motion for React quickstart guide](./react)\n\n[Motion for React](../) is a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\n\n## [What you'll learn](#what-you-ll-learn)\n\n- How to create your first animation with the `<motion.div />` component.\n- Which values and elements you can animate.\n- How to customise your animations with transition options.\n- How to animate elements as they enter and exit the DOM.\n- How to orchestrate animations with variants.\n\nIf you haven't installed Motion already, hop over to the [quick start guide for full instructions](./react).\n\n## [Animate with `<motion />`](#animate-with-motion)\n\nMost animations in Motion are created with the`<motion />` [component](./react-motion-component). Import it from `\"motion/react\"`:\n\n```\nimport { motion } from \"motion/react\"\n```\n\nEvery HTML & SVG element can be defined with a `motion` component:\n\n```\n<motion.div />\n```\n\n```\n<motion.a href=\"#\" />\n```\n\n```\n<motion.circle cx={0} />\n```\n\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of [special animation props](./react-motion-component#props).\n\nThe most common animation prop is `animate`. When values passed to `animate` change, the element will automatically animate to that value.\n\n```\n<motion.div animate={{ opacity: 1 }} />\n```\n\n### [Enter animations](#enter-animations)\n\nWe can set initial values for an element with the `initial` prop. So an element defined like this will fade in when it enters the DOM:\n\n```\n<motion.article\n  initial={{ opacity: 0 }}\n  animate={{ opacity: 1 }}\n/>\n```\n\n## [Animatable values](#animatable-values)\n\n**Motion can animate any CSS value**, like `opacity`, `filter` etc.\n\n```\n<motion.section\n  initial={{ filter: \"blur(10px)\" }}\n  animate={{ filter: \"none\" }}\n/>\n```\n\nIt can even animate values that aren't normally animatable by browsers, like `background-image` or `mask-image`:\n\n```\n<motion.nav\n  initial={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\" }}\n  animate={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\" }}\n/>\n```\n\n### [Transforms](#transforms)\n\nUnlike CSS, Motion can animate every transform axis independently.\n\n```\n<motion.div animate={{ x: 100 }} />\n```\n\nIt supports the following special transform values:\n\n- Translate: `x`, `y`, `z`\n- Scale: `scale`, `scaleX`, `scaleY`\n- Rotate: `rotate`, `rotateX`, `rotateY`, `rotateZ`\n- Skew: `skewX`, `skewY`\n- Perspective: `transformPerspective`\n\n`motion` components also have enhanced `style` props, allowing you to use these shorthands statically:\n\n```\n<motion.section style={{ x: -20 }} />\n```\n\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n\n```\n<motion.button\n  initial={{ y: 10 }}\n  animate={{ y: 0 }}\n  whileHover={{ scale: 1.1 }}\n  whileTap={{ scale: 0.9 }}\n/>\n```\n\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting `transform` directly.\n\n```\n<motion.li\n  initial={{ transform: \"translateX(-100px)\" }}\n  animate={{ transform: \"translateX(0px)\" }}\n  transition={{ type: \"spring\" }}\n/>\n```\n\nFor SVG components, `x` and `y` **attributes** can be set using `attrX` and `attrY`. [Learn more about SVG animations in React](./react-svg-animation).\n\n### [Supported value types](#supported-value-types)\n\nMotion can animate any of the following value types:\n\n- Numbers: `0`, `100` etc.\n- Strings containing numbers: `\"0vh\"`, `\"10px\"` etc.\n- Colors: Hex, RGBA, HSLA.\n- Complex strings containing multiple numbers and/or colors (like `box-shadow`).\n- `display: \"none\"/\"block\"` and `visibility: \"hidden\"/\"visible\"`.\n\n### [Value type conversion](#value-type-conversion)\n\nIn general, values can only be animated between two of the same type (i.e `\"0px\"` to `\"100px\"`).\n\nColors can be freely animated between hex, RGBA and HSLA types.\n\nAdditionally, `x`, `y`, `width`, `height`, `top`, `left`, `right` and `bottom` can animate between different value types.\n\n```\n<motion.div\n  initial={{ x: \"100%\" }}\n  animate={{ x: \"calc(100vw - 50%)\" }}\n/>\n```\n\nIt's also possible to animate `width` and `height` in to/out of `\"auto\"`.\n\n```\n<motion.div\n  initial={{ height: 0 }}\n  animate={{ height: \"auto\" }}\n/>\n```\n\nIf animating `height: auto` while also animating `display` in to/out of `\"none\"`, replace this with `visibility` `\"hidden\"` as elements with `display: none` can't be measured.\n\n### [Transform origin](#transform-origin)\n\n`transform-origin` has three shortcut values that can be set and animated individually:\n\n- `originX`\n- `originY`\n- `originZ`\n\nIf set as numbers, `originX` and `Y` default to a progress value between `0` and `1`. `originZ` defaults to pixels.\n\n```\n<motion.div style={{ originX: 0.5 }} />\n```\n\n### [CSS variables](#css-variables)\n\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\n\n#### [Animating CSS variables](#animating-css-variables)\n\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n\n```\n<motion.ul\n  initial={{ '--rotate': '0deg' }}\n  animate={{ '--rotate': '360deg' }}\n  transition={{ duration: 2, repeat: Infinity }}\n>\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n</motion.ul>\n```\n\nAnimating the value of a CSS variable **always triggers paint**, therefore it can be more performant to use `MotionValue`[s](./react-motion-value) to setup this kind of animation. [Learn more about web animation performance](../magazine/web-animation-performance-tier-list).\n\n### [CSS variables as animation targets](#css-variables-as-animation-targets)\n\nHTML `motion` components accept animation targets with CSS variables:\n\n```\n<motion.li animate={{ backgroundColor: \"var(--action-bg)\" }} />\n```\n\n## [Transitions](#transitions)\n\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\n\nFor instance, physical properties like `x` or `scale` are animated with spring physics, whereas values like `opacity` or `color` are animated with duration-based easing curves.\n\nHowever, you can define your own animations via [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div\n  animate={{ x: 100 }}\n  transition={{ ease: \"easeOut\", duration: 2 }}\n/>\n```\n\nA default `transition` can be set for many components with the `MotionConfig` [component](./react-motion-config):\n\n```\n<MotionConfig transition={{ duration: 0.3 }}>\n  <motion.div animate={{ opacity: 1 }} />\n```\n\nOr you can set a specific `transition` on any animation prop:\n\n```\n<motion.div\n  animate={{ opacity: 1 }}\n  whileHover={{\n    opacity: 0.7,\n    // Specific transitions override default transitions\n    transition: { duration: 0.3 }\n  }}\n  transition={{ duration: 0.5 }}\n/>\n```\n\n## [Enter animations](#enter-animations-1)\n\nWhen a `motion` component is first created, it'll automatically animate to the values in `animate` if they're different from those initially rendered, which you can either do via CSS or via [the](./react-motion-value) `initial` [prop.](./react-motion-value)\n\n```\n<motion.li\n  initial={{ opacity: 0, scale: 0 }}\n  animate={{ opacity: 1, scale: 1 }}\n/>\n```\n\nYou can also disable the enter animation entirely by setting `initial={false}`. This will make the element render with the values defined in `animate`.\n\n```\n<motion.div initial={false} animate={{ y: 100 }} />\n```\n\n## [Exit animations](#exit-animations)\n\nMotion for React can animate elements as they're removed from the DOM.\n\nIn React, when a component is removed, it's usually removed instantly. Motion provides [the](./react-animate-presence) `AnimatePresence` [component](./react-animate-presence) which keeps elements in the DOM while they perform an animation defined with the `exit` prop.\n\n```\n<AnimatePresence>\n  {isVisible && (\n    <motion.div\n      key=\"modal\"\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n    />\n  )}\n</AnimatePresence>\n```\n\n## [Keyframes](#keyframes)\n\nSo far, we've set animation props like `animate` and `exit` to single values, like `opacity: 0`.\n\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a **series of values**. In animation terms, these are called **keyframes**.\n\nAll animation props can accept keyframe arrays:\n\n```\n<motion.div animate={{ x: [0, 100, 0] }} />\n```\n\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\n\nIn the previous example, we explicitly set the initial value as `0`. But we can also say \"use the current value\" by setting the first value to `null`.\n\n```\n<motion.div animate={{ x: [null, 100, 0] }} />\n```\n\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\n\n### [Wildcard keyframes](#wildcard-keyframes)\n\nThis `null` keyframe is called a **wildcard keyframe**. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\n\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n\n```\n<motion.div\n  animate={{ x: [0, 100, null, 0 ] }}\n  // same as x: [0, 100, 100, 0] but easier to maintain\n/>\n```\n\n### [Keyframe timing](#keyframe-timing)\n\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting [the](./react-transitions#times) `times` [option](./react-transitions#times) via `transition`.\n\n`times` is an array of progress values between `0` and `1`, defining where in the animation each keyframe should be positioned.\n\n```\n<motion.circle\n  cx={500}\n  animate={{\n    cx: [null, 100, 200],\n    transition: { duration: 3, times: [0, 0.2, 1] }\n  }}\n/>\n```\n\n`0` is the start of the animation, and `1` is the end of the animation. Therefore, `0.2` places this keyframe somewhere towards the start of the animation.\n\n## [Gesture animations](#gesture-animations)\n\nMotion for React has animation props that can define how an element animates when it [recognises a gesture](./react-gestures).\n\nSupported gestures are:\n\n- `whileHover`\n- `whileTap`\n- `whileFocus`\n- `whileDrag`\n- `whileInView`\n\nWhen a gesture starts, it animates to the values defined in `while-`, and then when the gesture ends it animates back to the values in `initial` or `animate`.\n\n```\n<motion.button\n  initial={{ opacity: 0 }}\n  whileHover={{ backgroundColor: \"rgba(220, 220, 220, 1)\" }}\n  whileTap={{ backgroundColor: \"rgba(255, 255, 255, 1)\" }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\nThe [custom Cursor component](../) available in [Motion+](../plus) takes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n\n```\n<Cursor magnetic />\n```\n\n## [Variants](#variants)\n\nSetting `animate` as a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\n\nVariants are a set of named targets. These names can be anything.\n\n```\nconst variants = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n```\n\nVariants are passed to `motion` components via the `variants` prop:\n\n```\n<motion.div variants={variants} />\n```\n\nThese variants can now be referred to by a label, wherever you can define an animation target:\n\n```\n<motion.div\n  variants={variants}\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  exit=\"hidden\"\n/>\n```\n\nYou can also define multiple variants via an array:\n\n```\nanimate={[\"visible\", \"danger\"]}\n```\n\n### [Propagation](#propagation)\n\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\n\nVariants will flow down through `motion` components. So in this example when the `ul` enters the viewport, all of its children with a \"visible\" variant will also animate in:\n\n```\nconst list = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n\nconst item = {\n  visible: { opacity: 1, x: 0 },\n  hidden: { opacity: 0, x: -100 },\n}\n\nreturn (\n  <motion.ul\n    initial=\"hidden\"\n    whileInView=\"visible\"\n    variants={list}\n  >\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n  </motion.ul>\n)\n```\n\n### [Orchestration](#orchestration)\n\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new `transition` props `when` [and](./react-transitions#orchestration) `delayChildren`.\n\n```\nconst list = {\n  visible: {\n    opacity: 1,\n    transition: {\n      when: \"beforeChildren\",\n      delayChildren: stagger(0.3), // Stagger children by .3 seconds\n    },\n  },\n  hidden: {\n    opacity: 0,\n    transition: {\n      when: \"afterChildren\",\n    },\n  },\n}\n```\n\n### [Dynamic variants](#dynamic-variants)\n\nEach variant can be defined as a function that resolves when a variant is made active.\n\n```\nconst variants = {\n  hidden: { opacity: 0 },\n  visible: (index) => ({\n    opacity: 1,\n    transition: { delay: index * 0.3 }\n  })\n}\n```\n\nThese functions are provided a single argument, which is passed via the `custom` prop:\n\n```\nitems.map((item, index) => <motion.div custom={index} variants={variants} />)\n```\n\nThis way, variants can be resolved differently for each animating element.\n\n## [Animation controls](#animation-controls)\n\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\n\nThe `useAnimate` [hook](./react-use-animate) can be used for:\n\n- Animating any HTML/SVG element (not just `motion` components).\n- Complex animation sequences.\n- Controlling animations with `time`, `speed`, `play()`, `pause()` and other playback controls.\n\n```\nfunction MyComponent() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    const controls = animate([\n      [scope.current, { x: \"100%\" }],\n      [\"li\", { opacity: 1 }]\n    ])\n\n    controls.speed = 0.8\n\n    return () => controls.stop()\n  }, [])\n\n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n## [Animate content](#animate-content)\n\nBy passing [a](./react-motion-value) `MotionValue` as the child of a `motion` component, it will render its latest value in the HTML.\n\n```\nimport { useMotionValue, motion, animate } from \"motion/react\"\n\nfunction Counter() {\n  const count = useMotionValue(0)\n\n  useEffect(() => {\n    const controls = animate(count, 100, { duration: 5 })\n    return () => controls.stop()\n  }, [])\n\n  return <motion.pre>{count}</motion.pre>\n}\n```\n\nThis is more performant than setting React state as the `motion` component will set `innerHTML` directly.\n\nIt's also possible to [animate numbers](../) with a ticking counter effect using the `AnimateNumber` component in [Motion+](../plus) by passing them directly to the component:\n\n```\n<AnimateNumber>{value}</AnimateNumber>\n```\n\n## [Next](#next)\n\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its **animation props**. However, there's much more to discover.\n\nMost of the examples on this page have used HTML elements, but Motion also has unique [SVG animation](./react-svg-animation) features, like its simple line drawing API.\n\nWe've also only covered time-based animations, but Motion also provides powerful [scroll animation](./react-scroll-animations) features like `useScroll` and `whileInView`.\n\nIt also provides a powerful [layout animation](./react-layout-animations) engine, that can animate between any two layouts using performant transforms.\n\nFinally, there's also a whole [Fundamentals examples category](https://motion.dev/examples?platform=react#fundamentals) that covers all the basics of animating with Motion for React with live demos and copy-paste code.\n\n[Motion for React](../) is a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\n\n## [What you'll learn](#what-you-ll-learn)\n\n- How to create your first animation with the `<motion.div />` component.\n- Which values and elements you can animate.\n- How to customise your animations with transition options.\n- How to animate elements as they enter and exit the DOM.\n- How to orchestrate animations with variants.\n\nIf you haven't installed Motion already, hop over to the [quick start guide for full instructions](./react).\n\n## [Animate with `<motion />`](#animate-with-motion)\n\nMost animations in Motion are created with the`<motion />` [component](./react-motion-component). Import it from `\"motion/react\"`:\n\n```\nimport { motion } from \"motion/react\"\n```\n\nEvery HTML & SVG element can be defined with a `motion` component:\n\n```\n<motion.div />\n```\n\n```\n<motion.a href=\"#\" />\n```\n\n```\n<motion.circle cx={0} />\n```\n\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of [special animation props](./react-motion-component#props).\n\nThe most common animation prop is `animate`. When values passed to `animate` change, the element will automatically animate to that value.\n\n```\n<motion.div animate={{ opacity: 1 }} />\n```\n\n### [Enter animations](#enter-animations)\n\nWe can set initial values for an element with the `initial` prop. So an element defined like this will fade in when it enters the DOM:\n\n```\n<motion.article\n  initial={{ opacity: 0 }}\n  animate={{ opacity: 1 }}\n/>\n```\n\n## [Animatable values](#animatable-values)\n\n**Motion can animate any CSS value**, like `opacity`, `filter` etc.\n\n```\n<motion.section\n  initial={{ filter: \"blur(10px)\" }}\n  animate={{ filter: \"none\" }}\n/>\n```\n\nIt can even animate values that aren't normally animatable by browsers, like `background-image` or `mask-image`:\n\n```\n<motion.nav\n  initial={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\" }}\n  animate={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\" }}\n/>\n```\n\n### [Transforms](#transforms)\n\nUnlike CSS, Motion can animate every transform axis independently.\n\n```\n<motion.div animate={{ x: 100 }} />\n```\n\nIt supports the following special transform values:\n\n- Translate: `x`, `y`, `z`\n- Scale: `scale`, `scaleX`, `scaleY`\n- Rotate: `rotate`, `rotateX`, `rotateY`, `rotateZ`\n- Skew: `skewX`, `skewY`\n- Perspective: `transformPerspective`\n\n`motion` components also have enhanced `style` props, allowing you to use these shorthands statically:\n\n```\n<motion.section style={{ x: -20 }} />\n```\n\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n\n```\n<motion.button\n  initial={{ y: 10 }}\n  animate={{ y: 0 }}\n  whileHover={{ scale: 1.1 }}\n  whileTap={{ scale: 0.9 }}\n/>\n```\n\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting `transform` directly.\n\n```\n<motion.li\n  initial={{ transform: \"translateX(-100px)\" }}\n  animate={{ transform: \"translateX(0px)\" }}\n  transition={{ type: \"spring\" }}\n/>\n```\n\nFor SVG components, `x` and `y` **attributes** can be set using `attrX` and `attrY`. [Learn more about SVG animations in React](./react-svg-animation).\n\n### [Supported value types](#supported-value-types)\n\nMotion can animate any of the following value types:\n\n- Numbers: `0`, `100` etc.\n- Strings containing numbers: `\"0vh\"`, `\"10px\"` etc.\n- Colors: Hex, RGBA, HSLA.\n- Complex strings containing multiple numbers and/or colors (like `box-shadow`).\n- `display: \"none\"/\"block\"` and `visibility: \"hidden\"/\"visible\"`.\n\n### [Value type conversion](#value-type-conversion)\n\nIn general, values can only be animated between two of the same type (i.e `\"0px\"` to `\"100px\"`).\n\nColors can be freely animated between hex, RGBA and HSLA types.\n\nAdditionally, `x`, `y`, `width`, `height`, `top`, `left`, `right` and `bottom` can animate between different value types.\n\n```\n<motion.div\n  initial={{ x: \"100%\" }}\n  animate={{ x: \"calc(100vw - 50%)\" }}\n/>\n```\n\nIt's also possible to animate `width` and `height` in to/out of `\"auto\"`.\n\n```\n<motion.div\n  initial={{ height: 0 }}\n  animate={{ height: \"auto\" }}\n/>\n```\n\nIf animating `height: auto` while also animating `display` in to/out of `\"none\"`, replace this with `visibility` `\"hidden\"` as elements with `display: none` can't be measured.\n\n### [Transform origin](#transform-origin)\n\n`transform-origin` has three shortcut values that can be set and animated individually:\n\n- `originX`\n- `originY`\n- `originZ`\n\nIf set as numbers, `originX` and `Y` default to a progress value between `0` and `1`. `originZ` defaults to pixels.\n\n```\n<motion.div style={{ originX: 0.5 }} />\n```\n\n### [CSS variables](#css-variables)\n\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\n\n#### [Animating CSS variables](#animating-css-variables)\n\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n\n```\n<motion.ul\n  initial={{ '--rotate': '0deg' }}\n  animate={{ '--rotate': '360deg' }}\n  transition={{ duration: 2, repeat: Infinity }}\n>\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n</motion.ul>\n```\n\nAnimating the value of a CSS variable **always triggers paint**, therefore it can be more performant to use `MotionValue`[s](./react-motion-value) to setup this kind of animation. [Learn more about web animation performance](../magazine/web-animation-performance-tier-list).\n\n### [CSS variables as animation targets](#css-variables-as-animation-targets)\n\nHTML `motion` components accept animation targets with CSS variables:\n\n```\n<motion.li animate={{ backgroundColor: \"var(--action-bg)\" }} />\n```\n\n## [Transitions](#transitions)\n\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\n\nFor instance, physical properties like `x` or `scale` are animated with spring physics, whereas values like `opacity` or `color` are animated with duration-based easing curves.\n\nHowever, you can define your own animations via [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div\n  animate={{ x: 100 }}\n  transition={{ ease: \"easeOut\", duration: 2 }}\n/>\n```\n\nA default `transition` can be set for many components with the `MotionConfig` [component](./react-motion-config):\n\n```\n<MotionConfig transition={{ duration: 0.3 }}>\n  <motion.div animate={{ opacity: 1 }} />\n```\n\nOr you can set a specific `transition` on any animation prop:\n\n```\n<motion.div\n  animate={{ opacity: 1 }}\n  whileHover={{\n    opacity: 0.7,\n    // Specific transitions override default transitions\n    transition: { duration: 0.3 }\n  }}\n  transition={{ duration: 0.5 }}\n/>\n```\n\n## [Enter animations](#enter-animations-1)\n\nWhen a `motion` component is first created, it'll automatically animate to the values in `animate` if they're different from those initially rendered, which you can either do via CSS or via [the](./react-motion-value) `initial` [prop.](./react-motion-value)\n\n```\n<motion.li\n  initial={{ opacity: 0, scale: 0 }}\n  animate={{ opacity: 1, scale: 1 }}\n/>\n```\n\nYou can also disable the enter animation entirely by setting `initial={false}`. This will make the element render with the values defined in `animate`.\n\n```\n<motion.div initial={false} animate={{ y: 100 }} />\n```\n\n## [Exit animations](#exit-animations)\n\nMotion for React can animate elements as they're removed from the DOM.\n\nIn React, when a component is removed, it's usually removed instantly. Motion provides [the](./react-animate-presence) `AnimatePresence` [component](./react-animate-presence) which keeps elements in the DOM while they perform an animation defined with the `exit` prop.\n\n```\n<AnimatePresence>\n  {isVisible && (\n    <motion.div\n      key=\"modal\"\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n    />\n  )}\n</AnimatePresence>\n```\n\n## [Keyframes](#keyframes)\n\nSo far, we've set animation props like `animate` and `exit` to single values, like `opacity: 0`.\n\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a **series of values**. In animation terms, these are called **keyframes**.\n\nAll animation props can accept keyframe arrays:\n\n```\n<motion.div animate={{ x: [0, 100, 0] }} />\n```\n\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\n\nIn the previous example, we explicitly set the initial value as `0`. But we can also say \"use the current value\" by setting the first value to `null`.\n\n```\n<motion.div animate={{ x: [null, 100, 0] }} />\n```\n\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\n\n### [Wildcard keyframes](#wildcard-keyframes)\n\nThis `null` keyframe is called a **wildcard keyframe**. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\n\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n\n```\n<motion.div\n  animate={{ x: [0, 100, null, 0 ] }}\n  // same as x: [0, 100, 100, 0] but easier to maintain\n/>\n```\n\n### [Keyframe timing](#keyframe-timing)\n\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting [the](./react-transitions#times) `times` [option](./react-transitions#times) via `transition`.\n\n`times` is an array of progress values between `0` and `1`, defining where in the animation each keyframe should be positioned.\n\n```\n<motion.circle\n  cx={500}\n  animate={{\n    cx: [null, 100, 200],\n    transition: { duration: 3, times: [0, 0.2, 1] }\n  }}\n/>\n```\n\n`0` is the start of the animation, and `1` is the end of the animation. Therefore, `0.2` places this keyframe somewhere towards the start of the animation.\n\n## [Gesture animations](#gesture-animations)\n\nMotion for React has animation props that can define how an element animates when it [recognises a gesture](./react-gestures).\n\nSupported gestures are:\n\n- `whileHover`\n- `whileTap`\n- `whileFocus`\n- `whileDrag`\n- `whileInView`\n\nWhen a gesture starts, it animates to the values defined in `while-`, and then when the gesture ends it animates back to the values in `initial` or `animate`.\n\n```\n<motion.button\n  initial={{ opacity: 0 }}\n  whileHover={{ backgroundColor: \"rgba(220, 220, 220, 1)\" }}\n  whileTap={{ backgroundColor: \"rgba(255, 255, 255, 1)\" }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\nThe [custom Cursor component](../) available in [Motion+](../plus) takes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n\n```\n<Cursor magnetic />\n```\n\n## [Variants](#variants)\n\nSetting `animate` as a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\n\nVariants are a set of named targets. These names can be anything.\n\n```\nconst variants = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n```\n\nVariants are passed to `motion` components via the `variants` prop:\n\n```\n<motion.div variants={variants} />\n```\n\nThese variants can now be referred to by a label, wherever you can define an animation target:\n\n```\n<motion.div\n  variants={variants}\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  exit=\"hidden\"\n/>\n```\n\nYou can also define multiple variants via an array:\n\n```\nanimate={[\"visible\", \"danger\"]}\n```\n\n### [Propagation](#propagation)\n\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\n\nVariants will flow down through `motion` components. So in this example when the `ul` enters the viewport, all of its children with a \"visible\" variant will also animate in:\n\n```\nconst list = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n\nconst item = {\n  visible: { opacity: 1, x: 0 },\n  hidden: { opacity: 0, x: -100 },\n}\n\nreturn (\n  <motion.ul\n    initial=\"hidden\"\n    whileInView=\"visible\"\n    variants={list}\n  >\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n  </motion.ul>\n)\n```\n\n### [Orchestration](#orchestration)\n\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new `transition` props `when` [and](./react-transitions#orchestration) `delayChildren`.\n\n```\nconst list = {\n  visible: {\n    opacity: 1,\n    transition: {\n      when: \"beforeChildren\",\n      delayChildren: stagger(0.3), // Stagger children by .3 seconds\n    },\n  },\n  hidden: {\n    opacity: 0,\n    transition: {\n      when: \"afterChildren\",\n    },\n  },\n}\n```\n\n### [Dynamic variants](#dynamic-variants)\n\nEach variant can be defined as a function that resolves when a variant is made active.\n\n```\nconst variants = {\n  hidden: { opacity: 0 },\n  visible: (index) => ({\n    opacity: 1,\n    transition: { delay: index * 0.3 }\n  })\n}\n```\n\nThese functions are provided a single argument, which is passed via the `custom` prop:\n\n```\nitems.map((item, index) => <motion.div custom={index} variants={variants} />)\n```\n\nThis way, variants can be resolved differently for each animating element.\n\n## [Animation controls](#animation-controls)\n\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\n\nThe `useAnimate` [hook](./react-use-animate) can be used for:\n\n- Animating any HTML/SVG element (not just `motion` components).\n- Complex animation sequences.\n- Controlling animations with `time`, `speed`, `play()`, `pause()` and other playback controls.\n\n```\nfunction MyComponent() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    const controls = animate([\n      [scope.current, { x: \"100%\" }],\n      [\"li\", { opacity: 1 }]\n    ])\n\n    controls.speed = 0.8\n\n    return () => controls.stop()\n  }, [])\n\n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n## [Animate content](#animate-content)\n\nBy passing [a](./react-motion-value) `MotionValue` as the child of a `motion` component, it will render its latest value in the HTML.\n\n```\nimport { useMotionValue, motion, animate } from \"motion/react\"\n\nfunction Counter() {\n  const count = useMotionValue(0)\n\n  useEffect(() => {\n    const controls = animate(count, 100, { duration: 5 })\n    return () => controls.stop()\n  }, [])\n\n  return <motion.pre>{count}</motion.pre>\n}\n```\n\nThis is more performant than setting React state as the `motion` component will set `innerHTML` directly.\n\nIt's also possible to [animate numbers](../) with a ticking counter effect using the `AnimateNumber` component in [Motion+](../plus) by passing them directly to the component:\n\n```\n<AnimateNumber>{value}</AnimateNumber>\n```\n\n## [Next](#next)\n\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its **animation props**. However, there's much more to discover.\n\nMost of the examples on this page have used HTML elements, but Motion also has unique [SVG animation](./react-svg-animation) features, like its simple line drawing API.\n\nWe've also only covered time-based animations, but Motion also provides powerful [scroll animation](./react-scroll-animations) features like `useScroll` and `whileInView`.\n\nIt also provides a powerful [layout animation](./react-layout-animations) engine, that can animate between any two layouts using performant transforms.\n\nFinally, there's also a whole [Fundamentals examples category](https://motion.dev/examples?platform=react#fundamentals) that covers all the basics of animating with Motion for React with live demos and copy-paste code.\n\n[Motion for React](../) is a simple yet powerful animation library. Whether you're building hover effects, scroll-triggered animations, or complex animation sequences, this guide will provide an overview of all the ways you can animate in React with Motion.\n\n## [What you'll learn](#what-you-ll-learn)\n\n- How to create your first animation with the `<motion.div />` component.\n- Which values and elements you can animate.\n- How to customise your animations with transition options.\n- How to animate elements as they enter and exit the DOM.\n- How to orchestrate animations with variants.\n\nIf you haven't installed Motion already, hop over to the [quick start guide for full instructions](./react).\n\n## [Animate with `<motion />`](#animate-with-motion)\n\nMost animations in Motion are created with the`<motion />` [component](./react-motion-component). Import it from `\"motion/react\"`:\n\n```\nimport { motion } from \"motion/react\"\n```\n\nEvery HTML & SVG element can be defined with a `motion` component:\n\n```\n<motion.div />\n```\n\n```\n<motion.a href=\"#\" />\n```\n\n```\n<motion.circle cx={0} />\n```\n\nThese components are exactly the same as their normal static counterparts, except now they have access to a bunch of [special animation props](./react-motion-component#props).\n\nThe most common animation prop is `animate`. When values passed to `animate` change, the element will automatically animate to that value.\n\n```\n<motion.div animate={{ opacity: 1 }} />\n```\n\n### [Enter animations](#enter-animations)\n\nWe can set initial values for an element with the `initial` prop. So an element defined like this will fade in when it enters the DOM:\n\n```\n<motion.article\n  initial={{ opacity: 0 }}\n  animate={{ opacity: 1 }}\n/>\n```\n\n## [Animatable values](#animatable-values)\n\n**Motion can animate any CSS value**, like `opacity`, `filter` etc.\n\n```\n<motion.section\n  initial={{ filter: \"blur(10px)\" }}\n  animate={{ filter: \"none\" }}\n/>\n```\n\nIt can even animate values that aren't normally animatable by browsers, like `background-image` or `mask-image`:\n\n```\n<motion.nav\n  initial={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,0) 100%)\" }}\n  animate={{ maskImage: \"linear-gradient(to right, rgba(0,0,0,1) 90%, rgba(0,0,0,1) 100%)\" }}\n/>\n```\n\n### [Transforms](#transforms)\n\nUnlike CSS, Motion can animate every transform axis independently.\n\n```\n<motion.div animate={{ x: 100 }} />\n```\n\nIt supports the following special transform values:\n\n- Translate: `x`, `y`, `z`\n- Scale: `scale`, `scaleX`, `scaleY`\n- Rotate: `rotate`, `rotateX`, `rotateY`, `rotateZ`\n- Skew: `skewX`, `skewY`\n- Perspective: `transformPerspective`\n\n`motion` components also have enhanced `style` props, allowing you to use these shorthands statically:\n\n```\n<motion.section style={{ x: -20 }} />\n```\n\nAnimating transforms independently provides great flexibility, especially when animating different transforms with gestures:\n\n```\n<motion.button\n  initial={{ y: 10 }}\n  animate={{ y: 0 }}\n  whileHover={{ scale: 1.1 }}\n  whileTap={{ scale: 0.9 }}\n/>\n```\n\nIndependent transforms already perform great, but Motion uniquely offers hardware acceleration when setting `transform` directly.\n\n```\n<motion.li\n  initial={{ transform: \"translateX(-100px)\" }}\n  animate={{ transform: \"translateX(0px)\" }}\n  transition={{ type: \"spring\" }}\n/>\n```\n\nFor SVG components, `x` and `y` **attributes** can be set using `attrX` and `attrY`. [Learn more about SVG animations in React](./react-svg-animation).\n\n### [Supported value types](#supported-value-types)\n\nMotion can animate any of the following value types:\n\n- Numbers: `0`, `100` etc.\n- Strings containing numbers: `\"0vh\"`, `\"10px\"` etc.\n- Colors: Hex, RGBA, HSLA.\n- Complex strings containing multiple numbers and/or colors (like `box-shadow`).\n- `display: \"none\"/\"block\"` and `visibility: \"hidden\"/\"visible\"`.\n\n### [Value type conversion](#value-type-conversion)\n\nIn general, values can only be animated between two of the same type (i.e `\"0px\"` to `\"100px\"`).\n\nColors can be freely animated between hex, RGBA and HSLA types.\n\nAdditionally, `x`, `y`, `width`, `height`, `top`, `left`, `right` and `bottom` can animate between different value types.\n\n```\n<motion.div\n  initial={{ x: \"100%\" }}\n  animate={{ x: \"calc(100vw - 50%)\" }}\n/>\n```\n\nIt's also possible to animate `width` and `height` in to/out of `\"auto\"`.\n\n```\n<motion.div\n  initial={{ height: 0 }}\n  animate={{ height: \"auto\" }}\n/>\n```\n\nIf animating `height: auto` while also animating `display` in to/out of `\"none\"`, replace this with `visibility` `\"hidden\"` as elements with `display: none` can't be measured.\n\n### [Transform origin](#transform-origin)\n\n`transform-origin` has three shortcut values that can be set and animated individually:\n\n- `originX`\n- `originY`\n- `originZ`\n\nIf set as numbers, `originX` and `Y` default to a progress value between `0` and `1`. `originZ` defaults to pixels.\n\n```\n<motion.div style={{ originX: 0.5 }} />\n```\n\n### [CSS variables](#css-variables)\n\nMotion for React can animate CSS variables, and also use CSS variable definitions as animation targets.\n\n#### [Animating CSS variables](#animating-css-variables)\n\nSometimes it's convenient to be able to animate a CSS variable to animate many children:\n\n```\n<motion.ul\n  initial={{ '--rotate': '0deg' }}\n  animate={{ '--rotate': '360deg' }}\n  transition={{ duration: 2, repeat: Infinity }}\n>\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n  <li style={{ transform: 'rotate(var(--rotate))' }} />\n</motion.ul>\n```\n\nAnimating the value of a CSS variable **always triggers paint**, therefore it can be more performant to use `MotionValue`[s](./react-motion-value) to setup this kind of animation. [Learn more about web animation performance](../magazine/web-animation-performance-tier-list).\n\n### [CSS variables as animation targets](#css-variables-as-animation-targets)\n\nHTML `motion` components accept animation targets with CSS variables:\n\n```\n<motion.li animate={{ backgroundColor: \"var(--action-bg)\" }} />\n```\n\n## [Transitions](#transitions)\n\nBy default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.\n\nFor instance, physical properties like `x` or `scale` are animated with spring physics, whereas values like `opacity` or `color` are animated with duration-based easing curves.\n\nHowever, you can define your own animations via [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div\n  animate={{ x: 100 }}\n  transition={{ ease: \"easeOut\", duration: 2 }}\n/>\n```\n\nA default `transition` can be set for many components with the `MotionConfig` [component](./react-motion-config):\n\n```\n<MotionConfig transition={{ duration: 0.3 }}>\n  <motion.div animate={{ opacity: 1 }} />\n```\n\nOr you can set a specific `transition` on any animation prop:\n\n```\n<motion.div\n  animate={{ opacity: 1 }}\n  whileHover={{\n    opacity: 0.7,\n    // Specific transitions override default transitions\n    transition: { duration: 0.3 }\n  }}\n  transition={{ duration: 0.5 }}\n/>\n```\n\n## [Enter animations](#enter-animations-1)\n\nWhen a `motion` component is first created, it'll automatically animate to the values in `animate` if they're different from those initially rendered, which you can either do via CSS or via [the](./react-motion-value) `initial` [prop.](./react-motion-value)\n\n```\n<motion.li\n  initial={{ opacity: 0, scale: 0 }}\n  animate={{ opacity: 1, scale: 1 }}\n/>\n```\n\nYou can also disable the enter animation entirely by setting `initial={false}`. This will make the element render with the values defined in `animate`.\n\n```\n<motion.div initial={false} animate={{ y: 100 }} />\n```\n\n## [Exit animations](#exit-animations)\n\nMotion for React can animate elements as they're removed from the DOM.\n\nIn React, when a component is removed, it's usually removed instantly. Motion provides [the](./react-animate-presence) `AnimatePresence` [component](./react-animate-presence) which keeps elements in the DOM while they perform an animation defined with the `exit` prop.\n\n```\n<AnimatePresence>\n  {isVisible && (\n    <motion.div\n      key=\"modal\"\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n    />\n  )}\n</AnimatePresence>\n```\n\n## [Keyframes](#keyframes)\n\nSo far, we've set animation props like `animate` and `exit` to single values, like `opacity: 0`.\n\nThis is great when we want to animate from the current value to a new value. But sometimes we want to animate through a **series of values**. In animation terms, these are called **keyframes**.\n\nAll animation props can accept keyframe arrays:\n\n```\n<motion.div animate={{ x: [0, 100, 0] }} />\n```\n\nWhen we animate to an array of values, the element will animate through each of these values in sequence.\n\nIn the previous example, we explicitly set the initial value as `0`. But we can also say \"use the current value\" by setting the first value to `null`.\n\n```\n<motion.div animate={{ x: [null, 100, 0] }} />\n```\n\nThis way, if a keyframe animation is interrupting another animation, the transition will feel more natural.\n\n### [Wildcard keyframes](#wildcard-keyframes)\n\nThis `null` keyframe is called a **wildcard keyframe**. A wildcard keyframe simply takes the value before it (or the current value, if this is the first keyframe in the array).\n\nWildcard keyframes can be useful for holding a value mid-animation without having to repeat values.\n\n```\n<motion.div\n  animate={{ x: [0, 100, null, 0 ] }}\n  // same as x: [0, 100, 100, 0] but easier to maintain\n/>\n```\n\n### [Keyframe timing](#keyframe-timing)\n\nBy default, each keyframe is spaced evenly throughout the animation. You can override this by setting [the](./react-transitions#times) `times` [option](./react-transitions#times) via `transition`.\n\n`times` is an array of progress values between `0` and `1`, defining where in the animation each keyframe should be positioned.\n\n```\n<motion.circle\n  cx={500}\n  animate={{\n    cx: [null, 100, 200],\n    transition: { duration: 3, times: [0, 0.2, 1] }\n  }}\n/>\n```\n\n`0` is the start of the animation, and `1` is the end of the animation. Therefore, `0.2` places this keyframe somewhere towards the start of the animation.\n\n## [Gesture animations](#gesture-animations)\n\nMotion for React has animation props that can define how an element animates when it [recognises a gesture](./react-gestures).\n\nSupported gestures are:\n\n- `whileHover`\n- `whileTap`\n- `whileFocus`\n- `whileDrag`\n- `whileInView`\n\nWhen a gesture starts, it animates to the values defined in `while-`, and then when the gesture ends it animates back to the values in `initial` or `animate`.\n\n```\n<motion.button\n  initial={{ opacity: 0 }}\n  whileHover={{ backgroundColor: \"rgba(220, 220, 220, 1)\" }}\n  whileTap={{ backgroundColor: \"rgba(255, 255, 255, 1)\" }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\nThe [custom Cursor component](../) available in [Motion+](../plus) takes this a step further with magnetic and target-morphing effects as a user hovers clickable targets (like buttons and links):\n\n```\n<Cursor magnetic />\n```\n\n## [Variants](#variants)\n\nSetting `animate` as a target is useful for simple, single-element animations. It's also possible to orchestrate animations that propagate throughout the DOM. We can do so with variants.\n\nVariants are a set of named targets. These names can be anything.\n\n```\nconst variants = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n```\n\nVariants are passed to `motion` components via the `variants` prop:\n\n```\n<motion.div variants={variants} />\n```\n\nThese variants can now be referred to by a label, wherever you can define an animation target:\n\n```\n<motion.div\n  variants={variants}\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  exit=\"hidden\"\n/>\n```\n\nYou can also define multiple variants via an array:\n\n```\nanimate={[\"visible\", \"danger\"]}\n```\n\n### [Propagation](#propagation)\n\nVariants are useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.\n\nVariants will flow down through `motion` components. So in this example when the `ul` enters the viewport, all of its children with a \"visible\" variant will also animate in:\n\n```\nconst list = {\n  visible: { opacity: 1 },\n  hidden: { opacity: 0 },\n}\n\nconst item = {\n  visible: { opacity: 1, x: 0 },\n  hidden: { opacity: 0, x: -100 },\n}\n\nreturn (\n  <motion.ul\n    initial=\"hidden\"\n    whileInView=\"visible\"\n    variants={list}\n  >\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n    <motion.li variants={item} />\n  </motion.ul>\n)\n```\n\n### [Orchestration](#orchestration)\n\nBy default, this children animations will start simultaneously with the parent. But with variants we gain access to new `transition` props `when` [and](./react-transitions#orchestration) `delayChildren`.\n\n```\nconst list = {\n  visible: {\n    opacity: 1,\n    transition: {\n      when: \"beforeChildren\",\n      delayChildren: stagger(0.3), // Stagger children by .3 seconds\n    },\n  },\n  hidden: {\n    opacity: 0,\n    transition: {\n      when: \"afterChildren\",\n    },\n  },\n}\n```\n\n### [Dynamic variants](#dynamic-variants)\n\nEach variant can be defined as a function that resolves when a variant is made active.\n\n```\nconst variants = {\n  hidden: { opacity: 0 },\n  visible: (index) => ({\n    opacity: 1,\n    transition: { delay: index * 0.3 }\n  })\n}\n```\n\nThese functions are provided a single argument, which is passed via the `custom` prop:\n\n```\nitems.map((item, index) => <motion.div custom={index} variants={variants} />)\n```\n\nThis way, variants can be resolved differently for each animating element.\n\n## [Animation controls](#animation-controls)\n\nDeclarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.\n\nThe `useAnimate` [hook](./react-use-animate) can be used for:\n\n- Animating any HTML/SVG element (not just `motion` components).\n- Complex animation sequences.\n- Controlling animations with `time`, `speed`, `play()`, `pause()` and other playback controls.\n\n```\nfunction MyComponent() {\n  const [scope, animate] = useAnimate()\n\n  useEffect(() => {\n    const controls = animate([\n      [scope.current, { x: \"100%\" }],\n      [\"li\", { opacity: 1 }]\n    ])\n\n    controls.speed = 0.8\n\n    return () => controls.stop()\n  }, [])\n\n  return (\n    <ul ref={scope}>\n      <li />\n      <li />\n      <li />\n    </ul>\n  )\n}\n```\n\n## [Animate content](#animate-content)\n\nBy passing [a](./react-motion-value) `MotionValue` as the child of a `motion` component, it will render its latest value in the HTML.\n\n```\nimport { useMotionValue, motion, animate } from \"motion/react\"\n\nfunction Counter() {\n  const count = useMotionValue(0)\n\n  useEffect(() => {\n    const controls = animate(count, 100, { duration: 5 })\n    return () => controls.stop()\n  }, [])\n\n  return <motion.pre>{count}</motion.pre>\n}\n```\n\nThis is more performant than setting React state as the `motion` component will set `innerHTML` directly.\n\nIt's also possible to [animate numbers](../) with a ticking counter effect using the `AnimateNumber` component in [Motion+](../plus) by passing them directly to the component:\n\n```\n<AnimateNumber>{value}</AnimateNumber>\n```\n\n## [Next](#next)\n\nIn this guide we've covered the basic kinds of animations we can perform in Motion using its **animation props**. However, there's much more to discover.\n\nMost of the examples on this page have used HTML elements, but Motion also has unique [SVG animation](./react-svg-animation) features, like its simple line drawing API.\n\nWe've also only covered time-based animations, but Motion also provides powerful [scroll animation](./react-scroll-animations) features like `useScroll` and `whileInView`.\n\nIt also provides a powerful [layout animation](./react-layout-animations) engine, that can animate between any two layouts using performant transforms.\n\nFinally, there's also a whole [Fundamentals examples category](https://motion.dev/examples?platform=react#fundamentals) that covers all the basics of animating with Motion for React with live demos and copy-paste code.\n\n## Related topics\n\n- [### AI Context\n\n  Turn your LLM into an animation expert with access to the latest Motion documentation & examples.](./studio-ai-context)\n\n  [### AI Context\n\n  Turn your LLM into an animation expert with access to the latest Motion documentation & examples.](./studio-ai-context)\n\n  [### AI Context\n\n  Turn your LLM into an animation expert with access to the latest Motion documentation & examples.](./studio-ai-context)\n- [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n\n  [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n\n  [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n- [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n- [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n\n  [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n\n  [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n\n- [Tutorial\n\n  ### Transition options\n\n  An example of setting transition options in Motion for React.](../tutorials/react-transition)\n\n- [Tutorial\n\n  ### Transition options\n\n  An example of setting transition options in Motion for React.](../tutorials/react-transition)\n\n- [Tutorial\n\n  ### Transition options\n\n  An example of setting transition options in Motion for React.](../tutorials/react-transition)\n\nPrevious\n\n[Get started with Motion for React](./react)\n\nNext\n\n[Layout animation](./react-layout-animations)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Ready for the next step?\n\nLearn more by unlocking the full vault of Motion+ pre-built animation examples. Ready to copy-paste directly into your project.\n\n[See Motion+ features & pricing](../plus)\n\n[See Motion+ features & pricing](../plus)\n\n[See Motion+ features & pricing](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:04.893334+00:00",
  "content_length": 44963,
  "content_hash": "e040849e794b1ddc"
}