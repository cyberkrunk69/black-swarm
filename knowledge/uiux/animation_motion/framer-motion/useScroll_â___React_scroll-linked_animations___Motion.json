{
  "id": "framer-motion__motion_use-scroll_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/use-scroll/",
  "title": "useScroll \u00e2\u0080\u0094 React scroll-linked animations | Motion",
  "content": "useScroll\nis used to create scroll-linked animations, like progress indicators and parallax effects.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nUsage\nImport\nuseScroll\nfrom Motion:\nimport\n{\nuseScroll\n}\nfrom\n\"motion/react\"\nuseScroll\nreturns four\nmotion values\n:\nscrollX\n/\nY\n: The absolute scroll position, in pixels.\nscrollXProgress\n/\nYProgress\n: The scroll position between the defined offsets, as a value between\n0\nand\n1\n.\nPage scroll\nBy default, useScroll tracks the page scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\nlatest\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Page scroll: \"\n,\nlatest\n)\n}\n)\nFor example, we could show a page scroll indicator by passing\nscrollYProgress\nstraight to the\nscaleX\nstyle of a progress bar.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nAs\nuseScroll\nreturns motion values, we can compose this scroll info with other motion value hooks like\nuseTransform\nand\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nSince\nscrollY\nis a\nMotionValue\n, there's a neat trick you can use to tell when the user's scroll direction changes:\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nPerfect for triggering a sticky header animation!\n~ Sam Selikoff,\nMotion for React Recipes\nElement scroll\nTo track the scroll position of a scrollable element we can pass the element's\nref\nto\nuseScroll\n's\ncontainer\noption:\nconst\ncarouselRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollX\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncarouselRef\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncarouselRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n{\nchildren\n}\n</\ndiv\n>\n)\nElement position\nWe can track the progress of an element as it moves within a container by passing its\nref\nto the\ntarget\noption.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n>\nIn this example, each item has its own progress indicator.\nScroll offsets\nWith\nthe\noffset\noption\nwe can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\nOptions\nuseScroll\naccepts the following options.\ncontainer\nDefault\n: Viewport\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncontainerRef\n}\n)\ntarget\nuseScroll\ntracks the progress of the\ntarget\nwithin the\ncontainer\n. By default, the\ntarget\nis the scrollable area of the\ncontainer\n. It can additionally be set as another element, to track its progress within the\ncontainer\n.\nconst\ntargetRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n}\n)\naxis\nDefault:\n\"y\"\nThe tracked axis for the defined\noffset\n.\noffset\nDefault:\n[\"start start\", \"end end\"]\noffset\ndescribes intersections, points where the\ntarget\nand\ncontainer\nmeet.\nFor example, the intersection\n\"start end\"\nmeans when the\nstart of the target\non the tracked axis meets the\nend of the container.\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then\n\"start end\"\nis where the\ntop of the element\nmeets\nthe bottom of the viewport\n.\nAccepted intersections\nBoth target and container points can be defined as:\nNumber:\nA value where\n0\nrepresents the start of the axis and\n1\nrepresents the end. So to define the top of the target with the middle of the container you could define\n\"0 0.5\"\n. Values outside this range are permitted.\nNames:\n\"start\"\n,\n\"center\"\nand\n\"end\"\ncan be used as clear shortcuts for\n0\n,\n0.5\nand\n1\nrespectively.\nPixels:\nPixel values like\n\"100px\"\n,\n\"-50px\"\nwill be defined as that number of pixels from the start of the target/container.\nPercent:\nSame as raw numbers but expressed as\n\"0%\"\nto\n\"100%\"\n.\nViewport:\n\"vh\"\nand\n\"vw\"\nunits are accepted.\n// Track an element as it enters from the bottom\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\n// Track an element as it moves out the top\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end start\"\n]\n}\n)\ntrackContentSize\nDefault:\nfalse\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default\nuseScroll()\nwill not update until the next\n\"scroll\"\nevent.\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\nuseScroll\ncan automatically track changes to content size by setting\ntrackContentSize\nto\ntrue\n.\nuseScroll\n(\n{\ntrackContentSize\n:\ntrue\n}\n)\nuseScroll\nis used to create scroll-linked animations, like progress indicators and parallax effects.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nUsage\nImport\nuseScroll\nfrom Motion:\nimport\n{\nuseScroll\n}\nfrom\n\"motion/react\"\nuseScroll\nreturns four\nmotion values\n:\nscrollX\n/\nY\n: The absolute scroll position, in pixels.\nscrollXProgress\n/\nYProgress\n: The scroll position between the defined offsets, as a value between\n0\nand\n1\n.\nPage scroll\nBy default, useScroll tracks the page scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\nlatest\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Page scroll: \"\n,\nlatest\n)\n}\n)\nFor example, we could show a page scroll indicator by passing\nscrollYProgress\nstraight to the\nscaleX\nstyle of a progress bar.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nAs\nuseScroll\nreturns motion values, we can compose this scroll info with other motion value hooks like\nuseTransform\nand\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nSince\nscrollY\nis a\nMotionValue\n, there's a neat trick you can use to tell when the user's scroll direction changes:\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nPerfect for triggering a sticky header animation!\n~ Sam Selikoff,\nMotion for React Recipes\nElement scroll\nTo track the scroll position of a scrollable element we can pass the element's\nref\nto\nuseScroll\n's\ncontainer\noption:\nconst\ncarouselRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollX\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncarouselRef\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncarouselRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n{\nchildren\n}\n</\ndiv\n>\n)\nElement position\nWe can track the progress of an element as it moves within a container by passing its\nref\nto the\ntarget\noption.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n>\nIn this example, each item has its own progress indicator.\nScroll offsets\nWith\nthe\noffset\noption\nwe can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\nOptions\nuseScroll\naccepts the following options.\ncontainer\nDefault\n: Viewport\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncontainerRef\n}\n)\ntarget\nuseScroll\ntracks the progress of the\ntarget\nwithin the\ncontainer\n. By default, the\ntarget\nis the scrollable area of the\ncontainer\n. It can additionally be set as another element, to track its progress within the\ncontainer\n.\nconst\ntargetRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n}\n)\naxis\nDefault:\n\"y\"\nThe tracked axis for the defined\noffset\n.\noffset\nDefault:\n[\"start start\", \"end end\"]\noffset\ndescribes intersections, points where the\ntarget\nand\ncontainer\nmeet.\nFor example, the intersection\n\"start end\"\nmeans when the\nstart of the target\non the tracked axis meets the\nend of the container.\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then\n\"start end\"\nis where the\ntop of the element\nmeets\nthe bottom of the viewport\n.\nAccepted intersections\nBoth target and container points can be defined as:\nNumber:\nA value where\n0\nrepresents the start of the axis and\n1\nrepresents the end. So to define the top of the target with the middle of the container you could define\n\"0 0.5\"\n. Values outside this range are permitted.\nNames:\n\"start\"\n,\n\"center\"\nand\n\"end\"\ncan be used as clear shortcuts for\n0\n,\n0.5\nand\n1\nrespectively.\nPixels:\nPixel values like\n\"100px\"\n,\n\"-50px\"\nwill be defined as that number of pixels from the start of the target/container.\nPercent:\nSame as raw numbers but expressed as\n\"0%\"\nto\n\"100%\"\n.\nViewport:\n\"vh\"\nand\n\"vw\"\nunits are accepted.\n// Track an element as it enters from the bottom\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\n// Track an element as it moves out the top\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end start\"\n]\n}\n)\ntrackContentSize\nDefault:\nfalse\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default\nuseScroll()\nwill not update until the next\n\"scroll\"\nevent.\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\nuseScroll\ncan automatically track changes to content size by setting\ntrackContentSize\nto\ntrue\n.\nuseScroll\n(\n{\ntrackContentSize\n:\ntrue\n}\n)\nuseScroll\nis used to create scroll-linked animations, like progress indicators and parallax effects.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nUsage\nImport\nuseScroll\nfrom Motion:\nimport\n{\nuseScroll\n}\nfrom\n\"motion/react\"\nuseScroll\nreturns four\nmotion values\n:\nscrollX\n/\nY\n: The absolute scroll position, in pixels.\nscrollXProgress\n/\nYProgress\n: The scroll position between the defined offsets, as a value between\n0\nand\n1\n.\nPage scroll\nBy default, useScroll tracks the page scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\nlatest\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Page scroll: \"\n,\nlatest\n)\n}\n)\nFor example, we could show a page scroll indicator by passing\nscrollYProgress\nstraight to the\nscaleX\nstyle of a progress bar.\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n}\n}\n/>\nAs\nuseScroll\nreturns motion values, we can compose this scroll info with other motion value hooks like\nuseTransform\nand\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nSince\nscrollY\nis a\nMotionValue\n, there's a neat trick you can use to tell when the user's scroll direction changes:\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nPerfect for triggering a sticky header animation!\n~ Sam Selikoff,\nMotion for React Recipes\nElement scroll\nTo track the scroll position of a scrollable element we can pass the element's\nref\nto\nuseScroll\n's\ncontainer\noption:\nconst\ncarouselRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollX\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncarouselRef\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncarouselRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n{\nchildren\n}\n</\ndiv\n>\n)\nElement position\nWe can track the progress of an element as it moves within a container by passing its\nref\nto the\ntarget\noption.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n>\nIn this example, each item has its own progress indicator.\nScroll offsets\nWith\nthe\noffset\noption\nwe can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\nOptions\nuseScroll\naccepts the following options.\ncontainer\nDefault\n: Viewport\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ncontainer\n:\ncontainerRef\n}\n)\ntarget\nuseScroll\ntracks the progress of the\ntarget\nwithin the\ncontainer\n. By default, the\ntarget\nis the scrollable area of the\ncontainer\n. It can additionally be set as another element, to track its progress within the\ncontainer\n.\nconst\ntargetRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n}\n)\naxis\nDefault:\n\"y\"\nThe tracked axis for the defined\noffset\n.\noffset\nDefault:\n[\"start start\", \"end end\"]\noffset\ndescribes intersections, points where the\ntarget\nand\ncontainer\nmeet.\nFor example, the intersection\n\"start end\"\nmeans when the\nstart of the target\non the tracked axis meets the\nend of the container.\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then\n\"start end\"\nis where the\ntop of the element\nmeets\nthe bottom of the viewport\n.\nAccepted intersections\nBoth target and container points can be defined as:\nNumber:\nA value where\n0\nrepresents the start of the axis and\n1\nrepresents the end. So to define the top of the target with the middle of the container you could define\n\"0 0.5\"\n. Values outside this range are permitted.\nNames:\n\"start\"\n,\n\"center\"\nand\n\"end\"\ncan be used as clear shortcuts for\n0\n,\n0.5\nand\n1\nrespectively.\nPixels:\nPixel values like\n\"100px\"\n,\n\"-50px\"\nwill be defined as that number of pixels from the start of the target/container.\nPercent:\nSame as raw numbers but expressed as\n\"0%\"\nto\n\"100%\"\n.\nViewport:\n\"vh\"\nand\n\"vw\"\nunits are accepted.\n// Track an element as it enters from the bottom\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start end\"\n,\n\"end end\"\n]\n}\n)\n// Track an element as it moves out the top\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ntargetRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end start\"\n]\n}\n)\ntrackContentSize\nDefault:\nfalse\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default\nuseScroll()\nwill not update until the next\n\"scroll\"\nevent.\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\nuseScroll\ncan automatically track changes to content size by setting\ntrackContentSize\nto\ntrue\n.\nuseScroll\n(\n{\ntrackContentSize\n:\ntrue\n}\n)\nRelated topics\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nMotion values overview\nComposable animatable values that can updated styles without re-renders.\nReact animation\nCreate React animation with Motion components. Learn variants, gestures, and keyframes.\nReact animation\nCreate React animation with Motion components. Learn variants, gestures, and keyframes.\nReact animation\nCreate React animation with Motion components. Learn variants, gestures, and keyframes.\nuseScroll examples\nSee all examples & tutorials, with full copy & paste source code.\nuseScroll examples\nSee all examples & tutorials, with full copy & paste source code.\nuseScroll examples\nSee all examples & tutorials, with full copy & paste source code.\nPrevious\nuseMotionValueEvent\nNext\nuseSpring\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "`useScroll` is used to create scroll-linked animations, like progress indicators and parallax effects.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\n## [Usage](#usage)\n\nImport `useScroll` from Motion:\n\n```\nimport { useScroll } from \"motion/react\"\n```\n\n`useScroll` returns four [motion values](./react-motion-value):\n\n- `scrollX`/`Y`: The absolute scroll position, in pixels.\n- `scrollXProgress`/`YProgress`: The scroll position between the defined offsets, as a value between `0` and `1`.\n\n### [Page scroll](#page-scroll)\n\nBy default, useScroll tracks the page scroll.\n\n```\nconst { scrollY } = useScroll()\n\nuseMotionValueEvent(scrollY, \"change\", (latest) => {\n  console.log(\"Page scroll: \", latest)\n})\n```\n\nFor example, we could show a page scroll indicator by passing `scrollYProgress` straight to the `scaleX` style of a progress bar.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\nAs `useScroll` returns motion values, we can compose this scroll info with other motion value hooks like `useTransform` and `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll()\nconst scaleX = useSpring(scrollYProgress)\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n> Since `scrollY` is a `MotionValue`, there's a neat trick you can use to tell when the user's scroll direction changes:\n>\n> ```\n> const { scrollY } = useScroll()\n> const [scrollDirection, setScrollDirection] = useState(\"down\")\n>\n> useMotionValueEvent(scrollY, \"change\", (current) => {\n>   const diff = current - scrollY.getPrevious()\n>   setScrollDirection(diff > 0 ? \"down\" : \"up\")\n> })\n> ```\n>\n> Perfect for triggering a sticky header animation!\n>\n> ~ Sam Selikoff, [Motion for React Recipes](https://buildui.com/courses/framer-motion-recipes)\n\n### [Element scroll](#element-scroll)\n\nTo track the scroll position of a scrollable element we can pass the element's `ref` to `useScroll`'s `container` option:\n\n```\nconst carouselRef = useRef(null)\nconst { scrollX } = useScroll({\n  container: carouselRef\n})\n\nreturn (\n  <div ref={carouselRef} style={{ overflow: \"scroll\" }}>\n    {children}\n  </div>\n)\n```\n\n### [Element position](#element-position)\n\nWe can track the progress of an element as it moves within a container by passing its `ref` to the `target` option.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"end end\"]\n})\n\nreturn <div ref={ref}>\n```\n\nIn this example, each item has its own progress indicator.\n\n### [Scroll offsets](#scroll-offsets)\n\nWith [the](./react-use-scroll#offset) `offset` [option](./react-use-scroll#offset) we can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\n\n## [Options](#options)\n\n`useScroll` accepts the following options.\n\n### [`container`](#container)\n\n**Default**: Viewport\n\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({ container: containerRef })\n```\n\n### [`target`](#target)\n\n`useScroll` tracks the progress of the `target` within the `container`. By default, the `target` is the scrollable area of the `container`. It can additionally be set as another element, to track its progress within the `container`.\n\n```\nconst targetRef = useRef(null)\nconst { scrollYProgress } = useScroll({ target: targetRef })\n```\n\n### [`axis`](#axis)\n\n**Default:** `\"y\"`\n\nThe tracked axis for the defined `offset`.\n\n### [`offset`](#offset)\n\n**Default:** `[\"start start\", \"end end\"]`\n\n`offset` describes intersections, points where the `target` and `container` meet.\n\nFor example, the intersection `\"start end\"` means when the **start of the target** on the tracked axis meets the **end of the container.**\n\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then `\"start end\"` is where the **top of the element** meets **the bottom of the viewport**.\n\n#### [Accepted intersections](#accepted-intersections)\n\nBoth target and container points can be defined as:\n\n- **Number:** A value where `0` represents the start of the axis and `1` represents the end. So to define the top of the target with the middle of the container you could define `\"0 0.5\"`. Values outside this range are permitted.\n- **Names:** `\"start\"`, `\"center\"` and `\"end\"` can be used as clear shortcuts for `0`, `0.5` and `1` respectively.\n- **Pixels:** Pixel values like `\"100px\"`, `\"-50px\"` will be defined as that number of pixels from the start of the target/container.\n- **Percent:** Same as raw numbers but expressed as `\"0%\"` to `\"100%\"`.\n- **Viewport:** `\"vh\"` and `\"vw\"` units are accepted.\n\n```\n// Track an element as it enters from the bottom\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start end\", \"end end\"]\n})\n\n// Track an element as it moves out the top\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start start\", \"end start\"]\n})\n```\n\n### [`trackContentSize`](#trackcontentsize)\n\n**Default:** `false`\n\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default `useScroll()` will not update until the next `\"scroll\"` event.\n\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\n\n`useScroll` can automatically track changes to content size by setting `trackContentSize` to `true`.\n\n```\nuseScroll({ trackContentSize: true })\n```\n\n`useScroll` is used to create scroll-linked animations, like progress indicators and parallax effects.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\n## [Usage](#usage)\n\nImport `useScroll` from Motion:\n\n```\nimport { useScroll } from \"motion/react\"\n```\n\n`useScroll` returns four [motion values](./react-motion-value):\n\n- `scrollX`/`Y`: The absolute scroll position, in pixels.\n- `scrollXProgress`/`YProgress`: The scroll position between the defined offsets, as a value between `0` and `1`.\n\n### [Page scroll](#page-scroll)\n\nBy default, useScroll tracks the page scroll.\n\n```\nconst { scrollY } = useScroll()\n\nuseMotionValueEvent(scrollY, \"change\", (latest) => {\n  console.log(\"Page scroll: \", latest)\n})\n```\n\nFor example, we could show a page scroll indicator by passing `scrollYProgress` straight to the `scaleX` style of a progress bar.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\nAs `useScroll` returns motion values, we can compose this scroll info with other motion value hooks like `useTransform` and `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll()\nconst scaleX = useSpring(scrollYProgress)\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n> Since `scrollY` is a `MotionValue`, there's a neat trick you can use to tell when the user's scroll direction changes:\n>\n> ```\n> const { scrollY } = useScroll()\n> const [scrollDirection, setScrollDirection] = useState(\"down\")\n>\n> useMotionValueEvent(scrollY, \"change\", (current) => {\n>   const diff = current - scrollY.getPrevious()\n>   setScrollDirection(diff > 0 ? \"down\" : \"up\")\n> })\n> ```\n>\n> Perfect for triggering a sticky header animation!\n>\n> ~ Sam Selikoff, [Motion for React Recipes](https://buildui.com/courses/framer-motion-recipes)\n\n### [Element scroll](#element-scroll)\n\nTo track the scroll position of a scrollable element we can pass the element's `ref` to `useScroll`'s `container` option:\n\n```\nconst carouselRef = useRef(null)\nconst { scrollX } = useScroll({\n  container: carouselRef\n})\n\nreturn (\n  <div ref={carouselRef} style={{ overflow: \"scroll\" }}>\n    {children}\n  </div>\n)\n```\n\n### [Element position](#element-position)\n\nWe can track the progress of an element as it moves within a container by passing its `ref` to the `target` option.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"end end\"]\n})\n\nreturn <div ref={ref}>\n```\n\nIn this example, each item has its own progress indicator.\n\n### [Scroll offsets](#scroll-offsets)\n\nWith [the](./react-use-scroll#offset) `offset` [option](./react-use-scroll#offset) we can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\n\n## [Options](#options)\n\n`useScroll` accepts the following options.\n\n### [`container`](#container)\n\n**Default**: Viewport\n\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({ container: containerRef })\n```\n\n### [`target`](#target)\n\n`useScroll` tracks the progress of the `target` within the `container`. By default, the `target` is the scrollable area of the `container`. It can additionally be set as another element, to track its progress within the `container`.\n\n```\nconst targetRef = useRef(null)\nconst { scrollYProgress } = useScroll({ target: targetRef })\n```\n\n### [`axis`](#axis)\n\n**Default:** `\"y\"`\n\nThe tracked axis for the defined `offset`.\n\n### [`offset`](#offset)\n\n**Default:** `[\"start start\", \"end end\"]`\n\n`offset` describes intersections, points where the `target` and `container` meet.\n\nFor example, the intersection `\"start end\"` means when the **start of the target** on the tracked axis meets the **end of the container.**\n\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then `\"start end\"` is where the **top of the element** meets **the bottom of the viewport**.\n\n#### [Accepted intersections](#accepted-intersections)\n\nBoth target and container points can be defined as:\n\n- **Number:** A value where `0` represents the start of the axis and `1` represents the end. So to define the top of the target with the middle of the container you could define `\"0 0.5\"`. Values outside this range are permitted.\n- **Names:** `\"start\"`, `\"center\"` and `\"end\"` can be used as clear shortcuts for `0`, `0.5` and `1` respectively.\n- **Pixels:** Pixel values like `\"100px\"`, `\"-50px\"` will be defined as that number of pixels from the start of the target/container.\n- **Percent:** Same as raw numbers but expressed as `\"0%\"` to `\"100%\"`.\n- **Viewport:** `\"vh\"` and `\"vw\"` units are accepted.\n\n```\n// Track an element as it enters from the bottom\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start end\", \"end end\"]\n})\n\n// Track an element as it moves out the top\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start start\", \"end start\"]\n})\n```\n\n### [`trackContentSize`](#trackcontentsize)\n\n**Default:** `false`\n\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default `useScroll()` will not update until the next `\"scroll\"` event.\n\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\n\n`useScroll` can automatically track changes to content size by setting `trackContentSize` to `true`.\n\n```\nuseScroll({ trackContentSize: true })\n```\n\n`useScroll` is used to create scroll-linked animations, like progress indicators and parallax effects.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\n## [Usage](#usage)\n\nImport `useScroll` from Motion:\n\n```\nimport { useScroll } from \"motion/react\"\n```\n\n`useScroll` returns four [motion values](./react-motion-value):\n\n- `scrollX`/`Y`: The absolute scroll position, in pixels.\n- `scrollXProgress`/`YProgress`: The scroll position between the defined offsets, as a value between `0` and `1`.\n\n### [Page scroll](#page-scroll)\n\nBy default, useScroll tracks the page scroll.\n\n```\nconst { scrollY } = useScroll()\n\nuseMotionValueEvent(scrollY, \"change\", (latest) => {\n  console.log(\"Page scroll: \", latest)\n})\n```\n\nFor example, we could show a page scroll indicator by passing `scrollYProgress` straight to the `scaleX` style of a progress bar.\n\n```\nconst { scrollYProgress } = useScroll()\n\nreturn <motion.div style={{ scaleX: scrollYProgress }} />\n```\n\nAs `useScroll` returns motion values, we can compose this scroll info with other motion value hooks like `useTransform` and `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll()\nconst scaleX = useSpring(scrollYProgress)\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n> Since `scrollY` is a `MotionValue`, there's a neat trick you can use to tell when the user's scroll direction changes:\n>\n> ```\n> const { scrollY } = useScroll()\n> const [scrollDirection, setScrollDirection] = useState(\"down\")\n>\n> useMotionValueEvent(scrollY, \"change\", (current) => {\n>   const diff = current - scrollY.getPrevious()\n>   setScrollDirection(diff > 0 ? \"down\" : \"up\")\n> })\n> ```\n>\n> Perfect for triggering a sticky header animation!\n>\n> ~ Sam Selikoff, [Motion for React Recipes](https://buildui.com/courses/framer-motion-recipes)\n\n### [Element scroll](#element-scroll)\n\nTo track the scroll position of a scrollable element we can pass the element's `ref` to `useScroll`'s `container` option:\n\n```\nconst carouselRef = useRef(null)\nconst { scrollX } = useScroll({\n  container: carouselRef\n})\n\nreturn (\n  <div ref={carouselRef} style={{ overflow: \"scroll\" }}>\n    {children}\n  </div>\n)\n```\n\n### [Element position](#element-position)\n\nWe can track the progress of an element as it moves within a container by passing its `ref` to the `target` option.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"end end\"]\n})\n\nreturn <div ref={ref}>\n```\n\nIn this example, each item has its own progress indicator.\n\n### [Scroll offsets](#scroll-offsets)\n\nWith [the](./react-use-scroll#offset) `offset` [option](./react-use-scroll#offset) we can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.\n\n## [Options](#options)\n\n`useScroll` accepts the following options.\n\n### [`container`](#container)\n\n**Default**: Viewport\n\nThe scrollable container to track the scroll position of. By default, this is the browser viewport. By passing a ref to a scrollable element, that element can be used instead.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({ container: containerRef })\n```\n\n### [`target`](#target)\n\n`useScroll` tracks the progress of the `target` within the `container`. By default, the `target` is the scrollable area of the `container`. It can additionally be set as another element, to track its progress within the `container`.\n\n```\nconst targetRef = useRef(null)\nconst { scrollYProgress } = useScroll({ target: targetRef })\n```\n\n### [`axis`](#axis)\n\n**Default:** `\"y\"`\n\nThe tracked axis for the defined `offset`.\n\n### [`offset`](#offset)\n\n**Default:** `[\"start start\", \"end end\"]`\n\n`offset` describes intersections, points where the `target` and `container` meet.\n\nFor example, the intersection `\"start end\"` means when the **start of the target** on the tracked axis meets the **end of the container.**\n\nSo if the target is an element, the container is the window, and we're tracking the vertical axis then `\"start end\"` is where the **top of the element** meets **the bottom of the viewport**.\n\n#### [Accepted intersections](#accepted-intersections)\n\nBoth target and container points can be defined as:\n\n- **Number:** A value where `0` represents the start of the axis and `1` represents the end. So to define the top of the target with the middle of the container you could define `\"0 0.5\"`. Values outside this range are permitted.\n- **Names:** `\"start\"`, `\"center\"` and `\"end\"` can be used as clear shortcuts for `0`, `0.5` and `1` respectively.\n- **Pixels:** Pixel values like `\"100px\"`, `\"-50px\"` will be defined as that number of pixels from the start of the target/container.\n- **Percent:** Same as raw numbers but expressed as `\"0%\"` to `\"100%\"`.\n- **Viewport:** `\"vh\"` and `\"vw\"` units are accepted.\n\n```\n// Track an element as it enters from the bottom\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start end\", \"end end\"]\n})\n\n// Track an element as it moves out the top\nconst { scrollYProgress } = useScroll({\n  target: targetRef,\n  offset: [\"start start\", \"end start\"]\n})\n```\n\n### [`trackContentSize`](#trackcontentsize)\n\n**Default:** `false`\n\nWhen the size of a page or element's content changes, its scrollable area can change too. But, because browsers don't provide a callback for changes in content size, by default `useScroll()` will not update until the next `\"scroll\"` event.\n\nContent size tracking is disabled by default because most of the time, scrollable area remains stable, and tracking changes to it involves a small overhead.\n\n`useScroll` can automatically track changes to content size by setting `trackContentSize` to `true`.\n\n```\nuseScroll({ trackContentSize: true })\n```\n\n## Related topics\n\n- [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n- [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n\n  [### Motion values overview\n\n  Composable animatable values that can updated styles without re-renders.](./react-motion-value)\n- [### React animation\n\n  Create React animation with Motion components. Learn variants, gestures, and keyframes.](./react-animation)\n\n  [### React animation\n\n  Create React animation with Motion components. Learn variants, gestures, and keyframes.](./react-animation)\n\n  [### React animation\n\n  Create React animation with Motion components. Learn variants, gestures, and keyframes.](./react-animation)\n\n- [### useScroll examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useScroll)\n\n- [### useScroll examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useScroll)\n\n- [### useScroll examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=useScroll)\n\nPrevious\n\n[useMotionValueEvent](./react-use-motion-value-event)\n\nNext\n\n[useSpring](./react-use-spring)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:16.747524+00:00",
  "content_length": 17342,
  "content_hash": "815e8bef76449728"
}