{
  "id": "framer-motion__motion_scroll-animations_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/scroll-animations/",
  "title": "React scroll animation \u00e2\u0080\u0094 scroll-linked & parallax | Motion",
  "content": "Learn how to create scroll animations in React with Motion. This guide covers\nscroll-linked\nanimations,\nscroll-triggered\nanimations,\nparallax\n,\nhorizontal scrolling\n, and more. All with live examples and copy-paste code.\nTypes of scroll animation\nThere are two fundamental types of scroll animations:\nScroll-triggered:\nAn animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\nScroll-linked:\nAnimation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\nMotion supports both types of scroll animations with simple, performant APIs.\nScroll-triggered animations\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\nMotion provides\nthe\nwhileInView\nprop\nto set an animation target.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimate once on scroll\nBy default, elements will animate between\ninitial\n/\nanimate\n, and\nwhileInView\n, as the element enters and leaves the viewport. Via\nthe\nviewport\noptions\n, set\nonce: true\nso an animation only plays the first time an element scrolls into view.\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nChanging scroll container\nBy default, animations will trigger based on the\nwindow\nviewport. To set a custom scroll container element, pass the\nref\nof another scrollable element to the\nroot\noption:\nfunction\nComponent\n(\n)\n{\nconst\nscrollRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nscrollRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nroot\n:\nscrollRef\n}\n}\n/>\n</\ndiv\n>\n)\n}\nFor more configuration options, checkout\nthe\nmotion\ncomponent\nAPI reference.\nSetting state\nIt's also possible to set React state when any element (not just a\nmotion\ncomponent) enters and leaves the viewport with the\nuseInView\nhook\n.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nref\n}\n>\n{\nisInView\n?\n\"Hello!\"\n:\n\"Bye...\"\n}\n</\ndiv\n>\n)\n}\nScroll-linked animations\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the\nuseScroll\nhook\n.\nuseScroll\nreturns four motion values:\nscrollX\n/\nscrollY\n: Scroll position in pixels\nscrollXProgress\n/\nscrollYProgress\n: Scroll progress from\n0\nto\n1\nScroll progress bar\nCreate a reading progress indicator by linking\nscrollYProgress\nto\nscaleX\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nreturn\n(\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n,\noriginX\n:\n0\n}\n}\n/>\n)\nDetect scroll direction\nIt's possible to track scroll direction by using\nuseMotionValueEvent\non\nscrollY\n. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nSmoothing scroll values\nSmooth changes to a scroll value by passing one through\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n,\n{\nstiffness\n:\n100\n,\ndamping\n:\n30\n,\nrestDelta\n:\n0.001\n}\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nTransform scroll position to any value\nUse the\nuseTransform\nhook to map scroll progress to colours, positions, or any other CSS value:\nconst\nfilter\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nfilter\n}\n}\n/>\nTrack element scroll position through viewport\nBy default,\nuseScroll\nprogress values will represent the overall viewport scroll (or element scroll).\nBy passing an element via the\ntarget\noption,\nscrollYProgress\nwill return its progress through the visible space.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\n/*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\noffset\n:\n[\n\"start end\"\n,\n\"end start\"\n]\n}\n)\nParallax scrolling\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\nconst\n{\nforegroundY\n,\nbackgroundY\n}\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n1\n]\n,\n{\nforegroundY\n:\n[\n0\n,\n2\n]\n,\n// move 2px for every 1 scroll px\nbackgroundY\n:\n[\n0\n,\n0.5\n]\n// move 0.5px for every 1 scroll px\n}\n,\n{\nclamp\n:\nfalse\n}\n)\nScroll image reveal effect\nBy linking\nclipPath\nto\nscrollYProgress\n, you can have an image \"reveal\" itself as it scrolls into view.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"center center\"\n]\n}\n)\nconst\nclipPath\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"inset(0% 50% 0% 50%)\"\n,\n\"inset(0% 0% 0% 0%)\"\n]\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nclipPath\n}\n}\n>\n<\nimg\nsrc\n=\n\"/photo.jpg\"\nalt\n=\n\"Revealed image\"\n/>\n</\nmotion\n.\ndiv\n>\n)\nHorizontal scroll section\nYou can make a horizontally-scrolling section by combining\nuseScroll\n, a tall container section, and a wide\nposition: sticky\ncontainer.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ncontainerRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end end\"\n]\n}\n)\nconst\nx\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"0%\"\n,\n\"-75%\"\n]\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainerRef\n}\nstyle\n=\n{\n{\nheight\n:\n\"300vh\"\n}\n}\n>\n<\ndiv\nstyle\n=\n{\n{\nposition\n:\n\"sticky\"\n,\ntop\n:\n0\n,\nheight\n:\n\"100vh\"\n,\noverflow\n:\n\"hidden\"\n}\n}\n>\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\ndisplay\n:\n\"flex\"\n,\ngap\n:\n20\n}\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\ndiv\nkey\n=\n{\nitem\n.\nid\n}\nstyle\n=\n{\n{\nflexShrink\n:\n0\n,\nwidth\n:\n400\n}\n}\n>\n{\nitem\n.\ncontent\n}\n</\ndiv\n>\n)\n)\n}\n</\nmotion\n.\ndiv\n>\n</\ndiv\n>\n</\ndiv\n>\n)\nThe container should have a long viewport-relative measurement like\n300vh\n. Increasing this length will make the horizontal scrolling feel slower.\nText scroll\nBy combining\nuseScroll\nwith the Motion+\nTicker\nwe can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\nBy passing\nscrollY\nto\nuseTransform\nand multiplying it by\n-1\nwe get a\nmotion value\nthat moves in the opposite direction to the scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\ninvertScroll\n=\nuseTransform\n(\n(\n)\n=>\nscrollY\n.\nget\n(\n)\n* -\n1\n)\nconst\nlines\n=\n[\n{\ntext\n:\n\"Creative\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Design\"\n,\nreverse\n:\ntrue\n}\n,\n{\ntext\n:\n\"Motion\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Studio\"\n,\nreverse\n:\ntrue\n}\n,\n]\n{\nlines\n.\nmap\n(\n(\nline\n,\nindex\n)\n=>\n(\n<\nTicker\nkey\n=\n{\nline\n.\ntext\n}\nclassName\n=\n{\n`ticker-line ticker-\n${\nindex\n}\n`\n}\nitems\n=\n{\n[\n<\nspan\nclassName\n=\n\"text-solid\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n<\nspan\nclassName\n=\n\"text-outline\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n]\n}\noffset\n=\n{\nline\n.\nreverse\n?\ninvertScroll\n:\nscrollY\n}\n/>\n)\n)\n}\nExamples\nTrack element scroll offset\nTrack element within viewport\n3D\nScroll velocity and direction\nRead the\nfull\nuseScroll\ndocs\nto discover more about creating the above effects.\nLearn how to create scroll animations in React with Motion. This guide covers\nscroll-linked\nanimations,\nscroll-triggered\nanimations,\nparallax\n,\nhorizontal scrolling\n, and more. All with live examples and copy-paste code.\nTypes of scroll animation\nThere are two fundamental types of scroll animations:\nScroll-triggered:\nAn animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\nScroll-linked:\nAnimation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\nMotion supports both types of scroll animations with simple, performant APIs.\nScroll-triggered animations\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\nMotion provides\nthe\nwhileInView\nprop\nto set an animation target.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimate once on scroll\nBy default, elements will animate between\ninitial\n/\nanimate\n, and\nwhileInView\n, as the element enters and leaves the viewport. Via\nthe\nviewport\noptions\n, set\nonce: true\nso an animation only plays the first time an element scrolls into view.\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nChanging scroll container\nBy default, animations will trigger based on the\nwindow\nviewport. To set a custom scroll container element, pass the\nref\nof another scrollable element to the\nroot\noption:\nfunction\nComponent\n(\n)\n{\nconst\nscrollRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nscrollRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nroot\n:\nscrollRef\n}\n}\n/>\n</\ndiv\n>\n)\n}\nFor more configuration options, checkout\nthe\nmotion\ncomponent\nAPI reference.\nSetting state\nIt's also possible to set React state when any element (not just a\nmotion\ncomponent) enters and leaves the viewport with the\nuseInView\nhook\n.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nref\n}\n>\n{\nisInView\n?\n\"Hello!\"\n:\n\"Bye...\"\n}\n</\ndiv\n>\n)\n}\nScroll-linked animations\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the\nuseScroll\nhook\n.\nuseScroll\nreturns four motion values:\nscrollX\n/\nscrollY\n: Scroll position in pixels\nscrollXProgress\n/\nscrollYProgress\n: Scroll progress from\n0\nto\n1\nScroll progress bar\nCreate a reading progress indicator by linking\nscrollYProgress\nto\nscaleX\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nreturn\n(\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n,\noriginX\n:\n0\n}\n}\n/>\n)\nDetect scroll direction\nIt's possible to track scroll direction by using\nuseMotionValueEvent\non\nscrollY\n. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nSmoothing scroll values\nSmooth changes to a scroll value by passing one through\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n,\n{\nstiffness\n:\n100\n,\ndamping\n:\n30\n,\nrestDelta\n:\n0.001\n}\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nTransform scroll position to any value\nUse the\nuseTransform\nhook to map scroll progress to colours, positions, or any other CSS value:\nconst\nfilter\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nfilter\n}\n}\n/>\nTrack element scroll position through viewport\nBy default,\nuseScroll\nprogress values will represent the overall viewport scroll (or element scroll).\nBy passing an element via the\ntarget\noption,\nscrollYProgress\nwill return its progress through the visible space.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\n/*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\noffset\n:\n[\n\"start end\"\n,\n\"end start\"\n]\n}\n)\nParallax scrolling\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\nconst\n{\nforegroundY\n,\nbackgroundY\n}\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n1\n]\n,\n{\nforegroundY\n:\n[\n0\n,\n2\n]\n,\n// move 2px for every 1 scroll px\nbackgroundY\n:\n[\n0\n,\n0.5\n]\n// move 0.5px for every 1 scroll px\n}\n,\n{\nclamp\n:\nfalse\n}\n)\nScroll image reveal effect\nBy linking\nclipPath\nto\nscrollYProgress\n, you can have an image \"reveal\" itself as it scrolls into view.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"center center\"\n]\n}\n)\nconst\nclipPath\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"inset(0% 50% 0% 50%)\"\n,\n\"inset(0% 0% 0% 0%)\"\n]\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nclipPath\n}\n}\n>\n<\nimg\nsrc\n=\n\"/photo.jpg\"\nalt\n=\n\"Revealed image\"\n/>\n</\nmotion\n.\ndiv\n>\n)\nHorizontal scroll section\nYou can make a horizontally-scrolling section by combining\nuseScroll\n, a tall container section, and a wide\nposition: sticky\ncontainer.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ncontainerRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end end\"\n]\n}\n)\nconst\nx\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"0%\"\n,\n\"-75%\"\n]\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainerRef\n}\nstyle\n=\n{\n{\nheight\n:\n\"300vh\"\n}\n}\n>\n<\ndiv\nstyle\n=\n{\n{\nposition\n:\n\"sticky\"\n,\ntop\n:\n0\n,\nheight\n:\n\"100vh\"\n,\noverflow\n:\n\"hidden\"\n}\n}\n>\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\ndisplay\n:\n\"flex\"\n,\ngap\n:\n20\n}\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\ndiv\nkey\n=\n{\nitem\n.\nid\n}\nstyle\n=\n{\n{\nflexShrink\n:\n0\n,\nwidth\n:\n400\n}\n}\n>\n{\nitem\n.\ncontent\n}\n</\ndiv\n>\n)\n)\n}\n</\nmotion\n.\ndiv\n>\n</\ndiv\n>\n</\ndiv\n>\n)\nThe container should have a long viewport-relative measurement like\n300vh\n. Increasing this length will make the horizontal scrolling feel slower.\nText scroll\nBy combining\nuseScroll\nwith the Motion+\nTicker\nwe can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\nBy passing\nscrollY\nto\nuseTransform\nand multiplying it by\n-1\nwe get a\nmotion value\nthat moves in the opposite direction to the scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\ninvertScroll\n=\nuseTransform\n(\n(\n)\n=>\nscrollY\n.\nget\n(\n)\n* -\n1\n)\nconst\nlines\n=\n[\n{\ntext\n:\n\"Creative\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Design\"\n,\nreverse\n:\ntrue\n}\n,\n{\ntext\n:\n\"Motion\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Studio\"\n,\nreverse\n:\ntrue\n}\n,\n]\n{\nlines\n.\nmap\n(\n(\nline\n,\nindex\n)\n=>\n(\n<\nTicker\nkey\n=\n{\nline\n.\ntext\n}\nclassName\n=\n{\n`ticker-line ticker-\n${\nindex\n}\n`\n}\nitems\n=\n{\n[\n<\nspan\nclassName\n=\n\"text-solid\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n<\nspan\nclassName\n=\n\"text-outline\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n]\n}\noffset\n=\n{\nline\n.\nreverse\n?\ninvertScroll\n:\nscrollY\n}\n/>\n)\n)\n}\nExamples\nTrack element scroll offset\nTrack element within viewport\n3D\nScroll velocity and direction\nRead the\nfull\nuseScroll\ndocs\nto discover more about creating the above effects.\nLearn how to create scroll animations in React with Motion. This guide covers\nscroll-linked\nanimations,\nscroll-triggered\nanimations,\nparallax\n,\nhorizontal scrolling\n, and more. All with live examples and copy-paste code.\nTypes of scroll animation\nThere are two fundamental types of scroll animations:\nScroll-triggered:\nAn animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\nScroll-linked:\nAnimation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\nMotion supports both types of scroll animations with simple, performant APIs.\nScroll-triggered animations\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\nMotion provides\nthe\nwhileInView\nprop\nto set an animation target.\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\nAnimate once on scroll\nBy default, elements will animate between\ninitial\n/\nanimate\n, and\nwhileInView\n, as the element enters and leaves the viewport. Via\nthe\nviewport\noptions\n, set\nonce: true\nso an animation only plays the first time an element scrolls into view.\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nwhileInView\n=\n\"visible\"\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nChanging scroll container\nBy default, animations will trigger based on the\nwindow\nviewport. To set a custom scroll container element, pass the\nref\nof another scrollable element to the\nroot\noption:\nfunction\nComponent\n(\n)\n{\nconst\nscrollRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nscrollRef\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nroot\n:\nscrollRef\n}\n}\n/>\n</\ndiv\n>\n)\n}\nFor more configuration options, checkout\nthe\nmotion\ncomponent\nAPI reference.\nSetting state\nIt's also possible to set React state when any element (not just a\nmotion\ncomponent) enters and leaves the viewport with the\nuseInView\nhook\n.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n(\n<\ndiv\nref\n=\n{\nref\n}\n>\n{\nisInView\n?\n\"Hello!\"\n:\n\"Bye...\"\n}\n</\ndiv\n>\n)\n}\nScroll-linked animations\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the\nuseScroll\nhook\n.\nuseScroll\nreturns four motion values:\nscrollX\n/\nscrollY\n: Scroll position in pixels\nscrollXProgress\n/\nscrollYProgress\n: Scroll progress from\n0\nto\n1\nScroll progress bar\nCreate a reading progress indicator by linking\nscrollYProgress\nto\nscaleX\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nreturn\n(\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n:\nscrollYProgress\n,\noriginX\n:\n0\n}\n}\n/>\n)\nDetect scroll direction\nIt's possible to track scroll direction by using\nuseMotionValueEvent\non\nscrollY\n. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\n[\nscrollDirection\n,\nsetScrollDirection\n]\n=\nuseState\n(\n\"down\"\n)\nuseMotionValueEvent\n(\nscrollY\n,\n\"change\"\n,\n(\ncurrent\n)\n=>\n{\nconst\ndiff\n=\ncurrent\n-\nscrollY\n.\ngetPrevious\n(\n)\nsetScrollDirection\n(\ndiff\n>\n0\n?\n\"down\"\n:\n\"up\"\n)\n}\n)\nSmoothing scroll values\nSmooth changes to a scroll value by passing one through\nuseSpring\n:\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n)\n;\nconst\nscaleX\n=\nuseSpring\n(\nscrollYProgress\n,\n{\nstiffness\n:\n100\n,\ndamping\n:\n30\n,\nrestDelta\n:\n0.001\n}\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nscaleX\n}\n}\n/>\nTransform scroll position to any value\nUse the\nuseTransform\nhook to map scroll progress to colours, positions, or any other CSS value:\nconst\nfilter\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"blur(0px)\"\n,\n\"blur(10px)\"\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nfilter\n}\n}\n/>\nTrack element scroll position through viewport\nBy default,\nuseScroll\nprogress values will represent the overall viewport scroll (or element scroll).\nBy passing an element via the\ntarget\noption,\nscrollYProgress\nwill return its progress through the visible space.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\n/*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\noffset\n:\n[\n\"start end\"\n,\n\"end start\"\n]\n}\n)\nParallax scrolling\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\nconst\n{\nforegroundY\n,\nbackgroundY\n}\n=\nuseTransform\n(\nscrollY\n,\n[\n0\n,\n1\n]\n,\n{\nforegroundY\n:\n[\n0\n,\n2\n]\n,\n// move 2px for every 1 scroll px\nbackgroundY\n:\n[\n0\n,\n0.5\n]\n// move 0.5px for every 1 scroll px\n}\n,\n{\nclamp\n:\nfalse\n}\n)\nScroll image reveal effect\nBy linking\nclipPath\nto\nscrollYProgress\n, you can have an image \"reveal\" itself as it scrolls into view.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\nref\n,\noffset\n:\n[\n\"start end\"\n,\n\"center center\"\n]\n}\n)\nconst\nclipPath\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"inset(0% 50% 0% 50%)\"\n,\n\"inset(0% 0% 0% 0%)\"\n]\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nref\n}\nstyle\n=\n{\n{\nclipPath\n}\n}\n>\n<\nimg\nsrc\n=\n\"/photo.jpg\"\nalt\n=\n\"Revealed image\"\n/>\n</\nmotion\n.\ndiv\n>\n)\nHorizontal scroll section\nYou can make a horizontally-scrolling section by combining\nuseScroll\n, a tall container section, and a wide\nposition: sticky\ncontainer.\nconst\ncontainerRef\n=\nuseRef\n(\nnull\n)\nconst\n{\nscrollYProgress\n}\n=\nuseScroll\n(\n{\ntarget\n:\ncontainerRef\n,\noffset\n:\n[\n\"start start\"\n,\n\"end end\"\n]\n}\n)\nconst\nx\n=\nuseTransform\n(\nscrollYProgress\n,\n[\n0\n,\n1\n]\n,\n[\n\"0%\"\n,\n\"-75%\"\n]\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainerRef\n}\nstyle\n=\n{\n{\nheight\n:\n\"300vh\"\n}\n}\n>\n<\ndiv\nstyle\n=\n{\n{\nposition\n:\n\"sticky\"\n,\ntop\n:\n0\n,\nheight\n:\n\"100vh\"\n,\noverflow\n:\n\"hidden\"\n}\n}\n>\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\ndisplay\n:\n\"flex\"\n,\ngap\n:\n20\n}\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\ndiv\nkey\n=\n{\nitem\n.\nid\n}\nstyle\n=\n{\n{\nflexShrink\n:\n0\n,\nwidth\n:\n400\n}\n}\n>\n{\nitem\n.\ncontent\n}\n</\ndiv\n>\n)\n)\n}\n</\nmotion\n.\ndiv\n>\n</\ndiv\n>\n</\ndiv\n>\n)\nThe container should have a long viewport-relative measurement like\n300vh\n. Increasing this length will make the horizontal scrolling feel slower.\nText scroll\nBy combining\nuseScroll\nwith the Motion+\nTicker\nwe can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\nBy passing\nscrollY\nto\nuseTransform\nand multiplying it by\n-1\nwe get a\nmotion value\nthat moves in the opposite direction to the scroll.\nconst\n{\nscrollY\n}\n=\nuseScroll\n(\n)\nconst\ninvertScroll\n=\nuseTransform\n(\n(\n)\n=>\nscrollY\n.\nget\n(\n)\n* -\n1\n)\nconst\nlines\n=\n[\n{\ntext\n:\n\"Creative\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Design\"\n,\nreverse\n:\ntrue\n}\n,\n{\ntext\n:\n\"Motion\"\n,\nreverse\n:\nfalse\n}\n,\n{\ntext\n:\n\"Studio\"\n,\nreverse\n:\ntrue\n}\n,\n]\n{\nlines\n.\nmap\n(\n(\nline\n,\nindex\n)\n=>\n(\n<\nTicker\nkey\n=\n{\nline\n.\ntext\n}\nclassName\n=\n{\n`ticker-line ticker-\n${\nindex\n}\n`\n}\nitems\n=\n{\n[\n<\nspan\nclassName\n=\n\"text-solid\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n<\nspan\nclassName\n=\n\"text-outline\"\n>\n{\nline\n.\ntext\n}\n</\nspan\n>\n,\n]\n}\noffset\n=\n{\nline\n.\nreverse\n?\ninvertScroll\n:\nscrollY\n}\n/>\n)\n)\n}\nExamples\nTrack element scroll offset\nTrack element within viewport\n3D\nScroll velocity and direction\nRead the\nfull\nuseScroll\ndocs\nto discover more about creating the above effects.\nRelated topics\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nuseInView\nSwitch React state when an element enters/leaves the viewport.\nMotion+\nTicker\nInfinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.\nMotion+\nTicker\nInfinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.\nMotion+\nTicker\nInfinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.\nScroll animation examples\nSee all examples & tutorials, with full copy & paste source code.\nScroll animation examples\nSee all examples & tutorials, with full copy & paste source code.\nScroll animation examples\nSee all examples & tutorials, with full copy & paste source code.\nTutorial\nParallax\nAn example of creating a parallax effect using Motion for React's useScroll hook.\nTutorial\nParallax\nAn example of creating a parallax effect using Motion for React's useScroll hook.\nTutorial\nParallax\nAn example of creating a parallax effect using Motion for React's useScroll hook.\nPrevious\nLayout animation\nNext\nSVG animation\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nMastered the basics of scroll-linked animations? The Motion+ vault contains dozens of exclusive examples showcasing advanced effects like parallax, scroll-triggered tickers, and more.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "Learn how to create scroll animations in React with Motion. This guide covers **scroll-linked** animations, **scroll-triggered** animations, **parallax**, **horizontal scrolling**, and more. All with live examples and copy-paste code.\n\n## [Types of scroll animation](#types-of-scroll-animation)\n\nThere are two fundamental types of scroll animations:\n\n- **Scroll-triggered:** An animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\n- **Scroll-linked:** Animation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\n\nMotion supports both types of scroll animations with simple, performant APIs.\n\n## [Scroll-triggered animations](#scroll-triggered-animations)\n\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\n\nMotion provides [the](./react-motion-component#whileinview) `whileInView` [prop](./react-motion-component#whileinview) to set an animation target.\n\n```\n<motion.div\n  initial={{ opacity: 0 }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\n### [Animate once on scroll](#animate-once-on-scroll)\n\nBy default, elements will animate between `initial`/`animate`, and `whileInView`, as the element enters and leaves the viewport. Via [the](./react-motion-component#viewport-1) `viewport` [options](./react-motion-component#viewport-1), set `once: true` so an animation only plays the first time an element scrolls into view.\n\n```\n<motion.div\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  viewport={{ once: true }}\n/>\n```\n\n### [Changing scroll container](#changing-scroll-container)\n\nBy default, animations will trigger based on the `window` viewport. To set a custom scroll container element, pass the `ref` of another scrollable element to the `root` option:\n\n```\nfunction Component() {\n  const scrollRef = useRef(null)\n  \n  return (\n    <div ref={scrollRef} style={{ overflow: \"scroll\" }}>\n      <motion.div\n        initial={{ opacity: 0 }}\n        whileInView={{ opacity: 1 }}\n        viewport={{ root: scrollRef }}\n      />\n    </div>\n  )\n}\n```\n\nFor more configuration options, checkout [the](./react-motion-component#viewport-1) `motion` [component](./react-motion-component#viewport-1) API reference.\n\n### [Setting state](#setting-state)\n\nIt's also possible to set React state when any element (not just a `motion` component) enters and leaves the viewport with the `useInView` [hook](./react-use-in-view).\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return (\n    <div ref={ref}>\n      {isInView ? \"Hello!\" : \"Bye...\"}\n    </div>\n  )\n}\n```\n\n## [Scroll-linked animations](#scroll-linked-animations)\n\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the `useScroll` [hook](./react-use-scroll).\n\n`useScroll` returns four motion values:\n\n- `scrollX`/`scrollY`: Scroll position in pixels\n- `scrollXProgress`/`scrollYProgress`: Scroll progress from `0` to `1`\n\n### [Scroll progress bar](#scroll-progress-bar)\n\nCreate a reading progress indicator by linking `scrollYProgress` to `scaleX`:\n\n```\nconst { scrollYProgress } = useScroll();\n\nreturn (\n  <motion.div style={{ scaleX: scrollYProgress, originX: 0 }} />  \n)\n```\n\n### [Detect scroll direction](#detect-scroll-direction)\n\nIt's possible to track scroll direction by using `useMotionValueEvent` on `scrollY`. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\n\n```\nconst { scrollY } = useScroll()\nconst [scrollDirection, setScrollDirection] = useState(\"down\")\n\nuseMotionValueEvent(scrollY, \"change\", (current) => {\n  const diff = current - scrollY.getPrevious()\n  setScrollDirection(diff > 0 ? \"down\" : \"up\")\n})\n```\n\n### [Smoothing scroll values](#smoothing-scroll-values)\n\nSmooth changes to a scroll value by passing one through `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll();\nconst scaleX = useSpring(scrollYProgress, {\n  stiffness: 100,\n  damping: 30,\n  restDelta: 0.001\n})\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n### [Transform scroll position to any value](#transform-scroll-position-to-any-value)\n\nUse the `useTransform` hook to map scroll progress to colours, positions, or any other CSS value:\n\n```\nconst filter = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"blur(0px)\", \"blur(10px)\"]\n)\n\nreturn <motion.div style={{ filter }} />\n```\n\n### [Track element scroll position through viewport](#track-element-scroll-position-through-viewport)\n\nBy default, `useScroll` progress values will represent the overall viewport scroll (or element scroll).\n\nBy passing an element via the `target` option, `scrollYProgress` will return its progress through the visible space.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  /*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\n  offset: [\"start end\", \"end start\"]\n})\n```\n\n### [Parallax scrolling](#parallax-scrolling)\n\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\n\n```\nconst { foregroundY, backgroundY } = useTransform(\n  scrollY,\n  [0, 1],\n  {\n    foregroundY: [0, 2], // move 2px for every 1 scroll px\n    backgroundY: [0, 0.5] // move 0.5px for every 1 scroll px\n  },\n  { clamp: false }\n)\n```\n\n### [Scroll image reveal effect](#scroll-image-reveal-effect)\n\nBy linking `clipPath` to `scrollYProgress`, you can have an image \"reveal\" itself as it scrolls into view.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"center center\"]\n})\n\nconst clipPath = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"inset(0% 50% 0% 50%)\", \"inset(0% 0% 0% 0%)\"]\n)\n\nreturn (\n  <motion.div ref={ref} style={{ clipPath }}>\n    <img src=\"/photo.jpg\" alt=\"Revealed image\" />\n  </motion.div>\n)\n```\n\n### [Horizontal scroll section](#horizontal-scroll-section)\n\nYou can make a horizontally-scrolling section by combining `useScroll`, a tall container section, and a wide `position: sticky` container.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: containerRef,\n  offset: [\"start start\", \"end end\"]\n})\n\nconst x = useTransform(scrollYProgress, [0, 1], [\"0%\", \"-75%\"])\n\nreturn (\n  <div ref={containerRef} style={{ height: \"300vh\" }}>\n    <div style={{ position: \"sticky\", top: 0, height: \"100vh\", overflow: \"hidden\" }}>\n      <motion.div style={{ x, display: \"flex\", gap: 20 }}>\n        {items.map(item => (\n          <div key={item.id} style={{ flexShrink: 0, width: 400 }}>\n            {item.content}\n          </div>\n        ))}\n      </motion.div>\n    </div>\n  </div>\n)\n```\n\nThe container should have a long viewport-relative measurement like `300vh`. Increasing this length will make the horizontal scrolling feel slower.\n\n### [Text scroll](#text-scroll)\n\nBy combining `useScroll` with the Motion+ `Ticker` we can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\n\nBy passing `scrollY` to `useTransform` and multiplying it by `-1` we get a [motion value](./react-motion-value) that moves in the opposite direction to the scroll.\n\n```\nconst { scrollY } = useScroll()\nconst invertScroll = useTransform(() => scrollY.get() * -1)\n\nconst lines = [\n    { text: \"Creative\", reverse: false },\n    { text: \"Design\", reverse: true },\n    { text: \"Motion\", reverse: false },\n    { text: \"Studio\", reverse: true },\n]\n```\n\n```\n{lines.map((line, index) => (\n  <Ticker\n    key={line.text}\n    className={`ticker-line ticker-${index}`}\n    items={[\n      <span className=\"text-solid\">{line.text}</span>,\n      <span className=\"text-outline\">{line.text}</span>,\n    ]}\n    offset={line.reverse ? invertScroll : scrollY}\n  />\n))}\n```\n\n## [Examples](#examples)\n\n#### [Track element scroll offset](#track-element-scroll-offset)\n\n#### [Track element within viewport](#track-element-within-viewport)\n\n#### [3D](#3d)\n\n#### [Scroll velocity and direction](#scroll-velocity-and-direction)\n\nRead the [full](./react-use-scroll) `useScroll` [docs](./react-use-scroll) to discover more about creating the above effects.\n\nLearn how to create scroll animations in React with Motion. This guide covers **scroll-linked** animations, **scroll-triggered** animations, **parallax**, **horizontal scrolling**, and more. All with live examples and copy-paste code.\n\n## [Types of scroll animation](#types-of-scroll-animation)\n\nThere are two fundamental types of scroll animations:\n\n- **Scroll-triggered:** An animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\n- **Scroll-linked:** Animation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\n\nMotion supports both types of scroll animations with simple, performant APIs.\n\n## [Scroll-triggered animations](#scroll-triggered-animations)\n\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\n\nMotion provides [the](./react-motion-component#whileinview) `whileInView` [prop](./react-motion-component#whileinview) to set an animation target.\n\n```\n<motion.div\n  initial={{ opacity: 0 }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\n### [Animate once on scroll](#animate-once-on-scroll)\n\nBy default, elements will animate between `initial`/`animate`, and `whileInView`, as the element enters and leaves the viewport. Via [the](./react-motion-component#viewport-1) `viewport` [options](./react-motion-component#viewport-1), set `once: true` so an animation only plays the first time an element scrolls into view.\n\n```\n<motion.div\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  viewport={{ once: true }}\n/>\n```\n\n### [Changing scroll container](#changing-scroll-container)\n\nBy default, animations will trigger based on the `window` viewport. To set a custom scroll container element, pass the `ref` of another scrollable element to the `root` option:\n\n```\nfunction Component() {\n  const scrollRef = useRef(null)\n  \n  return (\n    <div ref={scrollRef} style={{ overflow: \"scroll\" }}>\n      <motion.div\n        initial={{ opacity: 0 }}\n        whileInView={{ opacity: 1 }}\n        viewport={{ root: scrollRef }}\n      />\n    </div>\n  )\n}\n```\n\nFor more configuration options, checkout [the](./react-motion-component#viewport-1) `motion` [component](./react-motion-component#viewport-1) API reference.\n\n### [Setting state](#setting-state)\n\nIt's also possible to set React state when any element (not just a `motion` component) enters and leaves the viewport with the `useInView` [hook](./react-use-in-view).\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return (\n    <div ref={ref}>\n      {isInView ? \"Hello!\" : \"Bye...\"}\n    </div>\n  )\n}\n```\n\n## [Scroll-linked animations](#scroll-linked-animations)\n\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the `useScroll` [hook](./react-use-scroll).\n\n`useScroll` returns four motion values:\n\n- `scrollX`/`scrollY`: Scroll position in pixels\n- `scrollXProgress`/`scrollYProgress`: Scroll progress from `0` to `1`\n\n### [Scroll progress bar](#scroll-progress-bar)\n\nCreate a reading progress indicator by linking `scrollYProgress` to `scaleX`:\n\n```\nconst { scrollYProgress } = useScroll();\n\nreturn (\n  <motion.div style={{ scaleX: scrollYProgress, originX: 0 }} />  \n)\n```\n\n### [Detect scroll direction](#detect-scroll-direction)\n\nIt's possible to track scroll direction by using `useMotionValueEvent` on `scrollY`. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\n\n```\nconst { scrollY } = useScroll()\nconst [scrollDirection, setScrollDirection] = useState(\"down\")\n\nuseMotionValueEvent(scrollY, \"change\", (current) => {\n  const diff = current - scrollY.getPrevious()\n  setScrollDirection(diff > 0 ? \"down\" : \"up\")\n})\n```\n\n### [Smoothing scroll values](#smoothing-scroll-values)\n\nSmooth changes to a scroll value by passing one through `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll();\nconst scaleX = useSpring(scrollYProgress, {\n  stiffness: 100,\n  damping: 30,\n  restDelta: 0.001\n})\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n### [Transform scroll position to any value](#transform-scroll-position-to-any-value)\n\nUse the `useTransform` hook to map scroll progress to colours, positions, or any other CSS value:\n\n```\nconst filter = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"blur(0px)\", \"blur(10px)\"]\n)\n\nreturn <motion.div style={{ filter }} />\n```\n\n### [Track element scroll position through viewport](#track-element-scroll-position-through-viewport)\n\nBy default, `useScroll` progress values will represent the overall viewport scroll (or element scroll).\n\nBy passing an element via the `target` option, `scrollYProgress` will return its progress through the visible space.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  /*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\n  offset: [\"start end\", \"end start\"]\n})\n```\n\n### [Parallax scrolling](#parallax-scrolling)\n\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\n\n```\nconst { foregroundY, backgroundY } = useTransform(\n  scrollY,\n  [0, 1],\n  {\n    foregroundY: [0, 2], // move 2px for every 1 scroll px\n    backgroundY: [0, 0.5] // move 0.5px for every 1 scroll px\n  },\n  { clamp: false }\n)\n```\n\n### [Scroll image reveal effect](#scroll-image-reveal-effect)\n\nBy linking `clipPath` to `scrollYProgress`, you can have an image \"reveal\" itself as it scrolls into view.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"center center\"]\n})\n\nconst clipPath = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"inset(0% 50% 0% 50%)\", \"inset(0% 0% 0% 0%)\"]\n)\n\nreturn (\n  <motion.div ref={ref} style={{ clipPath }}>\n    <img src=\"/photo.jpg\" alt=\"Revealed image\" />\n  </motion.div>\n)\n```\n\n### [Horizontal scroll section](#horizontal-scroll-section)\n\nYou can make a horizontally-scrolling section by combining `useScroll`, a tall container section, and a wide `position: sticky` container.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: containerRef,\n  offset: [\"start start\", \"end end\"]\n})\n\nconst x = useTransform(scrollYProgress, [0, 1], [\"0%\", \"-75%\"])\n\nreturn (\n  <div ref={containerRef} style={{ height: \"300vh\" }}>\n    <div style={{ position: \"sticky\", top: 0, height: \"100vh\", overflow: \"hidden\" }}>\n      <motion.div style={{ x, display: \"flex\", gap: 20 }}>\n        {items.map(item => (\n          <div key={item.id} style={{ flexShrink: 0, width: 400 }}>\n            {item.content}\n          </div>\n        ))}\n      </motion.div>\n    </div>\n  </div>\n)\n```\n\nThe container should have a long viewport-relative measurement like `300vh`. Increasing this length will make the horizontal scrolling feel slower.\n\n### [Text scroll](#text-scroll)\n\nBy combining `useScroll` with the Motion+ `Ticker` we can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\n\nBy passing `scrollY` to `useTransform` and multiplying it by `-1` we get a [motion value](./react-motion-value) that moves in the opposite direction to the scroll.\n\n```\nconst { scrollY } = useScroll()\nconst invertScroll = useTransform(() => scrollY.get() * -1)\n\nconst lines = [\n    { text: \"Creative\", reverse: false },\n    { text: \"Design\", reverse: true },\n    { text: \"Motion\", reverse: false },\n    { text: \"Studio\", reverse: true },\n]\n```\n\n```\n{lines.map((line, index) => (\n  <Ticker\n    key={line.text}\n    className={`ticker-line ticker-${index}`}\n    items={[\n      <span className=\"text-solid\">{line.text}</span>,\n      <span className=\"text-outline\">{line.text}</span>,\n    ]}\n    offset={line.reverse ? invertScroll : scrollY}\n  />\n))}\n```\n\n## [Examples](#examples)\n\n#### [Track element scroll offset](#track-element-scroll-offset)\n\n#### [Track element within viewport](#track-element-within-viewport)\n\n#### [3D](#3d)\n\n#### [Scroll velocity and direction](#scroll-velocity-and-direction)\n\nRead the [full](./react-use-scroll) `useScroll` [docs](./react-use-scroll) to discover more about creating the above effects.\n\nLearn how to create scroll animations in React with Motion. This guide covers **scroll-linked** animations, **scroll-triggered** animations, **parallax**, **horizontal scrolling**, and more. All with live examples and copy-paste code.\n\n## [Types of scroll animation](#types-of-scroll-animation)\n\nThere are two fundamental types of scroll animations:\n\n- **Scroll-triggered:** An animation is triggered when an element enters or leaves the viewport. Common for fade-in effects and lazy-loading.\n- **Scroll-linked:** Animation values are linked directly to scroll position. Used for parallax, progress bars, and interactive storytelling.\n\nMotion supports both types of scroll animations with simple, performant APIs.\n\n## [Scroll-triggered animations](#scroll-triggered-animations)\n\nScroll-triggered animations fire when an element enters or leaves the viewport, or scrolls to a specific point in the viewport.\n\nMotion provides [the](./react-motion-component#whileinview) `whileInView` [prop](./react-motion-component#whileinview) to set an animation target.\n\n```\n<motion.div\n  initial={{ opacity: 0 }}\n  whileInView={{ opacity: 1 }}\n/>\n```\n\n### [Animate once on scroll](#animate-once-on-scroll)\n\nBy default, elements will animate between `initial`/`animate`, and `whileInView`, as the element enters and leaves the viewport. Via [the](./react-motion-component#viewport-1) `viewport` [options](./react-motion-component#viewport-1), set `once: true` so an animation only plays the first time an element scrolls into view.\n\n```\n<motion.div\n  initial=\"hidden\"\n  whileInView=\"visible\"\n  viewport={{ once: true }}\n/>\n```\n\n### [Changing scroll container](#changing-scroll-container)\n\nBy default, animations will trigger based on the `window` viewport. To set a custom scroll container element, pass the `ref` of another scrollable element to the `root` option:\n\n```\nfunction Component() {\n  const scrollRef = useRef(null)\n  \n  return (\n    <div ref={scrollRef} style={{ overflow: \"scroll\" }}>\n      <motion.div\n        initial={{ opacity: 0 }}\n        whileInView={{ opacity: 1 }}\n        viewport={{ root: scrollRef }}\n      />\n    </div>\n  )\n}\n```\n\nFor more configuration options, checkout [the](./react-motion-component#viewport-1) `motion` [component](./react-motion-component#viewport-1) API reference.\n\n### [Setting state](#setting-state)\n\nIt's also possible to set React state when any element (not just a `motion` component) enters and leaves the viewport with the `useInView` [hook](./react-use-in-view).\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return (\n    <div ref={ref}>\n      {isInView ? \"Hello!\" : \"Bye...\"}\n    </div>\n  )\n}\n```\n\n## [Scroll-linked animations](#scroll-linked-animations)\n\nScroll-linked animations connect CSS styles directly to scroll position. In Motion, this is done with the `useScroll` [hook](./react-use-scroll).\n\n`useScroll` returns four motion values:\n\n- `scrollX`/`scrollY`: Scroll position in pixels\n- `scrollXProgress`/`scrollYProgress`: Scroll progress from `0` to `1`\n\n### [Scroll progress bar](#scroll-progress-bar)\n\nCreate a reading progress indicator by linking `scrollYProgress` to `scaleX`:\n\n```\nconst { scrollYProgress } = useScroll();\n\nreturn (\n  <motion.div style={{ scaleX: scrollYProgress, originX: 0 }} />  \n)\n```\n\n### [Detect scroll direction](#detect-scroll-direction)\n\nIt's possible to track scroll direction by using `useMotionValueEvent` on `scrollY`. With this, it's possible to animate items to different states, like a menu that only shows as we scroll down.\n\n```\nconst { scrollY } = useScroll()\nconst [scrollDirection, setScrollDirection] = useState(\"down\")\n\nuseMotionValueEvent(scrollY, \"change\", (current) => {\n  const diff = current - scrollY.getPrevious()\n  setScrollDirection(diff > 0 ? \"down\" : \"up\")\n})\n```\n\n### [Smoothing scroll values](#smoothing-scroll-values)\n\nSmooth changes to a scroll value by passing one through `useSpring`:\n\n```\nconst { scrollYProgress } = useScroll();\nconst scaleX = useSpring(scrollYProgress, {\n  stiffness: 100,\n  damping: 30,\n  restDelta: 0.001\n})\n\nreturn <motion.div style={{ scaleX }} />\n```\n\n### [Transform scroll position to any value](#transform-scroll-position-to-any-value)\n\nUse the `useTransform` hook to map scroll progress to colours, positions, or any other CSS value:\n\n```\nconst filter = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"blur(0px)\", \"blur(10px)\"]\n)\n\nreturn <motion.div style={{ filter }} />\n```\n\n### [Track element scroll position through viewport](#track-element-scroll-position-through-viewport)\n\nBy default, `useScroll` progress values will represent the overall viewport scroll (or element scroll).\n\nBy passing an element via the `target` option, `scrollYProgress` will return its progress through the visible space.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  /*\n    When the top of the target meets the bottom of the container\n    to when the bottom of the target meets the top of the container\n  */\n  offset: [\"start end\", \"end start\"]\n})\n```\n\n### [Parallax scrolling](#parallax-scrolling)\n\nParallax creates the illusion of depth by moving elements at different speeds. Background layers should move slower than foreground layers:\n\n```\nconst { foregroundY, backgroundY } = useTransform(\n  scrollY,\n  [0, 1],\n  {\n    foregroundY: [0, 2], // move 2px for every 1 scroll px\n    backgroundY: [0, 0.5] // move 0.5px for every 1 scroll px\n  },\n  { clamp: false }\n)\n```\n\n### [Scroll image reveal effect](#scroll-image-reveal-effect)\n\nBy linking `clipPath` to `scrollYProgress`, you can have an image \"reveal\" itself as it scrolls into view.\n\n```\nconst ref = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: ref,\n  offset: [\"start end\", \"center center\"]\n})\n\nconst clipPath = useTransform(\n  scrollYProgress,\n  [0, 1],\n  [\"inset(0% 50% 0% 50%)\", \"inset(0% 0% 0% 0%)\"]\n)\n\nreturn (\n  <motion.div ref={ref} style={{ clipPath }}>\n    <img src=\"/photo.jpg\" alt=\"Revealed image\" />\n  </motion.div>\n)\n```\n\n### [Horizontal scroll section](#horizontal-scroll-section)\n\nYou can make a horizontally-scrolling section by combining `useScroll`, a tall container section, and a wide `position: sticky` container.\n\n```\nconst containerRef = useRef(null)\nconst { scrollYProgress } = useScroll({\n  target: containerRef,\n  offset: [\"start start\", \"end end\"]\n})\n\nconst x = useTransform(scrollYProgress, [0, 1], [\"0%\", \"-75%\"])\n\nreturn (\n  <div ref={containerRef} style={{ height: \"300vh\" }}>\n    <div style={{ position: \"sticky\", top: 0, height: \"100vh\", overflow: \"hidden\" }}>\n      <motion.div style={{ x, display: \"flex\", gap: 20 }}>\n        {items.map(item => (\n          <div key={item.id} style={{ flexShrink: 0, width: 400 }}>\n            {item.content}\n          </div>\n        ))}\n      </motion.div>\n    </div>\n  </div>\n)\n```\n\nThe container should have a long viewport-relative measurement like `300vh`. Increasing this length will make the horizontal scrolling feel slower.\n\n### [Text scroll](#text-scroll)\n\nBy combining `useScroll` with the Motion+ `Ticker` we can make this popular effect where blocks of text scroll horizontally as the page itself scrolls vertically.\n\nBy passing `scrollY` to `useTransform` and multiplying it by `-1` we get a [motion value](./react-motion-value) that moves in the opposite direction to the scroll.\n\n```\nconst { scrollY } = useScroll()\nconst invertScroll = useTransform(() => scrollY.get() * -1)\n\nconst lines = [\n    { text: \"Creative\", reverse: false },\n    { text: \"Design\", reverse: true },\n    { text: \"Motion\", reverse: false },\n    { text: \"Studio\", reverse: true },\n]\n```\n\n```\n{lines.map((line, index) => (\n  <Ticker\n    key={line.text}\n    className={`ticker-line ticker-${index}`}\n    items={[\n      <span className=\"text-solid\">{line.text}</span>,\n      <span className=\"text-outline\">{line.text}</span>,\n    ]}\n    offset={line.reverse ? invertScroll : scrollY}\n  />\n))}\n```\n\n## [Examples](#examples)\n\n#### [Track element scroll offset](#track-element-scroll-offset)\n\n#### [Track element within viewport](#track-element-within-viewport)\n\n#### [3D](#3d)\n\n#### [Scroll velocity and direction](#scroll-velocity-and-direction)\n\nRead the [full](./react-use-scroll) `useScroll` [docs](./react-use-scroll) to discover more about creating the above effects.\n\n## Related topics\n\n- [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n\n  [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n\n  [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n- [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n\n  [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n\n  [### useInView\n\n  Switch React state when an element enters/leaves the viewport.](./react-use-in-view)\n- [Motion+\n\n  ### Ticker\n\n  Infinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.](./react-ticker)\n\n  [Motion+\n\n  ### Ticker\n\n  Infinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.](./react-ticker)\n\n  [Motion+\n\n  ### Ticker\n\n  Infinitely-scrolling ticker and marquee effects, driven by time, drag or scroll.](./react-ticker)\n\n- [### Scroll animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=scroll|useScroll|useInView|whileInView)\n\n- [### Scroll animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=scroll|useScroll|useInView|whileInView)\n\n- [### Scroll animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=scroll|useScroll|useInView|whileInView)\n\n- [Tutorial\n\n  ### Parallax\n\n  An example of creating a parallax effect using Motion for React's useScroll hook.](../tutorials/react-parallax)\n\n- [Tutorial\n\n  ### Parallax\n\n  An example of creating a parallax effect using Motion for React's useScroll hook.](../tutorials/react-parallax)\n\n- [Tutorial\n\n  ### Parallax\n\n  An example of creating a parallax effect using Motion for React's useScroll hook.](../tutorials/react-parallax)\n\nPrevious\n\n[Layout animation](./react-layout-animations)\n\nNext\n\n[SVG animation](./react-svg-animation)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nMastered the basics of scroll-linked animations? The Motion+ vault contains dozens of exclusive examples showcasing advanced effects like parallax, scroll-triggered tickers, and more.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:14.933858+00:00",
  "content_length": 23411,
  "content_hash": "922726fdef6b758a"
}