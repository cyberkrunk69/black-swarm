{
  "id": "framer-motion__motion_component_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/component/",
  "title": "React <motion /> component | Motion",
  "content": "Most\nReact animations\nin Motion are powered by the\n<motion />\ncomponent.\nThere's a\nmotion\ncomponent for every HTML and SVG element, for instance\nmotion.div\n,\nmotion.circle\netc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\nUsage\nImport\nmotion\nfrom Motion:\n// React\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\n// React Server Components (Next.js etc)\nimport\n*\nas\nmotion\nfrom\n\"motion/react-client\"\nYou can use a\nmotion\ncomponent exactly as you would any normal HTML/SVG component:\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n/>\nBut you also gain access to powerful animation APIs like the\nanimate\n,\nlayout\n,\nwhileInView\nprops.\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n// Animate when this value changes:\nanimate\n=\n{\n{\nscale\n:\n2\n}\n}\n// Fade in when the element enters the viewport:\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n// Animate the component when its layout changes:\nlayout\n// Style now supports indepedent transforms:\nstyle\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nPerformance\nmotion\ncomponents animate values without triggering React renders, for optimal performance.\nUsing\nmotion values\ninstead of React state to update\nstyle\nwill also avoid re-renders.\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Won't trigger a re-render!\nconst\ntimeout\n=\nsetTimeout\n(\n(\n)\n=>\nx\n.\nset\n(\n100\n)\n,\n1000\n)\nreturn\n(\n)\n=>\nclearTimeout\n(\ntimeout\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n}\n}\n/>\nServer-side rendering\nmotion\ncomponents are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n// Server will output `translateX(100px)`\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nCustom components\nAny React component can be turned into a\nmotion\ncomponent by passing it to\nmotion.create()\n.\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\nComponent\n)\nYour component\nmust\npass a ref to the component you want to animate.\nReact 18:\nUse\nforwardRef\nto wrap the component and pass\nref\nto the element you want to animate:\nconst\nComponent\n=\nReact\n.\nforwardRef\n(\n(\nprops\n,\nref\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\n)\nReact 19:\nReact 19 can pass\nref\nvia\nprops\n:\nconst\nComponent\n=\n(\nprops\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nprops\n.\nref\n}\n/>\n}\n)\nMake sure\nnot\nto call\nmotion.create()\nwithin a React render function! This will make a new component every render, breaking your animations.\nIt's also possible to pass strings to\nmotion.create\n, which will create custom DOM elements.\n// Will render <custom-element /> into HTML\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\n'custom-element'\n)\nBy default, all\nmotion\nprops (like\nanimate\netc) are filtered out of the\nprops\nforwarded to the provided component. By providing a\nforwardMotionProps\nconfig, the provided component will receive these props.\nmotion\n.\ncreate\n(\nComponent\n,\n{\nforwardMotionProps\n:\ntrue\n}\n)\nProps\nmotion\ncomponents accept the following props.\nAnimation\nMotion provides declarative animation props like\nanimate\nand\nexit\n.\nLearn more about React animations in Motion\n.\ninitial\nThe initial visual state of the\nmotion\ncomponent.\nThis can be set as an animation target:\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nx\n:\n0\n}\n}\n/>\nVariants:\n<\nmotion\n.\nli\ninitial\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nOr set as\nfalse\nto disable the enter animation and initially render as the values found in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\nanimate\nA target to animate to on enter, and on update.\nCan be set as an animation target:\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nboxShadow\n:\n\"0px 0px #000\"\n}\n}\nanimate\n=\n{\n{\nboxShadow\n:\n\"10px 10px #000\"\n}\n}\n/>\nOr variants:\n<\nmotion\n.\nli\nanimate\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nexit\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\nOwing to React limitations, the component being removed\nmust\nbe a\ndirect child\nof\nAnimatePresence\nto enable this animation.\ntransition\nThe default\ntransition\nfor this component to use when an animation prop (\nanimate\n,\nwhileHover\netc) has no\ntransition\ndefined.\n<\nmotion\n.\ndiv\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\nanimate\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the\nMotion extension\n.\nvariants\nThe\nvariants\nfor this component.\nconst\nvariants\n=\n{\nactive\n:\n{\nbackgroundColor\n:\n\"#f00\"\n}\n,\ninactive\n:\n{\nbackgroundColor\n:\n\"#fff\"\n,\ntransition\n:\n{\nduration\n:\n2\n}\n}\n}\nreturn\n(\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\nanimate\n=\n{\nisActive\n?\n\"active\"\n:\n\"inactive\"\n}\n/>\n)\nstyle\nThe normal React DOM\nstyle\nprop, with added support for\nmotion values\nand independent transforms.\nconst\nx\n=\nuseMotionValue\n(\n30\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\nrotate\n:\n90\n,\noriginX\n:\n0.5\n}\n}\n/>\nonUpdate\nCallback triggered every frame any value on the\nmotion\ncomponent updates. It's provided a single argument with the latest values.\n<\nmotion\n.\narticle\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nonUpdate\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nopacity\n)\n}\n/>\nonAnimationStart\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationStart\n) starts.\nIt's provided a single argument, with the target or variant name of the started animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationStart\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nonAnimationComplete\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationComplete\n) completes.\nIt's provided a single argument, with the target or variant name of the completed animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationComplete\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nHover\nwhileHover\nAnimation state, or variant label, to perform a\nhover animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileHover\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileHover\n=\n\"hovered\"\n/>\nonHoverStart\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonHoverEnd\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverEnd\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nTap\nwhileTap\nAnimation state, or variant label, to perform a\npress animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileTap\n=\n\"tapped\"\n/>\nonTapStart\nCallback function that fires when a pointer starts pressing the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTap\nCallback function that fires when a pointer stops pressing the component and the pointer was released\ninside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTap\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTapCancel\nCallback function that fires when a pointer stops pressing the component and the pointer was released\noutside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapCancel\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nFocus\nwhileFocus\nAnimation state, or variant label, to animate to while the focus gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileFocus\n=\n{\n{\noutline\n:\n\"dashed #000\"\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileFocus\n=\n\"focused\"\n/>\nPan\nonPan\nCallback function that fires when the pan gesture is recognised on this element.\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the\ntouch-action\nCSS rule.\nfunction\nonPan\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\nonPan\n=\n{\nonPan\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonPanStart\nCallback function that fires when a pan gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonPanEnd\nCallback function that fires when a pan gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nDrag\ndrag\nDefault:\nfalse\nEnable dragging for this element. Set\ntrue\nto drag in both directions. Set\n\"x\"\nor\n\"y\"\nto only drag in a specific direction.\n<\nmotion\n.\ndiv\ndrag\n/>\nwhileDrag\nAnimation state, or variant label, to perform a\ndrag animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n\"dragging\"\n/>\ndragConstraints\nApplies constraints on the draggable area.\nSet as an object of optional\ntop\n,\nleft\n,\nright\n, and\nbottom\nvalues, measured in pixels:\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\n/>\nOr as a\nref\nto another element to use its bounding box as the draggable constraints:\nconst\nMyComponent\n=\n(\n)\n=>\n{\nconst\nconstraintsRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nconstraintsRef\n}\n>\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\nconstraintsRef\n}\n/>\n</\nmotion\n.\ndiv\n>\n)\n}\ndragSnapToOrigin\nDefault:\nfalse\nIf\ntrue\n, the draggable element will animate back to its center/origin when released.\n<\nmotion\n.\ndiv\ndrag\ndragSnapToOrigin\n/>\ndragElastic\nDefault:\n0.5\nThe degree of movement allowed outside constraints.\n0\n= no movement,\n1\n= full movement.\nSet to\n0.5\nby default. Can also be set as\nfalse\nto disable movement.\nBy passing an object of\ntop\n/\nright\n/\nbottom\n/\nleft\n, individual values can be set per constraint. Any missing values will be set to\n0\n.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragElastic\n=\n{\n0.2\n}\n/>\ndragMomentum\nDefault:\ntrue\nApply momentum from the pan gesture to the component when dragging finishes. Set to\ntrue\nby default.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragMomentum\n=\n{\nfalse\n}\n/>\ndragTransition\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type\n\"inertia\"\nstarts. The animation is based on your dragging velocity. This property allows you to customize it.\n<\nmotion\n.\ndiv\ndrag\ndragTransition\n=\n{\n{\nbounceStiffness\n:\n600\n,\nbounceDamping\n:\n10\n}\n}\n/>\ndragDirectionLock\nDefault:\nfalse\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the\nx\naxis than\ny\naxis before the drag gesture kicks in, it will\nonly\ndrag on the\nx\naxis for the remainder of the gesture.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\n/>\ndragPropagation\nDefault:\nfalse\nAllows drag gesture propagation to child components.\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragPropagation\n/>\ndragControls\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\nBy creating a\ndragControls\nusing the\nuseDragControls\nhook\n, we can pass this into the draggable component's\ndragControls\nprop. It exposes a\nstart\nmethod that can start dragging from pointer events on other components.\nconst\ndragControls\n=\nuseDragControls\n(\n)\nfunction\nstartDrag\n(\nevent\n)\n{\ndragControls\n.\nstart\n(\nevent\n,\n{\nsnapToCursor\n:\ntrue\n}\n)\n}\nreturn\n(\n<\n>\n<\ndiv\nonPointerDown\n=\n{\nstartDrag\n}\n/>\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragControls\n=\n{\ndragControls\n}\n/>\n</\n>\n)\nGiven that by setting\ndragControls\nyou are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting\ndragListener={false}\n.\ndragListener\nDetermines whether to trigger the drag gesture from event listeners. If passing\ndragControls\n, setting this to\nfalse\nwill ensure dragging can only be initiated by the controls, rather than a\npointerdown\nevent on the draggable element.\nonDrag\nCallback function that fires when the drag gesture is recognised on this element.\nfunction\nonDrag\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\ndrag\nonDrag\n=\n{\nonDrag\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonDragStart\nCallback function that fires when a drag gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDragEnd\nCallback function that fires when a drag gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDirectionLock\nCallback function that fires a drag direction is determined.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\nonDirectionLock\n=\n{\naxis\n=>\nconsole\n.\nlog\n(\naxis\n)\n}\n/>\nViewport\nLearn more about\nscroll-triggered animations\nin React.\nwhileInView\nTarget or variants to label to while the element is in view.\n// As target\n<\nmotion\n.\ndiv\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileInView\n=\n\"visible\"\n/>\nviewport\nOptions to define how the element is tracked within the viewport.\n<\nmotion\n.\nsection\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nAvailable options:\nonce\n: If\ntrue\n, once element enters the viewport it won't detect subsequent leave/enter events.\nroot\n: The\nref\nof an ancestor scrollable element to detect intersections with (instead of\nwindow\n).\nmargin\n: A margin to add to the viewport to change the detection area. Defaults to\n\"0px\"\n. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\namount\n: The amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n. Defaults to\n\"some\"\n.\nonViewportEnter\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportEnter\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nisIntersecting\n)\n}\n/>\nonViewportLeave\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportLeave\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nintersectionRect\n)\n}\n/>\nLayout\nLearn more about\nlayout animations\nin React.\nlayout\nDefault:\nfalse\nIf\ntrue\n, this component will perform\nlayout animations\n.\n<\nmotion\n.\ndiv\nlayout\n/>\nIf set to\n\"position\"\nor\n\"size\"\n, only its position or size will animate, respectively.\n<\nmotion\n.\nimg\nlayout\n=\n\"position\"\n/>\nlayoutId\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching\nlayoutId\n, it will animate out from the previous element's size/position.\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\n>\n{\nitem\n.\nname\n}\n{\nitem\n.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\n}\n</\nmotion\n.\nli\n>\n)\n)\n}\nIf the previous component remains in the tree, the two elements will crossfade.\nlayoutDependency\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a\nlayoutDependency\nprop. Measurements will only occur when this value changes.\n<\nmotion\n.\nnav\nlayout\nlayoutDependency\n=\n{\nisOpen\n}\n/>\nlayoutScroll\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the\nlayoutScroll\nprop to elements that should be measured.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nlayoutRoot\nFor layout animations to work correctly within\nposition: fixed\nelements, we need to account for page scroll. Add\nlayoutRoot\nto mark an element as\nposition: fixed\n.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nonLayoutAnimationStart\nA callback to run when a layout animation starts.\nonLayoutAnimationComplete\nA callback to run when a layout animation completes.\nAdvanced\ninherit\nSet to\nfalse\nto prevent a component inheriting or propagating changes in a parent variant.\ncustom\nCustom data to pass through to dynamic variants.\nconst\nvariants\n=\n{\nvisible\n:\n(\ncustom\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\ncustom\n*\n0.2\n}\n}\n)\n}\nreturn\n(\n<\nmotion\n.\nul\nanimate\n=\n\"visible\"\n>\n<\nmotion\n.\nli\ncustom\n=\n{\n0\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n1\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n2\n}\nvariants\n=\n{\nvariants\n}\n/>\n</\nmotion\n.\nul\n>\n)\ntransformTemplate\nBy default, transforms are applied in order of\ntranslate\n,\nscale\n,\nrotate\nand\nskew\n.\nTo change this,\ntransformTemplate\ncan be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n// Use the latest transform values\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\n{\nx\n,\nrotate\n}\n)\n=>\n`rotate(\n${\nrotate\n}\ndeg) translateX(\n${\nx\n}\npx)`\n}\n/>\n// Or the generated transform string\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\nlatest\n,\ngenerated\n)\n=>\n`translate(-50%, -50%)\n${\ngenerated\n}\n`\n}\n/>\nMost\nReact animations\nin Motion are powered by the\n<motion />\ncomponent.\nThere's a\nmotion\ncomponent for every HTML and SVG element, for instance\nmotion.div\n,\nmotion.circle\netc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\nUsage\nImport\nmotion\nfrom Motion:\n// React\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\n// React Server Components (Next.js etc)\nimport\n*\nas\nmotion\nfrom\n\"motion/react-client\"\nYou can use a\nmotion\ncomponent exactly as you would any normal HTML/SVG component:\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n/>\nBut you also gain access to powerful animation APIs like the\nanimate\n,\nlayout\n,\nwhileInView\nprops.\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n// Animate when this value changes:\nanimate\n=\n{\n{\nscale\n:\n2\n}\n}\n// Fade in when the element enters the viewport:\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n// Animate the component when its layout changes:\nlayout\n// Style now supports indepedent transforms:\nstyle\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nPerformance\nmotion\ncomponents animate values without triggering React renders, for optimal performance.\nUsing\nmotion values\ninstead of React state to update\nstyle\nwill also avoid re-renders.\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Won't trigger a re-render!\nconst\ntimeout\n=\nsetTimeout\n(\n(\n)\n=>\nx\n.\nset\n(\n100\n)\n,\n1000\n)\nreturn\n(\n)\n=>\nclearTimeout\n(\ntimeout\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n}\n}\n/>\nServer-side rendering\nmotion\ncomponents are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n// Server will output `translateX(100px)`\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nCustom components\nAny React component can be turned into a\nmotion\ncomponent by passing it to\nmotion.create()\n.\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\nComponent\n)\nYour component\nmust\npass a ref to the component you want to animate.\nReact 18:\nUse\nforwardRef\nto wrap the component and pass\nref\nto the element you want to animate:\nconst\nComponent\n=\nReact\n.\nforwardRef\n(\n(\nprops\n,\nref\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\n)\nReact 19:\nReact 19 can pass\nref\nvia\nprops\n:\nconst\nComponent\n=\n(\nprops\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nprops\n.\nref\n}\n/>\n}\n)\nMake sure\nnot\nto call\nmotion.create()\nwithin a React render function! This will make a new component every render, breaking your animations.\nIt's also possible to pass strings to\nmotion.create\n, which will create custom DOM elements.\n// Will render <custom-element /> into HTML\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\n'custom-element'\n)\nBy default, all\nmotion\nprops (like\nanimate\netc) are filtered out of the\nprops\nforwarded to the provided component. By providing a\nforwardMotionProps\nconfig, the provided component will receive these props.\nmotion\n.\ncreate\n(\nComponent\n,\n{\nforwardMotionProps\n:\ntrue\n}\n)\nProps\nmotion\ncomponents accept the following props.\nAnimation\nMotion provides declarative animation props like\nanimate\nand\nexit\n.\nLearn more about React animations in Motion\n.\ninitial\nThe initial visual state of the\nmotion\ncomponent.\nThis can be set as an animation target:\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nx\n:\n0\n}\n}\n/>\nVariants:\n<\nmotion\n.\nli\ninitial\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nOr set as\nfalse\nto disable the enter animation and initially render as the values found in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\nanimate\nA target to animate to on enter, and on update.\nCan be set as an animation target:\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nboxShadow\n:\n\"0px 0px #000\"\n}\n}\nanimate\n=\n{\n{\nboxShadow\n:\n\"10px 10px #000\"\n}\n}\n/>\nOr variants:\n<\nmotion\n.\nli\nanimate\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nexit\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\nOwing to React limitations, the component being removed\nmust\nbe a\ndirect child\nof\nAnimatePresence\nto enable this animation.\ntransition\nThe default\ntransition\nfor this component to use when an animation prop (\nanimate\n,\nwhileHover\netc) has no\ntransition\ndefined.\n<\nmotion\n.\ndiv\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\nanimate\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the\nMotion extension\n.\nvariants\nThe\nvariants\nfor this component.\nconst\nvariants\n=\n{\nactive\n:\n{\nbackgroundColor\n:\n\"#f00\"\n}\n,\ninactive\n:\n{\nbackgroundColor\n:\n\"#fff\"\n,\ntransition\n:\n{\nduration\n:\n2\n}\n}\n}\nreturn\n(\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\nanimate\n=\n{\nisActive\n?\n\"active\"\n:\n\"inactive\"\n}\n/>\n)\nstyle\nThe normal React DOM\nstyle\nprop, with added support for\nmotion values\nand independent transforms.\nconst\nx\n=\nuseMotionValue\n(\n30\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\nrotate\n:\n90\n,\noriginX\n:\n0.5\n}\n}\n/>\nonUpdate\nCallback triggered every frame any value on the\nmotion\ncomponent updates. It's provided a single argument with the latest values.\n<\nmotion\n.\narticle\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nonUpdate\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nopacity\n)\n}\n/>\nonAnimationStart\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationStart\n) starts.\nIt's provided a single argument, with the target or variant name of the started animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationStart\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nonAnimationComplete\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationComplete\n) completes.\nIt's provided a single argument, with the target or variant name of the completed animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationComplete\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nHover\nwhileHover\nAnimation state, or variant label, to perform a\nhover animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileHover\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileHover\n=\n\"hovered\"\n/>\nonHoverStart\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonHoverEnd\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverEnd\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nTap\nwhileTap\nAnimation state, or variant label, to perform a\npress animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileTap\n=\n\"tapped\"\n/>\nonTapStart\nCallback function that fires when a pointer starts pressing the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTap\nCallback function that fires when a pointer stops pressing the component and the pointer was released\ninside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTap\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTapCancel\nCallback function that fires when a pointer stops pressing the component and the pointer was released\noutside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapCancel\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nFocus\nwhileFocus\nAnimation state, or variant label, to animate to while the focus gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileFocus\n=\n{\n{\noutline\n:\n\"dashed #000\"\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileFocus\n=\n\"focused\"\n/>\nPan\nonPan\nCallback function that fires when the pan gesture is recognised on this element.\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the\ntouch-action\nCSS rule.\nfunction\nonPan\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\nonPan\n=\n{\nonPan\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonPanStart\nCallback function that fires when a pan gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonPanEnd\nCallback function that fires when a pan gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nDrag\ndrag\nDefault:\nfalse\nEnable dragging for this element. Set\ntrue\nto drag in both directions. Set\n\"x\"\nor\n\"y\"\nto only drag in a specific direction.\n<\nmotion\n.\ndiv\ndrag\n/>\nwhileDrag\nAnimation state, or variant label, to perform a\ndrag animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n\"dragging\"\n/>\ndragConstraints\nApplies constraints on the draggable area.\nSet as an object of optional\ntop\n,\nleft\n,\nright\n, and\nbottom\nvalues, measured in pixels:\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\n/>\nOr as a\nref\nto another element to use its bounding box as the draggable constraints:\nconst\nMyComponent\n=\n(\n)\n=>\n{\nconst\nconstraintsRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nconstraintsRef\n}\n>\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\nconstraintsRef\n}\n/>\n</\nmotion\n.\ndiv\n>\n)\n}\ndragSnapToOrigin\nDefault:\nfalse\nIf\ntrue\n, the draggable element will animate back to its center/origin when released.\n<\nmotion\n.\ndiv\ndrag\ndragSnapToOrigin\n/>\ndragElastic\nDefault:\n0.5\nThe degree of movement allowed outside constraints.\n0\n= no movement,\n1\n= full movement.\nSet to\n0.5\nby default. Can also be set as\nfalse\nto disable movement.\nBy passing an object of\ntop\n/\nright\n/\nbottom\n/\nleft\n, individual values can be set per constraint. Any missing values will be set to\n0\n.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragElastic\n=\n{\n0.2\n}\n/>\ndragMomentum\nDefault:\ntrue\nApply momentum from the pan gesture to the component when dragging finishes. Set to\ntrue\nby default.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragMomentum\n=\n{\nfalse\n}\n/>\ndragTransition\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type\n\"inertia\"\nstarts. The animation is based on your dragging velocity. This property allows you to customize it.\n<\nmotion\n.\ndiv\ndrag\ndragTransition\n=\n{\n{\nbounceStiffness\n:\n600\n,\nbounceDamping\n:\n10\n}\n}\n/>\ndragDirectionLock\nDefault:\nfalse\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the\nx\naxis than\ny\naxis before the drag gesture kicks in, it will\nonly\ndrag on the\nx\naxis for the remainder of the gesture.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\n/>\ndragPropagation\nDefault:\nfalse\nAllows drag gesture propagation to child components.\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragPropagation\n/>\ndragControls\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\nBy creating a\ndragControls\nusing the\nuseDragControls\nhook\n, we can pass this into the draggable component's\ndragControls\nprop. It exposes a\nstart\nmethod that can start dragging from pointer events on other components.\nconst\ndragControls\n=\nuseDragControls\n(\n)\nfunction\nstartDrag\n(\nevent\n)\n{\ndragControls\n.\nstart\n(\nevent\n,\n{\nsnapToCursor\n:\ntrue\n}\n)\n}\nreturn\n(\n<\n>\n<\ndiv\nonPointerDown\n=\n{\nstartDrag\n}\n/>\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragControls\n=\n{\ndragControls\n}\n/>\n</\n>\n)\nGiven that by setting\ndragControls\nyou are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting\ndragListener={false}\n.\ndragListener\nDetermines whether to trigger the drag gesture from event listeners. If passing\ndragControls\n, setting this to\nfalse\nwill ensure dragging can only be initiated by the controls, rather than a\npointerdown\nevent on the draggable element.\nonDrag\nCallback function that fires when the drag gesture is recognised on this element.\nfunction\nonDrag\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\ndrag\nonDrag\n=\n{\nonDrag\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonDragStart\nCallback function that fires when a drag gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDragEnd\nCallback function that fires when a drag gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDirectionLock\nCallback function that fires a drag direction is determined.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\nonDirectionLock\n=\n{\naxis\n=>\nconsole\n.\nlog\n(\naxis\n)\n}\n/>\nViewport\nLearn more about\nscroll-triggered animations\nin React.\nwhileInView\nTarget or variants to label to while the element is in view.\n// As target\n<\nmotion\n.\ndiv\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileInView\n=\n\"visible\"\n/>\nviewport\nOptions to define how the element is tracked within the viewport.\n<\nmotion\n.\nsection\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nAvailable options:\nonce\n: If\ntrue\n, once element enters the viewport it won't detect subsequent leave/enter events.\nroot\n: The\nref\nof an ancestor scrollable element to detect intersections with (instead of\nwindow\n).\nmargin\n: A margin to add to the viewport to change the detection area. Defaults to\n\"0px\"\n. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\namount\n: The amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n. Defaults to\n\"some\"\n.\nonViewportEnter\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportEnter\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nisIntersecting\n)\n}\n/>\nonViewportLeave\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportLeave\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nintersectionRect\n)\n}\n/>\nLayout\nLearn more about\nlayout animations\nin React.\nlayout\nDefault:\nfalse\nIf\ntrue\n, this component will perform\nlayout animations\n.\n<\nmotion\n.\ndiv\nlayout\n/>\nIf set to\n\"position\"\nor\n\"size\"\n, only its position or size will animate, respectively.\n<\nmotion\n.\nimg\nlayout\n=\n\"position\"\n/>\nlayoutId\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching\nlayoutId\n, it will animate out from the previous element's size/position.\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\n>\n{\nitem\n.\nname\n}\n{\nitem\n.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\n}\n</\nmotion\n.\nli\n>\n)\n)\n}\nIf the previous component remains in the tree, the two elements will crossfade.\nlayoutDependency\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a\nlayoutDependency\nprop. Measurements will only occur when this value changes.\n<\nmotion\n.\nnav\nlayout\nlayoutDependency\n=\n{\nisOpen\n}\n/>\nlayoutScroll\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the\nlayoutScroll\nprop to elements that should be measured.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nlayoutRoot\nFor layout animations to work correctly within\nposition: fixed\nelements, we need to account for page scroll. Add\nlayoutRoot\nto mark an element as\nposition: fixed\n.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nonLayoutAnimationStart\nA callback to run when a layout animation starts.\nonLayoutAnimationComplete\nA callback to run when a layout animation completes.\nAdvanced\ninherit\nSet to\nfalse\nto prevent a component inheriting or propagating changes in a parent variant.\ncustom\nCustom data to pass through to dynamic variants.\nconst\nvariants\n=\n{\nvisible\n:\n(\ncustom\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\ncustom\n*\n0.2\n}\n}\n)\n}\nreturn\n(\n<\nmotion\n.\nul\nanimate\n=\n\"visible\"\n>\n<\nmotion\n.\nli\ncustom\n=\n{\n0\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n1\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n2\n}\nvariants\n=\n{\nvariants\n}\n/>\n</\nmotion\n.\nul\n>\n)\ntransformTemplate\nBy default, transforms are applied in order of\ntranslate\n,\nscale\n,\nrotate\nand\nskew\n.\nTo change this,\ntransformTemplate\ncan be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n// Use the latest transform values\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\n{\nx\n,\nrotate\n}\n)\n=>\n`rotate(\n${\nrotate\n}\ndeg) translateX(\n${\nx\n}\npx)`\n}\n/>\n// Or the generated transform string\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\nlatest\n,\ngenerated\n)\n=>\n`translate(-50%, -50%)\n${\ngenerated\n}\n`\n}\n/>\nMost\nReact animations\nin Motion are powered by the\n<motion />\ncomponent.\nThere's a\nmotion\ncomponent for every HTML and SVG element, for instance\nmotion.div\n,\nmotion.circle\netc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\nUsage\nImport\nmotion\nfrom Motion:\n// React\nimport\n{\nmotion\n}\nfrom\n\"motion/react\"\n// React Server Components (Next.js etc)\nimport\n*\nas\nmotion\nfrom\n\"motion/react-client\"\nYou can use a\nmotion\ncomponent exactly as you would any normal HTML/SVG component:\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n/>\nBut you also gain access to powerful animation APIs like the\nanimate\n,\nlayout\n,\nwhileInView\nprops.\n<\nmotion\n.\ndiv\nclassName\n=\n\"box\"\n// Animate when this value changes:\nanimate\n=\n{\n{\nscale\n:\n2\n}\n}\n// Fade in when the element enters the viewport:\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n// Animate the component when its layout changes:\nlayout\n// Style now supports indepedent transforms:\nstyle\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nPerformance\nmotion\ncomponents animate values without triggering React renders, for optimal performance.\nUsing\nmotion values\ninstead of React state to update\nstyle\nwill also avoid re-renders.\nconst\nx\n=\nuseMotionValue\n(\n0\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Won't trigger a re-render!\nconst\ntimeout\n=\nsetTimeout\n(\n(\n)\n=>\nx\n.\nset\n(\n100\n)\n,\n1000\n)\nreturn\n(\n)\n=>\nclearTimeout\n(\ntimeout\n)\n}\n,\n[\n]\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n}\n}\n/>\nServer-side rendering\nmotion\ncomponents are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n// Server will output `translateX(100px)`\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nx\n:\n100\n}\n}\n/>\nCustom components\nAny React component can be turned into a\nmotion\ncomponent by passing it to\nmotion.create()\n.\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\nComponent\n)\nYour component\nmust\npass a ref to the component you want to animate.\nReact 18:\nUse\nforwardRef\nto wrap the component and pass\nref\nto the element you want to animate:\nconst\nComponent\n=\nReact\n.\nforwardRef\n(\n(\nprops\n,\nref\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\n)\nReact 19:\nReact 19 can pass\nref\nvia\nprops\n:\nconst\nComponent\n=\n(\nprops\n)\n=>\n{\nreturn\n<\ndiv\nref\n=\n{\nprops\n.\nref\n}\n/>\n}\n)\nMake sure\nnot\nto call\nmotion.create()\nwithin a React render function! This will make a new component every render, breaking your animations.\nIt's also possible to pass strings to\nmotion.create\n, which will create custom DOM elements.\n// Will render <custom-element /> into HTML\nconst\nMotionComponent\n=\nmotion\n.\ncreate\n(\n'custom-element'\n)\nBy default, all\nmotion\nprops (like\nanimate\netc) are filtered out of the\nprops\nforwarded to the provided component. By providing a\nforwardMotionProps\nconfig, the provided component will receive these props.\nmotion\n.\ncreate\n(\nComponent\n,\n{\nforwardMotionProps\n:\ntrue\n}\n)\nProps\nmotion\ncomponents accept the following props.\nAnimation\nMotion provides declarative animation props like\nanimate\nand\nexit\n.\nLearn more about React animations in Motion\n.\ninitial\nThe initial visual state of the\nmotion\ncomponent.\nThis can be set as an animation target:\n<\nmotion\n.\nsection\ninitial\n=\n{\n{\nopacity\n:\n0\n,\nx\n:\n0\n}\n}\n/>\nVariants:\n<\nmotion\n.\nli\ninitial\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nOr set as\nfalse\nto disable the enter animation and initially render as the values found in\nanimate\n.\n<\nmotion\n.\ndiv\ninitial\n=\n{\nfalse\n}\nanimate\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\nanimate\nA target to animate to on enter, and on update.\nCan be set as an animation target:\n<\nmotion\n.\ndiv\ninitial\n=\n{\n{\nboxShadow\n:\n\"0px 0px #000\"\n}\n}\nanimate\n=\n{\n{\nboxShadow\n:\n\"10px 10px #000\"\n}\n}\n/>\nOr variants:\n<\nmotion\n.\nli\nanimate\n=\n\"visible\"\n/>\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n{\n[\n\"visible\"\n,\n\"active\"\n]\n}\n/>\nexit\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\nOwing to React limitations, the component being removed\nmust\nbe a\ndirect child\nof\nAnimatePresence\nto enable this animation.\ntransition\nThe default\ntransition\nfor this component to use when an animation prop (\nanimate\n,\nwhileHover\netc) has no\ntransition\ndefined.\n<\nmotion\n.\ndiv\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\nanimate\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the\nMotion extension\n.\nvariants\nThe\nvariants\nfor this component.\nconst\nvariants\n=\n{\nactive\n:\n{\nbackgroundColor\n:\n\"#f00\"\n}\n,\ninactive\n:\n{\nbackgroundColor\n:\n\"#fff\"\n,\ntransition\n:\n{\nduration\n:\n2\n}\n}\n}\nreturn\n(\n<\nmotion\n.\ndiv\nvariants\n=\n{\nvariants\n}\nanimate\n=\n{\nisActive\n?\n\"active\"\n:\n\"inactive\"\n}\n/>\n)\nstyle\nThe normal React DOM\nstyle\nprop, with added support for\nmotion values\nand independent transforms.\nconst\nx\n=\nuseMotionValue\n(\n30\n)\nreturn\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n,\nrotate\n:\n90\n,\noriginX\n:\n0.5\n}\n}\n/>\nonUpdate\nCallback triggered every frame any value on the\nmotion\ncomponent updates. It's provided a single argument with the latest values.\n<\nmotion\n.\narticle\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nonUpdate\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nopacity\n)\n}\n/>\nonAnimationStart\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationStart\n) starts.\nIt's provided a single argument, with the target or variant name of the started animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationStart\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nonAnimationComplete\nCallback triggered when any animation (except layout animations, see\nonLayoutAnimationComplete\n) completes.\nIt's provided a single argument, with the target or variant name of the completed animation.\n<\nmotion\n.\ncircle\nanimate\n=\n{\n{\nr\n:\n10\n}\n}\nonAnimationComplete\n=\n{\nlatest\n=>\nconsole\n.\nlog\n(\nlatest\n.\nr\n)\n}\n/>\nHover\nwhileHover\nAnimation state, or variant label, to perform a\nhover animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileHover\n=\n{\n{\nscale\n:\n1.2\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileHover\n=\n\"hovered\"\n/>\nonHoverStart\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonHoverEnd\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonHoverEnd\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nTap\nwhileTap\nAnimation state, or variant label, to perform a\npress animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileTap\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileTap\n=\n\"tapped\"\n/>\nonTapStart\nCallback function that fires when a pointer starts pressing the component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapStart\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTap\nCallback function that fires when a pointer stops pressing the component and the pointer was released\ninside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTap\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nonTapCancel\nCallback function that fires when a pointer stops pressing the component and the pointer was released\noutside\nthe component. Provided the triggering\nPointerEvent\n.\n<\nmotion\n.\ndiv\nonTapCancel\n=\n{\n(\nevent\n)\n=>\nconsole\n.\nlog\n(\nevent\n)\n}\n/>\nFocus\nwhileFocus\nAnimation state, or variant label, to animate to while the focus gesture is active.\n// As target\n<\nmotion\n.\nbutton\nwhileFocus\n=\n{\n{\noutline\n:\n\"dashed #000\"\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileFocus\n=\n\"focused\"\n/>\nPan\nonPan\nCallback function that fires when the pan gesture is recognised on this element.\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the\ntouch-action\nCSS rule.\nfunction\nonPan\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\nonPan\n=\n{\nonPan\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonPanStart\nCallback function that fires when a pan gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonPanEnd\nCallback function that fires when a pan gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\nonPanEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nDrag\ndrag\nDefault:\nfalse\nEnable dragging for this element. Set\ntrue\nto drag in both directions. Set\n\"x\"\nor\n\"y\"\nto only drag in a specific direction.\n<\nmotion\n.\ndiv\ndrag\n/>\nwhileDrag\nAnimation state, or variant label, to perform a\ndrag animation\nto while the hover gesture is active.\n// As target\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n{\n{\nscale\n:\n0.9\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\ndrag\nwhileDrag\n=\n\"dragging\"\n/>\ndragConstraints\nApplies constraints on the draggable area.\nSet as an object of optional\ntop\n,\nleft\n,\nright\n, and\nbottom\nvalues, measured in pixels:\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\n/>\nOr as a\nref\nto another element to use its bounding box as the draggable constraints:\nconst\nMyComponent\n=\n(\n)\n=>\n{\nconst\nconstraintsRef\n=\nuseRef\n(\nnull\n)\nreturn\n(\n<\nmotion\n.\ndiv\nref\n=\n{\nconstraintsRef\n}\n>\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\nconstraintsRef\n}\n/>\n</\nmotion\n.\ndiv\n>\n)\n}\ndragSnapToOrigin\nDefault:\nfalse\nIf\ntrue\n, the draggable element will animate back to its center/origin when released.\n<\nmotion\n.\ndiv\ndrag\ndragSnapToOrigin\n/>\ndragElastic\nDefault:\n0.5\nThe degree of movement allowed outside constraints.\n0\n= no movement,\n1\n= full movement.\nSet to\n0.5\nby default. Can also be set as\nfalse\nto disable movement.\nBy passing an object of\ntop\n/\nright\n/\nbottom\n/\nleft\n, individual values can be set per constraint. Any missing values will be set to\n0\n.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragElastic\n=\n{\n0.2\n}\n/>\ndragMomentum\nDefault:\ntrue\nApply momentum from the pan gesture to the component when dragging finishes. Set to\ntrue\nby default.\n<\nmotion\n.\ndiv\ndrag\ndragConstraints\n=\n{\n{\nleft\n:\n0\n,\nright\n:\n300\n}\n}\ndragMomentum\n=\n{\nfalse\n}\n/>\ndragTransition\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type\n\"inertia\"\nstarts. The animation is based on your dragging velocity. This property allows you to customize it.\n<\nmotion\n.\ndiv\ndrag\ndragTransition\n=\n{\n{\nbounceStiffness\n:\n600\n,\nbounceDamping\n:\n10\n}\n}\n/>\ndragDirectionLock\nDefault:\nfalse\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the\nx\naxis than\ny\naxis before the drag gesture kicks in, it will\nonly\ndrag on the\nx\naxis for the remainder of the gesture.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\n/>\ndragPropagation\nDefault:\nfalse\nAllows drag gesture propagation to child components.\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragPropagation\n/>\ndragControls\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\nBy creating a\ndragControls\nusing the\nuseDragControls\nhook\n, we can pass this into the draggable component's\ndragControls\nprop. It exposes a\nstart\nmethod that can start dragging from pointer events on other components.\nconst\ndragControls\n=\nuseDragControls\n(\n)\nfunction\nstartDrag\n(\nevent\n)\n{\ndragControls\n.\nstart\n(\nevent\n,\n{\nsnapToCursor\n:\ntrue\n}\n)\n}\nreturn\n(\n<\n>\n<\ndiv\nonPointerDown\n=\n{\nstartDrag\n}\n/>\n<\nmotion\n.\ndiv\ndrag\n=\n\"x\"\ndragControls\n=\n{\ndragControls\n}\n/>\n</\n>\n)\nGiven that by setting\ndragControls\nyou are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting\ndragListener={false}\n.\ndragListener\nDetermines whether to trigger the drag gesture from event listeners. If passing\ndragControls\n, setting this to\nfalse\nwill ensure dragging can only be initiated by the controls, rather than a\npointerdown\nevent on the draggable element.\nonDrag\nCallback function that fires when the drag gesture is recognised on this element.\nfunction\nonDrag\n(\nevent\n,\ninfo\n)\n{\nconsole\n.\nlog\n(\ninfo\n.\npoint\n.\nx\n,\ninfo\n.\npoint\n.\ny\n)\n}\n<\nmotion\n.\ndiv\ndrag\nonDrag\n=\n{\nonDrag\n}\n/>\nPan and drag events are provided the origin\nPointerEvent\nas well as an object\ninfo\nthat contains\nx\nand\ny\npoint values for the following:\npoint\n: Relative to the device or page.\ndelta\n: Distance since the last event.\noffset\n: Distance from the original event.\nvelocity\n: Current velocity of the pointer.\nonDragStart\nCallback function that fires when a drag gesture starts. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragStart\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDragEnd\nCallback function that fires when a drag gesture ends. Provided the triggering\nPointerEvent\nand\ninfo\n.\n<\nmotion\n.\ndiv\ndrag\nonDragEnd\n=\n{\n(\nevent\n,\ninfo\n)\n=>\nconsole\n.\nlog\n(\ninfo\n.\ndelta\n.\nx\n)\n}\n/>\nonDirectionLock\nCallback function that fires a drag direction is determined.\n<\nmotion\n.\ndiv\ndrag\ndragDirectionLock\nonDirectionLock\n=\n{\naxis\n=>\nconsole\n.\nlog\n(\naxis\n)\n}\n/>\nViewport\nLearn more about\nscroll-triggered animations\nin React.\nwhileInView\nTarget or variants to label to while the element is in view.\n// As target\n<\nmotion\n.\ndiv\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\n/>\n// As variants\n<\nmotion\n.\ndiv\nwhileInView\n=\n\"visible\"\n/>\nviewport\nOptions to define how the element is tracked within the viewport.\n<\nmotion\n.\nsection\nwhileInView\n=\n{\n{\nopacity\n:\n1\n}\n}\nviewport\n=\n{\n{\nonce\n:\ntrue\n}\n}\n/>\nAvailable options:\nonce\n: If\ntrue\n, once element enters the viewport it won't detect subsequent leave/enter events.\nroot\n: The\nref\nof an ancestor scrollable element to detect intersections with (instead of\nwindow\n).\nmargin\n: A margin to add to the viewport to change the detection area. Defaults to\n\"0px\"\n. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\namount\n: The amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n. Defaults to\n\"some\"\n.\nonViewportEnter\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportEnter\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nisIntersecting\n)\n}\n/>\nonViewportLeave\nCallback function that fires when an element enters the viewport. Provided the\nIntersectionObserverEntry\nwith details of the intersection event.\n<\nmotion\n.\ndiv\nonViewportLeave\n=\n{\n(\nentry\n)\n=>\nconsole\n.\nlog\n(\nentry\n.\nintersectionRect\n)\n}\n/>\nLayout\nLearn more about\nlayout animations\nin React.\nlayout\nDefault:\nfalse\nIf\ntrue\n, this component will perform\nlayout animations\n.\n<\nmotion\n.\ndiv\nlayout\n/>\nIf set to\n\"position\"\nor\n\"size\"\n, only its position or size will animate, respectively.\n<\nmotion\n.\nimg\nlayout\n=\n\"position\"\n/>\nlayoutId\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching\nlayoutId\n, it will animate out from the previous element's size/position.\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\n>\n{\nitem\n.\nname\n}\n{\nitem\n.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\n}\n</\nmotion\n.\nli\n>\n)\n)\n}\nIf the previous component remains in the tree, the two elements will crossfade.\nlayoutDependency\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a\nlayoutDependency\nprop. Measurements will only occur when this value changes.\n<\nmotion\n.\nnav\nlayout\nlayoutDependency\n=\n{\nisOpen\n}\n/>\nlayoutScroll\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the\nlayoutScroll\nprop to elements that should be measured.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nlayoutRoot\nFor layout animations to work correctly within\nposition: fixed\nelements, we need to account for page scroll. Add\nlayoutRoot\nto mark an element as\nposition: fixed\n.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\n/>\n</\nmotion\n.\ndiv\n>\nonLayoutAnimationStart\nA callback to run when a layout animation starts.\nonLayoutAnimationComplete\nA callback to run when a layout animation completes.\nAdvanced\ninherit\nSet to\nfalse\nto prevent a component inheriting or propagating changes in a parent variant.\ncustom\nCustom data to pass through to dynamic variants.\nconst\nvariants\n=\n{\nvisible\n:\n(\ncustom\n)\n=>\n(\n{\nopacity\n:\n1\n,\ntransition\n:\n{\ndelay\n:\ncustom\n*\n0.2\n}\n}\n)\n}\nreturn\n(\n<\nmotion\n.\nul\nanimate\n=\n\"visible\"\n>\n<\nmotion\n.\nli\ncustom\n=\n{\n0\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n1\n}\nvariants\n=\n{\nvariants\n}\n/>\n<\nmotion\n.\nli\ncustom\n=\n{\n2\n}\nvariants\n=\n{\nvariants\n}\n/>\n</\nmotion\n.\nul\n>\n)\ntransformTemplate\nBy default, transforms are applied in order of\ntranslate\n,\nscale\n,\nrotate\nand\nskew\n.\nTo change this,\ntransformTemplate\ncan be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n// Use the latest transform values\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\n{\nx\n,\nrotate\n}\n)\n=>\n`rotate(\n${\nrotate\n}\ndeg) translateX(\n${\nx\n}\npx)`\n}\n/>\n// Or the generated transform string\n<\nmotion\n.\ndiv\nstyle\n=\n{\n{\nx\n:\n0\n,\nrotate\n:\n180\n}\n}\ntransformTemplate\n=\n{\n(\nlatest\n,\ngenerated\n)\n=>\n`translate(-50%, -50%)\n${\ngenerated\n}\n`\n}\n/>\nRelated topics\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nSVG animation\nAnimate SVGs in React - Line drawing and morphing effects, and more.\nSVG animation\nAnimate SVGs in React - Line drawing and morphing effects, and more.\nSVG animation\nAnimate SVGs in React - Line drawing and morphing effects, and more.\nMotion component examples\nSee all examples & tutorials, with full copy & paste source code.\nMotion component examples\nSee all examples & tutorials, with full copy & paste source code.\nMotion component examples\nSee all examples & tutorials, with full copy & paste source code.\nTutorial\nMagnetic filings\nAn example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.\nTutorial\nMagnetic filings\nAn example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.\nTutorial\nMagnetic filings\nAn example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.\nPrevious\nDrag animation\nNext\nAnimateActivity\nMotion+\nMotion+\nMotion+\nLove animating with components?\nMotion+ includes premium animation components like Cursor and Ticker that will save you hours of development time.\nSee the full feature list\nSee the full feature list\nSee the full feature list\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "Most [React animations](./react-animation) in Motion are powered by the `<motion />` component.\n\nThere's a `motion` component for every HTML and SVG element, for instance `motion.div`, `motion.circle` etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\n\n## [Usage](#usage)\n\nImport `motion` from Motion:\n\n```\n// React\nimport { motion } from \"motion/react\"\n\n// React Server Components (Next.js etc)\nimport * as motion from \"motion/react-client\"\n```\n\nYou can use a `motion` component exactly as you would any normal HTML/SVG component:\n\n```\n<motion.div className=\"box\" />\n```\n\nBut you also gain access to powerful animation APIs like the `animate`, `layout`, `whileInView` props.\n\n```\n<motion.div\n  className=\"box\"\n  // Animate when this value changes:\n  animate={{ scale: 2 }}\n  // Fade in when the element enters the viewport:\n  whileInView={{ opacity: 1 }}\n  // Animate the component when its layout changes:\n  layout\n  // Style now supports indepedent transforms:\n  style={{ x: 100 }}\n/>\n```\n\n### [Performance](#performance)\n\n`motion` components animate values without triggering React renders, for optimal performance.\n\nUsing [motion values](./react-motion-value) instead of React state to update `style` will also avoid re-renders.\n\n```\nconst x = useMotionValue(0)\n\nuseEffect(() => {\n  // Won't trigger a re-render!\n  const timeout = setTimeout(() => x.set(100), 1000)\n\n  return () => clearTimeout(timeout)\n}, [])\n\nreturn <motion.div style={{ x }} />\n```\n\n### [Server-side rendering](#server-side-rendering)\n\n`motion` components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n\n```\n// Server will output `translateX(100px)`\n<motion.div initial={false} animate={{ x: 100 }} />\n```\n\n### [Custom components](#custom-components)\n\nAny React component can be turned into a `motion` component by passing it to `motion.create()`.\n\n```\nconst MotionComponent = motion.create(Component)\n```\n\nYour component **must** pass a ref to the component you want to animate.\n\n**React 18:** Use `forwardRef` to wrap the component and pass `ref` to the element you want to animate:\n\n```\nconst Component = React.forwardRef((props, ref) => {\n  return <div ref={ref} />\n})\n```\n\n**React 19:** React 19 can pass `ref` via `props`:\n\n```\nconst Component = (props) => {\n  return <div ref={props.ref} />\n})\n```\n\nMake sure **not** to call `motion.create()` within a React render function! This will make a new component every render, breaking your animations.\n\nIt's also possible to pass strings to `motion.create`, which will create custom DOM elements.\n\n```\n// Will render <custom-element /> into HTML\nconst MotionComponent = motion.create('custom-element')\n```\n\nBy default, all `motion` props (like `animate` etc) are filtered out of the `props` forwarded to the provided component. By providing a `forwardMotionProps` config, the provided component will receive these props.\n\n```\nmotion.create(Component, { forwardMotionProps: true })\n```\n\n## [Props](#props)\n\n`motion` components accept the following props.\n\n### [Animation](#animation)\n\nMotion provides declarative animation props like `animate` and `exit`. [Learn more about React animations in Motion](./react-animation).\n\n#### [`initial`](#initial)\n\nThe initial visual state of the `motion` component.\n\nThis can be set as an animation target:\n\n```\n<motion.section initial={{ opacity: 0, x: 0 }} />\n```\n\nVariants:\n\n```\n<motion.li initial=\"visible\" />\n```\n\n```\n<motion.div initial={[\"visible\", \"active\"]} />\n```\n\nOr set as `false` to disable the enter animation and initially render as the values found in `animate`.\n\n```\n<motion.div initial={false} animate={{ opacity: 0 }} />\n```\n\n#### [`animate`](#animate)\n\nA target to animate to on enter, and on update.\n\nCan be set as an animation target:\n\n```\n<motion.div\n  initial={{ boxShadow: \"0px 0px #000\" }}\n  animate={{ boxShadow: \"10px 10px #000\" }}\n/>\n```\n\nOr variants:\n\n```\n<motion.li animate=\"visible\" />\n```\n\n```\n<motion.div initial=\"hidden\" animate={[\"visible\", \"active\"]} />\n```\n\n#### [`exit`](#exit)\n\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\n\nOwing to React limitations, the component being removed **must** be a **direct child** of `AnimatePresence` to enable this animation.\n\n#### [`transition`](#transition)\n\nThe default [transition](./react-transitions) for this component to use when an animation prop (`animate`, `whileHover` etc) has no `transition` defined.\n\n```\n<motion.div transition={{ type: \"spring\" }} animate={{ scale: 1.2 }} />\n```\n\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the [Motion extension](./studio-install).\n\n#### [`variants`](#variants)\n\nThe [variants](./react-animation#variants) for this component.\n\n```\nconst variants = {\n  active: {\n      backgroundColor: \"#f00\"\n  },\n  inactive: {\n    backgroundColor: \"#fff\",\n    transition: { duration: 2 }\n  }\n}\n\nreturn (\n  <motion.div\n    variants={variants}\n    animate={isActive ? \"active\" : \"inactive\"}\n  />\n)\n```\n\n#### [`style`](#style)\n\nThe normal React DOM `style` prop, with added support for [motion values](./react-motion-value) and independent transforms.\n\n```\nconst x = useMotionValue(30)\n\nreturn <motion.div style={{ x, rotate: 90, originX: 0.5 }} />\n```\n\n#### [`onUpdate`](#onupdate)\n\nCallback triggered every frame any value on the `motion` component updates. It's provided a single argument with the latest values.\n\n```\n<motion.article\n  animate={{ opacity: 1 }}\n  onUpdate={latest => console.log(latest.opacity)}\n/>\n```\n\n#### [`onAnimationStart`](#onanimationstart)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationStart`) starts.\n\nIt's provided a single argument, with the target or variant name of the started animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationStart={latest => console.log(latest.r)}\n/>\n```\n\n#### [`onAnimationComplete`](#onanimationcomplete)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationComplete`) completes.\n\nIt's provided a single argument, with the target or variant name of the completed animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationComplete={latest => console.log(latest.r)}\n/>\n```\n\n### [Hover](#hover)\n\n#### [`whileHover`](#whilehover)\n\nAnimation state, or variant label, to perform a [hover animation](./react-hover-animation) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileHover={{ scale: 1.2 }} />\n```\n\n```\n// As variants\n<motion.div whileHover=\"hovered\" />\n```\n\n#### [`onHoverStart`](#onhoverstart)\n\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverStart={(event) => console.log(event)} />\n```\n\n#### [`onHoverEnd`](#onhoverend)\n\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverEnd={(event) => console.log(event)} />\n```\n\n#### [Tap](#tap)\n\n#### [`whileTap`](#whiletap)\n\nAnimation state, or variant label, to perform a [press animation](./react-gestures) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileTap={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div whileTap=\"tapped\" />\n```\n\n#### [`onTapStart`](#ontapstart)\n\nCallback function that fires when a pointer starts pressing the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapStart={(event) => console.log(event)} />\n```\n\n#### [`onTap`](#ontap)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **inside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTap={(event) => console.log(event)} />\n```\n\n#### [`onTapCancel`](#ontapcancel)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **outside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapCancel={(event) => console.log(event)} />\n```\n\n### [Focus](#focus)\n\n#### [`whileFocus`](#whilefocus)\n\nAnimation state, or variant label, to animate to while the focus gesture is active.\n\n```\n// As target\n<motion.button whileFocus={{ outline: \"dashed #000\" }} />\n```\n\n```\n// As variants\n<motion.div whileFocus=\"focused\" />\n```\n\n### [Pan](#pan)\n\n#### [`onPan`](#onpan)\n\nCallback function that fires when the pan gesture is recognised on this element.\n\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the `touch-action` CSS rule.\n\n```\nfunction onPan(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div onPan={onPan} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onPanStart`](#onpanstart)\n\nCallback function that fires when a pan gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onPanEnd`](#onpanend)\n\nCallback function that fires when a pan gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n### [Drag](#drag)\n\n#### [`drag`](#drag-1)\n\n**Default:** `false`\n\nEnable dragging for this element. Set `true` to drag in both directions. Set `\"x\"` or `\"y\"` to only drag in a specific direction.\n\n```\n<motion.div drag />\n```\n\n#### [`whileDrag`](#whiledrag)\n\nAnimation state, or variant label, to perform a [drag animation](./react-drag) to while the hover gesture is active.\n\n```\n// As target\n<motion.div drag whileDrag={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div drag whileDrag=\"dragging\" />\n```\n\n#### [`dragConstraints`](#dragconstraints)\n\nApplies constraints on the draggable area.\n\nSet as an object of optional `top`, `left`, `right`, and `bottom` values, measured in pixels:\n\n```\n<motion.div\n  drag=\"x\"\n  dragConstraints={{ left: 0, right: 300 }}\n/>\n```\n\nOr as a `ref` to another element to use its bounding box as the draggable constraints:\n\n```\nconst MyComponent = () => {\n  const constraintsRef = useRef(null)\n\n  return (\n     <motion.div ref={constraintsRef}>\n         <motion.div drag dragConstraints={constraintsRef} />\n     </motion.div>\n  )\n}\n```\n\n#### [`dragSnapToOrigin`](#dragsnaptoorigin)\n\n**Default:** `false`\n\nIf `true`, the draggable element will animate back to its center/origin when released.\n\n```\n<motion.div drag dragSnapToOrigin />\n```\n\n#### [`dragElastic`](#dragelastic)\n\n**Default:** `0.5`\n\nThe degree of movement allowed outside constraints. `0` = no movement, `1` = full movement.\n\nSet to `0.5` by default. Can also be set as `false` to disable movement.\n\nBy passing an object of `top`/`right`/`bottom`/`left`, individual values can be set per constraint. Any missing values will be set to `0`.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragElastic={0.2}\n/>\n```\n\n#### [`dragMomentum`](#dragmomentum)\n\n**Default:** `true`\n\nApply momentum from the pan gesture to the component when dragging finishes. Set to `true` by default.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragMomentum={false}\n/>\n```\n\n#### [`dragTransition`](#dragtransition)\n\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type `\"inertia\"` starts. The animation is based on your dragging velocity. This property allows you to customize it.\n\n```\n<motion.div\n  drag\n  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}\n/>\n```\n\n#### [`dragDirectionLock`](#dragdirectionlock)\n\n**Default:** `false`\n\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the `x` axis than `y` axis before the drag gesture kicks in, it will **only** drag on the `x` axis for the remainder of the gesture.\n\n```\n<motion.div drag dragDirectionLock />\n```\n\n#### [`dragPropagation`](#dragpropagation)\n\n**Default:** `false`\n\nAllows drag gesture propagation to child components.\n\n```\n<motion.div drag=\"x\" dragPropagation />\n```\n\n#### [`dragControls`](#dragcontrols)\n\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\n\nBy creating a `dragControls` using the `useDragControls` [hook](./react-use-drag-controls), we can pass this into the draggable component's `dragControls` prop. It exposes a `start` method that can start dragging from pointer events on other components.\n\n```\nconst dragControls = useDragControls()\n\nfunction startDrag(event) {\n  dragControls.start(event, { snapToCursor: true })\n}\n\nreturn (\n  <>\n    <div onPointerDown={startDrag} />\n    <motion.div drag=\"x\" dragControls={dragControls} />\n  </>\n)\n```\n\nGiven that by setting `dragControls` you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting `dragListener={false}`.\n\n#### [`dragListener`](#draglistener)\n\nDetermines whether to trigger the drag gesture from event listeners. If passing `dragControls`, setting this to `false` will ensure dragging can only be initiated by the controls, rather than a `pointerdown` event on the draggable element.\n\n#### [`onDrag`](#ondrag)\n\nCallback function that fires when the drag gesture is recognised on this element.\n\n```\nfunction onDrag(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div drag onDrag={onDrag} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onDragStart`](#ondragstart)\n\nCallback function that fires when a drag gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDragEnd`](#ondragend)\n\nCallback function that fires when a drag gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDirectionLock`](#ondirectionlock)\n\nCallback function that fires a drag direction is determined.\n\n```\n<motion.div\n  drag\n  dragDirectionLock\n  onDirectionLock={axis => console.log(axis)}\n/>\n```\n\n### [Viewport](#viewport)\n\nLearn more about [scroll-triggered animations](./react-scroll-animations) in React.\n\n#### [`whileInView`](#whileinview)\n\nTarget or variants to label to while the element is in view.\n\n```\n// As target\n<motion.div whileInView={{ opacity: 1 }} />\n```\n\n```\n// As variants\n<motion.div whileInView=\"visible\" />\n```\n\n#### [`viewport`](#viewport-1)\n\nOptions to define how the element is tracked within the viewport.\n\n```\n<motion.section\n  whileInView={{ opacity: 1 }}\n  viewport={{ once: true }}\n/>\n```\n\nAvailable options:\n\n- `once`: If `true`, once element enters the viewport it won't detect subsequent leave/enter events.\n- `root`: The `ref` of an ancestor scrollable element to detect intersections with (instead of `window`).\n- `margin`: A margin to add to the viewport to change the detection area. Defaults to `\"0px\"`. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n- `amount`: The amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`. Defaults to `\"some\"`.\n\n#### [`onViewportEnter`](#onviewportenter)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />\n```\n\n#### [`onViewportLeave`](#onviewportleave)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />\n```\n\n### [Layout](#layout)\n\nLearn more about [layout animations](./react-layout-animations) in React.\n\n#### [`layout`](#layout-1)\n\n**Default:** `false`\n\nIf `true`, this component will perform [layout animations](./react-layout-animations).\n\n```\n<motion.div layout />\n```\n\nIf set to `\"position\"` or `\"size\"`, only its position or size will animate, respectively.\n\n```\n<motion.img layout=\"position\" />\n```\n\n#### [`layoutId`](#layoutid)\n\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching `layoutId`, it will animate out from the previous element's size/position.\n\n```\n{items.map(item => (\n   <motion.li layout>\n      {item.name}\n      {item.isSelected && <motion.div layoutId=\"underline\" />}\n   </motion.li>\n))}\n```\n\nIf the previous component remains in the tree, the two elements will crossfade.\n\n#### [`layoutDependency`](#layoutdependency)\n\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a `layoutDependency` prop. Measurements will only occur when this value changes.\n\n```\n<motion.nav layout layoutDependency={isOpen} />\n```\n\n#### [`layoutScroll`](#layoutscroll)\n\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the `layoutScroll` prop to elements that should be measured.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`layoutRoot`](#layoutroot)\n\nFor layout animations to work correctly within `position: fixed` elements, we need to account for page scroll. Add `layoutRoot` to mark an element as `position: fixed`.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`onLayoutAnimationStart`](#onlayoutanimationstart)\n\nA callback to run when a layout animation starts.\n\n#### [`onLayoutAnimationComplete`](#onlayoutanimationcomplete)\n\nA callback to run when a layout animation completes.\n\n### [Advanced](#advanced)\n\n#### [`inherit`](#inherit)\n\nSet to `false` to prevent a component inheriting or propagating changes in a parent variant.\n\n#### [`custom`](#custom)\n\nCustom data to pass through to dynamic variants.\n\n```\nconst variants = {\n  visible: (custom) => ({\n    opacity: 1,\n    transition: { delay: custom * 0.2 }\n  })\n}\n\nreturn (\n  <motion.ul animate=\"visible\">\n    <motion.li custom={0} variants={variants} />\n    <motion.li custom={1} variants={variants} />\n    <motion.li custom={2} variants={variants} />\n  </motion.ul>\n)\n```\n\n#### [`transformTemplate`](#transformtemplate)\n\nBy default, transforms are applied in order of `translate`, `scale`, `rotate` and `skew`.\n\nTo change this, `transformTemplate` can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n\n```\n// Use the latest transform values\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`\n  }\n/>\n```\n\n```\n// Or the generated transform string\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    (latest, generated) => `translate(-50%, -50%) ${generated}`\n  }\n/>\n```\n\nMost [React animations](./react-animation) in Motion are powered by the `<motion />` component.\n\nThere's a `motion` component for every HTML and SVG element, for instance `motion.div`, `motion.circle` etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\n\n## [Usage](#usage)\n\nImport `motion` from Motion:\n\n```\n// React\nimport { motion } from \"motion/react\"\n\n// React Server Components (Next.js etc)\nimport * as motion from \"motion/react-client\"\n```\n\nYou can use a `motion` component exactly as you would any normal HTML/SVG component:\n\n```\n<motion.div className=\"box\" />\n```\n\nBut you also gain access to powerful animation APIs like the `animate`, `layout`, `whileInView` props.\n\n```\n<motion.div\n  className=\"box\"\n  // Animate when this value changes:\n  animate={{ scale: 2 }}\n  // Fade in when the element enters the viewport:\n  whileInView={{ opacity: 1 }}\n  // Animate the component when its layout changes:\n  layout\n  // Style now supports indepedent transforms:\n  style={{ x: 100 }}\n/>\n```\n\n### [Performance](#performance)\n\n`motion` components animate values without triggering React renders, for optimal performance.\n\nUsing [motion values](./react-motion-value) instead of React state to update `style` will also avoid re-renders.\n\n```\nconst x = useMotionValue(0)\n\nuseEffect(() => {\n  // Won't trigger a re-render!\n  const timeout = setTimeout(() => x.set(100), 1000)\n\n  return () => clearTimeout(timeout)\n}, [])\n\nreturn <motion.div style={{ x }} />\n```\n\n### [Server-side rendering](#server-side-rendering)\n\n`motion` components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n\n```\n// Server will output `translateX(100px)`\n<motion.div initial={false} animate={{ x: 100 }} />\n```\n\n### [Custom components](#custom-components)\n\nAny React component can be turned into a `motion` component by passing it to `motion.create()`.\n\n```\nconst MotionComponent = motion.create(Component)\n```\n\nYour component **must** pass a ref to the component you want to animate.\n\n**React 18:** Use `forwardRef` to wrap the component and pass `ref` to the element you want to animate:\n\n```\nconst Component = React.forwardRef((props, ref) => {\n  return <div ref={ref} />\n})\n```\n\n**React 19:** React 19 can pass `ref` via `props`:\n\n```\nconst Component = (props) => {\n  return <div ref={props.ref} />\n})\n```\n\nMake sure **not** to call `motion.create()` within a React render function! This will make a new component every render, breaking your animations.\n\nIt's also possible to pass strings to `motion.create`, which will create custom DOM elements.\n\n```\n// Will render <custom-element /> into HTML\nconst MotionComponent = motion.create('custom-element')\n```\n\nBy default, all `motion` props (like `animate` etc) are filtered out of the `props` forwarded to the provided component. By providing a `forwardMotionProps` config, the provided component will receive these props.\n\n```\nmotion.create(Component, { forwardMotionProps: true })\n```\n\n## [Props](#props)\n\n`motion` components accept the following props.\n\n### [Animation](#animation)\n\nMotion provides declarative animation props like `animate` and `exit`. [Learn more about React animations in Motion](./react-animation).\n\n#### [`initial`](#initial)\n\nThe initial visual state of the `motion` component.\n\nThis can be set as an animation target:\n\n```\n<motion.section initial={{ opacity: 0, x: 0 }} />\n```\n\nVariants:\n\n```\n<motion.li initial=\"visible\" />\n```\n\n```\n<motion.div initial={[\"visible\", \"active\"]} />\n```\n\nOr set as `false` to disable the enter animation and initially render as the values found in `animate`.\n\n```\n<motion.div initial={false} animate={{ opacity: 0 }} />\n```\n\n#### [`animate`](#animate)\n\nA target to animate to on enter, and on update.\n\nCan be set as an animation target:\n\n```\n<motion.div\n  initial={{ boxShadow: \"0px 0px #000\" }}\n  animate={{ boxShadow: \"10px 10px #000\" }}\n/>\n```\n\nOr variants:\n\n```\n<motion.li animate=\"visible\" />\n```\n\n```\n<motion.div initial=\"hidden\" animate={[\"visible\", \"active\"]} />\n```\n\n#### [`exit`](#exit)\n\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\n\nOwing to React limitations, the component being removed **must** be a **direct child** of `AnimatePresence` to enable this animation.\n\n#### [`transition`](#transition)\n\nThe default [transition](./react-transitions) for this component to use when an animation prop (`animate`, `whileHover` etc) has no `transition` defined.\n\n```\n<motion.div transition={{ type: \"spring\" }} animate={{ scale: 1.2 }} />\n```\n\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the [Motion extension](./studio-install).\n\n#### [`variants`](#variants)\n\nThe [variants](./react-animation#variants) for this component.\n\n```\nconst variants = {\n  active: {\n      backgroundColor: \"#f00\"\n  },\n  inactive: {\n    backgroundColor: \"#fff\",\n    transition: { duration: 2 }\n  }\n}\n\nreturn (\n  <motion.div\n    variants={variants}\n    animate={isActive ? \"active\" : \"inactive\"}\n  />\n)\n```\n\n#### [`style`](#style)\n\nThe normal React DOM `style` prop, with added support for [motion values](./react-motion-value) and independent transforms.\n\n```\nconst x = useMotionValue(30)\n\nreturn <motion.div style={{ x, rotate: 90, originX: 0.5 }} />\n```\n\n#### [`onUpdate`](#onupdate)\n\nCallback triggered every frame any value on the `motion` component updates. It's provided a single argument with the latest values.\n\n```\n<motion.article\n  animate={{ opacity: 1 }}\n  onUpdate={latest => console.log(latest.opacity)}\n/>\n```\n\n#### [`onAnimationStart`](#onanimationstart)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationStart`) starts.\n\nIt's provided a single argument, with the target or variant name of the started animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationStart={latest => console.log(latest.r)}\n/>\n```\n\n#### [`onAnimationComplete`](#onanimationcomplete)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationComplete`) completes.\n\nIt's provided a single argument, with the target or variant name of the completed animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationComplete={latest => console.log(latest.r)}\n/>\n```\n\n### [Hover](#hover)\n\n#### [`whileHover`](#whilehover)\n\nAnimation state, or variant label, to perform a [hover animation](./react-hover-animation) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileHover={{ scale: 1.2 }} />\n```\n\n```\n// As variants\n<motion.div whileHover=\"hovered\" />\n```\n\n#### [`onHoverStart`](#onhoverstart)\n\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverStart={(event) => console.log(event)} />\n```\n\n#### [`onHoverEnd`](#onhoverend)\n\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverEnd={(event) => console.log(event)} />\n```\n\n#### [Tap](#tap)\n\n#### [`whileTap`](#whiletap)\n\nAnimation state, or variant label, to perform a [press animation](./react-gestures) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileTap={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div whileTap=\"tapped\" />\n```\n\n#### [`onTapStart`](#ontapstart)\n\nCallback function that fires when a pointer starts pressing the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapStart={(event) => console.log(event)} />\n```\n\n#### [`onTap`](#ontap)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **inside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTap={(event) => console.log(event)} />\n```\n\n#### [`onTapCancel`](#ontapcancel)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **outside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapCancel={(event) => console.log(event)} />\n```\n\n### [Focus](#focus)\n\n#### [`whileFocus`](#whilefocus)\n\nAnimation state, or variant label, to animate to while the focus gesture is active.\n\n```\n// As target\n<motion.button whileFocus={{ outline: \"dashed #000\" }} />\n```\n\n```\n// As variants\n<motion.div whileFocus=\"focused\" />\n```\n\n### [Pan](#pan)\n\n#### [`onPan`](#onpan)\n\nCallback function that fires when the pan gesture is recognised on this element.\n\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the `touch-action` CSS rule.\n\n```\nfunction onPan(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div onPan={onPan} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onPanStart`](#onpanstart)\n\nCallback function that fires when a pan gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onPanEnd`](#onpanend)\n\nCallback function that fires when a pan gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n### [Drag](#drag)\n\n#### [`drag`](#drag-1)\n\n**Default:** `false`\n\nEnable dragging for this element. Set `true` to drag in both directions. Set `\"x\"` or `\"y\"` to only drag in a specific direction.\n\n```\n<motion.div drag />\n```\n\n#### [`whileDrag`](#whiledrag)\n\nAnimation state, or variant label, to perform a [drag animation](./react-drag) to while the hover gesture is active.\n\n```\n// As target\n<motion.div drag whileDrag={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div drag whileDrag=\"dragging\" />\n```\n\n#### [`dragConstraints`](#dragconstraints)\n\nApplies constraints on the draggable area.\n\nSet as an object of optional `top`, `left`, `right`, and `bottom` values, measured in pixels:\n\n```\n<motion.div\n  drag=\"x\"\n  dragConstraints={{ left: 0, right: 300 }}\n/>\n```\n\nOr as a `ref` to another element to use its bounding box as the draggable constraints:\n\n```\nconst MyComponent = () => {\n  const constraintsRef = useRef(null)\n\n  return (\n     <motion.div ref={constraintsRef}>\n         <motion.div drag dragConstraints={constraintsRef} />\n     </motion.div>\n  )\n}\n```\n\n#### [`dragSnapToOrigin`](#dragsnaptoorigin)\n\n**Default:** `false`\n\nIf `true`, the draggable element will animate back to its center/origin when released.\n\n```\n<motion.div drag dragSnapToOrigin />\n```\n\n#### [`dragElastic`](#dragelastic)\n\n**Default:** `0.5`\n\nThe degree of movement allowed outside constraints. `0` = no movement, `1` = full movement.\n\nSet to `0.5` by default. Can also be set as `false` to disable movement.\n\nBy passing an object of `top`/`right`/`bottom`/`left`, individual values can be set per constraint. Any missing values will be set to `0`.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragElastic={0.2}\n/>\n```\n\n#### [`dragMomentum`](#dragmomentum)\n\n**Default:** `true`\n\nApply momentum from the pan gesture to the component when dragging finishes. Set to `true` by default.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragMomentum={false}\n/>\n```\n\n#### [`dragTransition`](#dragtransition)\n\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type `\"inertia\"` starts. The animation is based on your dragging velocity. This property allows you to customize it.\n\n```\n<motion.div\n  drag\n  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}\n/>\n```\n\n#### [`dragDirectionLock`](#dragdirectionlock)\n\n**Default:** `false`\n\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the `x` axis than `y` axis before the drag gesture kicks in, it will **only** drag on the `x` axis for the remainder of the gesture.\n\n```\n<motion.div drag dragDirectionLock />\n```\n\n#### [`dragPropagation`](#dragpropagation)\n\n**Default:** `false`\n\nAllows drag gesture propagation to child components.\n\n```\n<motion.div drag=\"x\" dragPropagation />\n```\n\n#### [`dragControls`](#dragcontrols)\n\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\n\nBy creating a `dragControls` using the `useDragControls` [hook](./react-use-drag-controls), we can pass this into the draggable component's `dragControls` prop. It exposes a `start` method that can start dragging from pointer events on other components.\n\n```\nconst dragControls = useDragControls()\n\nfunction startDrag(event) {\n  dragControls.start(event, { snapToCursor: true })\n}\n\nreturn (\n  <>\n    <div onPointerDown={startDrag} />\n    <motion.div drag=\"x\" dragControls={dragControls} />\n  </>\n)\n```\n\nGiven that by setting `dragControls` you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting `dragListener={false}`.\n\n#### [`dragListener`](#draglistener)\n\nDetermines whether to trigger the drag gesture from event listeners. If passing `dragControls`, setting this to `false` will ensure dragging can only be initiated by the controls, rather than a `pointerdown` event on the draggable element.\n\n#### [`onDrag`](#ondrag)\n\nCallback function that fires when the drag gesture is recognised on this element.\n\n```\nfunction onDrag(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div drag onDrag={onDrag} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onDragStart`](#ondragstart)\n\nCallback function that fires when a drag gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDragEnd`](#ondragend)\n\nCallback function that fires when a drag gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDirectionLock`](#ondirectionlock)\n\nCallback function that fires a drag direction is determined.\n\n```\n<motion.div\n  drag\n  dragDirectionLock\n  onDirectionLock={axis => console.log(axis)}\n/>\n```\n\n### [Viewport](#viewport)\n\nLearn more about [scroll-triggered animations](./react-scroll-animations) in React.\n\n#### [`whileInView`](#whileinview)\n\nTarget or variants to label to while the element is in view.\n\n```\n// As target\n<motion.div whileInView={{ opacity: 1 }} />\n```\n\n```\n// As variants\n<motion.div whileInView=\"visible\" />\n```\n\n#### [`viewport`](#viewport-1)\n\nOptions to define how the element is tracked within the viewport.\n\n```\n<motion.section\n  whileInView={{ opacity: 1 }}\n  viewport={{ once: true }}\n/>\n```\n\nAvailable options:\n\n- `once`: If `true`, once element enters the viewport it won't detect subsequent leave/enter events.\n- `root`: The `ref` of an ancestor scrollable element to detect intersections with (instead of `window`).\n- `margin`: A margin to add to the viewport to change the detection area. Defaults to `\"0px\"`. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n- `amount`: The amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`. Defaults to `\"some\"`.\n\n#### [`onViewportEnter`](#onviewportenter)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />\n```\n\n#### [`onViewportLeave`](#onviewportleave)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />\n```\n\n### [Layout](#layout)\n\nLearn more about [layout animations](./react-layout-animations) in React.\n\n#### [`layout`](#layout-1)\n\n**Default:** `false`\n\nIf `true`, this component will perform [layout animations](./react-layout-animations).\n\n```\n<motion.div layout />\n```\n\nIf set to `\"position\"` or `\"size\"`, only its position or size will animate, respectively.\n\n```\n<motion.img layout=\"position\" />\n```\n\n#### [`layoutId`](#layoutid)\n\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching `layoutId`, it will animate out from the previous element's size/position.\n\n```\n{items.map(item => (\n   <motion.li layout>\n      {item.name}\n      {item.isSelected && <motion.div layoutId=\"underline\" />}\n   </motion.li>\n))}\n```\n\nIf the previous component remains in the tree, the two elements will crossfade.\n\n#### [`layoutDependency`](#layoutdependency)\n\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a `layoutDependency` prop. Measurements will only occur when this value changes.\n\n```\n<motion.nav layout layoutDependency={isOpen} />\n```\n\n#### [`layoutScroll`](#layoutscroll)\n\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the `layoutScroll` prop to elements that should be measured.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`layoutRoot`](#layoutroot)\n\nFor layout animations to work correctly within `position: fixed` elements, we need to account for page scroll. Add `layoutRoot` to mark an element as `position: fixed`.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`onLayoutAnimationStart`](#onlayoutanimationstart)\n\nA callback to run when a layout animation starts.\n\n#### [`onLayoutAnimationComplete`](#onlayoutanimationcomplete)\n\nA callback to run when a layout animation completes.\n\n### [Advanced](#advanced)\n\n#### [`inherit`](#inherit)\n\nSet to `false` to prevent a component inheriting or propagating changes in a parent variant.\n\n#### [`custom`](#custom)\n\nCustom data to pass through to dynamic variants.\n\n```\nconst variants = {\n  visible: (custom) => ({\n    opacity: 1,\n    transition: { delay: custom * 0.2 }\n  })\n}\n\nreturn (\n  <motion.ul animate=\"visible\">\n    <motion.li custom={0} variants={variants} />\n    <motion.li custom={1} variants={variants} />\n    <motion.li custom={2} variants={variants} />\n  </motion.ul>\n)\n```\n\n#### [`transformTemplate`](#transformtemplate)\n\nBy default, transforms are applied in order of `translate`, `scale`, `rotate` and `skew`.\n\nTo change this, `transformTemplate` can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n\n```\n// Use the latest transform values\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`\n  }\n/>\n```\n\n```\n// Or the generated transform string\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    (latest, generated) => `translate(-50%, -50%) ${generated}`\n  }\n/>\n```\n\nMost [React animations](./react-animation) in Motion are powered by the `<motion />` component.\n\nThere's a `motion` component for every HTML and SVG element, for instance `motion.div`, `motion.circle` etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.\n\n## [Usage](#usage)\n\nImport `motion` from Motion:\n\n```\n// React\nimport { motion } from \"motion/react\"\n\n// React Server Components (Next.js etc)\nimport * as motion from \"motion/react-client\"\n```\n\nYou can use a `motion` component exactly as you would any normal HTML/SVG component:\n\n```\n<motion.div className=\"box\" />\n```\n\nBut you also gain access to powerful animation APIs like the `animate`, `layout`, `whileInView` props.\n\n```\n<motion.div\n  className=\"box\"\n  // Animate when this value changes:\n  animate={{ scale: 2 }}\n  // Fade in when the element enters the viewport:\n  whileInView={{ opacity: 1 }}\n  // Animate the component when its layout changes:\n  layout\n  // Style now supports indepedent transforms:\n  style={{ x: 100 }}\n/>\n```\n\n### [Performance](#performance)\n\n`motion` components animate values without triggering React renders, for optimal performance.\n\nUsing [motion values](./react-motion-value) instead of React state to update `style` will also avoid re-renders.\n\n```\nconst x = useMotionValue(0)\n\nuseEffect(() => {\n  // Won't trigger a re-render!\n  const timeout = setTimeout(() => x.set(100), 1000)\n\n  return () => clearTimeout(timeout)\n}, [])\n\nreturn <motion.div style={{ x }} />\n```\n\n### [Server-side rendering](#server-side-rendering)\n\n`motion` components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.\n\n```\n// Server will output `translateX(100px)`\n<motion.div initial={false} animate={{ x: 100 }} />\n```\n\n### [Custom components](#custom-components)\n\nAny React component can be turned into a `motion` component by passing it to `motion.create()`.\n\n```\nconst MotionComponent = motion.create(Component)\n```\n\nYour component **must** pass a ref to the component you want to animate.\n\n**React 18:** Use `forwardRef` to wrap the component and pass `ref` to the element you want to animate:\n\n```\nconst Component = React.forwardRef((props, ref) => {\n  return <div ref={ref} />\n})\n```\n\n**React 19:** React 19 can pass `ref` via `props`:\n\n```\nconst Component = (props) => {\n  return <div ref={props.ref} />\n})\n```\n\nMake sure **not** to call `motion.create()` within a React render function! This will make a new component every render, breaking your animations.\n\nIt's also possible to pass strings to `motion.create`, which will create custom DOM elements.\n\n```\n// Will render <custom-element /> into HTML\nconst MotionComponent = motion.create('custom-element')\n```\n\nBy default, all `motion` props (like `animate` etc) are filtered out of the `props` forwarded to the provided component. By providing a `forwardMotionProps` config, the provided component will receive these props.\n\n```\nmotion.create(Component, { forwardMotionProps: true })\n```\n\n## [Props](#props)\n\n`motion` components accept the following props.\n\n### [Animation](#animation)\n\nMotion provides declarative animation props like `animate` and `exit`. [Learn more about React animations in Motion](./react-animation).\n\n#### [`initial`](#initial)\n\nThe initial visual state of the `motion` component.\n\nThis can be set as an animation target:\n\n```\n<motion.section initial={{ opacity: 0, x: 0 }} />\n```\n\nVariants:\n\n```\n<motion.li initial=\"visible\" />\n```\n\n```\n<motion.div initial={[\"visible\", \"active\"]} />\n```\n\nOr set as `false` to disable the enter animation and initially render as the values found in `animate`.\n\n```\n<motion.div initial={false} animate={{ opacity: 0 }} />\n```\n\n#### [`animate`](#animate)\n\nA target to animate to on enter, and on update.\n\nCan be set as an animation target:\n\n```\n<motion.div\n  initial={{ boxShadow: \"0px 0px #000\" }}\n  animate={{ boxShadow: \"10px 10px #000\" }}\n/>\n```\n\nOr variants:\n\n```\n<motion.li animate=\"visible\" />\n```\n\n```\n<motion.div initial=\"hidden\" animate={[\"visible\", \"active\"]} />\n```\n\n#### [`exit`](#exit)\n\nA target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.\n\nOwing to React limitations, the component being removed **must** be a **direct child** of `AnimatePresence` to enable this animation.\n\n#### [`transition`](#transition)\n\nThe default [transition](./react-transitions) for this component to use when an animation prop (`animate`, `whileHover` etc) has no `transition` defined.\n\n```\n<motion.div transition={{ type: \"spring\" }} animate={{ scale: 1.2 }} />\n```\n\nFor immediate visual feedback, you can edit CSS or Motion easing curves directly in your code editor with the [Motion extension](./studio-install).\n\n#### [`variants`](#variants)\n\nThe [variants](./react-animation#variants) for this component.\n\n```\nconst variants = {\n  active: {\n      backgroundColor: \"#f00\"\n  },\n  inactive: {\n    backgroundColor: \"#fff\",\n    transition: { duration: 2 }\n  }\n}\n\nreturn (\n  <motion.div\n    variants={variants}\n    animate={isActive ? \"active\" : \"inactive\"}\n  />\n)\n```\n\n#### [`style`](#style)\n\nThe normal React DOM `style` prop, with added support for [motion values](./react-motion-value) and independent transforms.\n\n```\nconst x = useMotionValue(30)\n\nreturn <motion.div style={{ x, rotate: 90, originX: 0.5 }} />\n```\n\n#### [`onUpdate`](#onupdate)\n\nCallback triggered every frame any value on the `motion` component updates. It's provided a single argument with the latest values.\n\n```\n<motion.article\n  animate={{ opacity: 1 }}\n  onUpdate={latest => console.log(latest.opacity)}\n/>\n```\n\n#### [`onAnimationStart`](#onanimationstart)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationStart`) starts.\n\nIt's provided a single argument, with the target or variant name of the started animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationStart={latest => console.log(latest.r)}\n/>\n```\n\n#### [`onAnimationComplete`](#onanimationcomplete)\n\nCallback triggered when any animation (except layout animations, see `onLayoutAnimationComplete`) completes.\n\nIt's provided a single argument, with the target or variant name of the completed animation.\n\n```\n<motion.circle\n  animate={{ r: 10 }}\n  onAnimationComplete={latest => console.log(latest.r)}\n/>\n```\n\n### [Hover](#hover)\n\n#### [`whileHover`](#whilehover)\n\nAnimation state, or variant label, to perform a [hover animation](./react-hover-animation) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileHover={{ scale: 1.2 }} />\n```\n\n```\n// As variants\n<motion.div whileHover=\"hovered\" />\n```\n\n#### [`onHoverStart`](#onhoverstart)\n\nCallback function that fires when a pointer starts hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverStart={(event) => console.log(event)} />\n```\n\n#### [`onHoverEnd`](#onhoverend)\n\nCallback function that fires when a pointer stops hovering over the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onHoverEnd={(event) => console.log(event)} />\n```\n\n#### [Tap](#tap)\n\n#### [`whileTap`](#whiletap)\n\nAnimation state, or variant label, to perform a [press animation](./react-gestures) to while the hover gesture is active.\n\n```\n// As target\n<motion.button whileTap={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div whileTap=\"tapped\" />\n```\n\n#### [`onTapStart`](#ontapstart)\n\nCallback function that fires when a pointer starts pressing the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapStart={(event) => console.log(event)} />\n```\n\n#### [`onTap`](#ontap)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **inside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTap={(event) => console.log(event)} />\n```\n\n#### [`onTapCancel`](#ontapcancel)\n\nCallback function that fires when a pointer stops pressing the component and the pointer was released **outside** the component. Provided the triggering `PointerEvent`.\n\n```\n<motion.div onTapCancel={(event) => console.log(event)} />\n```\n\n### [Focus](#focus)\n\n#### [`whileFocus`](#whilefocus)\n\nAnimation state, or variant label, to animate to while the focus gesture is active.\n\n```\n// As target\n<motion.button whileFocus={{ outline: \"dashed #000\" }} />\n```\n\n```\n// As variants\n<motion.div whileFocus=\"focused\" />\n```\n\n### [Pan](#pan)\n\n#### [`onPan`](#onpan)\n\nCallback function that fires when the pan gesture is recognised on this element.\n\nFor pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the `touch-action` CSS rule.\n\n```\nfunction onPan(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div onPan={onPan} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onPanStart`](#onpanstart)\n\nCallback function that fires when a pan gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onPanEnd`](#onpanend)\n\nCallback function that fires when a pan gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n### [Drag](#drag)\n\n#### [`drag`](#drag-1)\n\n**Default:** `false`\n\nEnable dragging for this element. Set `true` to drag in both directions. Set `\"x\"` or `\"y\"` to only drag in a specific direction.\n\n```\n<motion.div drag />\n```\n\n#### [`whileDrag`](#whiledrag)\n\nAnimation state, or variant label, to perform a [drag animation](./react-drag) to while the hover gesture is active.\n\n```\n// As target\n<motion.div drag whileDrag={{ scale: 0.9 }} />\n```\n\n```\n// As variants\n<motion.div drag whileDrag=\"dragging\" />\n```\n\n#### [`dragConstraints`](#dragconstraints)\n\nApplies constraints on the draggable area.\n\nSet as an object of optional `top`, `left`, `right`, and `bottom` values, measured in pixels:\n\n```\n<motion.div\n  drag=\"x\"\n  dragConstraints={{ left: 0, right: 300 }}\n/>\n```\n\nOr as a `ref` to another element to use its bounding box as the draggable constraints:\n\n```\nconst MyComponent = () => {\n  const constraintsRef = useRef(null)\n\n  return (\n     <motion.div ref={constraintsRef}>\n         <motion.div drag dragConstraints={constraintsRef} />\n     </motion.div>\n  )\n}\n```\n\n#### [`dragSnapToOrigin`](#dragsnaptoorigin)\n\n**Default:** `false`\n\nIf `true`, the draggable element will animate back to its center/origin when released.\n\n```\n<motion.div drag dragSnapToOrigin />\n```\n\n#### [`dragElastic`](#dragelastic)\n\n**Default:** `0.5`\n\nThe degree of movement allowed outside constraints. `0` = no movement, `1` = full movement.\n\nSet to `0.5` by default. Can also be set as `false` to disable movement.\n\nBy passing an object of `top`/`right`/`bottom`/`left`, individual values can be set per constraint. Any missing values will be set to `0`.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragElastic={0.2}\n/>\n```\n\n#### [`dragMomentum`](#dragmomentum)\n\n**Default:** `true`\n\nApply momentum from the pan gesture to the component when dragging finishes. Set to `true` by default.\n\n```\n<motion.div\n  drag\n  dragConstraints={{ left: 0, right: 300 }}\n  dragMomentum={false}\n/>\n```\n\n#### [`dragTransition`](#dragtransition)\n\nAllows you to change dragging momentum transition. When releasing a draggable element, an animation with type `\"inertia\"` starts. The animation is based on your dragging velocity. This property allows you to customize it.\n\n```\n<motion.div\n  drag\n  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}\n/>\n```\n\n#### [`dragDirectionLock`](#dragdirectionlock)\n\n**Default:** `false`\n\nLocks drag direction into the soonest detected direction. For example, if the component is moved more on the `x` axis than `y` axis before the drag gesture kicks in, it will **only** drag on the `x` axis for the remainder of the gesture.\n\n```\n<motion.div drag dragDirectionLock />\n```\n\n#### [`dragPropagation`](#dragpropagation)\n\n**Default:** `false`\n\nAllows drag gesture propagation to child components.\n\n```\n<motion.div drag=\"x\" dragPropagation />\n```\n\n#### [`dragControls`](#dragcontrols)\n\nUsually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.\n\nBy creating a `dragControls` using the `useDragControls` [hook](./react-use-drag-controls), we can pass this into the draggable component's `dragControls` prop. It exposes a `start` method that can start dragging from pointer events on other components.\n\n```\nconst dragControls = useDragControls()\n\nfunction startDrag(event) {\n  dragControls.start(event, { snapToCursor: true })\n}\n\nreturn (\n  <>\n    <div onPointerDown={startDrag} />\n    <motion.div drag=\"x\" dragControls={dragControls} />\n  </>\n)\n```\n\nGiven that by setting `dragControls` you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting `dragListener={false}`.\n\n#### [`dragListener`](#draglistener)\n\nDetermines whether to trigger the drag gesture from event listeners. If passing `dragControls`, setting this to `false` will ensure dragging can only be initiated by the controls, rather than a `pointerdown` event on the draggable element.\n\n#### [`onDrag`](#ondrag)\n\nCallback function that fires when the drag gesture is recognised on this element.\n\n```\nfunction onDrag(event, info) {\n  console.log(info.point.x, info.point.y)\n}\n\n<motion.div drag onDrag={onDrag} />\n```\n\nPan and drag events are provided the origin `PointerEvent` as well as an object `info` that contains `x` and `y` point values for the following:\n\n- `point`: Relative to the device or page.\n- `delta`: Distance since the last event.\n- `offset`: Distance from the original event.\n- `velocity`: Current velocity of the pointer.\n\n#### [`onDragStart`](#ondragstart)\n\nCallback function that fires when a drag gesture starts. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDragEnd`](#ondragend)\n\nCallback function that fires when a drag gesture ends. Provided the triggering `PointerEvent` and `info`.\n\n```\n<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />\n```\n\n#### [`onDirectionLock`](#ondirectionlock)\n\nCallback function that fires a drag direction is determined.\n\n```\n<motion.div\n  drag\n  dragDirectionLock\n  onDirectionLock={axis => console.log(axis)}\n/>\n```\n\n### [Viewport](#viewport)\n\nLearn more about [scroll-triggered animations](./react-scroll-animations) in React.\n\n#### [`whileInView`](#whileinview)\n\nTarget or variants to label to while the element is in view.\n\n```\n// As target\n<motion.div whileInView={{ opacity: 1 }} />\n```\n\n```\n// As variants\n<motion.div whileInView=\"visible\" />\n```\n\n#### [`viewport`](#viewport-1)\n\nOptions to define how the element is tracked within the viewport.\n\n```\n<motion.section\n  whileInView={{ opacity: 1 }}\n  viewport={{ once: true }}\n/>\n```\n\nAvailable options:\n\n- `once`: If `true`, once element enters the viewport it won't detect subsequent leave/enter events.\n- `root`: The `ref` of an ancestor scrollable element to detect intersections with (instead of `window`).\n- `margin`: A margin to add to the viewport to change the detection area. Defaults to `\"0px\"`. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n- `amount`: The amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`. Defaults to `\"some\"`.\n\n#### [`onViewportEnter`](#onviewportenter)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />\n```\n\n#### [`onViewportLeave`](#onviewportleave)\n\nCallback function that fires when an element enters the viewport. Provided the `IntersectionObserverEntry` with details of the intersection event.\n\n```\n<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />\n```\n\n### [Layout](#layout)\n\nLearn more about [layout animations](./react-layout-animations) in React.\n\n#### [`layout`](#layout-1)\n\n**Default:** `false`\n\nIf `true`, this component will perform [layout animations](./react-layout-animations).\n\n```\n<motion.div layout />\n```\n\nIf set to `\"position\"` or `\"size\"`, only its position or size will animate, respectively.\n\n```\n<motion.img layout=\"position\" />\n```\n\n#### [`layoutId`](#layoutid)\n\nIf set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching `layoutId`, it will animate out from the previous element's size/position.\n\n```\n{items.map(item => (\n   <motion.li layout>\n      {item.name}\n      {item.isSelected && <motion.div layoutId=\"underline\" />}\n   </motion.li>\n))}\n```\n\nIf the previous component remains in the tree, the two elements will crossfade.\n\n#### [`layoutDependency`](#layoutdependency)\n\nBy default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a `layoutDependency` prop. Measurements will only occur when this value changes.\n\n```\n<motion.nav layout layoutDependency={isOpen} />\n```\n\n#### [`layoutScroll`](#layoutscroll)\n\nFor layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the `layoutScroll` prop to elements that should be measured.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`layoutRoot`](#layoutroot)\n\nFor layout animations to work correctly within `position: fixed` elements, we need to account for page scroll. Add `layoutRoot` to mark an element as `position: fixed`.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }}>\n  <motion.div layout />\n</motion.div>\n```\n\n#### [`onLayoutAnimationStart`](#onlayoutanimationstart)\n\nA callback to run when a layout animation starts.\n\n#### [`onLayoutAnimationComplete`](#onlayoutanimationcomplete)\n\nA callback to run when a layout animation completes.\n\n### [Advanced](#advanced)\n\n#### [`inherit`](#inherit)\n\nSet to `false` to prevent a component inheriting or propagating changes in a parent variant.\n\n#### [`custom`](#custom)\n\nCustom data to pass through to dynamic variants.\n\n```\nconst variants = {\n  visible: (custom) => ({\n    opacity: 1,\n    transition: { delay: custom * 0.2 }\n  })\n}\n\nreturn (\n  <motion.ul animate=\"visible\">\n    <motion.li custom={0} variants={variants} />\n    <motion.li custom={1} variants={variants} />\n    <motion.li custom={2} variants={variants} />\n  </motion.ul>\n)\n```\n\n#### [`transformTemplate`](#transformtemplate)\n\nBy default, transforms are applied in order of `translate`, `scale`, `rotate` and `skew`.\n\nTo change this, `transformTemplate` can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.\n\n```\n// Use the latest transform values\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`\n  }\n/>\n```\n\n```\n// Or the generated transform string\n<motion.div\n  style={{ x: 0, rotate: 180 }}\n  transformTemplate={\n    (latest, generated) => `translate(-50%, -50%) ${generated}`\n  }\n/>\n```\n\n## Related topics\n\n- [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n\n  [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n\n  [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n- [### SVG animation\n\n  Animate SVGs in React - Line drawing and morphing effects, and more.](./react-svg-animation)\n\n  [### SVG animation\n\n  Animate SVGs in React - Line drawing and morphing effects, and more.](./react-svg-animation)\n\n  [### SVG animation\n\n  Animate SVGs in React - Line drawing and morphing effects, and more.](./react-svg-animation)\n\n- [### Motion component examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=motion)\n\n- [### Motion component examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=motion)\n\n- [### Motion component examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=motion)\n\n- [Tutorial\n\n  ### Magnetic filings\n\n  An example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.](../tutorials/react-magnetic-filings)\n\n- [Tutorial\n\n  ### Magnetic filings\n\n  An example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.](../tutorials/react-magnetic-filings)\n\n- [Tutorial\n\n  ### Magnetic filings\n\n  An example of creating a grid of metal filings that rotate to point towards the cursor position using Motion for React.](../tutorials/react-magnetic-filings)\n\nPrevious\n\n[Drag animation](./react-drag)\n\nNext\n\n[AnimateActivity](./react-animate-activity)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Love animating with components?\n\nMotion+ includes premium animation components like Cursor and Ticker that will save you hours of development time.\n\n[See the full feature list](../plus)\n\n[See the full feature list](../plus)\n\n[See the full feature list](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:11.018206+00:00",
  "content_length": 55232,
  "content_hash": "b8e5166583e49ea6"
}