{
  "id": "framer-motion__motion_animate-presence_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/animate-presence/",
  "title": "AnimatePresence \u00e2\u0080\u0094 React exit animations | Motion",
  "content": "AnimatePresence\nmakes exit animations easy. By wrapping one or more\nmotion\ncomponents\nwith\nAnimatePresence\n, we gain access to the\nexit\nanimation prop.\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n}\n</\nAnimatePresence\n>\nUsage\nImport\nimport\n{\nAnimatePresence\n}\nfrom\n\"motion/react\"\nExit animations\nAnimatePresence\nworks by detecting when its\ndirect children\nare removed from the React tree.\nThis can be due to a component mounting/remounting:\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nModal\nkey\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nIts\nkey\nchanging:\n<\nAnimatePresence\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\nOr when children in a list are added/removed:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nkey\n=\n{\nitem\n.\nid\n}\nexit\n=\n{\n{\nopacity\n:\n1\n}\n}\nlayout\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAny\nmotion\ncomponents within the exiting component will fire animations defined on their\nexit\nprops before the component is removed from the DOM.\nfunction\nSlide\n(\n{\nimg\n,\ndescription\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nimg\nsrc\n=\n{\nimg\n.\nsrc\n}\n/>\n<\nmotion\n.\np\nexit\n=\n{\n{\ny\n:\n10\n}\n}\n>\n{\ndescription\n}\n</\nmotion\n.\np\n>\n</\nmotion\n.\ndiv\n>\n)\n}\nDirect children must each have a unique\nkey\nprop so\nAnimatePresence\ncan track their presence in the tree.\nLike\ninitial\nand\nanimate\n,\nexit\ncan be defined either as an object of values, or as a variant label.\nconst\nmodalVariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n}\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n}\n}\n}\nfunction\nModal\n(\n{\nchildren\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n>\n{\nchildren\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nChanging\nkey\nChanging a\nkey\nprop makes React create an entirely new component. So by changing the\nkey\nof a single child of\nAnimatePresence\n, we can easily make components like slideshows.\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n}\n)\n=>\n(\n<\nAnimatePresence\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\ninitial\n=\n{\n{\nx\n:\n300\n,\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nx\n:\n0\n,\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nx\n:\n-\n300\n,\nopacity\n:\n0\n}\n}\n/>\n</\nAnimatePresence\n>\n)\nAccess presence state\nAny child of\nAnimatePresence\ncan access presence state with the\nuseIsPresence\nhook.\nimport\n{\nuseIsPresent\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nreturn\nisPresent\n?\n\"Here!\"\n:\n\"Exiting...\"\n}\nThis allows you to change content or styles when a component is no longer rendered.\nAccess presence data\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use\nAnimatePresence\n's\ncustom\nprop to pass new data down through the tree, even into exiting components.\n<\nAnimatePresence\ncustom\n=\n{\nswipeDirection\n}\n>\n<\nSlide\nkey\n=\n{\nactiveSlideId\n}\n>\nThen later we can extract that using\nusePresenceData\n.\nimport\n{\nAnimatePresence\n,\nusePresenceData\n}\nfrom\n\"motion/react\"\nfunction\nSlide\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nconst\ndirection\n=\nusePresenceData\n(\n)\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n{\nisPresent\n?\n\"Here!\"\n:\n\"Exiting \"\n+\ndirection\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nManual usage\nIt's also possible to manually tell\nAnimatePresence\nwhen a component is safe to remove with the\nusePresence\nhook.\nThis returns both\nisPresent\nstate and a callback,\nsafeToRemove\n, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\nimport\n{\nusePresence\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Remove from DOM 1000ms after being removed from React\n!\nisPresent\n&&\nsetTimeout\n(\nsafeToRemove\n,\n1000\n)\n}\n,\n[\nisPresent\n]\n)\nreturn\n<\ndiv\n/>\n}\nPropagate exit animations\nBy default,\nAnimatePresence\ncontrols the\nexit\nanimations on all of its children,\nuntil\nanother\nAnimatePresence\ncomponent is rendered.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nBy setting an\nAnimatePresence\ncomponent's\npropagate\nprop to\ntrue\n, when it's removed from another\nAnimatePresence\nit will fire all of\nits\nchildren's exit animations.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nProps\ninitial\nBy passing\ninitial={false}\n,\nAnimatePresence\nwill disable any initial animations on children that are present when the component is first rendered.\n<\nAnimatePresence\ninitial\n=\n{\nfalse\n}\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\ncustom\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\nBy passing a value through\nAnimatePresence\n's\ncustom\nprop, we can use dynamic variants to change the\nexit\nanimation.\nconst\nvariants\n=\n{\nhidden\n:\n(\ndirection\n)\n=>\n(\n{\nopacity\n:\n0\n,\nx\n:\ndirection\n===\n1\n? -\n300\n:\n300\n}\n)\n,\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n}\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n,\ndirection\n}\n)\n=>\n(\n<\nAnimatePresence\ncustom\n=\n{\ndirection\n}\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\n</\nAnimatePresence\n>\n)\nThis data can be accessed by children via\nusePresenceData\n.\nmode\nDefault:\n\"sync\"\nDecides how\nAnimatePresence\nhandles entering and exiting children.\nsync\nIn\n\"sync\"\nmode, elements animate in and out as soon as they're added/removed.\nThis is the most basic (and default) mode -\nAnimatePresence\ntakes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using\nposition: absolute\nor similar), or try one of the other two\nmode\noptions.\nwait\nIn\n\"wait\"\nmode, the entering element will\nwait\nuntil the exiting child has animated out, before it animates in.\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\nwait\nmode only supports one child at a time.\nTry setting\nease: \"easeIn\"\n(or similar) on the exit animation, and\nease: \"easeOut\"\non the enter animation for an overall\neaseInOut\neasing effect.\npopLayout\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the\nlayout\nprop, so elements can animate to their new layout.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nWhen using\npopLayout\nmode, any immediate child of AnimatePresence that's a custom component\nmust\nbe wrapped in React's\nforwardRef\nfunction, forwarding the provided\nref\nto the DOM node you wish to pop out of the layout.\nFor a more detailed comparison, check out the\nfull AnimatePresence modes tutorial\n.\nonExitComplete\nFires when all exiting nodes have completed animating out.\npropagate\nDefault:\nfalse\nIf set to\ntrue\n, exit animations on children will also trigger when this\nAnimatePresence\nexits from a parent\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/* This exit prop will now fire when show is false */\n}\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nx\n:\n-\n100\n}\n}\n/>\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nroot\nRoot element for injecting\npopLayout\nstyles. Defaults to\ndocument.head\nbut can be set to another\nShadowRoot\n, for use within shadow DOM.\nTroubleshooting\nExit animations aren't working\nEnsure all\nimmediate\nchildren get a unique\nkey\nprop that\nremains the same for that component every render\n.\nFor instance, providing\nindex\nas a\nkey\nis\nbad\nbecause if the items reorder then the\nindex\nwill not be matched to the\nitem\n:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nindex\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nIt's preferred to pass something that's unique to that item, for instance an ID:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAlso make sure\nAnimatePresence\nis\noutside\nof the code that unmounts the element. If\nAnimatePresence\nitself unmounts, then it can't control exit animations!\nFor example, this will\nnot work\n:\nisVisible\n&&\n(\n<\nAnimatePresence\n>\n<\nComponent\n/>\n</\nAnimatePresence\n>\n)\nInstead, the conditional should be at the root of\nAnimatePresence\n:\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n<\nComponent\n/>\n}\n</\nAnimatePresence\n>\nLayout animations not working with\nmode=\"sync\"\nWhen mixing exit and\nlayout animations\n, it might be necessary to wrap the group in\nLayoutGroup\nto ensure that components outside of\nAnimatePresence\nknow when to perform a layout animation.\n<\nLayoutGroup\n>\n<\nmotion\n.\nul\nlayout\n>\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\n</\nLayoutGroup\n>\nLayout animations not working with\nmode=\"popLayout\"\nWhen any HTML element has an active\ntransform\nit temporarily becomes the\noffset parent\nof its children. This can cause children with\nposition: \"absolute\"\nnot to appear where you expect.\nmode=\"popLayout\"\nworks by using\nposition: \"absolute\"\n. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a\nposition\nother than\n\"static\"\n.\n<\nmotion\n.\nul\nlayout\nstyle\n=\n{\n{\nposition\n:\n\"relative\"\n}\n}\n>\n<\nAnimatePresence\nmode\n=\n\"popLayout\"\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\nAnimatePresence\nmakes exit animations easy. By wrapping one or more\nmotion\ncomponents\nwith\nAnimatePresence\n, we gain access to the\nexit\nanimation prop.\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n}\n</\nAnimatePresence\n>\nUsage\nImport\nimport\n{\nAnimatePresence\n}\nfrom\n\"motion/react\"\nExit animations\nAnimatePresence\nworks by detecting when its\ndirect children\nare removed from the React tree.\nThis can be due to a component mounting/remounting:\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nModal\nkey\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nIts\nkey\nchanging:\n<\nAnimatePresence\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\nOr when children in a list are added/removed:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nkey\n=\n{\nitem\n.\nid\n}\nexit\n=\n{\n{\nopacity\n:\n1\n}\n}\nlayout\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAny\nmotion\ncomponents within the exiting component will fire animations defined on their\nexit\nprops before the component is removed from the DOM.\nfunction\nSlide\n(\n{\nimg\n,\ndescription\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nimg\nsrc\n=\n{\nimg\n.\nsrc\n}\n/>\n<\nmotion\n.\np\nexit\n=\n{\n{\ny\n:\n10\n}\n}\n>\n{\ndescription\n}\n</\nmotion\n.\np\n>\n</\nmotion\n.\ndiv\n>\n)\n}\nDirect children must each have a unique\nkey\nprop so\nAnimatePresence\ncan track their presence in the tree.\nLike\ninitial\nand\nanimate\n,\nexit\ncan be defined either as an object of values, or as a variant label.\nconst\nmodalVariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n}\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n}\n}\n}\nfunction\nModal\n(\n{\nchildren\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n>\n{\nchildren\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nChanging\nkey\nChanging a\nkey\nprop makes React create an entirely new component. So by changing the\nkey\nof a single child of\nAnimatePresence\n, we can easily make components like slideshows.\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n}\n)\n=>\n(\n<\nAnimatePresence\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\ninitial\n=\n{\n{\nx\n:\n300\n,\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nx\n:\n0\n,\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nx\n:\n-\n300\n,\nopacity\n:\n0\n}\n}\n/>\n</\nAnimatePresence\n>\n)\nAccess presence state\nAny child of\nAnimatePresence\ncan access presence state with the\nuseIsPresence\nhook.\nimport\n{\nuseIsPresent\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nreturn\nisPresent\n?\n\"Here!\"\n:\n\"Exiting...\"\n}\nThis allows you to change content or styles when a component is no longer rendered.\nAccess presence data\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use\nAnimatePresence\n's\ncustom\nprop to pass new data down through the tree, even into exiting components.\n<\nAnimatePresence\ncustom\n=\n{\nswipeDirection\n}\n>\n<\nSlide\nkey\n=\n{\nactiveSlideId\n}\n>\nThen later we can extract that using\nusePresenceData\n.\nimport\n{\nAnimatePresence\n,\nusePresenceData\n}\nfrom\n\"motion/react\"\nfunction\nSlide\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nconst\ndirection\n=\nusePresenceData\n(\n)\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n{\nisPresent\n?\n\"Here!\"\n:\n\"Exiting \"\n+\ndirection\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nManual usage\nIt's also possible to manually tell\nAnimatePresence\nwhen a component is safe to remove with the\nusePresence\nhook.\nThis returns both\nisPresent\nstate and a callback,\nsafeToRemove\n, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\nimport\n{\nusePresence\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Remove from DOM 1000ms after being removed from React\n!\nisPresent\n&&\nsetTimeout\n(\nsafeToRemove\n,\n1000\n)\n}\n,\n[\nisPresent\n]\n)\nreturn\n<\ndiv\n/>\n}\nPropagate exit animations\nBy default,\nAnimatePresence\ncontrols the\nexit\nanimations on all of its children,\nuntil\nanother\nAnimatePresence\ncomponent is rendered.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nBy setting an\nAnimatePresence\ncomponent's\npropagate\nprop to\ntrue\n, when it's removed from another\nAnimatePresence\nit will fire all of\nits\nchildren's exit animations.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nProps\ninitial\nBy passing\ninitial={false}\n,\nAnimatePresence\nwill disable any initial animations on children that are present when the component is first rendered.\n<\nAnimatePresence\ninitial\n=\n{\nfalse\n}\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\ncustom\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\nBy passing a value through\nAnimatePresence\n's\ncustom\nprop, we can use dynamic variants to change the\nexit\nanimation.\nconst\nvariants\n=\n{\nhidden\n:\n(\ndirection\n)\n=>\n(\n{\nopacity\n:\n0\n,\nx\n:\ndirection\n===\n1\n? -\n300\n:\n300\n}\n)\n,\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n}\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n,\ndirection\n}\n)\n=>\n(\n<\nAnimatePresence\ncustom\n=\n{\ndirection\n}\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\n</\nAnimatePresence\n>\n)\nThis data can be accessed by children via\nusePresenceData\n.\nmode\nDefault:\n\"sync\"\nDecides how\nAnimatePresence\nhandles entering and exiting children.\nsync\nIn\n\"sync\"\nmode, elements animate in and out as soon as they're added/removed.\nThis is the most basic (and default) mode -\nAnimatePresence\ntakes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using\nposition: absolute\nor similar), or try one of the other two\nmode\noptions.\nwait\nIn\n\"wait\"\nmode, the entering element will\nwait\nuntil the exiting child has animated out, before it animates in.\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\nwait\nmode only supports one child at a time.\nTry setting\nease: \"easeIn\"\n(or similar) on the exit animation, and\nease: \"easeOut\"\non the enter animation for an overall\neaseInOut\neasing effect.\npopLayout\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the\nlayout\nprop, so elements can animate to their new layout.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nWhen using\npopLayout\nmode, any immediate child of AnimatePresence that's a custom component\nmust\nbe wrapped in React's\nforwardRef\nfunction, forwarding the provided\nref\nto the DOM node you wish to pop out of the layout.\nFor a more detailed comparison, check out the\nfull AnimatePresence modes tutorial\n.\nonExitComplete\nFires when all exiting nodes have completed animating out.\npropagate\nDefault:\nfalse\nIf set to\ntrue\n, exit animations on children will also trigger when this\nAnimatePresence\nexits from a parent\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/* This exit prop will now fire when show is false */\n}\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nx\n:\n-\n100\n}\n}\n/>\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nroot\nRoot element for injecting\npopLayout\nstyles. Defaults to\ndocument.head\nbut can be set to another\nShadowRoot\n, for use within shadow DOM.\nTroubleshooting\nExit animations aren't working\nEnsure all\nimmediate\nchildren get a unique\nkey\nprop that\nremains the same for that component every render\n.\nFor instance, providing\nindex\nas a\nkey\nis\nbad\nbecause if the items reorder then the\nindex\nwill not be matched to the\nitem\n:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nindex\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nIt's preferred to pass something that's unique to that item, for instance an ID:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAlso make sure\nAnimatePresence\nis\noutside\nof the code that unmounts the element. If\nAnimatePresence\nitself unmounts, then it can't control exit animations!\nFor example, this will\nnot work\n:\nisVisible\n&&\n(\n<\nAnimatePresence\n>\n<\nComponent\n/>\n</\nAnimatePresence\n>\n)\nInstead, the conditional should be at the root of\nAnimatePresence\n:\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n<\nComponent\n/>\n}\n</\nAnimatePresence\n>\nLayout animations not working with\nmode=\"sync\"\nWhen mixing exit and\nlayout animations\n, it might be necessary to wrap the group in\nLayoutGroup\nto ensure that components outside of\nAnimatePresence\nknow when to perform a layout animation.\n<\nLayoutGroup\n>\n<\nmotion\n.\nul\nlayout\n>\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\n</\nLayoutGroup\n>\nLayout animations not working with\nmode=\"popLayout\"\nWhen any HTML element has an active\ntransform\nit temporarily becomes the\noffset parent\nof its children. This can cause children with\nposition: \"absolute\"\nnot to appear where you expect.\nmode=\"popLayout\"\nworks by using\nposition: \"absolute\"\n. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a\nposition\nother than\n\"static\"\n.\n<\nmotion\n.\nul\nlayout\nstyle\n=\n{\n{\nposition\n:\n\"relative\"\n}\n}\n>\n<\nAnimatePresence\nmode\n=\n\"popLayout\"\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\nAnimatePresence\nmakes exit animations easy. By wrapping one or more\nmotion\ncomponents\nwith\nAnimatePresence\n, we gain access to the\nexit\nanimation prop.\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nmotion\n.\ndiv\nkey\n=\n\"modal\"\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n}\n</\nAnimatePresence\n>\nUsage\nImport\nimport\n{\nAnimatePresence\n}\nfrom\n\"motion/react\"\nExit animations\nAnimatePresence\nworks by detecting when its\ndirect children\nare removed from the React tree.\nThis can be due to a component mounting/remounting:\n<\nAnimatePresence\n>\n{\nshow\n&&\n<\nModal\nkey\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nIts\nkey\nchanging:\n<\nAnimatePresence\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\nOr when children in a list are added/removed:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nkey\n=\n{\nitem\n.\nid\n}\nexit\n=\n{\n{\nopacity\n:\n1\n}\n}\nlayout\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAny\nmotion\ncomponents within the exiting component will fire animations defined on their\nexit\nprops before the component is removed from the DOM.\nfunction\nSlide\n(\n{\nimg\n,\ndescription\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nimg\nsrc\n=\n{\nimg\n.\nsrc\n}\n/>\n<\nmotion\n.\np\nexit\n=\n{\n{\ny\n:\n10\n}\n}\n>\n{\ndescription\n}\n</\nmotion\n.\np\n>\n</\nmotion\n.\ndiv\n>\n)\n}\nDirect children must each have a unique\nkey\nprop so\nAnimatePresence\ncan track their presence in the tree.\nLike\ninitial\nand\nanimate\n,\nexit\ncan be defined either as an object of values, or as a variant label.\nconst\nmodalVariants\n=\n{\nvisible\n:\n{\nopacity\n:\n1\n,\ntransition\n:\n{\nwhen\n:\n\"beforeChildren\"\n}\n}\n,\nhidden\n:\n{\nopacity\n:\n0\n,\ntransition\n:\n{\nwhen\n:\n\"afterChildren\"\n}\n}\n}\nfunction\nModal\n(\n{\nchildren\n}\n)\n{\nreturn\n(\n<\nmotion\n.\ndiv\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n>\n{\nchildren\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nChanging\nkey\nChanging a\nkey\nprop makes React create an entirely new component. So by changing the\nkey\nof a single child of\nAnimatePresence\n, we can easily make components like slideshows.\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n}\n)\n=>\n(\n<\nAnimatePresence\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\ninitial\n=\n{\n{\nx\n:\n300\n,\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nx\n:\n0\n,\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nx\n:\n-\n300\n,\nopacity\n:\n0\n}\n}\n/>\n</\nAnimatePresence\n>\n)\nAccess presence state\nAny child of\nAnimatePresence\ncan access presence state with the\nuseIsPresence\nhook.\nimport\n{\nuseIsPresent\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nreturn\nisPresent\n?\n\"Here!\"\n:\n\"Exiting...\"\n}\nThis allows you to change content or styles when a component is no longer rendered.\nAccess presence data\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use\nAnimatePresence\n's\ncustom\nprop to pass new data down through the tree, even into exiting components.\n<\nAnimatePresence\ncustom\n=\n{\nswipeDirection\n}\n>\n<\nSlide\nkey\n=\n{\nactiveSlideId\n}\n>\nThen later we can extract that using\nusePresenceData\n.\nimport\n{\nAnimatePresence\n,\nusePresenceData\n}\nfrom\n\"motion/react\"\nfunction\nSlide\n(\n)\n{\nconst\nisPresent\n=\nuseIsPresent\n(\n)\nconst\ndirection\n=\nusePresenceData\n(\n)\nreturn\n(\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n{\nisPresent\n?\n\"Here!\"\n:\n\"Exiting \"\n+\ndirection\n}\n</\nmotion\n.\ndiv\n>\n)\n}\nManual usage\nIt's also possible to manually tell\nAnimatePresence\nwhen a component is safe to remove with the\nusePresence\nhook.\nThis returns both\nisPresent\nstate and a callback,\nsafeToRemove\n, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\nimport\n{\nusePresence\n}\nfrom\n\"motion/react\"\nfunction\nComponent\n(\n)\n{\nconst\n[\nisPresent\n,\nsafeToRemove\n]\n=\nusePresence\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\n// Remove from DOM 1000ms after being removed from React\n!\nisPresent\n&&\nsetTimeout\n(\nsafeToRemove\n,\n1000\n)\n}\n,\n[\nisPresent\n]\n)\nreturn\n<\ndiv\n/>\n}\nPropagate exit animations\nBy default,\nAnimatePresence\ncontrols the\nexit\nanimations on all of its children,\nuntil\nanother\nAnimatePresence\ncomponent is rendered.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nBy setting an\nAnimatePresence\ncomponent's\npropagate\nprop to\ntrue\n, when it's removed from another\nAnimatePresence\nit will fire all of\nits\nchildren's exit animations.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */\n}\n{\nchildren\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nProps\ninitial\nBy passing\ninitial={false}\n,\nAnimatePresence\nwill disable any initial animations on children that are present when the component is first rendered.\n<\nAnimatePresence\ninitial\n=\n{\nfalse\n}\n>\n<\nSlide\nkey\n=\n{\nactiveItem\n.\nid\n}\n/>\n</\nAnimatePresence\n>\ncustom\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\nBy passing a value through\nAnimatePresence\n's\ncustom\nprop, we can use dynamic variants to change the\nexit\nanimation.\nconst\nvariants\n=\n{\nhidden\n:\n(\ndirection\n)\n=>\n(\n{\nopacity\n:\n0\n,\nx\n:\ndirection\n===\n1\n? -\n300\n:\n300\n}\n)\n,\nvisible\n:\n{\nopacity\n:\n1\n,\nx\n:\n0\n}\n}\nexport\nconst\nSlideshow\n=\n(\n{\nimage\n,\ndirection\n}\n)\n=>\n(\n<\nAnimatePresence\ncustom\n=\n{\ndirection\n}\n>\n<\nmotion\n.\nimg\nkey\n=\n{\nimage\n.\nsrc\n}\nsrc\n=\n{\nimage\n.\nsrc\n}\nvariants\n=\n{\nvariants\n}\ninitial\n=\n\"hidden\"\nanimate\n=\n\"visible\"\nexit\n=\n\"hidden\"\n/>\n</\nAnimatePresence\n>\n)\nThis data can be accessed by children via\nusePresenceData\n.\nmode\nDefault:\n\"sync\"\nDecides how\nAnimatePresence\nhandles entering and exiting children.\nsync\nIn\n\"sync\"\nmode, elements animate in and out as soon as they're added/removed.\nThis is the most basic (and default) mode -\nAnimatePresence\ntakes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using\nposition: absolute\nor similar), or try one of the other two\nmode\noptions.\nwait\nIn\n\"wait\"\nmode, the entering element will\nwait\nuntil the exiting child has animated out, before it animates in.\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\nwait\nmode only supports one child at a time.\nTry setting\nease: \"easeIn\"\n(or similar) on the exit animation, and\nease: \"easeOut\"\non the enter animation for an overall\neaseInOut\neasing effect.\npopLayout\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the\nlayout\nprop, so elements can animate to their new layout.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\nWhen using\npopLayout\nmode, any immediate child of AnimatePresence that's a custom component\nmust\nbe wrapped in React's\nforwardRef\nfunction, forwarding the provided\nref\nto the DOM node you wish to pop out of the layout.\nFor a more detailed comparison, check out the\nfull AnimatePresence modes tutorial\n.\nonExitComplete\nFires when all exiting nodes have completed animating out.\npropagate\nDefault:\nfalse\nIf set to\ntrue\n, exit animations on children will also trigger when this\nAnimatePresence\nexits from a parent\nAnimatePresence\n.\n<\nAnimatePresence\n>\n{\nshow\n?\n(\n<\nmotion\n.\nsection\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\n>\n<\nAnimatePresence\npropagate\n>\n{\n/* This exit prop will now fire when show is false */\n}\n<\nmotion\n.\ndiv\nexit\n=\n{\n{\nx\n:\n-\n100\n}\n}\n/>\n</\nAnimatePresence\n>\n</\nmotion\n.\nsection\n>\n)\n:\nnull\n}\n</\nAnimatePresence\n>\nroot\nRoot element for injecting\npopLayout\nstyles. Defaults to\ndocument.head\nbut can be set to another\nShadowRoot\n, for use within shadow DOM.\nTroubleshooting\nExit animations aren't working\nEnsure all\nimmediate\nchildren get a unique\nkey\nprop that\nremains the same for that component every render\n.\nFor instance, providing\nindex\nas a\nkey\nis\nbad\nbecause if the items reorder then the\nindex\nwill not be matched to the\nitem\n:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nindex\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nIt's preferred to pass something that's unique to that item, for instance an ID:\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nComponent\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nAlso make sure\nAnimatePresence\nis\noutside\nof the code that unmounts the element. If\nAnimatePresence\nitself unmounts, then it can't control exit animations!\nFor example, this will\nnot work\n:\nisVisible\n&&\n(\n<\nAnimatePresence\n>\n<\nComponent\n/>\n</\nAnimatePresence\n>\n)\nInstead, the conditional should be at the root of\nAnimatePresence\n:\n<\nAnimatePresence\n>\n{\nisVisible\n&&\n<\nComponent\n/>\n}\n</\nAnimatePresence\n>\nLayout animations not working with\nmode=\"sync\"\nWhen mixing exit and\nlayout animations\n, it might be necessary to wrap the group in\nLayoutGroup\nto ensure that components outside of\nAnimatePresence\nknow when to perform a layout animation.\n<\nLayoutGroup\n>\n<\nmotion\n.\nul\nlayout\n>\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\n</\nLayoutGroup\n>\nLayout animations not working with\nmode=\"popLayout\"\nWhen any HTML element has an active\ntransform\nit temporarily becomes the\noffset parent\nof its children. This can cause children with\nposition: \"absolute\"\nnot to appear where you expect.\nmode=\"popLayout\"\nworks by using\nposition: \"absolute\"\n. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a\nposition\nother than\n\"static\"\n.\n<\nmotion\n.\nul\nlayout\nstyle\n=\n{\n{\nposition\n:\n\"relative\"\n}\n}\n>\n<\nAnimatePresence\nmode\n=\n\"popLayout\"\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nmotion\n.\nli\nlayout\nkey\n=\n{\nitem\n.\nid\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\n</\nmotion\n.\nul\n>\nRelated topics\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nMotion component\nAnimate elements with a declarative API. Supports variants, gestures, and layout animations.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nMotion+\nCursor\nCreate custom cursor and follow-along effects in React.\nMotion+\nAnimateActivity\nAdd powerful enter, exit, and layout animations to components managed by React's <Activity>\nMotion+\nAnimateActivity\nAdd powerful enter, exit, and layout animations to components managed by React's <Activity>\nMotion+\nAnimateActivity\nAdd powerful enter, exit, and layout animations to components managed by React's <Activity>\nAnimatePresence examples\nSee all examples & tutorials, with full copy & paste source code.\nAnimatePresence examples\nSee all examples & tutorials, with full copy & paste source code.\nAnimatePresence examples\nSee all examples & tutorials, with full copy & paste source code.\nTutorial\nExit animation\nAn example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.\nTutorial\nExit animation\nAn example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.\nTutorial\nExit animation\nAn example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.\nPrevious\nAnimateActivity\nNext\nLayoutGroup\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "`AnimatePresence` makes exit animations easy. By wrapping one or more `motion` [components](./react-motion-component) with `AnimatePresence`, we gain access to the `exit` animation prop.\n\n```\n<AnimatePresence>\n  {show && <motion.div key=\"modal\" exit={{ opacity: 0 }} />}\n</AnimatePresence>\n```\n\n## [Usage](#usage)\n\n### [Import](#import)\n\n```\nimport { AnimatePresence } from \"motion/react\"\n```\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` works by detecting when its **direct children** are removed from the React tree.\n\nThis can be due to a component mounting/remounting:\n\n```\n<AnimatePresence>\n  {show && <Modal key=\"modal\" />}\n</AnimatePresence>\n```\n\nIts `key` changing:\n\n```\n<AnimatePresence>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\nOr when children in a list are added/removed:\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li key={item.id} exit={{ opacity: 1 }} layout />\n  ))}\n</AnimatePresence>\n```\n\nAny `motion` components within the exiting component will fire animations defined on their `exit` props before the component is removed from the DOM.\n\n```\nfunction Slide({ img, description }) {\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      <img src={img.src} />\n      <motion.p exit={{ y: 10 }}>{description}</motion.p>\n    </motion.div>\n  )\n}\n```\n\nDirect children must each have a unique `key` prop so `AnimatePresence` can track their presence in the tree.\n\nLike `initial` and `animate`, `exit` can be defined either as an object of values, or as a variant label.\n\n```\nconst modalVariants = {\n  visible: { opacity: 1, transition: { when: \"beforeChildren\" } },\n  hidden: { opacity: 0, transition: { when: \"afterChildren\" } }\n}\n\nfunction Modal({ children }) {\n  return (\n    <motion.div initial=\"hidden\" animate=\"visible\" exit=\"hidden\">\n      {children}\n    </motion.div>\n  )\n}\n```\n\n### [Changing `key`](#changing-key)\n\nChanging a `key` prop makes React create an entirely new component. So by changing the `key` of a single child of `AnimatePresence`, we can easily make components like slideshows.\n\n```\nexport const Slideshow = ({ image }) => (\n  <AnimatePresence>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      initial={{ x: 300, opacity: 0 }}\n      animate={{ x: 0, opacity: 1 }}\n      exit={{ x: -300, opacity: 0 }}\n    />\n  </AnimatePresence>\n)\n```\n\n### [Access presence state](#access-presence-state)\n\nAny child of `AnimatePresence` can access presence state with the `useIsPresence` hook.\n\n```\nimport { useIsPresent } from \"motion/react\"\n\nfunction Component() {\n  const isPresent = useIsPresent()\n\n  return isPresent ? \"Here!\" : \"Exiting...\"\n}\n```\n\nThis allows you to change content or styles when a component is no longer rendered.\n\n### [Access presence data](#access-presence-data)\n\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use `AnimatePresence`'s `custom` prop to pass new data down through the tree, even into exiting components.\n\n```\n<AnimatePresence custom={swipeDirection}>\n  <Slide key={activeSlideId}>\n```\n\nThen later we can extract that using `usePresenceData`.\n\n```\nimport { AnimatePresence, usePresenceData } from \"motion/react\"\n\nfunction Slide() {\n  const isPresent = useIsPresent()\n  const direction = usePresenceData()\n\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      {isPresent ? \"Here!\" : \"Exiting \" + direction}\n    </motion.div>\n  )\n}\n```\n\n### [Manual usage](#manual-usage)\n\nIt's also possible to manually tell `AnimatePresence` when a component is safe to remove with the `usePresence` hook.\n\nThis returns both `isPresent` state and a callback, `safeToRemove`, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\n\n```\nimport { usePresence } from \"motion/react\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n\n  useEffect(() => {\n    // Remove from DOM 1000ms after being removed from React\n    !isPresent && setTimeout(safeToRemove, 1000)\n  }, [isPresent])\n\n  return <div />\n}\n```\n\n### [Propagate exit animations](#propagate-exit-animations)\n\nBy default, `AnimatePresence` controls the `exit` animations on all of its children, **until** another `AnimatePresence` component is rendered.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\nBy setting an `AnimatePresence` component's `propagate` prop to `true`, when it's removed from another `AnimatePresence` it will fire all of **its** children's exit animations.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n## [Props](#props)\n\n### [`initial`](#initial)\n\nBy passing `initial={false}`, `AnimatePresence` will disable any initial animations on children that are present when the component is first rendered.\n\n```\n<AnimatePresence initial={false}>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\n### [`custom`](#custom)\n\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\n\nBy passing a value through `AnimatePresence`'s `custom` prop, we can use dynamic variants to change the `exit` animation.\n\n```\nconst variants = {\n  hidden: (direction) => ({\n    opacity: 0,\n    x: direction === 1 ? -300 : 300\n  }),\n  visible: { opacity: 1, x: 0 }\n}\n\nexport const Slideshow = ({ image, direction }) => (\n  <AnimatePresence custom={direction}>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      variants={variants}\n      initial=\"hidden\"\n      animate=\"visible\"\n      exit=\"hidden\"\n    />\n  </AnimatePresence>\n)\n```\n\nThis data can be accessed by children via `usePresenceData`.\n\n### [`mode`](#mode)\n\n**Default:** `\"sync\"`\n\nDecides how `AnimatePresence` handles entering and exiting children.\n\n#### [`sync`](#sync)\n\nIn `\"sync\"` mode, elements animate in and out as soon as they're added/removed.\n\nThis is the most basic (and default) mode - `AnimatePresence` takes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using `position: absolute` or similar), or try one of the other two `mode` options.\n\n#### [`wait`](#wait)\n\nIn `\"wait\"` mode, the entering element will **wait** until the exiting child has animated out, before it animates in.\n\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\n\n`wait` mode only supports one child at a time.\n\nTry setting `ease: \"easeIn\"` (or similar) on the exit animation, and `ease: \"easeOut\"` on the enter animation for an overall `easeInOut` easing effect.\n\n#### [`popLayout`](#poplayout)\n\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the `layout` prop, so elements can animate to their new layout.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li layout exit={{ opacity: 0 }} />\n  )}\n</AnimatePresence>\n```\n\nWhen using `popLayout` mode, any immediate child of AnimatePresence that's a custom component **must** be wrapped in React's `forwardRef` function, forwarding the provided `ref` to the DOM node you wish to pop out of the layout.\n\nFor a more detailed comparison, check out the [full AnimatePresence modes tutorial](../tutorials/react-animate-presence-modes).\n\n### [`onExitComplete`](#onexitcomplete)\n\nFires when all exiting nodes have completed animating out.\n\n### [`propagate`](#propagate)\n\n**Default:** `false`\n\nIf set to `true`, exit animations on children will also trigger when this `AnimatePresence` exits from a parent `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/* This exit prop will now fire when show is false */}\n        <motion.div exit={{ x: -100 }} />\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n### [`root`](#root)\n\nRoot element for injecting `popLayout` styles. Defaults to `document.head` but can be set to another `ShadowRoot`, for use within shadow DOM.\n\n## [Troubleshooting](#troubleshooting)\n\n### [Exit animations aren't working](#exit-animations-aren-t-working)\n\nEnsure all **immediate** children get a unique `key` prop that **remains the same for that component every render**.\n\nFor instance, providing `index` as a `key` is **bad** because if the items reorder then the `index` will not be matched to the `item`:\n\n```\n<AnimatePresence>\n  {items.map((item, index) => (\n    <Component key={index} />\n  ))}\n</AnimatePresence>\n```\n\nIt's preferred to pass something that's unique to that item, for instance an ID:\n\n```\n<AnimatePresence>\n  {items.map((item) => (\n    <Component key={item.id} />\n  ))}\n</AnimatePresence>\n```\n\nAlso make sure `AnimatePresence` is **outside** of the code that unmounts the element. If `AnimatePresence` itself unmounts, then it can't control exit animations!\n\nFor example, this will **not work**:\n\n```\nisVisible && (\n  <AnimatePresence>\n    <Component />\n  </AnimatePresence>\n)\n```\n\nInstead, the conditional should be at the root of `AnimatePresence`:\n\n```\n<AnimatePresence>\n  {isVisible && <Component />}\n</AnimatePresence>\n```\n\n### [Layout animations not working with `mode=\"sync\"`](#layout-animations-not-working-with-mode-sync)\n\nWhen mixing exit and [layout animations](./react-layout-animations), it might be necessary to wrap the group in `LayoutGroup` to ensure that components outside of `AnimatePresence` know when to perform a layout animation.\n\n```\n<LayoutGroup>\n  <motion.ul layout>\n    <AnimatePresence>\n      {items.map(item => (\n        <motion.li layout key={item.id} />\n      ))}\n    </AnimatePresence>\n  </motion.ul>\n</LayoutGroup>\n```\n\n### [Layout animations not working with `mode=\"popLayout\"`](#layout-animations-not-working-with-mode-poplayout)\n\nWhen any HTML element has an active `transform` it temporarily becomes the [offset parent](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent) of its children. This can cause children with `position: \"absolute\"` not to appear where you expect.  \n  \n`mode=\"popLayout\"` works by using `position: \"absolute\"`. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a `position` other than `\"static\"`.\n\n```\n<motion.ul layout style={{ position: \"relative\" }}>\n  <AnimatePresence mode=\"popLayout\">\n    {items.map(item => (\n      <motion.li layout key={item.id} />\n    ))}\n  </AnimatePresence>\n</motion.ul>\n```\n\n`AnimatePresence` makes exit animations easy. By wrapping one or more `motion` [components](./react-motion-component) with `AnimatePresence`, we gain access to the `exit` animation prop.\n\n```\n<AnimatePresence>\n  {show && <motion.div key=\"modal\" exit={{ opacity: 0 }} />}\n</AnimatePresence>\n```\n\n## [Usage](#usage)\n\n### [Import](#import)\n\n```\nimport { AnimatePresence } from \"motion/react\"\n```\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` works by detecting when its **direct children** are removed from the React tree.\n\nThis can be due to a component mounting/remounting:\n\n```\n<AnimatePresence>\n  {show && <Modal key=\"modal\" />}\n</AnimatePresence>\n```\n\nIts `key` changing:\n\n```\n<AnimatePresence>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\nOr when children in a list are added/removed:\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li key={item.id} exit={{ opacity: 1 }} layout />\n  ))}\n</AnimatePresence>\n```\n\nAny `motion` components within the exiting component will fire animations defined on their `exit` props before the component is removed from the DOM.\n\n```\nfunction Slide({ img, description }) {\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      <img src={img.src} />\n      <motion.p exit={{ y: 10 }}>{description}</motion.p>\n    </motion.div>\n  )\n}\n```\n\nDirect children must each have a unique `key` prop so `AnimatePresence` can track their presence in the tree.\n\nLike `initial` and `animate`, `exit` can be defined either as an object of values, or as a variant label.\n\n```\nconst modalVariants = {\n  visible: { opacity: 1, transition: { when: \"beforeChildren\" } },\n  hidden: { opacity: 0, transition: { when: \"afterChildren\" } }\n}\n\nfunction Modal({ children }) {\n  return (\n    <motion.div initial=\"hidden\" animate=\"visible\" exit=\"hidden\">\n      {children}\n    </motion.div>\n  )\n}\n```\n\n### [Changing `key`](#changing-key)\n\nChanging a `key` prop makes React create an entirely new component. So by changing the `key` of a single child of `AnimatePresence`, we can easily make components like slideshows.\n\n```\nexport const Slideshow = ({ image }) => (\n  <AnimatePresence>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      initial={{ x: 300, opacity: 0 }}\n      animate={{ x: 0, opacity: 1 }}\n      exit={{ x: -300, opacity: 0 }}\n    />\n  </AnimatePresence>\n)\n```\n\n### [Access presence state](#access-presence-state)\n\nAny child of `AnimatePresence` can access presence state with the `useIsPresence` hook.\n\n```\nimport { useIsPresent } from \"motion/react\"\n\nfunction Component() {\n  const isPresent = useIsPresent()\n\n  return isPresent ? \"Here!\" : \"Exiting...\"\n}\n```\n\nThis allows you to change content or styles when a component is no longer rendered.\n\n### [Access presence data](#access-presence-data)\n\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use `AnimatePresence`'s `custom` prop to pass new data down through the tree, even into exiting components.\n\n```\n<AnimatePresence custom={swipeDirection}>\n  <Slide key={activeSlideId}>\n```\n\nThen later we can extract that using `usePresenceData`.\n\n```\nimport { AnimatePresence, usePresenceData } from \"motion/react\"\n\nfunction Slide() {\n  const isPresent = useIsPresent()\n  const direction = usePresenceData()\n\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      {isPresent ? \"Here!\" : \"Exiting \" + direction}\n    </motion.div>\n  )\n}\n```\n\n### [Manual usage](#manual-usage)\n\nIt's also possible to manually tell `AnimatePresence` when a component is safe to remove with the `usePresence` hook.\n\nThis returns both `isPresent` state and a callback, `safeToRemove`, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\n\n```\nimport { usePresence } from \"motion/react\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n\n  useEffect(() => {\n    // Remove from DOM 1000ms after being removed from React\n    !isPresent && setTimeout(safeToRemove, 1000)\n  }, [isPresent])\n\n  return <div />\n}\n```\n\n### [Propagate exit animations](#propagate-exit-animations)\n\nBy default, `AnimatePresence` controls the `exit` animations on all of its children, **until** another `AnimatePresence` component is rendered.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\nBy setting an `AnimatePresence` component's `propagate` prop to `true`, when it's removed from another `AnimatePresence` it will fire all of **its** children's exit animations.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n## [Props](#props)\n\n### [`initial`](#initial)\n\nBy passing `initial={false}`, `AnimatePresence` will disable any initial animations on children that are present when the component is first rendered.\n\n```\n<AnimatePresence initial={false}>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\n### [`custom`](#custom)\n\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\n\nBy passing a value through `AnimatePresence`'s `custom` prop, we can use dynamic variants to change the `exit` animation.\n\n```\nconst variants = {\n  hidden: (direction) => ({\n    opacity: 0,\n    x: direction === 1 ? -300 : 300\n  }),\n  visible: { opacity: 1, x: 0 }\n}\n\nexport const Slideshow = ({ image, direction }) => (\n  <AnimatePresence custom={direction}>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      variants={variants}\n      initial=\"hidden\"\n      animate=\"visible\"\n      exit=\"hidden\"\n    />\n  </AnimatePresence>\n)\n```\n\nThis data can be accessed by children via `usePresenceData`.\n\n### [`mode`](#mode)\n\n**Default:** `\"sync\"`\n\nDecides how `AnimatePresence` handles entering and exiting children.\n\n#### [`sync`](#sync)\n\nIn `\"sync\"` mode, elements animate in and out as soon as they're added/removed.\n\nThis is the most basic (and default) mode - `AnimatePresence` takes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using `position: absolute` or similar), or try one of the other two `mode` options.\n\n#### [`wait`](#wait)\n\nIn `\"wait\"` mode, the entering element will **wait** until the exiting child has animated out, before it animates in.\n\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\n\n`wait` mode only supports one child at a time.\n\nTry setting `ease: \"easeIn\"` (or similar) on the exit animation, and `ease: \"easeOut\"` on the enter animation for an overall `easeInOut` easing effect.\n\n#### [`popLayout`](#poplayout)\n\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the `layout` prop, so elements can animate to their new layout.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li layout exit={{ opacity: 0 }} />\n  )}\n</AnimatePresence>\n```\n\nWhen using `popLayout` mode, any immediate child of AnimatePresence that's a custom component **must** be wrapped in React's `forwardRef` function, forwarding the provided `ref` to the DOM node you wish to pop out of the layout.\n\nFor a more detailed comparison, check out the [full AnimatePresence modes tutorial](../tutorials/react-animate-presence-modes).\n\n### [`onExitComplete`](#onexitcomplete)\n\nFires when all exiting nodes have completed animating out.\n\n### [`propagate`](#propagate)\n\n**Default:** `false`\n\nIf set to `true`, exit animations on children will also trigger when this `AnimatePresence` exits from a parent `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/* This exit prop will now fire when show is false */}\n        <motion.div exit={{ x: -100 }} />\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n### [`root`](#root)\n\nRoot element for injecting `popLayout` styles. Defaults to `document.head` but can be set to another `ShadowRoot`, for use within shadow DOM.\n\n## [Troubleshooting](#troubleshooting)\n\n### [Exit animations aren't working](#exit-animations-aren-t-working)\n\nEnsure all **immediate** children get a unique `key` prop that **remains the same for that component every render**.\n\nFor instance, providing `index` as a `key` is **bad** because if the items reorder then the `index` will not be matched to the `item`:\n\n```\n<AnimatePresence>\n  {items.map((item, index) => (\n    <Component key={index} />\n  ))}\n</AnimatePresence>\n```\n\nIt's preferred to pass something that's unique to that item, for instance an ID:\n\n```\n<AnimatePresence>\n  {items.map((item) => (\n    <Component key={item.id} />\n  ))}\n</AnimatePresence>\n```\n\nAlso make sure `AnimatePresence` is **outside** of the code that unmounts the element. If `AnimatePresence` itself unmounts, then it can't control exit animations!\n\nFor example, this will **not work**:\n\n```\nisVisible && (\n  <AnimatePresence>\n    <Component />\n  </AnimatePresence>\n)\n```\n\nInstead, the conditional should be at the root of `AnimatePresence`:\n\n```\n<AnimatePresence>\n  {isVisible && <Component />}\n</AnimatePresence>\n```\n\n### [Layout animations not working with `mode=\"sync\"`](#layout-animations-not-working-with-mode-sync)\n\nWhen mixing exit and [layout animations](./react-layout-animations), it might be necessary to wrap the group in `LayoutGroup` to ensure that components outside of `AnimatePresence` know when to perform a layout animation.\n\n```\n<LayoutGroup>\n  <motion.ul layout>\n    <AnimatePresence>\n      {items.map(item => (\n        <motion.li layout key={item.id} />\n      ))}\n    </AnimatePresence>\n  </motion.ul>\n</LayoutGroup>\n```\n\n### [Layout animations not working with `mode=\"popLayout\"`](#layout-animations-not-working-with-mode-poplayout)\n\nWhen any HTML element has an active `transform` it temporarily becomes the [offset parent](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent) of its children. This can cause children with `position: \"absolute\"` not to appear where you expect.  \n  \n`mode=\"popLayout\"` works by using `position: \"absolute\"`. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a `position` other than `\"static\"`.\n\n```\n<motion.ul layout style={{ position: \"relative\" }}>\n  <AnimatePresence mode=\"popLayout\">\n    {items.map(item => (\n      <motion.li layout key={item.id} />\n    ))}\n  </AnimatePresence>\n</motion.ul>\n```\n\n`AnimatePresence` makes exit animations easy. By wrapping one or more `motion` [components](./react-motion-component) with `AnimatePresence`, we gain access to the `exit` animation prop.\n\n```\n<AnimatePresence>\n  {show && <motion.div key=\"modal\" exit={{ opacity: 0 }} />}\n</AnimatePresence>\n```\n\n## [Usage](#usage)\n\n### [Import](#import)\n\n```\nimport { AnimatePresence } from \"motion/react\"\n```\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` works by detecting when its **direct children** are removed from the React tree.\n\nThis can be due to a component mounting/remounting:\n\n```\n<AnimatePresence>\n  {show && <Modal key=\"modal\" />}\n</AnimatePresence>\n```\n\nIts `key` changing:\n\n```\n<AnimatePresence>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\nOr when children in a list are added/removed:\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li key={item.id} exit={{ opacity: 1 }} layout />\n  ))}\n</AnimatePresence>\n```\n\nAny `motion` components within the exiting component will fire animations defined on their `exit` props before the component is removed from the DOM.\n\n```\nfunction Slide({ img, description }) {\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      <img src={img.src} />\n      <motion.p exit={{ y: 10 }}>{description}</motion.p>\n    </motion.div>\n  )\n}\n```\n\nDirect children must each have a unique `key` prop so `AnimatePresence` can track their presence in the tree.\n\nLike `initial` and `animate`, `exit` can be defined either as an object of values, or as a variant label.\n\n```\nconst modalVariants = {\n  visible: { opacity: 1, transition: { when: \"beforeChildren\" } },\n  hidden: { opacity: 0, transition: { when: \"afterChildren\" } }\n}\n\nfunction Modal({ children }) {\n  return (\n    <motion.div initial=\"hidden\" animate=\"visible\" exit=\"hidden\">\n      {children}\n    </motion.div>\n  )\n}\n```\n\n### [Changing `key`](#changing-key)\n\nChanging a `key` prop makes React create an entirely new component. So by changing the `key` of a single child of `AnimatePresence`, we can easily make components like slideshows.\n\n```\nexport const Slideshow = ({ image }) => (\n  <AnimatePresence>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      initial={{ x: 300, opacity: 0 }}\n      animate={{ x: 0, opacity: 1 }}\n      exit={{ x: -300, opacity: 0 }}\n    />\n  </AnimatePresence>\n)\n```\n\n### [Access presence state](#access-presence-state)\n\nAny child of `AnimatePresence` can access presence state with the `useIsPresence` hook.\n\n```\nimport { useIsPresent } from \"motion/react\"\n\nfunction Component() {\n  const isPresent = useIsPresent()\n\n  return isPresent ? \"Here!\" : \"Exiting...\"\n}\n```\n\nThis allows you to change content or styles when a component is no longer rendered.\n\n### [Access presence data](#access-presence-data)\n\nWhen a component has been removed from the React tree, its props can no longer be updated. We can use `AnimatePresence`'s `custom` prop to pass new data down through the tree, even into exiting components.\n\n```\n<AnimatePresence custom={swipeDirection}>\n  <Slide key={activeSlideId}>\n```\n\nThen later we can extract that using `usePresenceData`.\n\n```\nimport { AnimatePresence, usePresenceData } from \"motion/react\"\n\nfunction Slide() {\n  const isPresent = useIsPresent()\n  const direction = usePresenceData()\n\n  return (\n    <motion.div exit={{ opacity: 0 }}>\n      {isPresent ? \"Here!\" : \"Exiting \" + direction}\n    </motion.div>\n  )\n}\n```\n\n### [Manual usage](#manual-usage)\n\nIt's also possible to manually tell `AnimatePresence` when a component is safe to remove with the `usePresence` hook.\n\nThis returns both `isPresent` state and a callback, `safeToRemove`, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).\n\n```\nimport { usePresence } from \"motion/react\"\n\nfunction Component() {\n  const [isPresent, safeToRemove] = usePresence()\n\n  useEffect(() => {\n    // Remove from DOM 1000ms after being removed from React\n    !isPresent && setTimeout(safeToRemove, 1000)\n  }, [isPresent])\n\n  return <div />\n}\n```\n\n### [Propagate exit animations](#propagate-exit-animations)\n\nBy default, `AnimatePresence` controls the `exit` animations on all of its children, **until** another `AnimatePresence` component is rendered.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children will not fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\nBy setting an `AnimatePresence` component's `propagate` prop to `true`, when it's removed from another `AnimatePresence` it will fire all of **its** children's exit animations.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/*\n          * When `show` becomes `false`, exit animations\n          * on these children **will** fire.\n          */}\n        {children}\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n## [Props](#props)\n\n### [`initial`](#initial)\n\nBy passing `initial={false}`, `AnimatePresence` will disable any initial animations on children that are present when the component is first rendered.\n\n```\n<AnimatePresence initial={false}>\n  <Slide key={activeItem.id} />\n</AnimatePresence>\n```\n\n### [`custom`](#custom)\n\nWhen a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.\n\nBy passing a value through `AnimatePresence`'s `custom` prop, we can use dynamic variants to change the `exit` animation.\n\n```\nconst variants = {\n  hidden: (direction) => ({\n    opacity: 0,\n    x: direction === 1 ? -300 : 300\n  }),\n  visible: { opacity: 1, x: 0 }\n}\n\nexport const Slideshow = ({ image, direction }) => (\n  <AnimatePresence custom={direction}>\n    <motion.img\n      key={image.src}\n      src={image.src}\n      variants={variants}\n      initial=\"hidden\"\n      animate=\"visible\"\n      exit=\"hidden\"\n    />\n  </AnimatePresence>\n)\n```\n\nThis data can be accessed by children via `usePresenceData`.\n\n### [`mode`](#mode)\n\n**Default:** `\"sync\"`\n\nDecides how `AnimatePresence` handles entering and exiting children.\n\n#### [`sync`](#sync)\n\nIn `\"sync\"` mode, elements animate in and out as soon as they're added/removed.\n\nThis is the most basic (and default) mode - `AnimatePresence` takes no opinion on sequencing animations or layout. Therefore, if element layouts conflict (as in the above example), you can either implement your own solution (using `position: absolute` or similar), or try one of the other two `mode` options.\n\n#### [`wait`](#wait)\n\nIn `\"wait\"` mode, the entering element will **wait** until the exiting child has animated out, before it animates in.\n\nThis is great for sequential animations, presenting users with one piece of information or one UI element at a time.\n\n`wait` mode only supports one child at a time.\n\nTry setting `ease: \"easeIn\"` (or similar) on the exit animation, and `ease: \"easeOut\"` on the enter animation for an overall `easeInOut` easing effect.\n\n#### [`popLayout`](#poplayout)\n\nExiting elements will be \"popped\" out of the page layout, allowing surrounding elements to immediately reflow. Pairs especially well with the `layout` prop, so elements can animate to their new layout.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <motion.li layout exit={{ opacity: 0 }} />\n  )}\n</AnimatePresence>\n```\n\nWhen using `popLayout` mode, any immediate child of AnimatePresence that's a custom component **must** be wrapped in React's `forwardRef` function, forwarding the provided `ref` to the DOM node you wish to pop out of the layout.\n\nFor a more detailed comparison, check out the [full AnimatePresence modes tutorial](../tutorials/react-animate-presence-modes).\n\n### [`onExitComplete`](#onexitcomplete)\n\nFires when all exiting nodes have completed animating out.\n\n### [`propagate`](#propagate)\n\n**Default:** `false`\n\nIf set to `true`, exit animations on children will also trigger when this `AnimatePresence` exits from a parent `AnimatePresence`.\n\n```\n<AnimatePresence>\n  {show ? (\n    <motion.section exit={{ opacity: 0 }}>\n      <AnimatePresence propagate>\n        {/* This exit prop will now fire when show is false */}\n        <motion.div exit={{ x: -100 }} />\n      </AnimatePresence>\n    </motion.section>\n  ) : null}\n</AnimatePresence>\n```\n\n### [`root`](#root)\n\nRoot element for injecting `popLayout` styles. Defaults to `document.head` but can be set to another `ShadowRoot`, for use within shadow DOM.\n\n## [Troubleshooting](#troubleshooting)\n\n### [Exit animations aren't working](#exit-animations-aren-t-working)\n\nEnsure all **immediate** children get a unique `key` prop that **remains the same for that component every render**.\n\nFor instance, providing `index` as a `key` is **bad** because if the items reorder then the `index` will not be matched to the `item`:\n\n```\n<AnimatePresence>\n  {items.map((item, index) => (\n    <Component key={index} />\n  ))}\n</AnimatePresence>\n```\n\nIt's preferred to pass something that's unique to that item, for instance an ID:\n\n```\n<AnimatePresence>\n  {items.map((item) => (\n    <Component key={item.id} />\n  ))}\n</AnimatePresence>\n```\n\nAlso make sure `AnimatePresence` is **outside** of the code that unmounts the element. If `AnimatePresence` itself unmounts, then it can't control exit animations!\n\nFor example, this will **not work**:\n\n```\nisVisible && (\n  <AnimatePresence>\n    <Component />\n  </AnimatePresence>\n)\n```\n\nInstead, the conditional should be at the root of `AnimatePresence`:\n\n```\n<AnimatePresence>\n  {isVisible && <Component />}\n</AnimatePresence>\n```\n\n### [Layout animations not working with `mode=\"sync\"`](#layout-animations-not-working-with-mode-sync)\n\nWhen mixing exit and [layout animations](./react-layout-animations), it might be necessary to wrap the group in `LayoutGroup` to ensure that components outside of `AnimatePresence` know when to perform a layout animation.\n\n```\n<LayoutGroup>\n  <motion.ul layout>\n    <AnimatePresence>\n      {items.map(item => (\n        <motion.li layout key={item.id} />\n      ))}\n    </AnimatePresence>\n  </motion.ul>\n</LayoutGroup>\n```\n\n### [Layout animations not working with `mode=\"popLayout\"`](#layout-animations-not-working-with-mode-poplayout)\n\nWhen any HTML element has an active `transform` it temporarily becomes the [offset parent](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent) of its children. This can cause children with `position: \"absolute\"` not to appear where you expect.  \n  \n`mode=\"popLayout\"` works by using `position: \"absolute\"`. So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a `position` other than `\"static\"`.\n\n```\n<motion.ul layout style={{ position: \"relative\" }}>\n  <AnimatePresence mode=\"popLayout\">\n    {items.map(item => (\n      <motion.li layout key={item.id} />\n    ))}\n  </AnimatePresence>\n</motion.ul>\n```\n\n## Related topics\n\n- [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n\n  [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n\n  [### Motion component\n\n  Animate elements with a declarative API. Supports variants, gestures, and layout animations.](./react-motion-component)\n- [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n\n  [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n\n  [Motion+\n\n  ### Cursor\n\n  Create custom cursor and follow-along effects in React.](./cursor)\n- [Motion+\n\n  ### AnimateActivity\n\n  Add powerful enter, exit, and layout animations to components managed by React's <Activity>](./react-animate-activity)\n\n  [Motion+\n\n  ### AnimateActivity\n\n  Add powerful enter, exit, and layout animations to components managed by React's <Activity>](./react-animate-activity)\n\n  [Motion+\n\n  ### AnimateActivity\n\n  Add powerful enter, exit, and layout animations to components managed by React's <Activity>](./react-animate-activity)\n\n- [### AnimatePresence examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=animatepresence)\n\n- [### AnimatePresence examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=animatepresence)\n\n- [### AnimatePresence examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=animatepresence)\n\n- [Tutorial\n\n  ### Exit animation\n\n  An example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.](../tutorials/react-exit-animation)\n\n- [Tutorial\n\n  ### Exit animation\n\n  An example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.](../tutorials/react-exit-animation)\n\n- [Tutorial\n\n  ### Exit animation\n\n  An example of animating an element when it's removed from the DOM using AnimatePresence in Motion for React.](../tutorials/react-exit-animation)\n\nPrevious\n\n[AnimateActivity](./react-animate-activity)\n\nNext\n\n[LayoutGroup](./react-layout-group)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:22.739982+00:00",
  "content_length": 32190,
  "content_hash": "e3b5184ec161475c"
}