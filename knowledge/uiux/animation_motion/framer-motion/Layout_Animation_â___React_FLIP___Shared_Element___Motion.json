{
  "id": "framer-motion__motion_layout-animations_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/layout-animations/",
  "title": "Layout Animation \u00e2\u0080\u0094 React FLIP & Shared Element | Motion",
  "content": "Motion makes it simple to\nanimate an element's size and position\nbetween different layouts. With the\nlayout\nprop, you can perform layout animations, and by using\nlayoutId\nyou can create seamless \"magic motion\" effects between two separate elements.\nIn this guide, we'll learn how to:\nAnimate layout changes\nwith a single prop.\nCreate\nshared element transitions\nbetween components.\nExplore\nadvanced techniques\n.\nTroubleshoot\ncommon layout animation issues.\nUnderstand the\ndifferences\nbetween Motion and the native View Transitions API.\nHow to animate layout changes\nTo enable layout animations on a\nmotion\ncomponent, simply add the\nlayout\nprop. Any layout change that happens as a result of a React render will now be automatically animated.\n<\nmotion\n.\ndiv\nlayout\n/>\nLayout animation can animate previously unanimatable CSS values, like switching\njustify-content\nbetween\nflex-start\nand\nflex-end\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\njustifyContent\n:\nisOn\n?\n\"flex-start\"\n:\n\"flex-end\"\n}\n}\n/>\nOr by using the\nlayoutId\nprop, it's possible to match two elements and animate between them for some truly advanced animations.\n<\nmotion\n.\nli\nlayoutId\n=\n\"item\"\n/>\nIt can handle anything from microinteractions to full page transitions.\nWhen performing layout animations, changes to layout should be made via\nstyle\nor\nclassName\n, not via animation props like\nanimate\nor\nwhileHover\n, as\nlayout\nwill take care of the animation.\nLayout changes can be anything, changing\nwidth\n/\nheight\n, number of grid columns, reordering a list, or adding/removing new items:\nPerformance\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS\ntransform\nproperty for the highest possible performance.\nShared layout animations\nFor more advanced shared layout animations,\nlayoutId\nallows you to connect two different elements.\nWhen a new component is added with a\nlayoutId\nprop matching an existing component, it will automatically animate out from the old component.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\nTo animate an element back to its origin, you can use the\nAnimatePresence\ncomponent to keep it in the DOM until its exit animation has finished.\n<\nAnimatePresence\n>\n{\nisOpen\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nCustomise a layout animation\nLayout animations can be customised using\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nlayout\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like\nopacity\n), you can define a dedicated\nlayout\ntransition.\n<\nmotion\n.\ndiv\nlayout\nanimate\n=\n{\n{\nopacity\n:\n0.5\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"linear\"\n,\nlayout\n:\n{\nduration\n:\n0.3\n}\n}\n}\n/>\nWhen performing a shared layout animation, the transition defined for element we're animating\nto\nwill be used.\n<\n>\n<\nmotion\n.\nbutton\nlayoutId\n=\n\"modal\"\nonClick\n=\n{\n(\n)\n=>\nsetIsOpen\n(\ntrue\n)\n}\n// This transition will be used when the modal closes\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n>\nOpen\n</\nmotion\n.\nbutton\n>\n<\nAnimatePresence\n>\n{\nisOn\n&&\n(\n<\nmotion\n.\ndialog\nlayoutId\n=\n\"modal\"\n// This transition will be used when the modal opens\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\n</\n>\nAdvanced use-cases\nAnimating within scrollable element\nTo correctly animate layout within a scrollable container, you must add the\nlayoutScroll\nprop to the scrollable element. This allows Motion to account for the element's scroll offset.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n/>\nAnimating within fixed containers\nTo correctly animate layout within fixed elements, we need to provide them the\nlayoutRoot\nprop.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n/>\nThis lets Motion account for the page's scroll offset when measuring children.\nGroup layout animations\nLayout animations are triggered when a component re-renders and its layout has changed.\nfunction\nAccordion\n(\n)\n{\nconst\n[\nisOpen\n,\nsetOpen\n]\n=\nuseState\n(\nfalse\n)\nreturn\n(\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nheight\n:\nisOpen\n?\n\"100px\"\n:\n\"500px\"\n}\n}\nonClick\n=\n{\n(\n)\n=>\nsetOpen\n(\n!\nisOpen\n)\n}\n/>\n)\n}\nBut what happens when we have two or more components that don't re-render at the same time, but\ndo\naffect each other's layout?\nfunction\nList\n(\n)\n{\nreturn\n(\n<\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\n>\n)\n}\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\nWe can synchronise layout changes across multiple components by wrapping them in the\nLayoutGroup component\n.\nimport\n{\nLayoutGroup\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nLayoutGroup\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\nLayoutGroup\n>\n)\n}\nWhen layout changes are detected in any grouped\nmotion\ncomponent, layout animations will trigger across all of them.\nScale correction\nBecause\nlayout\nanimations use\ntransform: scale()\n, they can sometimes visually distort children or certain CSS properties.\nChild elements:\nTo fix distortion on direct children, these can also be given the\nlayout\nprop.\nBorder radius and box shadow:\nMotion automatically corrects distortion on these properties, but they must be set via the\nstyle\n,\nanimate\nor other animation prop.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nTroubleshooting\nThe component isn't animating\nEnsure the component is\nnot\nset to\ndisplay: inline\n, as browsers don't apply\ntransform\nto these elements.\nEnsure the component is re-rendering when you expect the layout animation to start.\nAnimations don't work during window resize\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\nSVG layout animations are broken\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like\ncx\netc.\nThe content stretches undesirably\nThis is a natural side-effect of animating\nwidth\nand\nheight\nwith\nscale\n.\nOften, this can be fixed by providing these elements a\nlayout\nanimation and they'll be scale-corrected.\n<\nmotion\n.\nsection\nlayout\n>\n<\nmotion\n.\nimg\nlayout\n/>\n</\nmotion\n.\nsection\n>\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with\nlayout=\"position\"\n.\nBorder radius or box shadows are behaving strangely\nAnimating\nscale\nis performant but can distort some styles like\nborder-radius\nand\nbox-shadow\n.\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via\nstyle\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nBorder looks stretched during animation\nElements with a\nborder\nmay look stretched during the animation. This is for two reasons:\nBecause changing\nborder\ntriggers layout recalculations, it defeats the performance benefits of animating via\ntransform\n. You might as well animate\nwidth\nand\nheight\nclassically.\nborder\ncan't render smaller than\n1px\n, which limits the degree of scale correction that Motion can perform on this style.\nA work around is to replace\nborder\nwith a parent element with padding that acts as a\nborder\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n10\n,\npadding\n:\n5\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n5\n}\n}\n/>\n</\nmotion\n.\ndiv\n>\nTechnical reading\nInterested in the technical details behind layout animations? Nanda does an incredible job of\nexplaining the challenges\nof animating layout with transforms using interactive examples. Matt, creator of Motion, did a\ntalk at Vercel conference\nabout the implementation details that is largely up to date.\nMotion's layout animations vs the View Transitions API\nMore browsers are starting to support the\nView Transitions API\n, which is similar to Motion's layout animations.\nBenefits of View Transitions API\nThe main two benefits of View Transitions is that\nit's included in browsers\nand\nfeatures a unique rendering system\n.\nFilesize\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\nRendering\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations.\nFramer's Page Effects\nwere built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\nDrawbacks to View Transitions API\nThere are quite a few drawbacks to the API vs layout animations:\nNot interruptible\n: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\nBlocks interaction\n: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\nDifficult to manage IDs\n: Layout animations allow more than one element with a\nlayoutId\nwhereas View Transitions will break if the previous element isn't removed.\nLess performant:\nView Transitions take an actual screenshot and animate via\nwidth\n/\nheight\nvs layout animation's\ntransform\n. This is measurably less performant when animating many elements.\nDoesn't account for scroll\n: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\nNo relative animations:\nIf a nested element has a\ndelay\nit will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\nOne animation at a time\n: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\nMotion makes it simple to\nanimate an element's size and position\nbetween different layouts. With the\nlayout\nprop, you can perform layout animations, and by using\nlayoutId\nyou can create seamless \"magic motion\" effects between two separate elements.\nIn this guide, we'll learn how to:\nAnimate layout changes\nwith a single prop.\nCreate\nshared element transitions\nbetween components.\nExplore\nadvanced techniques\n.\nTroubleshoot\ncommon layout animation issues.\nUnderstand the\ndifferences\nbetween Motion and the native View Transitions API.\nHow to animate layout changes\nTo enable layout animations on a\nmotion\ncomponent, simply add the\nlayout\nprop. Any layout change that happens as a result of a React render will now be automatically animated.\n<\nmotion\n.\ndiv\nlayout\n/>\nLayout animation can animate previously unanimatable CSS values, like switching\njustify-content\nbetween\nflex-start\nand\nflex-end\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\njustifyContent\n:\nisOn\n?\n\"flex-start\"\n:\n\"flex-end\"\n}\n}\n/>\nOr by using the\nlayoutId\nprop, it's possible to match two elements and animate between them for some truly advanced animations.\n<\nmotion\n.\nli\nlayoutId\n=\n\"item\"\n/>\nIt can handle anything from microinteractions to full page transitions.\nWhen performing layout animations, changes to layout should be made via\nstyle\nor\nclassName\n, not via animation props like\nanimate\nor\nwhileHover\n, as\nlayout\nwill take care of the animation.\nLayout changes can be anything, changing\nwidth\n/\nheight\n, number of grid columns, reordering a list, or adding/removing new items:\nPerformance\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS\ntransform\nproperty for the highest possible performance.\nShared layout animations\nFor more advanced shared layout animations,\nlayoutId\nallows you to connect two different elements.\nWhen a new component is added with a\nlayoutId\nprop matching an existing component, it will automatically animate out from the old component.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\nTo animate an element back to its origin, you can use the\nAnimatePresence\ncomponent to keep it in the DOM until its exit animation has finished.\n<\nAnimatePresence\n>\n{\nisOpen\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nCustomise a layout animation\nLayout animations can be customised using\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nlayout\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like\nopacity\n), you can define a dedicated\nlayout\ntransition.\n<\nmotion\n.\ndiv\nlayout\nanimate\n=\n{\n{\nopacity\n:\n0.5\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"linear\"\n,\nlayout\n:\n{\nduration\n:\n0.3\n}\n}\n}\n/>\nWhen performing a shared layout animation, the transition defined for element we're animating\nto\nwill be used.\n<\n>\n<\nmotion\n.\nbutton\nlayoutId\n=\n\"modal\"\nonClick\n=\n{\n(\n)\n=>\nsetIsOpen\n(\ntrue\n)\n}\n// This transition will be used when the modal closes\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n>\nOpen\n</\nmotion\n.\nbutton\n>\n<\nAnimatePresence\n>\n{\nisOn\n&&\n(\n<\nmotion\n.\ndialog\nlayoutId\n=\n\"modal\"\n// This transition will be used when the modal opens\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\n</\n>\nAdvanced use-cases\nAnimating within scrollable element\nTo correctly animate layout within a scrollable container, you must add the\nlayoutScroll\nprop to the scrollable element. This allows Motion to account for the element's scroll offset.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n/>\nAnimating within fixed containers\nTo correctly animate layout within fixed elements, we need to provide them the\nlayoutRoot\nprop.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n/>\nThis lets Motion account for the page's scroll offset when measuring children.\nGroup layout animations\nLayout animations are triggered when a component re-renders and its layout has changed.\nfunction\nAccordion\n(\n)\n{\nconst\n[\nisOpen\n,\nsetOpen\n]\n=\nuseState\n(\nfalse\n)\nreturn\n(\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nheight\n:\nisOpen\n?\n\"100px\"\n:\n\"500px\"\n}\n}\nonClick\n=\n{\n(\n)\n=>\nsetOpen\n(\n!\nisOpen\n)\n}\n/>\n)\n}\nBut what happens when we have two or more components that don't re-render at the same time, but\ndo\naffect each other's layout?\nfunction\nList\n(\n)\n{\nreturn\n(\n<\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\n>\n)\n}\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\nWe can synchronise layout changes across multiple components by wrapping them in the\nLayoutGroup component\n.\nimport\n{\nLayoutGroup\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nLayoutGroup\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\nLayoutGroup\n>\n)\n}\nWhen layout changes are detected in any grouped\nmotion\ncomponent, layout animations will trigger across all of them.\nScale correction\nBecause\nlayout\nanimations use\ntransform: scale()\n, they can sometimes visually distort children or certain CSS properties.\nChild elements:\nTo fix distortion on direct children, these can also be given the\nlayout\nprop.\nBorder radius and box shadow:\nMotion automatically corrects distortion on these properties, but they must be set via the\nstyle\n,\nanimate\nor other animation prop.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nTroubleshooting\nThe component isn't animating\nEnsure the component is\nnot\nset to\ndisplay: inline\n, as browsers don't apply\ntransform\nto these elements.\nEnsure the component is re-rendering when you expect the layout animation to start.\nAnimations don't work during window resize\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\nSVG layout animations are broken\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like\ncx\netc.\nThe content stretches undesirably\nThis is a natural side-effect of animating\nwidth\nand\nheight\nwith\nscale\n.\nOften, this can be fixed by providing these elements a\nlayout\nanimation and they'll be scale-corrected.\n<\nmotion\n.\nsection\nlayout\n>\n<\nmotion\n.\nimg\nlayout\n/>\n</\nmotion\n.\nsection\n>\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with\nlayout=\"position\"\n.\nBorder radius or box shadows are behaving strangely\nAnimating\nscale\nis performant but can distort some styles like\nborder-radius\nand\nbox-shadow\n.\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via\nstyle\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nBorder looks stretched during animation\nElements with a\nborder\nmay look stretched during the animation. This is for two reasons:\nBecause changing\nborder\ntriggers layout recalculations, it defeats the performance benefits of animating via\ntransform\n. You might as well animate\nwidth\nand\nheight\nclassically.\nborder\ncan't render smaller than\n1px\n, which limits the degree of scale correction that Motion can perform on this style.\nA work around is to replace\nborder\nwith a parent element with padding that acts as a\nborder\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n10\n,\npadding\n:\n5\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n5\n}\n}\n/>\n</\nmotion\n.\ndiv\n>\nTechnical reading\nInterested in the technical details behind layout animations? Nanda does an incredible job of\nexplaining the challenges\nof animating layout with transforms using interactive examples. Matt, creator of Motion, did a\ntalk at Vercel conference\nabout the implementation details that is largely up to date.\nMotion's layout animations vs the View Transitions API\nMore browsers are starting to support the\nView Transitions API\n, which is similar to Motion's layout animations.\nBenefits of View Transitions API\nThe main two benefits of View Transitions is that\nit's included in browsers\nand\nfeatures a unique rendering system\n.\nFilesize\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\nRendering\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations.\nFramer's Page Effects\nwere built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\nDrawbacks to View Transitions API\nThere are quite a few drawbacks to the API vs layout animations:\nNot interruptible\n: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\nBlocks interaction\n: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\nDifficult to manage IDs\n: Layout animations allow more than one element with a\nlayoutId\nwhereas View Transitions will break if the previous element isn't removed.\nLess performant:\nView Transitions take an actual screenshot and animate via\nwidth\n/\nheight\nvs layout animation's\ntransform\n. This is measurably less performant when animating many elements.\nDoesn't account for scroll\n: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\nNo relative animations:\nIf a nested element has a\ndelay\nit will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\nOne animation at a time\n: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\nMotion makes it simple to\nanimate an element's size and position\nbetween different layouts. With the\nlayout\nprop, you can perform layout animations, and by using\nlayoutId\nyou can create seamless \"magic motion\" effects between two separate elements.\nIn this guide, we'll learn how to:\nAnimate layout changes\nwith a single prop.\nCreate\nshared element transitions\nbetween components.\nExplore\nadvanced techniques\n.\nTroubleshoot\ncommon layout animation issues.\nUnderstand the\ndifferences\nbetween Motion and the native View Transitions API.\nHow to animate layout changes\nTo enable layout animations on a\nmotion\ncomponent, simply add the\nlayout\nprop. Any layout change that happens as a result of a React render will now be automatically animated.\n<\nmotion\n.\ndiv\nlayout\n/>\nLayout animation can animate previously unanimatable CSS values, like switching\njustify-content\nbetween\nflex-start\nand\nflex-end\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\njustifyContent\n:\nisOn\n?\n\"flex-start\"\n:\n\"flex-end\"\n}\n}\n/>\nOr by using the\nlayoutId\nprop, it's possible to match two elements and animate between them for some truly advanced animations.\n<\nmotion\n.\nli\nlayoutId\n=\n\"item\"\n/>\nIt can handle anything from microinteractions to full page transitions.\nWhen performing layout animations, changes to layout should be made via\nstyle\nor\nclassName\n, not via animation props like\nanimate\nor\nwhileHover\n, as\nlayout\nwill take care of the animation.\nLayout changes can be anything, changing\nwidth\n/\nheight\n, number of grid columns, reordering a list, or adding/removing new items:\nPerformance\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS\ntransform\nproperty for the highest possible performance.\nShared layout animations\nFor more advanced shared layout animations,\nlayoutId\nallows you to connect two different elements.\nWhen a new component is added with a\nlayoutId\nprop matching an existing component, it will automatically animate out from the old component.\nisSelected\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"underline\"\n/>\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\nTo animate an element back to its origin, you can use the\nAnimatePresence\ncomponent to keep it in the DOM until its exit animation has finished.\n<\nAnimatePresence\n>\n{\nisOpen\n&&\n<\nmotion\n.\ndiv\nlayoutId\n=\n\"modal\"\n/>\n}\n</\nAnimatePresence\n>\nCustomise a layout animation\nLayout animations can be customised using\nthe\ntransition\nprop\n.\n<\nmotion\n.\ndiv\nlayout\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like\nopacity\n), you can define a dedicated\nlayout\ntransition.\n<\nmotion\n.\ndiv\nlayout\nanimate\n=\n{\n{\nopacity\n:\n0.5\n}\n}\ntransition\n=\n{\n{\nease\n:\n\"linear\"\n,\nlayout\n:\n{\nduration\n:\n0.3\n}\n}\n}\n/>\nWhen performing a shared layout animation, the transition defined for element we're animating\nto\nwill be used.\n<\n>\n<\nmotion\n.\nbutton\nlayoutId\n=\n\"modal\"\nonClick\n=\n{\n(\n)\n=>\nsetIsOpen\n(\ntrue\n)\n}\n// This transition will be used when the modal closes\ntransition\n=\n{\n{\ntype\n:\n\"spring\"\n}\n}\n>\nOpen\n</\nmotion\n.\nbutton\n>\n<\nAnimatePresence\n>\n{\nisOn\n&&\n(\n<\nmotion\n.\ndialog\nlayoutId\n=\n\"modal\"\n// This transition will be used when the modal opens\ntransition\n=\n{\n{\nduration\n:\n0.3\n}\n}\n/>\n)\n}\n</\nAnimatePresence\n>\n</\n>\nAdvanced use-cases\nAnimating within scrollable element\nTo correctly animate layout within a scrollable container, you must add the\nlayoutScroll\nprop to the scrollable element. This allows Motion to account for the element's scroll offset.\n<\nmotion\n.\ndiv\nlayoutScroll\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n/>\nAnimating within fixed containers\nTo correctly animate layout within fixed elements, we need to provide them the\nlayoutRoot\nprop.\n<\nmotion\n.\ndiv\nlayoutRoot\nstyle\n=\n{\n{\nposition\n:\n\"fixed\"\n}\n}\n/>\nThis lets Motion account for the page's scroll offset when measuring children.\nGroup layout animations\nLayout animations are triggered when a component re-renders and its layout has changed.\nfunction\nAccordion\n(\n)\n{\nconst\n[\nisOpen\n,\nsetOpen\n]\n=\nuseState\n(\nfalse\n)\nreturn\n(\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nheight\n:\nisOpen\n?\n\"100px\"\n:\n\"500px\"\n}\n}\nonClick\n=\n{\n(\n)\n=>\nsetOpen\n(\n!\nisOpen\n)\n}\n/>\n)\n}\nBut what happens when we have two or more components that don't re-render at the same time, but\ndo\naffect each other's layout?\nfunction\nList\n(\n)\n{\nreturn\n(\n<\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\n>\n)\n}\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\nWe can synchronise layout changes across multiple components by wrapping them in the\nLayoutGroup component\n.\nimport\n{\nLayoutGroup\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nLayoutGroup\n>\n<\nAccordion\n/>\n<\nAccordion\n/>\n</\nLayoutGroup\n>\n)\n}\nWhen layout changes are detected in any grouped\nmotion\ncomponent, layout animations will trigger across all of them.\nScale correction\nBecause\nlayout\nanimations use\ntransform: scale()\n, they can sometimes visually distort children or certain CSS properties.\nChild elements:\nTo fix distortion on direct children, these can also be given the\nlayout\nprop.\nBorder radius and box shadow:\nMotion automatically corrects distortion on these properties, but they must be set via the\nstyle\n,\nanimate\nor other animation prop.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nTroubleshooting\nThe component isn't animating\nEnsure the component is\nnot\nset to\ndisplay: inline\n, as browsers don't apply\ntransform\nto these elements.\nEnsure the component is re-rendering when you expect the layout animation to start.\nAnimations don't work during window resize\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\nSVG layout animations are broken\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like\ncx\netc.\nThe content stretches undesirably\nThis is a natural side-effect of animating\nwidth\nand\nheight\nwith\nscale\n.\nOften, this can be fixed by providing these elements a\nlayout\nanimation and they'll be scale-corrected.\n<\nmotion\n.\nsection\nlayout\n>\n<\nmotion\n.\nimg\nlayout\n/>\n</\nmotion\n.\nsection\n>\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with\nlayout=\"position\"\n.\nBorder radius or box shadows are behaving strangely\nAnimating\nscale\nis performant but can distort some styles like\nborder-radius\nand\nbox-shadow\n.\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via\nstyle\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n20\n}\n}\n/>\nBorder looks stretched during animation\nElements with a\nborder\nmay look stretched during the animation. This is for two reasons:\nBecause changing\nborder\ntriggers layout recalculations, it defeats the performance benefits of animating via\ntransform\n. You might as well animate\nwidth\nand\nheight\nclassically.\nborder\ncan't render smaller than\n1px\n, which limits the degree of scale correction that Motion can perform on this style.\nA work around is to replace\nborder\nwith a parent element with padding that acts as a\nborder\n.\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n10\n,\npadding\n:\n5\n}\n}\n>\n<\nmotion\n.\ndiv\nlayout\nstyle\n=\n{\n{\nborderRadius\n:\n5\n}\n}\n/>\n</\nmotion\n.\ndiv\n>\nTechnical reading\nInterested in the technical details behind layout animations? Nanda does an incredible job of\nexplaining the challenges\nof animating layout with transforms using interactive examples. Matt, creator of Motion, did a\ntalk at Vercel conference\nabout the implementation details that is largely up to date.\nMotion's layout animations vs the View Transitions API\nMore browsers are starting to support the\nView Transitions API\n, which is similar to Motion's layout animations.\nBenefits of View Transitions API\nThe main two benefits of View Transitions is that\nit's included in browsers\nand\nfeatures a unique rendering system\n.\nFilesize\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\nRendering\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations.\nFramer's Page Effects\nwere built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\nDrawbacks to View Transitions API\nThere are quite a few drawbacks to the API vs layout animations:\nNot interruptible\n: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\nBlocks interaction\n: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\nDifficult to manage IDs\n: Layout animations allow more than one element with a\nlayoutId\nwhereas View Transitions will break if the previous element isn't removed.\nLess performant:\nView Transitions take an actual screenshot and animate via\nwidth\n/\nheight\nvs layout animation's\ntransform\n. This is measurably less performant when animating many elements.\nDoesn't account for scroll\n: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\nNo relative animations:\nIf a nested element has a\ndelay\nit will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\nOne animation at a time\n: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\nRelated topics\nInstall Motion Studio\nEnhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.\nInstall Motion Studio\nEnhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.\nInstall Motion Studio\nEnhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.\nMotion+\nAnimateNumber\nCreate beautiful number ticker and countdown animations in React.\nMotion+\nAnimateNumber\nCreate beautiful number ticker and countdown animations in React.\nMotion+\nAnimateNumber\nCreate beautiful number ticker and countdown animations in React.\nLayout animation examples\nSee all examples & tutorials, with full copy & paste source code.\nLayout animation examples\nSee all examples & tutorials, with full copy & paste source code.\nLayout animation examples\nSee all examples & tutorials, with full copy & paste source code.\nTutorial\niOS App Store\nAn example of animating cards inspired by the iOS App Store using Motion for React's layout animations.\nTutorial\niOS App Store\nAn example of animating cards inspired by the iOS App Store using Motion for React's layout animations.\nTutorial\niOS App Store\nAn example of animating cards inspired by the iOS App Store using Motion for React's layout animations.\nPrevious\nReact animation\nNext\nScroll animation\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "Motion makes it simple to **animate an element's size and position** between different layouts. With the `layout` prop, you can perform layout animations, and by using `layoutId` you can create seamless \"magic motion\" effects between two separate elements.\n\nIn this guide, we'll learn how to:\n\n- **Animate layout changes** with a single prop.\n- Create **shared element transitions** between components.\n- Explore **advanced techniques**.\n- **Troubleshoot** common layout animation issues.\n- Understand the **differences** between Motion and the native View Transitions API.\n\n## [How to animate layout changes](#how-to-animate-layout-changes)\n\nTo enable layout animations on a `motion` component, simply add the `layout` prop. Any layout change that happens as a result of a React render will now be automatically animated.\n\n```\n<motion.div layout />\n```\n\nLayout animation can animate previously unanimatable CSS values, like switching `justify-content` between `flex-start` and `flex-end`.\n\n```\n<motion.div\n  layout\n  style={{ justifyContent: isOn ? \"flex-start\" : \"flex-end\" }}\n/>\n```\n\nOr by using the `layoutId` prop, it's possible to match two elements and animate between them for some truly advanced animations.\n\n```\n<motion.li layoutId=\"item\" />\n```\n\nIt can handle anything from microinteractions to full page transitions.\n\nWhen performing layout animations, changes to layout should be made via `style` or `className`, not via animation props like `animate` or `whileHover`, as `layout` will take care of the animation.\n\nLayout changes can be anything, changing `width`/`height`, number of grid columns, reordering a list, or adding/removing new items:\n\n### [Performance](#performance)\n\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS `transform` property for the highest possible performance.\n\n### [Shared layout animations](#shared-layout-animations)\n\nFor more advanced shared layout animations, `layoutId` allows you to connect two different elements.\n\nWhen a new component is added with a `layoutId` prop matching an existing component, it will automatically animate out from the old component.\n\n```\nisSelected && <motion.div layoutId=\"underline\" />\n```\n\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\n\nTo animate an element back to its origin, you can use the `AnimatePresence` component to keep it in the DOM until its exit animation has finished.\n\n```\n<AnimatePresence>\n  {isOpen && <motion.div layoutId=\"modal\" />}\n</AnimatePresence>\n```\n\n### [Customise a layout animation](#customise-a-layout-animation)\n\nLayout animations can be customised using [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div layout transition={{ duration: 0.3 }} />\n```\n\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like `opacity`), you can define a dedicated `layout` transition.\n\n```\n<motion.div\n  layout\n  animate={{ opacity: 0.5 }}\n  transition={{\n    ease: \"linear\",\n    layout: { duration: 0.3 }\n  }}\n/>\n```\n\nWhen performing a shared layout animation, the transition defined for element we're animating **to** will be used.\n\n```\n<>\n  <motion.button\n    layoutId=\"modal\"\n    onClick={() => setIsOpen(true)}\n    // This transition will be used when the modal closes\n    transition={{ type: \"spring\" }}\n  >\n    Open\n  </motion.button>\n  <AnimatePresence>\n    {isOn && (\n      <motion.dialog\n        layoutId=\"modal\"\n        // This transition will be used when the modal opens\n        transition={{ duration: 0.3 }}\n      />\n    )}\n  </AnimatePresence>\n</>\n```\n\n## [Advanced use-cases](#advanced-use-cases)\n\n### [Animating within scrollable element](#animating-within-scrollable-element)\n\nTo correctly animate layout within a scrollable container, you must add the `layoutScroll` prop to the scrollable element. This allows Motion to account for the element's scroll offset.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }} />\n```\n\n### [Animating within fixed containers](#animating-within-fixed-containers)\n\nTo correctly animate layout within fixed elements, we need to provide them the `layoutRoot` prop.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }} />\n```\n\nThis lets Motion account for the page's scroll offset when measuring children.\n\n### [Group layout animations](#group-layout-animations)\n\nLayout animations are triggered when a component re-renders and its layout has changed.\n\n```\nfunction Accordion() {\n  const [isOpen, setOpen] = useState(false)\n  \n  return (\n    <motion.div\n      layout\n      style={{ height: isOpen ? \"100px\" : \"500px\" }}\n      onClick={() => setOpen(!isOpen)}\n    />\n  )\n}\n```\n\nBut what happens when we have two or more components that don't re-render at the same time, but **do** affect each other's layout?\n\n```\nfunction List() {\n  return (\n    <>\n      <Accordion />\n      <Accordion />\n    </>  \n  )\n}\n```\n\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\n\nWe can synchronise layout changes across multiple components by wrapping them in the `LayoutGroup component`.\n\n```\nimport { LayoutGroup } from \"motion/react\"\n\nfunction List() {\n  return (\n    <LayoutGroup>\n      <Accordion />\n      <Accordion />\n    </LayoutGroup>  \n  )\n}\n```\n\nWhen layout changes are detected in any grouped `motion` component, layout animations will trigger across all of them.\n\n### [Scale correction](#scale-correction)\n\nBecause `layout` animations use `transform: scale()`, they can sometimes visually distort children or certain CSS properties.\n\n- **Child elements:** To fix distortion on direct children, these can also be given the `layout` prop.\n- **Border radius and box shadow:** Motion automatically corrects distortion on these properties, but they must be set via the `style`, `animate` or other animation prop.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [The component isn't animating](#the-component-isn-t-animating)\n\nEnsure the component is **not** set to `display: inline`, as browsers don't apply `transform` to these elements.\n\nEnsure the component is re-rendering when you expect the layout animation to start.\n\n### [Animations don't work during window resize](#animations-don-t-work-during-window-resize)\n\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\n\n### [SVG layout animations are broken](#svg-layout-animations-are-broken)\n\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like `cx` etc.\n\n### [The content stretches undesirably](#the-content-stretches-undesirably)\n\nThis is a natural side-effect of animating `width` and `height` with `scale`.\n\nOften, this can be fixed by providing these elements a `layout` animation and they'll be scale-corrected.\n\n```\n<motion.section layout>\n  <motion.img layout />\n</motion.section>\n```\n\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with `layout=\"position\"`.\n\n### [Border radius or box shadows are behaving strangely](#border-radius-or-box-shadows-are-behaving-strangely)\n\nAnimating `scale` is performant but can distort some styles like `border-radius` and `box-shadow`.\n\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via `style`.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n### [Border looks stretched during animation](#border-looks-stretched-during-animation)\n\nElements with a `border` may look stretched during the animation. This is for two reasons:\n\n1. Because changing `border` triggers layout recalculations, it defeats the performance benefits of animating via `transform`. You might as well animate `width` and `height` classically.\n2. `border` can't render smaller than `1px`, which limits the degree of scale correction that Motion can perform on this style.\n\nA work around is to replace `border` with a parent element with padding that acts as a `border`.\n\n```\n<motion.div layout style={{ borderRadius: 10, padding: 5 }}>\n  <motion.div layout style={{ borderRadius: 5 }} />\n</motion.div>\n```\n\n## [Technical reading](#technical-reading)\n\nInterested in the technical details behind layout animations? Nanda does an incredible job of [explaining the challenges](https://www.nan.fyi/magic-motion) of animating layout with transforms using interactive examples. Matt, creator of Motion, did a [talk at Vercel conference](https://www.youtube.com/watch?v=5-JIu0u42Jc&ab_channel=Vercel) about the implementation details that is largely up to date.\n\n## [Motion's layout animations vs the View Transitions API](#motion-s-layout-animations-vs-the-view-transitions-api)\n\nMore browsers are starting to support the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API), which is similar to Motion's layout animations.\n\n### [Benefits of View Transitions API](#benefits-of-view-transitions-api)\n\nThe main two benefits of View Transitions is that **it's included in browsers** and **features a unique rendering system**.\n\n#### [Filesize](#filesize)\n\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\n\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\n\n#### [Rendering](#rendering)\n\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\n\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\n\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations. [Framer's Page Effects](https://www.framer.com/academy/lessons/page-effects) were built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\n\n### [Drawbacks to View Transitions API](#drawbacks-to-view-transitions-api)\n\nThere are quite a few drawbacks to the API vs layout animations:\n\n- **Not interruptible**: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\n- **Blocks interaction**: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\n- **Difficult to manage IDs**: Layout animations allow more than one element with a `layoutId` whereas View Transitions will break if the previous element isn't removed.\n- **Less performant:** View Transitions take an actual screenshot and animate via `width`/`height` vs layout animation's `transform`. This is measurably less performant when animating many elements.\n- **Doesn't account for scroll**: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\n- **No relative animations:** If a nested element has a `delay` it will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\n- **One animation at a time**: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\n\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\n\nMotion makes it simple to **animate an element's size and position** between different layouts. With the `layout` prop, you can perform layout animations, and by using `layoutId` you can create seamless \"magic motion\" effects between two separate elements.\n\nIn this guide, we'll learn how to:\n\n- **Animate layout changes** with a single prop.\n- Create **shared element transitions** between components.\n- Explore **advanced techniques**.\n- **Troubleshoot** common layout animation issues.\n- Understand the **differences** between Motion and the native View Transitions API.\n\n## [How to animate layout changes](#how-to-animate-layout-changes)\n\nTo enable layout animations on a `motion` component, simply add the `layout` prop. Any layout change that happens as a result of a React render will now be automatically animated.\n\n```\n<motion.div layout />\n```\n\nLayout animation can animate previously unanimatable CSS values, like switching `justify-content` between `flex-start` and `flex-end`.\n\n```\n<motion.div\n  layout\n  style={{ justifyContent: isOn ? \"flex-start\" : \"flex-end\" }}\n/>\n```\n\nOr by using the `layoutId` prop, it's possible to match two elements and animate between them for some truly advanced animations.\n\n```\n<motion.li layoutId=\"item\" />\n```\n\nIt can handle anything from microinteractions to full page transitions.\n\nWhen performing layout animations, changes to layout should be made via `style` or `className`, not via animation props like `animate` or `whileHover`, as `layout` will take care of the animation.\n\nLayout changes can be anything, changing `width`/`height`, number of grid columns, reordering a list, or adding/removing new items:\n\n### [Performance](#performance)\n\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS `transform` property for the highest possible performance.\n\n### [Shared layout animations](#shared-layout-animations)\n\nFor more advanced shared layout animations, `layoutId` allows you to connect two different elements.\n\nWhen a new component is added with a `layoutId` prop matching an existing component, it will automatically animate out from the old component.\n\n```\nisSelected && <motion.div layoutId=\"underline\" />\n```\n\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\n\nTo animate an element back to its origin, you can use the `AnimatePresence` component to keep it in the DOM until its exit animation has finished.\n\n```\n<AnimatePresence>\n  {isOpen && <motion.div layoutId=\"modal\" />}\n</AnimatePresence>\n```\n\n### [Customise a layout animation](#customise-a-layout-animation)\n\nLayout animations can be customised using [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div layout transition={{ duration: 0.3 }} />\n```\n\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like `opacity`), you can define a dedicated `layout` transition.\n\n```\n<motion.div\n  layout\n  animate={{ opacity: 0.5 }}\n  transition={{\n    ease: \"linear\",\n    layout: { duration: 0.3 }\n  }}\n/>\n```\n\nWhen performing a shared layout animation, the transition defined for element we're animating **to** will be used.\n\n```\n<>\n  <motion.button\n    layoutId=\"modal\"\n    onClick={() => setIsOpen(true)}\n    // This transition will be used when the modal closes\n    transition={{ type: \"spring\" }}\n  >\n    Open\n  </motion.button>\n  <AnimatePresence>\n    {isOn && (\n      <motion.dialog\n        layoutId=\"modal\"\n        // This transition will be used when the modal opens\n        transition={{ duration: 0.3 }}\n      />\n    )}\n  </AnimatePresence>\n</>\n```\n\n## [Advanced use-cases](#advanced-use-cases)\n\n### [Animating within scrollable element](#animating-within-scrollable-element)\n\nTo correctly animate layout within a scrollable container, you must add the `layoutScroll` prop to the scrollable element. This allows Motion to account for the element's scroll offset.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }} />\n```\n\n### [Animating within fixed containers](#animating-within-fixed-containers)\n\nTo correctly animate layout within fixed elements, we need to provide them the `layoutRoot` prop.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }} />\n```\n\nThis lets Motion account for the page's scroll offset when measuring children.\n\n### [Group layout animations](#group-layout-animations)\n\nLayout animations are triggered when a component re-renders and its layout has changed.\n\n```\nfunction Accordion() {\n  const [isOpen, setOpen] = useState(false)\n  \n  return (\n    <motion.div\n      layout\n      style={{ height: isOpen ? \"100px\" : \"500px\" }}\n      onClick={() => setOpen(!isOpen)}\n    />\n  )\n}\n```\n\nBut what happens when we have two or more components that don't re-render at the same time, but **do** affect each other's layout?\n\n```\nfunction List() {\n  return (\n    <>\n      <Accordion />\n      <Accordion />\n    </>  \n  )\n}\n```\n\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\n\nWe can synchronise layout changes across multiple components by wrapping them in the `LayoutGroup component`.\n\n```\nimport { LayoutGroup } from \"motion/react\"\n\nfunction List() {\n  return (\n    <LayoutGroup>\n      <Accordion />\n      <Accordion />\n    </LayoutGroup>  \n  )\n}\n```\n\nWhen layout changes are detected in any grouped `motion` component, layout animations will trigger across all of them.\n\n### [Scale correction](#scale-correction)\n\nBecause `layout` animations use `transform: scale()`, they can sometimes visually distort children or certain CSS properties.\n\n- **Child elements:** To fix distortion on direct children, these can also be given the `layout` prop.\n- **Border radius and box shadow:** Motion automatically corrects distortion on these properties, but they must be set via the `style`, `animate` or other animation prop.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [The component isn't animating](#the-component-isn-t-animating)\n\nEnsure the component is **not** set to `display: inline`, as browsers don't apply `transform` to these elements.\n\nEnsure the component is re-rendering when you expect the layout animation to start.\n\n### [Animations don't work during window resize](#animations-don-t-work-during-window-resize)\n\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\n\n### [SVG layout animations are broken](#svg-layout-animations-are-broken)\n\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like `cx` etc.\n\n### [The content stretches undesirably](#the-content-stretches-undesirably)\n\nThis is a natural side-effect of animating `width` and `height` with `scale`.\n\nOften, this can be fixed by providing these elements a `layout` animation and they'll be scale-corrected.\n\n```\n<motion.section layout>\n  <motion.img layout />\n</motion.section>\n```\n\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with `layout=\"position\"`.\n\n### [Border radius or box shadows are behaving strangely](#border-radius-or-box-shadows-are-behaving-strangely)\n\nAnimating `scale` is performant but can distort some styles like `border-radius` and `box-shadow`.\n\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via `style`.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n### [Border looks stretched during animation](#border-looks-stretched-during-animation)\n\nElements with a `border` may look stretched during the animation. This is for two reasons:\n\n1. Because changing `border` triggers layout recalculations, it defeats the performance benefits of animating via `transform`. You might as well animate `width` and `height` classically.\n2. `border` can't render smaller than `1px`, which limits the degree of scale correction that Motion can perform on this style.\n\nA work around is to replace `border` with a parent element with padding that acts as a `border`.\n\n```\n<motion.div layout style={{ borderRadius: 10, padding: 5 }}>\n  <motion.div layout style={{ borderRadius: 5 }} />\n</motion.div>\n```\n\n## [Technical reading](#technical-reading)\n\nInterested in the technical details behind layout animations? Nanda does an incredible job of [explaining the challenges](https://www.nan.fyi/magic-motion) of animating layout with transforms using interactive examples. Matt, creator of Motion, did a [talk at Vercel conference](https://www.youtube.com/watch?v=5-JIu0u42Jc&ab_channel=Vercel) about the implementation details that is largely up to date.\n\n## [Motion's layout animations vs the View Transitions API](#motion-s-layout-animations-vs-the-view-transitions-api)\n\nMore browsers are starting to support the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API), which is similar to Motion's layout animations.\n\n### [Benefits of View Transitions API](#benefits-of-view-transitions-api)\n\nThe main two benefits of View Transitions is that **it's included in browsers** and **features a unique rendering system**.\n\n#### [Filesize](#filesize)\n\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\n\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\n\n#### [Rendering](#rendering)\n\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\n\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\n\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations. [Framer's Page Effects](https://www.framer.com/academy/lessons/page-effects) were built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\n\n### [Drawbacks to View Transitions API](#drawbacks-to-view-transitions-api)\n\nThere are quite a few drawbacks to the API vs layout animations:\n\n- **Not interruptible**: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\n- **Blocks interaction**: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\n- **Difficult to manage IDs**: Layout animations allow more than one element with a `layoutId` whereas View Transitions will break if the previous element isn't removed.\n- **Less performant:** View Transitions take an actual screenshot and animate via `width`/`height` vs layout animation's `transform`. This is measurably less performant when animating many elements.\n- **Doesn't account for scroll**: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\n- **No relative animations:** If a nested element has a `delay` it will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\n- **One animation at a time**: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\n\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\n\nMotion makes it simple to **animate an element's size and position** between different layouts. With the `layout` prop, you can perform layout animations, and by using `layoutId` you can create seamless \"magic motion\" effects between two separate elements.\n\nIn this guide, we'll learn how to:\n\n- **Animate layout changes** with a single prop.\n- Create **shared element transitions** between components.\n- Explore **advanced techniques**.\n- **Troubleshoot** common layout animation issues.\n- Understand the **differences** between Motion and the native View Transitions API.\n\n## [How to animate layout changes](#how-to-animate-layout-changes)\n\nTo enable layout animations on a `motion` component, simply add the `layout` prop. Any layout change that happens as a result of a React render will now be automatically animated.\n\n```\n<motion.div layout />\n```\n\nLayout animation can animate previously unanimatable CSS values, like switching `justify-content` between `flex-start` and `flex-end`.\n\n```\n<motion.div\n  layout\n  style={{ justifyContent: isOn ? \"flex-start\" : \"flex-end\" }}\n/>\n```\n\nOr by using the `layoutId` prop, it's possible to match two elements and animate between them for some truly advanced animations.\n\n```\n<motion.li layoutId=\"item\" />\n```\n\nIt can handle anything from microinteractions to full page transitions.\n\nWhen performing layout animations, changes to layout should be made via `style` or `className`, not via animation props like `animate` or `whileHover`, as `layout` will take care of the animation.\n\nLayout changes can be anything, changing `width`/`height`, number of grid columns, reordering a list, or adding/removing new items:\n\n### [Performance](#performance)\n\nAnimating layout is traditionally slow, but Motion performs all layout animations using the CSS `transform` property for the highest possible performance.\n\n### [Shared layout animations](#shared-layout-animations)\n\nFor more advanced shared layout animations, `layoutId` allows you to connect two different elements.\n\nWhen a new component is added with a `layoutId` prop matching an existing component, it will automatically animate out from the old component.\n\n```\nisSelected && <motion.div layoutId=\"underline\" />\n```\n\nIf the original component is still on the page when the new one enters, they will automatically crossfade.\n\nTo animate an element back to its origin, you can use the `AnimatePresence` component to keep it in the DOM until its exit animation has finished.\n\n```\n<AnimatePresence>\n  {isOpen && <motion.div layoutId=\"modal\" />}\n</AnimatePresence>\n```\n\n### [Customise a layout animation](#customise-a-layout-animation)\n\nLayout animations can be customised using [the](./react-transitions) `transition` [prop](./react-transitions).\n\n```\n<motion.div layout transition={{ duration: 0.3 }} />\n```\n\nIf you need to set a transition specifically for the layout animation while having a different transition for other properties (like `opacity`), you can define a dedicated `layout` transition.\n\n```\n<motion.div\n  layout\n  animate={{ opacity: 0.5 }}\n  transition={{\n    ease: \"linear\",\n    layout: { duration: 0.3 }\n  }}\n/>\n```\n\nWhen performing a shared layout animation, the transition defined for element we're animating **to** will be used.\n\n```\n<>\n  <motion.button\n    layoutId=\"modal\"\n    onClick={() => setIsOpen(true)}\n    // This transition will be used when the modal closes\n    transition={{ type: \"spring\" }}\n  >\n    Open\n  </motion.button>\n  <AnimatePresence>\n    {isOn && (\n      <motion.dialog\n        layoutId=\"modal\"\n        // This transition will be used when the modal opens\n        transition={{ duration: 0.3 }}\n      />\n    )}\n  </AnimatePresence>\n</>\n```\n\n## [Advanced use-cases](#advanced-use-cases)\n\n### [Animating within scrollable element](#animating-within-scrollable-element)\n\nTo correctly animate layout within a scrollable container, you must add the `layoutScroll` prop to the scrollable element. This allows Motion to account for the element's scroll offset.\n\n```\n<motion.div layoutScroll style={{ overflow: \"scroll\" }} />\n```\n\n### [Animating within fixed containers](#animating-within-fixed-containers)\n\nTo correctly animate layout within fixed elements, we need to provide them the `layoutRoot` prop.\n\n```\n<motion.div layoutRoot style={{ position: \"fixed\" }} />\n```\n\nThis lets Motion account for the page's scroll offset when measuring children.\n\n### [Group layout animations](#group-layout-animations)\n\nLayout animations are triggered when a component re-renders and its layout has changed.\n\n```\nfunction Accordion() {\n  const [isOpen, setOpen] = useState(false)\n  \n  return (\n    <motion.div\n      layout\n      style={{ height: isOpen ? \"100px\" : \"500px\" }}\n      onClick={() => setOpen(!isOpen)}\n    />\n  )\n}\n```\n\nBut what happens when we have two or more components that don't re-render at the same time, but **do** affect each other's layout?\n\n```\nfunction List() {\n  return (\n    <>\n      <Accordion />\n      <Accordion />\n    </>  \n  )\n}\n```\n\nWhen one re-renders, for performance reasons the other won't be able to detect changes to its layout.\n\nWe can synchronise layout changes across multiple components by wrapping them in the `LayoutGroup component`.\n\n```\nimport { LayoutGroup } from \"motion/react\"\n\nfunction List() {\n  return (\n    <LayoutGroup>\n      <Accordion />\n      <Accordion />\n    </LayoutGroup>  \n  )\n}\n```\n\nWhen layout changes are detected in any grouped `motion` component, layout animations will trigger across all of them.\n\n### [Scale correction](#scale-correction)\n\nBecause `layout` animations use `transform: scale()`, they can sometimes visually distort children or certain CSS properties.\n\n- **Child elements:** To fix distortion on direct children, these can also be given the `layout` prop.\n- **Border radius and box shadow:** Motion automatically corrects distortion on these properties, but they must be set via the `style`, `animate` or other animation prop.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n## [Troubleshooting](#troubleshooting)\n\n### [The component isn't animating](#the-component-isn-t-animating)\n\nEnsure the component is **not** set to `display: inline`, as browsers don't apply `transform` to these elements.\n\nEnsure the component is re-rendering when you expect the layout animation to start.\n\n### [Animations don't work during window resize](#animations-don-t-work-during-window-resize)\n\nLayout animations are blocked during horizontal window resize to improve performance and to prevent unnecessary animations.\n\n### [SVG layout animations are broken](#svg-layout-animations-are-broken)\n\nSVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like `cx` etc.\n\n### [The content stretches undesirably](#the-content-stretches-undesirably)\n\nThis is a natural side-effect of animating `width` and `height` with `scale`.\n\nOften, this can be fixed by providing these elements a `layout` animation and they'll be scale-corrected.\n\n```\n<motion.section layout>\n  <motion.img layout />\n</motion.section>\n```\n\nSome elements, like images or text that are changing between different aspect ratios, might be better animated with `layout=\"position\"`.\n\n### [Border radius or box shadows are behaving strangely](#border-radius-or-box-shadows-are-behaving-strangely)\n\nAnimating `scale` is performant but can distort some styles like `border-radius` and `box-shadow`.\n\nMotion automatically corrects for scale distortion on these properties, but they must be set on the element via `style`.\n\n```\n<motion.div layout style={{ borderRadius: 20 }} />\n```\n\n### [Border looks stretched during animation](#border-looks-stretched-during-animation)\n\nElements with a `border` may look stretched during the animation. This is for two reasons:\n\n1. Because changing `border` triggers layout recalculations, it defeats the performance benefits of animating via `transform`. You might as well animate `width` and `height` classically.\n2. `border` can't render smaller than `1px`, which limits the degree of scale correction that Motion can perform on this style.\n\nA work around is to replace `border` with a parent element with padding that acts as a `border`.\n\n```\n<motion.div layout style={{ borderRadius: 10, padding: 5 }}>\n  <motion.div layout style={{ borderRadius: 5 }} />\n</motion.div>\n```\n\n## [Technical reading](#technical-reading)\n\nInterested in the technical details behind layout animations? Nanda does an incredible job of [explaining the challenges](https://www.nan.fyi/magic-motion) of animating layout with transforms using interactive examples. Matt, creator of Motion, did a [talk at Vercel conference](https://www.youtube.com/watch?v=5-JIu0u42Jc&ab_channel=Vercel) about the implementation details that is largely up to date.\n\n## [Motion's layout animations vs the View Transitions API](#motion-s-layout-animations-vs-the-view-transitions-api)\n\nMore browsers are starting to support the [View Transitions API](https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API), which is similar to Motion's layout animations.\n\n### [Benefits of View Transitions API](#benefits-of-view-transitions-api)\n\nThe main two benefits of View Transitions is that **it's included in browsers** and **features a unique rendering system**.\n\n#### [Filesize](#filesize)\n\nBecause the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.\n\nHowever, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching\n\n#### [Rendering](#rendering)\n\nWhereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.\n\nFor shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.\n\nThis can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations. [Framer's Page Effects](https://www.framer.com/academy/lessons/page-effects) were built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.\n\n### [Drawbacks to View Transitions API](#drawbacks-to-view-transitions-api)\n\nThere are quite a few drawbacks to the API vs layout animations:\n\n- **Not interruptible**: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.\n- **Blocks interaction**: The animating elements overlay the \"real\" page underneath and block pointer events. Makes things feel quite sticky.\n- **Difficult to manage IDs**: Layout animations allow more than one element with a `layoutId` whereas View Transitions will break if the previous element isn't removed.\n- **Less performant:** View Transitions take an actual screenshot and animate via `width`/`height` vs layout animation's `transform`. This is measurably less performant when animating many elements.\n- **Doesn't account for scroll**: If the page scroll changes during a view transition, elements will incorrectly animate this delta.\n- **No relative animations:** If a nested element has a `delay` it will get \"left behind\" when its parent animates away, whereas Motion handles this kind of relative animation.\n- **One animation at a time**: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.\n\nAll-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.\n\n## Related topics\n\n- [### Install Motion Studio\n\n  Enhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.](./studio-install)\n\n  [### Install Motion Studio\n\n  Enhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.](./studio-install)\n\n  [### Install Motion Studio\n\n  Enhance Copilot with Motion docs, and add visual animation editing tools for CSS and Motion.](./studio-install)\n- [Motion+\n\n  ### AnimateNumber\n\n  Create beautiful number ticker and countdown animations in React.](./react-animate-number)\n\n  [Motion+\n\n  ### AnimateNumber\n\n  Create beautiful number ticker and countdown animations in React.](./react-animate-number)\n\n  [Motion+\n\n  ### AnimateNumber\n\n  Create beautiful number ticker and countdown animations in React.](./react-animate-number)\n\n- [### Layout animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=layout|layoutId)\n\n- [### Layout animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=layout|layoutId)\n\n- [### Layout animation examples\n\n  See all examples & tutorials, with full copy & paste source code.](https://motion.dev/examples?platform=react&search=layout|layoutId)\n\n- [Tutorial\n\n  ### iOS App Store\n\n  An example of animating cards inspired by the iOS App Store using Motion for React's layout animations.](../tutorials/react-app-store)\n\n- [Tutorial\n\n  ### iOS App Store\n\n  An example of animating cards inspired by the iOS App Store using Motion for React's layout animations.](../tutorials/react-app-store)\n\n- [Tutorial\n\n  ### iOS App Store\n\n  An example of animating cards inspired by the iOS App Store using Motion for React's layout animations.](../tutorials/react-app-store)\n\nPrevious\n\n[React animation](./react-animation)\n\nNext\n\n[Scroll animation](./react-scroll-animations)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:13.050214+00:00",
  "content_length": 32852,
  "content_hash": "311be961b8da761f"
}