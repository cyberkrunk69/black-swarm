{
  "id": "framer-motion__motion_use-in-view_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/use-in-view/",
  "title": "useInView \u00e2\u0080\u0094 React scroll-triggered state | Motion",
  "content": "useInView\nis a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\nUsage\nImport\nuseInView\nfrom Motion:\nimport\n{\nuseInView\n}\nfrom\n\"motion/react\"\nuseInView\ncan track the visibility of any HTML element. Pass a\nref\nobject to both\nuseInView\nand the HTML element.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\nWhile the element is outside the viewport,\nuseInView\nwill return\nfalse\n. When it moves inside the view, it'll re-render the component and return\ntrue\n.\nEffects\nuseInView\nis vanilla React state, so firing functions when\nisInView\nchanges is a matter of passing it to a\nuseEffect\n.\nuseEffect\n(\n(\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Element is in view: \"\n,\nisInView\n)\n}\n,\n[\nisInView\n]\n)\nOptions\nuseInView\ncan accept options to define how the element is tracked within the viewport.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\nroot\nBy default,\nuseInView\nwill track the visibility of an element as it enters/leaves the window viewport. Set\nroot\nto be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\nfunction\nCarousel\n(\n)\n{\nconst\ncontainer\n=\nuseRef\n(\nnull\n)\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nroot\n:\ncontainer\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainer\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\ndiv\nref\n=\n{\nref\n}\n/>\n</\ndiv\n>\n)\n}\nmargin\nDefault:\n\"0px\"\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\nconst\nisInView\n=\nuseInView\n(\n{\nmargin\n:\n\"0px 100px -50px 0px\"\n}\n)\nFor browser security reasons,\nmargin\nwon't take affect within cross-origin iframes\nunless\nroot\nis explicitly defined.\nonce\nDefault:\nfalse\nIf\ntrue\n, once an element is in view, useInView will stop observing the element and always return\ntrue\n.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\ninitial\nDefault:\nfalse\nSet an initial value to return until the element has been measured.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\ninitial\n:\ntrue\n}\n)\namount\nDefault:\n\"some\"\nThe amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n.\nExample\nuseInView\nis a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\nUsage\nImport\nuseInView\nfrom Motion:\nimport\n{\nuseInView\n}\nfrom\n\"motion/react\"\nuseInView\ncan track the visibility of any HTML element. Pass a\nref\nobject to both\nuseInView\nand the HTML element.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\nWhile the element is outside the viewport,\nuseInView\nwill return\nfalse\n. When it moves inside the view, it'll re-render the component and return\ntrue\n.\nEffects\nuseInView\nis vanilla React state, so firing functions when\nisInView\nchanges is a matter of passing it to a\nuseEffect\n.\nuseEffect\n(\n(\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Element is in view: \"\n,\nisInView\n)\n}\n,\n[\nisInView\n]\n)\nOptions\nuseInView\ncan accept options to define how the element is tracked within the viewport.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\nroot\nBy default,\nuseInView\nwill track the visibility of an element as it enters/leaves the window viewport. Set\nroot\nto be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\nfunction\nCarousel\n(\n)\n{\nconst\ncontainer\n=\nuseRef\n(\nnull\n)\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nroot\n:\ncontainer\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainer\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\ndiv\nref\n=\n{\nref\n}\n/>\n</\ndiv\n>\n)\n}\nmargin\nDefault:\n\"0px\"\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\nconst\nisInView\n=\nuseInView\n(\n{\nmargin\n:\n\"0px 100px -50px 0px\"\n}\n)\nFor browser security reasons,\nmargin\nwon't take affect within cross-origin iframes\nunless\nroot\nis explicitly defined.\nonce\nDefault:\nfalse\nIf\ntrue\n, once an element is in view, useInView will stop observing the element and always return\ntrue\n.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\ninitial\nDefault:\nfalse\nSet an initial value to return until the element has been measured.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\ninitial\n:\ntrue\n}\n)\namount\nDefault:\n\"some\"\nThe amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n.\nExample\nuseInView\nis a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\nUsage\nImport\nuseInView\nfrom Motion:\nimport\n{\nuseInView\n}\nfrom\n\"motion/react\"\nuseInView\ncan track the visibility of any HTML element. Pass a\nref\nobject to both\nuseInView\nand the HTML element.\nfunction\nComponent\n(\n)\n{\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n)\nreturn\n<\ndiv\nref\n=\n{\nref\n}\n/>\n}\nWhile the element is outside the viewport,\nuseInView\nwill return\nfalse\n. When it moves inside the view, it'll re-render the component and return\ntrue\n.\nEffects\nuseInView\nis vanilla React state, so firing functions when\nisInView\nchanges is a matter of passing it to a\nuseEffect\n.\nuseEffect\n(\n(\n)\n=>\n{\nconsole\n.\nlog\n(\n\"Element is in view: \"\n,\nisInView\n)\n}\n,\n[\nisInView\n]\n)\nOptions\nuseInView\ncan accept options to define how the element is tracked within the viewport.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\nroot\nBy default,\nuseInView\nwill track the visibility of an element as it enters/leaves the window viewport. Set\nroot\nto be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\nfunction\nCarousel\n(\n)\n{\nconst\ncontainer\n=\nuseRef\n(\nnull\n)\nconst\nref\n=\nuseRef\n(\nnull\n)\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nroot\n:\ncontainer\n}\n)\nreturn\n(\n<\ndiv\nref\n=\n{\ncontainer\n}\nstyle\n=\n{\n{\noverflow\n:\n\"scroll\"\n}\n}\n>\n<\ndiv\nref\n=\n{\nref\n}\n/>\n</\ndiv\n>\n)\n}\nmargin\nDefault:\n\"0px\"\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g.\n\"0px -20px 0px 100px\"\n.\nconst\nisInView\n=\nuseInView\n(\n{\nmargin\n:\n\"0px 100px -50px 0px\"\n}\n)\nFor browser security reasons,\nmargin\nwon't take affect within cross-origin iframes\nunless\nroot\nis explicitly defined.\nonce\nDefault:\nfalse\nIf\ntrue\n, once an element is in view, useInView will stop observing the element and always return\ntrue\n.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\nonce\n:\ntrue\n}\n)\ninitial\nDefault:\nfalse\nSet an initial value to return until the element has been measured.\nconst\nisInView\n=\nuseInView\n(\nref\n,\n{\ninitial\n:\ntrue\n}\n)\namount\nDefault:\n\"some\"\nThe amount of an element that should enter the viewport to be considered \"entered\". Either\n\"some\"\n,\n\"all\"\nor a number between\n0\nand\n1\n.\nExample\nRelated topics\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nScroll animation\nCreate scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nuseScroll\nCreate scroll-linked animations like progress bars & parallax with the useScroll React hook.\nPrevious\nuseDragControls\nNext\nusePageInView\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "`useInView` is a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\n\n```\nconst ref = useRef(null)\nconst isInView = useInView(ref)\n\nreturn <div ref={ref} />\n```\n\n## [Usage](#usage)\n\nImport `useInView` from Motion:\n\n```\nimport { useInView } from \"motion/react\"\n```\n\n`useInView` can track the visibility of any HTML element. Pass a `ref` object to both `useInView` and the HTML element.\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return <div ref={ref} />\n}\n```\n\nWhile the element is outside the viewport, `useInView` will return `false`. When it moves inside the view, it'll re-render the component and return `true`.\n\n### [Effects](#effects)\n\n`useInView` is vanilla React state, so firing functions when `isInView` changes is a matter of passing it to a `useEffect`.\n\n```\nuseEffect(() => {\n  console.log(\"Element is in view: \", isInView)\n}, [isInView])\n```\n\n## [Options](#options)\n\n`useInView` can accept options to define how the element is tracked within the viewport.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`root`](#root)\n\nBy default, `useInView` will track the visibility of an element as it enters/leaves the window viewport. Set `root` to be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\n\n```\nfunction Carousel() {\n  const container = useRef(null)\n  const ref = useRef(null)\n  const isInView = useInView(ref, { root: container })\n  \n  return (\n    <div ref={container} style={{ overflow: \"scroll\" }}>\n      <div ref={ref} />\n    </div>\n  )\n}\n```\n\n### [`margin`](#margin)\n\n**Default:** `\"0px\"`\n\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n\n```\nconst isInView = useInView({\n  margin: \"0px 100px -50px 0px\"\n})\n```\n\nFor browser security reasons, `margin` [won't take affect within cross-origin iframes](https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-rootmargin) unless `root` is explicitly defined.\n\n### [`once`](#once)\n\n**Default:** `false`\n\nIf `true`, once an element is in view, useInView will stop observing the element and always return `true`.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`initial`](#initial)\n\n**Default:** `false`\n\nSet an initial value to return until the element has been measured.\n\n```\nconst isInView = useInView(ref, { initial: true })\n```\n\n### [`amount`](#amount)\n\n**Default:** `\"some\"`\n\nThe amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`.\n\n## [Example](#example)\n\n`useInView` is a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\n\n```\nconst ref = useRef(null)\nconst isInView = useInView(ref)\n\nreturn <div ref={ref} />\n```\n\n## [Usage](#usage)\n\nImport `useInView` from Motion:\n\n```\nimport { useInView } from \"motion/react\"\n```\n\n`useInView` can track the visibility of any HTML element. Pass a `ref` object to both `useInView` and the HTML element.\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return <div ref={ref} />\n}\n```\n\nWhile the element is outside the viewport, `useInView` will return `false`. When it moves inside the view, it'll re-render the component and return `true`.\n\n### [Effects](#effects)\n\n`useInView` is vanilla React state, so firing functions when `isInView` changes is a matter of passing it to a `useEffect`.\n\n```\nuseEffect(() => {\n  console.log(\"Element is in view: \", isInView)\n}, [isInView])\n```\n\n## [Options](#options)\n\n`useInView` can accept options to define how the element is tracked within the viewport.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`root`](#root)\n\nBy default, `useInView` will track the visibility of an element as it enters/leaves the window viewport. Set `root` to be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\n\n```\nfunction Carousel() {\n  const container = useRef(null)\n  const ref = useRef(null)\n  const isInView = useInView(ref, { root: container })\n  \n  return (\n    <div ref={container} style={{ overflow: \"scroll\" }}>\n      <div ref={ref} />\n    </div>\n  )\n}\n```\n\n### [`margin`](#margin)\n\n**Default:** `\"0px\"`\n\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n\n```\nconst isInView = useInView({\n  margin: \"0px 100px -50px 0px\"\n})\n```\n\nFor browser security reasons, `margin` [won't take affect within cross-origin iframes](https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-rootmargin) unless `root` is explicitly defined.\n\n### [`once`](#once)\n\n**Default:** `false`\n\nIf `true`, once an element is in view, useInView will stop observing the element and always return `true`.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`initial`](#initial)\n\n**Default:** `false`\n\nSet an initial value to return until the element has been measured.\n\n```\nconst isInView = useInView(ref, { initial: true })\n```\n\n### [`amount`](#amount)\n\n**Default:** `\"some\"`\n\nThe amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`.\n\n## [Example](#example)\n\n`useInView` is a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.\n\n```\nconst ref = useRef(null)\nconst isInView = useInView(ref)\n\nreturn <div ref={ref} />\n```\n\n## [Usage](#usage)\n\nImport `useInView` from Motion:\n\n```\nimport { useInView } from \"motion/react\"\n```\n\n`useInView` can track the visibility of any HTML element. Pass a `ref` object to both `useInView` and the HTML element.\n\n```\nfunction Component() {\n  const ref = useRef(null)\n  const isInView = useInView(ref)\n\n  return <div ref={ref} />\n}\n```\n\nWhile the element is outside the viewport, `useInView` will return `false`. When it moves inside the view, it'll re-render the component and return `true`.\n\n### [Effects](#effects)\n\n`useInView` is vanilla React state, so firing functions when `isInView` changes is a matter of passing it to a `useEffect`.\n\n```\nuseEffect(() => {\n  console.log(\"Element is in view: \", isInView)\n}, [isInView])\n```\n\n## [Options](#options)\n\n`useInView` can accept options to define how the element is tracked within the viewport.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`root`](#root)\n\nBy default, `useInView` will track the visibility of an element as it enters/leaves the window viewport. Set `root` to be the ref of a scrollable parent, and it'll use that element to be the viewport instead.\n\n```\nfunction Carousel() {\n  const container = useRef(null)\n  const ref = useRef(null)\n  const isInView = useInView(ref, { root: container })\n  \n  return (\n    <div ref={container} style={{ overflow: \"scroll\" }}>\n      <div ref={ref} />\n    </div>\n  )\n}\n```\n\n### [`margin`](#margin)\n\n**Default:** `\"0px\"`\n\nA margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g. `\"0px -20px 0px 100px\"`.\n\n```\nconst isInView = useInView({\n  margin: \"0px 100px -50px 0px\"\n})\n```\n\nFor browser security reasons, `margin` [won't take affect within cross-origin iframes](https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-rootmargin) unless `root` is explicitly defined.\n\n### [`once`](#once)\n\n**Default:** `false`\n\nIf `true`, once an element is in view, useInView will stop observing the element and always return `true`.\n\n```\nconst isInView = useInView(ref, { once: true })\n```\n\n### [`initial`](#initial)\n\n**Default:** `false`\n\nSet an initial value to return until the element has been measured.\n\n```\nconst isInView = useInView(ref, { initial: true })\n```\n\n### [`amount`](#amount)\n\n**Default:** `\"some\"`\n\nThe amount of an element that should enter the viewport to be considered \"entered\". Either `\"some\"`, `\"all\"` or a number between `0` and `1`.\n\n## [Example](#example)\n\n## Related topics\n\n- [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n\n  [### Scroll animation\n\n  Create scroll-triggered and scroll-linked effects \u00e2\u0080\u0094 parallax, progress and more.](./react-scroll-animations)\n- [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n\n  [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n\n  [### useScroll\n\n  Create scroll-linked animations like progress bars & parallax with the useScroll React hook.](./react-use-scroll)\n\nPrevious\n\n[useDragControls](./react-use-drag-controls)\n\nNext\n\n[usePageInView](./react-use-page-in-view)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:18.671876+00:00",
  "content_length": 8162,
  "content_hash": "8dec5ad6aefc1637"
}