{
  "id": "framer-motion__motion_reorder_",
  "source_id": "framer-motion",
  "source_name": "Framer Motion",
  "category": "animation_motion",
  "url": "https://www.framer.com/motion/reorder/",
  "title": "Reorder \u00e2\u0080\u0094 React drag-to-reorder animation | Motion",
  "content": "The\nReorder\ncomponents can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\naxis\n=\n\"y\"\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\nReorder\nis for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base\nmotion\ncomponent but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like\nDnD Kit\n.\nUsage\nEvery reorderable list is wrapped in the\nReorder.Group\ncomponent.\nimport\n{\nReorder\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nReorder\n.\nGroup\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nBy default, this is rendered as a\n<ul>\n, but this can be changed with the\nas\nprop.\n<\nReorder\n.\nGroup\nas\n=\n\"ol\"\n>\nReorder.Group\nmust be passed the array of values in your reorderable list via the\nvalues\nprop.\nAdditionally, a\nonReorder\nevent will fire with the latest calculated order. For items to reorder, this must update the\nvalues\nstate.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nTo render each reorderable item, use\nReorder.Item\n, passing it the value it represents via the\nvalue\nprop.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\n}\nNow, when items are dragged and reordered,\nonReorder\nwill fire with a new order.\nLayout animations\nReorder.Item\ncomponents are already configured to perform\nlayout animations\n, so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\nExit animations\nAnimatePresence\ncan be used as normal to animate items as they enter/leave the React tree.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\nkey\n=\n{\nitem\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nDrag triggers\nBy default, all of a\nReorder.Item\nwill be draggable.\nuseDragControls\ncan be used to define a different component to act as a drag trigger.\nimport\n{\nReorder\n,\nuseDragControls\n}\nfrom\n\"framer-motion\"\nfunction\nItem\n(\n{\nvalue\n}\n)\n{\nconst\ncontrols\n=\nuseDragControls\n(\n)\nreturn\n(\n<\nReorder\n.\nItem\nvalue\n=\n{\nvalue\n}\ndragListener\n=\n{\nfalse\n}\ndragControls\n=\n{\ncontrols\n}\n>\n<\ndiv\nclassName\n=\n\"reorder-handle\"\nonPointerDown\n=\n{\n(\ne\n)\n=>\ncontrols\n.\nstart\n(\ne\n)\n}\n/>\n</\nReorder\n.\nItem\n>\n)\n}\nAuto-scroll lists\nIf a\nReorder.Group\nis within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\nThe closer to the edge of the container, the faster the scroll.\nz-index\nReorder.Item\nwill automatically set a\nz-index\nstyle on the currently dragged item so it appears above the surrounding items.\nHowever,\nz-index\nonly affects items with\nposition !== \"static\"\n. So to enable this effect ensure the position of the\nReorder.Item\nis set to\nrelative\nor\nabsolute\n.\nAPI\nReorder.Group\nas\nDefault\n:\n\"ul\"\nThe underlying element for\nReorder.Group\nto render as.\n<\nReorder\n.\nGroup\nas\n=\n\"div\"\n>\n</\nReorder\n.\nGroup\n>\naxis\nDefault\n:\n\"y\"\nThe direction of reorder detection.\nBy default, all\nReorder.Item\ncomponents will visibly move only on this axis. To allow visual motion (but\nnot\nreordering) on both axes, pass the\ndrag\nprop to child\nReorder.Item\ncomponents.\nvalues\nThe values array that will be reordered. Each item in this list must match a\nvalue\npassed to each\nReorder.Item\n.\nonReorder\nA callback that will fire when items are detected to have reordered. The provided\nnewOrder\nshould be passed to a\nvalues\nstate update function.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\nReorder.Item\nReorder.Item\ncomponents accept all\nmotion\ncomponent props\nin addition to the following:\nas\nDefault:\n\"li\"\nThe element for\nReorder.Item\nto render as.\nvalue\nWhen\nonReorder\nis called, this is the value that will be passed through in the newly ordered array.\nThe\nReorder\ncomponents can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\naxis\n=\n\"y\"\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\nReorder\nis for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base\nmotion\ncomponent but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like\nDnD Kit\n.\nUsage\nEvery reorderable list is wrapped in the\nReorder.Group\ncomponent.\nimport\n{\nReorder\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nReorder\n.\nGroup\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nBy default, this is rendered as a\n<ul>\n, but this can be changed with the\nas\nprop.\n<\nReorder\n.\nGroup\nas\n=\n\"ol\"\n>\nReorder.Group\nmust be passed the array of values in your reorderable list via the\nvalues\nprop.\nAdditionally, a\nonReorder\nevent will fire with the latest calculated order. For items to reorder, this must update the\nvalues\nstate.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nTo render each reorderable item, use\nReorder.Item\n, passing it the value it represents via the\nvalue\nprop.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\n}\nNow, when items are dragged and reordered,\nonReorder\nwill fire with a new order.\nLayout animations\nReorder.Item\ncomponents are already configured to perform\nlayout animations\n, so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\nExit animations\nAnimatePresence\ncan be used as normal to animate items as they enter/leave the React tree.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\nkey\n=\n{\nitem\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nDrag triggers\nBy default, all of a\nReorder.Item\nwill be draggable.\nuseDragControls\ncan be used to define a different component to act as a drag trigger.\nimport\n{\nReorder\n,\nuseDragControls\n}\nfrom\n\"framer-motion\"\nfunction\nItem\n(\n{\nvalue\n}\n)\n{\nconst\ncontrols\n=\nuseDragControls\n(\n)\nreturn\n(\n<\nReorder\n.\nItem\nvalue\n=\n{\nvalue\n}\ndragListener\n=\n{\nfalse\n}\ndragControls\n=\n{\ncontrols\n}\n>\n<\ndiv\nclassName\n=\n\"reorder-handle\"\nonPointerDown\n=\n{\n(\ne\n)\n=>\ncontrols\n.\nstart\n(\ne\n)\n}\n/>\n</\nReorder\n.\nItem\n>\n)\n}\nAuto-scroll lists\nIf a\nReorder.Group\nis within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\nThe closer to the edge of the container, the faster the scroll.\nz-index\nReorder.Item\nwill automatically set a\nz-index\nstyle on the currently dragged item so it appears above the surrounding items.\nHowever,\nz-index\nonly affects items with\nposition !== \"static\"\n. So to enable this effect ensure the position of the\nReorder.Item\nis set to\nrelative\nor\nabsolute\n.\nAPI\nReorder.Group\nas\nDefault\n:\n\"ul\"\nThe underlying element for\nReorder.Group\nto render as.\n<\nReorder\n.\nGroup\nas\n=\n\"div\"\n>\n</\nReorder\n.\nGroup\n>\naxis\nDefault\n:\n\"y\"\nThe direction of reorder detection.\nBy default, all\nReorder.Item\ncomponents will visibly move only on this axis. To allow visual motion (but\nnot\nreordering) on both axes, pass the\ndrag\nprop to child\nReorder.Item\ncomponents.\nvalues\nThe values array that will be reordered. Each item in this list must match a\nvalue\npassed to each\nReorder.Item\n.\nonReorder\nA callback that will fire when items are detected to have reordered. The provided\nnewOrder\nshould be passed to a\nvalues\nstate update function.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\nReorder.Item\nReorder.Item\ncomponents accept all\nmotion\ncomponent props\nin addition to the following:\nas\nDefault:\n\"li\"\nThe element for\nReorder.Item\nto render as.\nvalue\nWhen\nonReorder\nis called, this is the value that will be passed through in the newly ordered array.\nThe\nReorder\ncomponents can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\naxis\n=\n\"y\"\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\n(\nitem\n)\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\nReorder\nis for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base\nmotion\ncomponent but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like\nDnD Kit\n.\nUsage\nEvery reorderable list is wrapped in the\nReorder.Group\ncomponent.\nimport\n{\nReorder\n}\nfrom\n\"motion/react\"\nfunction\nList\n(\n)\n{\nreturn\n(\n<\nReorder\n.\nGroup\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nBy default, this is rendered as a\n<ul>\n, but this can be changed with the\nas\nprop.\n<\nReorder\n.\nGroup\nas\n=\n\"ol\"\n>\nReorder.Group\nmust be passed the array of values in your reorderable list via the\nvalues\nprop.\nAdditionally, a\nonReorder\nevent will fire with the latest calculated order. For items to reorder, this must update the\nvalues\nstate.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n</\nReorder\n.\nGroup\n>\n)\n}\nTo render each reorderable item, use\nReorder.Item\n, passing it the value it represents via the\nvalue\nprop.\nimport\n{\nReorder\n}\nfrom\n\"framer-motion\"\nfunction\nList\n(\n)\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\nkey\n=\n{\nitem\n}\nvalue\n=\n{\nitem\n}\n>\n{\nitem\n}\n</\nReorder\n.\nItem\n>\n)\n)\n}\n</\nReorder\n.\nGroup\n>\n)\n}\nNow, when items are dragged and reordered,\nonReorder\nwill fire with a new order.\nLayout animations\nReorder.Item\ncomponents are already configured to perform\nlayout animations\n, so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\nExit animations\nAnimatePresence\ncan be used as normal to animate items as they enter/leave the React tree.\n<\nAnimatePresence\n>\n{\nitems\n.\nmap\n(\nitem\n=>\n(\n<\nReorder\n.\nItem\ninitial\n=\n{\n{\nopacity\n:\n0\n}\n}\nanimate\n=\n{\n{\nopacity\n:\n1\n}\n}\nexit\n=\n{\n{\nopacity\n:\n0\n}\n}\nkey\n=\n{\nitem\n}\n/>\n)\n)\n}\n</\nAnimatePresence\n>\nDrag triggers\nBy default, all of a\nReorder.Item\nwill be draggable.\nuseDragControls\ncan be used to define a different component to act as a drag trigger.\nimport\n{\nReorder\n,\nuseDragControls\n}\nfrom\n\"framer-motion\"\nfunction\nItem\n(\n{\nvalue\n}\n)\n{\nconst\ncontrols\n=\nuseDragControls\n(\n)\nreturn\n(\n<\nReorder\n.\nItem\nvalue\n=\n{\nvalue\n}\ndragListener\n=\n{\nfalse\n}\ndragControls\n=\n{\ncontrols\n}\n>\n<\ndiv\nclassName\n=\n\"reorder-handle\"\nonPointerDown\n=\n{\n(\ne\n)\n=>\ncontrols\n.\nstart\n(\ne\n)\n}\n/>\n</\nReorder\n.\nItem\n>\n)\n}\nAuto-scroll lists\nIf a\nReorder.Group\nis within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\nThe closer to the edge of the container, the faster the scroll.\nz-index\nReorder.Item\nwill automatically set a\nz-index\nstyle on the currently dragged item so it appears above the surrounding items.\nHowever,\nz-index\nonly affects items with\nposition !== \"static\"\n. So to enable this effect ensure the position of the\nReorder.Item\nis set to\nrelative\nor\nabsolute\n.\nAPI\nReorder.Group\nas\nDefault\n:\n\"ul\"\nThe underlying element for\nReorder.Group\nto render as.\n<\nReorder\n.\nGroup\nas\n=\n\"div\"\n>\n</\nReorder\n.\nGroup\n>\naxis\nDefault\n:\n\"y\"\nThe direction of reorder detection.\nBy default, all\nReorder.Item\ncomponents will visibly move only on this axis. To allow visual motion (but\nnot\nreordering) on both axes, pass the\ndrag\nprop to child\nReorder.Item\ncomponents.\nvalues\nThe values array that will be reordered. Each item in this list must match a\nvalue\npassed to each\nReorder.Item\n.\nonReorder\nA callback that will fire when items are detected to have reordered. The provided\nnewOrder\nshould be passed to a\nvalues\nstate update function.\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n(\n[\n0\n,\n1\n,\n2\n,\n3\n]\n)\nreturn\n(\n<\nReorder\n.\nGroup\nvalues\n=\n{\nitems\n}\nonReorder\n=\n{\nsetItems\n}\n>\nReorder.Item\nReorder.Item\ncomponents accept all\nmotion\ncomponent props\nin addition to the following:\nas\nDefault:\n\"li\"\nThe element for\nReorder.Item\nto render as.\nvalue\nWhen\nonReorder\nis called, this is the value that will be passed through in the newly ordered array.\nRelated topics\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nLayout animation\nSmoothly animate layout changes and create shared element animations.\nAnimatePresence\nAdd exit animations to React components when they're removed from the page.\nAnimatePresence\nAdd exit animations to React components when they're removed from the page.\nAnimatePresence\nAdd exit animations to React components when they're removed from the page.\nPrevious\nMotionConfig\nNext\nAnimateNumber\nMotion+\nMotion+\nMotion+\nLevel up your animations with Motion+\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\nGet Motion+\nGet Motion+\nGet Motion+\nOne-time payment, lifetime updates.\nAI-ready animations\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.",
  "content_markdown": "The `Reorder` components can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group axis=\"y\" values={items} onReorder={setItems}>\n    {items.map((item) => (\n      <Reorder.Item key={item} value={item}>\n        {item}\n      </Reorder.Item>\n    ))}\n  </Reorder.Group>\n)\n```\n\n`Reorder` is for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base `motion` component but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like [DnD Kit](https://docs.dndkit.com/).\n\n## [Usage](#usage)\n\nEvery reorderable list is wrapped in the `Reorder.Group` component.\n\n```\nimport { Reorder } from \"motion/react\"\n\nfunction List() {\n  return (\n    <Reorder.Group>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nBy default, this is rendered as a `<ul>`, but this can be changed with the `as` prop.\n\n```\n<Reorder.Group as=\"ol\">\n```\n\n`Reorder.Group` must be passed the array of values in your reorderable list via the `values` prop.\n\nAdditionally, a `onReorder` event will fire with the latest calculated order. For items to reorder, this must update the `values` state.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nTo render each reorderable item, use `Reorder.Item`, passing it the value it represents via the `value` prop.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n      {items.map(item => (\n        <Reorder.Item key={item} value={item}>\n          {item}\n        </Reorder.Item>\n      ))}\n    </Reorder.Group>\n  )\n}\n```\n\nNow, when items are dragged and reordered, `onReorder` will fire with a new order.\n\n### [Layout animations](#layout-animations)\n\n`Reorder.Item` components are already configured to perform [layout animations](./react-layout-animations), so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` can be used as normal to animate items as they enter/leave the React tree.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <Reorder.Item\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      key={item}\n    />  \n  ))}\n</AnimatePresence>\n```\n\n### [Drag triggers](#drag-triggers)\n\nBy default, all of a `Reorder.Item` will be draggable. `useDragControls` can be used to define a different component to act as a drag trigger.\n\n```\nimport { Reorder, useDragControls } from \"framer-motion\"\n\nfunction Item({ value }) {\n  const controls = useDragControls()\n  \n  return (\n    <Reorder.Item\n      value={value}\n      dragListener={false}\n      dragControls={controls}\n    >\n      <div\n        className=\"reorder-handle\"\n        onPointerDown={(e) => controls.start(e)}\n      />\n    </Reorder.Item>\n  )\n}\n```\n\n### [Auto-scroll lists](#auto-scroll-lists)\n\nIf a `Reorder.Group` is within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\n\nThe closer to the edge of the container, the faster the scroll.\n\n### [z-index](#z-index)\n\n`Reorder.Item` will automatically set a `z-index` style on the currently dragged item so it appears above the surrounding items.\n\nHowever, `z-index` only affects items with `position !== \"static\"`. So to enable this effect ensure the position of the `Reorder.Item` is set to `relative` or `absolute`.\n\n## [API](#api)\n\n### [`Reorder.Group`](#reorder.group)\n\n#### [`as`](#as)\n\n**Default**: `\"ul\"`\n\nThe underlying element for `Reorder.Group` to render as.\n\n```\n<Reorder.Group as=\"div\"></Reorder.Group>\n```\n\n#### [`axis`](#axis)\n\n**Default**: `\"y\"`\n\nThe direction of reorder detection.\n\nBy default, all `Reorder.Item` components will visibly move only on this axis. To allow visual motion (but **not** reordering) on both axes, pass the `drag` prop to child `Reorder.Item` components.\n\n#### [`values`](#values)\n\nThe values array that will be reordered. Each item in this list must match a `value` passed to each `Reorder.Item`.\n\n#### [`onReorder`](#onreorder)\n\nA callback that will fire when items are detected to have reordered. The provided `newOrder` should be passed to a `values` state update function.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group values={items} onReorder={setItems}>\n```\n\n### [`Reorder.Item`](#reorder.item)\n\n`Reorder.Item` components accept all `motion` [component props](./react-motion-component) in addition to the following:\n\n#### [`as`](#as-1)\n\n**Default:** `\"li\"`\n\nThe element for `Reorder.Item` to render as.\n\n#### [`value`](#value)\n\nWhen `onReorder` is called, this is the value that will be passed through in the newly ordered array.\n\nThe `Reorder` components can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group axis=\"y\" values={items} onReorder={setItems}>\n    {items.map((item) => (\n      <Reorder.Item key={item} value={item}>\n        {item}\n      </Reorder.Item>\n    ))}\n  </Reorder.Group>\n)\n```\n\n`Reorder` is for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base `motion` component but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like [DnD Kit](https://docs.dndkit.com/).\n\n## [Usage](#usage)\n\nEvery reorderable list is wrapped in the `Reorder.Group` component.\n\n```\nimport { Reorder } from \"motion/react\"\n\nfunction List() {\n  return (\n    <Reorder.Group>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nBy default, this is rendered as a `<ul>`, but this can be changed with the `as` prop.\n\n```\n<Reorder.Group as=\"ol\">\n```\n\n`Reorder.Group` must be passed the array of values in your reorderable list via the `values` prop.\n\nAdditionally, a `onReorder` event will fire with the latest calculated order. For items to reorder, this must update the `values` state.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nTo render each reorderable item, use `Reorder.Item`, passing it the value it represents via the `value` prop.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n      {items.map(item => (\n        <Reorder.Item key={item} value={item}>\n          {item}\n        </Reorder.Item>\n      ))}\n    </Reorder.Group>\n  )\n}\n```\n\nNow, when items are dragged and reordered, `onReorder` will fire with a new order.\n\n### [Layout animations](#layout-animations)\n\n`Reorder.Item` components are already configured to perform [layout animations](./react-layout-animations), so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` can be used as normal to animate items as they enter/leave the React tree.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <Reorder.Item\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      key={item}\n    />  \n  ))}\n</AnimatePresence>\n```\n\n### [Drag triggers](#drag-triggers)\n\nBy default, all of a `Reorder.Item` will be draggable. `useDragControls` can be used to define a different component to act as a drag trigger.\n\n```\nimport { Reorder, useDragControls } from \"framer-motion\"\n\nfunction Item({ value }) {\n  const controls = useDragControls()\n  \n  return (\n    <Reorder.Item\n      value={value}\n      dragListener={false}\n      dragControls={controls}\n    >\n      <div\n        className=\"reorder-handle\"\n        onPointerDown={(e) => controls.start(e)}\n      />\n    </Reorder.Item>\n  )\n}\n```\n\n### [Auto-scroll lists](#auto-scroll-lists)\n\nIf a `Reorder.Group` is within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\n\nThe closer to the edge of the container, the faster the scroll.\n\n### [z-index](#z-index)\n\n`Reorder.Item` will automatically set a `z-index` style on the currently dragged item so it appears above the surrounding items.\n\nHowever, `z-index` only affects items with `position !== \"static\"`. So to enable this effect ensure the position of the `Reorder.Item` is set to `relative` or `absolute`.\n\n## [API](#api)\n\n### [`Reorder.Group`](#reorder.group)\n\n#### [`as`](#as)\n\n**Default**: `\"ul\"`\n\nThe underlying element for `Reorder.Group` to render as.\n\n```\n<Reorder.Group as=\"div\"></Reorder.Group>\n```\n\n#### [`axis`](#axis)\n\n**Default**: `\"y\"`\n\nThe direction of reorder detection.\n\nBy default, all `Reorder.Item` components will visibly move only on this axis. To allow visual motion (but **not** reordering) on both axes, pass the `drag` prop to child `Reorder.Item` components.\n\n#### [`values`](#values)\n\nThe values array that will be reordered. Each item in this list must match a `value` passed to each `Reorder.Item`.\n\n#### [`onReorder`](#onreorder)\n\nA callback that will fire when items are detected to have reordered. The provided `newOrder` should be passed to a `values` state update function.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group values={items} onReorder={setItems}>\n```\n\n### [`Reorder.Item`](#reorder.item)\n\n`Reorder.Item` components accept all `motion` [component props](./react-motion-component) in addition to the following:\n\n#### [`as`](#as-1)\n\n**Default:** `\"li\"`\n\nThe element for `Reorder.Item` to render as.\n\n#### [`value`](#value)\n\nWhen `onReorder` is called, this is the value that will be passed through in the newly ordered array.\n\nThe `Reorder` components can be used to create drag-to-reorder lists, like reorderable tabs or todo items.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group axis=\"y\" values={items} onReorder={setItems}>\n    {items.map((item) => (\n      <Reorder.Item key={item} value={item}>\n        {item}\n      </Reorder.Item>\n    ))}\n  </Reorder.Group>\n)\n```\n\n`Reorder` is for simple drag-to-reorder implementations. It's exceptionally lightweight ontop of the base `motion` component but lacks some features like multirow, dragging between columns, or dragging within scrollable containers. For advanced use-cases we recommend something like [DnD Kit](https://docs.dndkit.com/).\n\n## [Usage](#usage)\n\nEvery reorderable list is wrapped in the `Reorder.Group` component.\n\n```\nimport { Reorder } from \"motion/react\"\n\nfunction List() {\n  return (\n    <Reorder.Group>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nBy default, this is rendered as a `<ul>`, but this can be changed with the `as` prop.\n\n```\n<Reorder.Group as=\"ol\">\n```\n\n`Reorder.Group` must be passed the array of values in your reorderable list via the `values` prop.\n\nAdditionally, a `onReorder` event will fire with the latest calculated order. For items to reorder, this must update the `values` state.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n    \n    </Reorder.Group>\n  )\n}\n```\n\nTo render each reorderable item, use `Reorder.Item`, passing it the value it represents via the `value` prop.\n\n```\nimport { Reorder } from \"framer-motion\"\n\nfunction List() {\n  const [items, setItems] = useState([0, 1, 2, 3])\n\n  return (\n    <Reorder.Group values={items} onReorder={setItems}>\n      {items.map(item => (\n        <Reorder.Item key={item} value={item}>\n          {item}\n        </Reorder.Item>\n      ))}\n    </Reorder.Group>\n  )\n}\n```\n\nNow, when items are dragged and reordered, `onReorder` will fire with a new order.\n\n### [Layout animations](#layout-animations)\n\n`Reorder.Item` components are already configured to perform [layout animations](./react-layout-animations), so if new items are added or removed to the reorderable list, surrounding items will animate to their new position automatically.\n\n### [Exit animations](#exit-animations)\n\n`AnimatePresence` can be used as normal to animate items as they enter/leave the React tree.\n\n```\n<AnimatePresence>\n  {items.map(item => (\n    <Reorder.Item\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      key={item}\n    />  \n  ))}\n</AnimatePresence>\n```\n\n### [Drag triggers](#drag-triggers)\n\nBy default, all of a `Reorder.Item` will be draggable. `useDragControls` can be used to define a different component to act as a drag trigger.\n\n```\nimport { Reorder, useDragControls } from \"framer-motion\"\n\nfunction Item({ value }) {\n  const controls = useDragControls()\n  \n  return (\n    <Reorder.Item\n      value={value}\n      dragListener={false}\n      dragControls={controls}\n    >\n      <div\n        className=\"reorder-handle\"\n        onPointerDown={(e) => controls.start(e)}\n      />\n    </Reorder.Item>\n  )\n}\n```\n\n### [Auto-scroll lists](#auto-scroll-lists)\n\nIf a `Reorder.Group` is within a scrollable container, the container will automatically scroll when a user drags an item towards the top and bottom of the list.\n\nThe closer to the edge of the container, the faster the scroll.\n\n### [z-index](#z-index)\n\n`Reorder.Item` will automatically set a `z-index` style on the currently dragged item so it appears above the surrounding items.\n\nHowever, `z-index` only affects items with `position !== \"static\"`. So to enable this effect ensure the position of the `Reorder.Item` is set to `relative` or `absolute`.\n\n## [API](#api)\n\n### [`Reorder.Group`](#reorder.group)\n\n#### [`as`](#as)\n\n**Default**: `\"ul\"`\n\nThe underlying element for `Reorder.Group` to render as.\n\n```\n<Reorder.Group as=\"div\"></Reorder.Group>\n```\n\n#### [`axis`](#axis)\n\n**Default**: `\"y\"`\n\nThe direction of reorder detection.\n\nBy default, all `Reorder.Item` components will visibly move only on this axis. To allow visual motion (but **not** reordering) on both axes, pass the `drag` prop to child `Reorder.Item` components.\n\n#### [`values`](#values)\n\nThe values array that will be reordered. Each item in this list must match a `value` passed to each `Reorder.Item`.\n\n#### [`onReorder`](#onreorder)\n\nA callback that will fire when items are detected to have reordered. The provided `newOrder` should be passed to a `values` state update function.\n\n```\nconst [items, setItems] = useState([0, 1, 2, 3])\n\nreturn (\n  <Reorder.Group values={items} onReorder={setItems}>\n```\n\n### [`Reorder.Item`](#reorder.item)\n\n`Reorder.Item` components accept all `motion` [component props](./react-motion-component) in addition to the following:\n\n#### [`as`](#as-1)\n\n**Default:** `\"li\"`\n\nThe element for `Reorder.Item` to render as.\n\n#### [`value`](#value)\n\nWhen `onReorder` is called, this is the value that will be passed through in the newly ordered array.\n\n## Related topics\n\n- [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n\n  [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n\n  [### Layout animation\n\n  Smoothly animate layout changes and create shared element animations.](./react-layout-animations)\n- [### AnimatePresence\n\n  Add exit animations to React components when they're removed from the page.](./react-animate-presence)\n\n  [### AnimatePresence\n\n  Add exit animations to React components when they're removed from the page.](./react-animate-presence)\n\n  [### AnimatePresence\n\n  Add exit animations to React components when they're removed from the page.](./react-animate-presence)\n\nPrevious\n\n[MotionConfig](./react-motion-config)\n\nNext\n\n[AnimateNumber](./react-animate-number)\n\nMotion+\n\nMotion+\n\nMotion+\n\n## Level up your animations with Motion+\n\nUnlock the full vault of 330+ Motion examples, 100+ tutorials, premium APIs, private Discord and GitHub, and powerful Motion Studio animation editing tools for your IDE.\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\n[Get Motion+](../plus)\n\nOne-time payment, lifetime updates.\n\n[![](https://framerusercontent.com/images/5efyyhcUoAlTBRRovqyx3jnMnEM.png?width=1568&height=1174)](https://framerusercontent.com/assets/MK7ot7xHs8BI3SZScC9oiKpURY4.mp4)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n![](https://framerusercontent.com/images/dvcUQX74Mh8wmjKmhIoM2Yli4.png?width=2000&height=2000)\n\n[![](https://framerusercontent.com/images/a6LWvnzoehr1qy4ywp7QSBDq5iQ.jpg?width=290&height=223)\n\nAI-ready animations\n\nMake your LLM an animation expert with 330+ pre-built examples available via MCP.](../plus)",
  "tags": [
    "framer",
    "motion",
    "react",
    "animation"
  ],
  "extracted_at": "2026-02-03T12:48:24.856922+00:00",
  "content_length": 14660,
  "content_hash": "d917d3e0b71cc0d2"
}