{
  "id": "tanstack-table__table_latest_docs_guide_pagination",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/pagination",
  "title": "Pagination Guide",
  "content": "Examples\nWant to skip to the implementation? Check out these examples:\npagination\npagination-controlled (React Query)\neditable-data\nexpanding\nfilters\nfully-controlled\nrow-selection\nAPI\nPagination API\nPagination Guide\nTanStack Table has great support for both client-side and server-side pagination. This guide will walk you through the different ways to implement pagination in your table.\nClient-Side Pagination\nUsing client-side pagination means that the\ndata\nthat you fetch will contain\nALL\nof the rows for the table, and the table instance will handle pagination logic in the front-end.\nShould You Use Client-Side Pagination?\nClient-side pagination is usually the simplest way to implement pagination when using TanStack Table, but it might not be practical for very large datasets.\nHowever, a lot of people underestimate just how much data can be handled client-side. If your table will only ever have a few thousand rows or less, client-side pagination can still be a viable option. TanStack Table is designed to scale up to 10s of thousands of rows with decent performance for pagination, filtering, sorting, and grouping. The\nofficial pagination example\nloads 100,000 rows and still performs well, albeit with only handful of columns.\nEvery use-case is different and will depend on the complexity of the table, how many columns you have, how large every piece of data is, etc. The main bottlenecks to pay attention to are:\nCan your server query all of the data in a reasonable amount of time (and cost)?\nWhat is the total size of the fetch? (This might not scale as badly as you think if you don't have many columns.)\nIs the client's browser using too much memory if all of the data is loaded at once?\nIf you're not sure, you can always start with client-side pagination and then switch to server-side pagination in the future as your data grows.\nShould You Use Virtualization Instead?\nAlternatively, instead of paginating the data, you can render all rows of a large dataset on the same page, but only use the browser's resources to render the rows that are visible in the viewport. This strategy is often called \"virtualization\" or \"windowing\". TanStack offers a virtualization library called\nTanStack Virtual\nthat can work well with TanStack Table. The UI/UX of both virtualization and pagination have their own trade-offs, so see which one works best for your use-case.\nPagination Row Model\nIf you want to take advantage of the built-in client-side pagination in TanStack Table, you first need to pass in the pagination row model.\njsx\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(), //load client-side pagination code\n});\nManual Server-Side Pagination\nIf you decide that you need to use server-side pagination, here is how you can implement it.\nNo pagination row model is needed for server-side pagination, but if you have provided it for other tables that do need it in a shared component, you can still turn off the client-side pagination by setting the\nmanualPagination\noption to\ntrue\n. Setting the\nmanualPagination\noption to\ntrue\nwill tell the table instance to use the\ntable.getPrePaginationRowModel\nrow model under the hood, and it will make the table instance assume that the\ndata\nthat you pass in is already paginated.\nPage Count and Row Count\nThe table instance will have no way of knowing how many rows/pages there are in total in your back-end unless you tell it. Provide either the\nrowCount\nor\npageCount\ntable option to let the table instance know how many pages there are in total. If you provide a\nrowCount\n, the table instance will calculate the\npageCount\ninternally from\nrowCount\nand\npageSize\n. Otherwise, you can directly provide the\npageCount\nif you already have it. If you don't know the page count, you can just pass in\n-1\nfor the\npageCount\n, but the\ngetCanNextPage\nand\ngetCanPreviousPage\nrow model functions will always return\ntrue\nin this case.\njsx\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  // getPaginationRowModel: getPaginationRowModel(), //not needed for server-side pagination\n  manualPagination: true, //turn off client-side pagination\n  rowCount: dataQuery.data?.rowCount, //pass in the total row count so the table knows how many pages there are (pageCount calculated internally if not provided)\n  // pageCount: dataQuery.data?.pageCount, //alternatively directly pass in pageCount instead of rowCount\n});\nNote\n: Setting the\nmanualPagination\noption to\ntrue\nwill make the table instance assume that the\ndata\nthat you pass in is already paginated.\nPagination State\nWhether or not you are using client-side or manual server-side pagination, you can use the built-in\npagination\nstate and APIs.\nThe\npagination\nstate is an object that contains the following properties:\npageIndex\n: The current page index (zero-based).\npageSize\n: The current page size.\nYou can manage the\npagination\nstate just like any other state in the table instance.\njsx\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst [pagination, setPagination] = useState({\n  pageIndex: 0, //initial page index\n  pageSize: 10, //default page size\n});\n\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  onPaginationChange: setPagination, //update the pagination state when internal APIs mutate the pagination state\n  state: {\n    //...\n    pagination,\n  },\n});\nAlternatively, if you have no need for managing the\npagination\nstate in your own scope, but you need to set different initial values for the\npageIndex\nand\npageSize\n, you can use the\ninitialState\noption.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  initialState: {\n    pagination: {\n      pageIndex: 2, //custom initial page index\n      pageSize: 25, //custom default page size\n    },\n  },\n});\nNote\n: Do NOT pass the\npagination\nstate to both the\nstate\nand\ninitialState\noptions.\nstate\nwill overwrite\ninitialState\n. Only use one or the other.\nPagination Options\nBesides the\nmanualPagination\n,\npageCount\n, and\nrowCount\noptions which are useful for manual server-side pagination (and discussed\nabove\n), there is one other table option that is useful to understand.\nAuto Reset Page Index\nBy default,\npageIndex\nis reset to\n0\nwhen page-altering state changes occur, such as when the\ndata\nis updated, filters change, grouping changes, etc. This behavior is automatically disabled when\nmanualPagination\nis true but it can be overridden by explicitly assigning a boolean value to the\nautoResetPageIndex\ntable option.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  autoResetPageIndex: false, //turn off auto reset of pageIndex\n});\nBe aware, however, that if you turn off\nautoResetPageIndex\n, you may need to add some logic to handle resetting the\npageIndex\nyourself to avoid showing empty pages.\nPagination APIs\nThere are several pagination table instance APIs that are useful for hooking up your pagination UI components.\nPagination Button APIs\ngetCanPreviousPage\n: Useful for disabling the \"previous page\" button when on the first page.\ngetCanNextPage\n: Useful for disabling the \"next page\" button when there are no more pages.\npreviousPage\n: Useful for going to the previous page. (Button click handler)\nnextPage\n: Useful for going to the next page. (Button click handler)\nfirstPage\n: Useful for going to the first page. (Button click handler)\nlastPage\n: Useful for going to the last page. (Button click handler)\nsetPageIndex\n: Useful for a \"go to page\" input.\nresetPageIndex\n: Useful for resetting the table state to the original page index.\nsetPageSize\n: Useful for a \"page size\" input/select.\nresetPageSize\n: Useful for resetting the table state to the original page size.\nsetPagination\n: Useful for setting all of the pagination state at once.\nresetPagination\n: Useful for resetting the table state to the original pagination state.\nNote\n: Some of these APIs are new in\nv8.13.0\n.\njsx\n<Button\n  onClick={() => table.firstPage()}\n  disabled={!table.getCanPreviousPage()}\n>\n  {'<<'}\n</Button>\n<Button\n  onClick={() => table.previousPage()}\n  disabled={!table.getCanPreviousPage()}\n>\n  {'<'}\n</Button>\n<Button\n  onClick={() => table.nextPage()}\n  disabled={!table.getCanNextPage()}\n>\n  {'>'}\n</Button>\n<Button\n  onClick={() => table.lastPage()}\n  disabled={!table.getCanNextPage()}\n>\n  {'>>'}\n</Button>\n<select\n  value={table.getState().pagination.pageSize}\n  onChange={e => {\n    table.setPageSize(Number(e.target.value))\n  }}\n>\n  {[10, 20, 30, 40, 50].map(pageSize => (\n    <option key={pageSize} value={pageSize}>\n      {pageSize}\n    </option>\n  ))}\n</select>\nPagination Info APIs\ngetPageCount\n: Useful for showing the total number of pages.\ngetRowCount\n: Useful for showing the total number of rows.",
  "content_markdown": "[## Examples](#examples)\n\nWant to skip to the implementation? Check out these examples:\n\n- [pagination](/table/latest/docs/framework/react/examples/pagination)\n- [pagination-controlled (React Query)](/table/latest/docs/framework/react/examples/pagination-controlled)\n- [editable-data](/table/latest/docs/framework/react/examples/editable-data)\n- [expanding](/table/latest/docs/framework/react/examples/expanding)\n- [filters](/table/latest/docs/framework/react/examples/filters)\n- [fully-controlled](/table/latest/docs/framework/react/examples/fully-controlled)\n- [row-selection](/table/latest/docs/framework/react/examples/row-selection)\n\n[## API](#api)\n\n[Pagination API](/table/latest/docs/api/features/pagination)\n\n[## Pagination Guide](#pagination-guide)\n\nTanStack Table has great support for both client-side and server-side pagination. This guide will walk you through the different ways to implement pagination in your table.\n\n[### Client-Side Pagination](#client-side-pagination)\n\nUsing client-side pagination means that the data that you fetch will contain ***ALL*** of the rows for the table, and the table instance will handle pagination logic in the front-end.\n\n[#### Should You Use Client-Side Pagination?](#should-you-use-client-side-pagination)\n\nClient-side pagination is usually the simplest way to implement pagination when using TanStack Table, but it might not be practical for very large datasets.\n\nHowever, a lot of people underestimate just how much data can be handled client-side. If your table will only ever have a few thousand rows or less, client-side pagination can still be a viable option. TanStack Table is designed to scale up to 10s of thousands of rows with decent performance for pagination, filtering, sorting, and grouping. The [official pagination example](/table/latest/docs/framework/react/examples/pagination) loads 100,000 rows and still performs well, albeit with only handful of columns.\n\nEvery use-case is different and will depend on the complexity of the table, how many columns you have, how large every piece of data is, etc. The main bottlenecks to pay attention to are:\n\n1. Can your server query all of the data in a reasonable amount of time (and cost)?\n2. What is the total size of the fetch? (This might not scale as badly as you think if you don't have many columns.)\n3. Is the client's browser using too much memory if all of the data is loaded at once?\n\nIf you're not sure, you can always start with client-side pagination and then switch to server-side pagination in the future as your data grows.\n\n[#### Should You Use Virtualization Instead?](#should-you-use-virtualization-instead)\n\nAlternatively, instead of paginating the data, you can render all rows of a large dataset on the same page, but only use the browser's resources to render the rows that are visible in the viewport. This strategy is often called \"virtualization\" or \"windowing\". TanStack offers a virtualization library called [TanStack Virtual](https://tanstack.com/virtual/latest) that can work well with TanStack Table. The UI/UX of both virtualization and pagination have their own trade-offs, so see which one works best for your use-case.\n\n[#### Pagination Row Model](#pagination-row-model)\n\nIf you want to take advantage of the built-in client-side pagination in TanStack Table, you first need to pass in the pagination row model.\n\njsx\n\n```\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(), //load client-side pagination code\n});\n```\n\n[### Manual Server-Side Pagination](#manual-server-side-pagination)\n\nIf you decide that you need to use server-side pagination, here is how you can implement it.\n\nNo pagination row model is needed for server-side pagination, but if you have provided it for other tables that do need it in a shared component, you can still turn off the client-side pagination by setting the manualPagination option to true. Setting the manualPagination option to true will tell the table instance to use the table.getPrePaginationRowModel row model under the hood, and it will make the table instance assume that the data that you pass in is already paginated.\n\n[#### Page Count and Row Count](#page-count-and-row-count)\n\nThe table instance will have no way of knowing how many rows/pages there are in total in your back-end unless you tell it. Provide either the rowCount or pageCount table option to let the table instance know how many pages there are in total. If you provide a rowCount, the table instance will calculate the pageCount internally from rowCount and pageSize. Otherwise, you can directly provide the pageCount if you already have it. If you don't know the page count, you can just pass in -1 for the pageCount, but the getCanNextPage and getCanPreviousPage row model functions will always return true in this case.\n\njsx\n\n```\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  // getPaginationRowModel: getPaginationRowModel(), //not needed for server-side pagination\n  manualPagination: true, //turn off client-side pagination\n  rowCount: dataQuery.data?.rowCount, //pass in the total row count so the table knows how many pages there are (pageCount calculated internally if not provided)\n  // pageCount: dataQuery.data?.pageCount, //alternatively directly pass in pageCount instead of rowCount\n});\n```\n\n> **Note**: Setting the manualPagination option to true will make the table instance assume that the data that you pass in is already paginated.\n\n[### Pagination State](#pagination-state)\n\nWhether or not you are using client-side or manual server-side pagination, you can use the built-in pagination state and APIs.\n\nThe pagination state is an object that contains the following properties:\n\n- pageIndex: The current page index (zero-based).\n- pageSize: The current page size.\n\nYou can manage the pagination state just like any other state in the table instance.\n\njsx\n\n```\nimport { useReactTable, getCoreRowModel, getPaginationRowModel } from '@tanstack/react-table';\n//...\nconst [pagination, setPagination] = useState({\n  pageIndex: 0, //initial page index\n  pageSize: 10, //default page size\n});\n\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  onPaginationChange: setPagination, //update the pagination state when internal APIs mutate the pagination state\n  state: {\n    //...\n    pagination,\n  },\n});\n```\n\nAlternatively, if you have no need for managing the pagination state in your own scope, but you need to set different initial values for the pageIndex and pageSize, you can use the initialState option.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  initialState: {\n    pagination: {\n      pageIndex: 2, //custom initial page index\n      pageSize: 25, //custom default page size\n    },\n  },\n});\n```\n\n> **Note**: Do NOT pass the pagination state to both the state and initialState options. state will overwrite initialState. Only use one or the other.\n\n[### Pagination Options](#pagination-options)\n\nBesides the manualPagination, pageCount, and rowCount options which are useful for manual server-side pagination (and discussed [above](#manual-server-side-pagination)), there is one other table option that is useful to understand.\n\n[#### Auto Reset Page Index](#auto-reset-page-index)\n\nBy default, pageIndex is reset to 0 when page-altering state changes occur, such as when the data is updated, filters change, grouping changes, etc. This behavior is automatically disabled when manualPagination is true but it can be overridden by explicitly assigning a boolean value to the autoResetPageIndex table option.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getPaginationRowModel: getPaginationRowModel(),\n  autoResetPageIndex: false, //turn off auto reset of pageIndex\n});\n```\n\nBe aware, however, that if you turn off autoResetPageIndex, you may need to add some logic to handle resetting the pageIndex yourself to avoid showing empty pages.\n\n[### Pagination APIs](#pagination-apis)\n\nThere are several pagination table instance APIs that are useful for hooking up your pagination UI components.\n\n[#### Pagination Button APIs](#pagination-button-apis)\n\n- getCanPreviousPage: Useful for disabling the \"previous page\" button when on the first page.\n- getCanNextPage: Useful for disabling the \"next page\" button when there are no more pages.\n- previousPage: Useful for going to the previous page. (Button click handler)\n- nextPage: Useful for going to the next page. (Button click handler)\n- firstPage: Useful for going to the first page. (Button click handler)\n- lastPage: Useful for going to the last page. (Button click handler)\n- setPageIndex: Useful for a \"go to page\" input.\n- resetPageIndex: Useful for resetting the table state to the original page index.\n- setPageSize: Useful for a \"page size\" input/select.\n- resetPageSize: Useful for resetting the table state to the original page size.\n- setPagination: Useful for setting all of the pagination state at once.\n- resetPagination: Useful for resetting the table state to the original pagination state.\n\n> **Note**: Some of these APIs are new in v8.13.0.\n\njsx\n\n```\n<Button\n  onClick={() => table.firstPage()}\n  disabled={!table.getCanPreviousPage()}\n>\n  {'<<'}\n</Button>\n<Button\n  onClick={() => table.previousPage()}\n  disabled={!table.getCanPreviousPage()}\n>\n  {'<'}\n</Button>\n<Button\n  onClick={() => table.nextPage()}\n  disabled={!table.getCanNextPage()}\n>\n  {'>'}\n</Button>\n<Button\n  onClick={() => table.lastPage()}\n  disabled={!table.getCanNextPage()}\n>\n  {'>>'}\n</Button>\n<select\n  value={table.getState().pagination.pageSize}\n  onChange={e => {\n    table.setPageSize(Number(e.target.value))\n  }}\n>\n  {[10, 20, 30, 40, 50].map(pageSize => (\n    <option key={pageSize} value={pageSize}>\n      {pageSize}\n    </option>\n  ))}\n</select>\n```\n\n[#### Pagination Info APIs](#pagination-info-apis)\n\n- getPageCount: Useful for showing the total number of pages.\n- getRowCount: Useful for showing the total number of rows.",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:23.981910+00:00",
  "content_length": 9228,
  "content_hash": "411dde8becb2b603"
}