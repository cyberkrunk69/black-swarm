{
  "id": "tanstack-table__table_latest_docs_guide_grouping",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/grouping",
  "title": "Grouping Guide",
  "content": "Examples\nWant to skip to the implementation? Check out these examples:\ngrouping\nAPI\nGrouping API\nGrouping Guide\nThere are 3 table features that can reorder columns, which happen in the following order:\nColumn Pinning\n- If pinning, columns are split into left, center (unpinned), and right pinned columns.\nManual\nColumn Ordering\n- A manually specified column order is applied.\nGrouping\n- If grouping is enabled, a grouping state is active, and\ntableOptions.groupedColumnMode\nis set to\n'reorder' | 'remove'\n, then the grouped columns are reordered to the start of the column flow.\nGrouping in TanStack table is a feature that applies to columns and allows you to categorize and organize the table rows based on specific columns. This can be useful in cases where you have a large amount of data and you want to group them together based on certain criteria.\nTo use the grouping feature, you will need to use the grouped row model. This model is responsible for grouping the rows based on the grouping state.\ntsx\nimport { getGroupedRowModel } from '@tanstack/react-table'\n\nconst table = useReactTable({\n  // other options...\n  getGroupedRowModel: getGroupedRowModel(),\n})\nWhen grouping state is active, the table will add matching rows as subRows to the grouped row. The grouped row will be added to the table rows at the same index as the first matching row. The matching rows will be removed from the table rows.\nTo allow the user to expand and collapse the grouped rows, you can use the expanding feature.\ntsx\nimport { getGroupedRowModel, getExpandedRowModel} from '@tanstack/react-table'\n\nconst table = useReactTable({\n  // other options...\n  getGroupedRowModel: getGroupedRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\nGrouping state\nThe grouping state is an array of strings, where each string is the ID of a column to group by. The order of the strings in the array determines the order of the grouping. For example, if the grouping state is ['column1', 'column2'], then the table will first group by column1, and then within each group, it will group by column2. You can control the grouping state using the setGrouping function:\ntsx\ntable.setGrouping(['column1', 'column2']);\nYou can also reset the grouping state to its initial state using the resetGrouping function:\ntsx\ntable.resetGrouping();\nBy default, when a column is grouped, it is moved to the start of the table. You can control this behavior using the groupedColumnMode option. If you set it to 'reorder', then the grouped columns will be moved to the start of the table. If you set it to 'remove', then the grouped columns will be removed from the table. If you set it to false, then the grouped columns will not be moved or removed.\ntsx\nconst table = useReactTable({\n  // other options...\n  groupedColumnMode: 'reorder',\n})\nAggregations\nWhen rows are grouped, you can aggregate the data in the grouped rows by columns using the aggregationFn option. This is a string that is the ID of the aggregation function. You can define the aggregation functions using the aggregationFns option.\ntsx\nconst column = columnHelper.accessor('key', {\n  aggregationFn: 'sum',\n})\nIn the above example, the sum aggregation function will be used to aggregate the data in the grouped rows.\nBy default, numeric columns will use the sum aggregation function, and non-numeric columns will use the count aggregation function. You can override this behavior by specifying the aggregationFn option in the column definition.\nThere are several built-in aggregation functions that you can use:\nsum - Sums the values in the grouped rows.\ncount - Counts the number of rows in the grouped rows.\nmin - Finds the minimum value in the grouped rows.\nmax - Finds the maximum value in the grouped rows.\nextent - Finds the extent (min and max) of the values in the grouped rows.\nmean - Finds the mean of the values in the grouped rows.\nmedian - Finds the median of the values in the grouped rows.\nunique - Returns an array of unique values in the grouped rows.\nuniqueCount - Counts the number of unique values in the grouped rows.\nCustom Aggregations\nWhen rows are grouped, you can aggregate the data in the grouped rows using the aggregationFns option. This is a record where the keys are the IDs of the aggregation functions, and the values are the aggregation functions themselves. You can then reference these aggregation functions in a column's aggregationFn option.\ntsx\nconst table = useReactTable({\n  // other options...\n  aggregationFns: {\n    myCustomAggregation: (columnId, leafRows, childRows) => {\n      // return the aggregated value\n    },\n  },\n})\nIn the above example, myCustomAggregation is a custom aggregation function that takes the column ID, the leaf rows, and the child rows, and returns the aggregated value. You can then use this aggregation function in a column's aggregationFn option:\ntsx\nconst column = columnHelper.accessor('key', {\n  aggregationFn: 'myCustomAggregation',\n})\nManual Grouping\nIf you are doing server-side grouping and aggregation, you can enable manual grouping using the manualGrouping option. When this option is set to true, the table will not automatically group rows using getGroupedRowModel() and instead will expect you to manually group the rows before passing them to the table.\ntsx\nconst table = useReactTable({\n  // other options...\n  manualGrouping: true,\n})\nNote:\nThere are not currently many known easy ways to do server-side grouping with TanStack Table. You will need to do lots of custom cell rendering to make this work.\nGrouping Change Handler\nIf you want to manage the grouping state yourself, you can use the onGroupingChange option. This option is a function that is called when the grouping state changes. You can pass the managed state back to the table via the tableOptions.state.grouping option.\ntsx\nconst [grouping, setGrouping] = useState<string[]>([])\n\nconst table = useReactTable({\n  // other options...\n  state: {\n    grouping: grouping,\n  },\n  onGroupingChange: setGrouping\n})",
  "content_markdown": "[## Examples](#examples)\n\nWant to skip to the implementation? Check out these examples:\n\n- [grouping](https://github.com/TanStack/table/tree/main/examples/react/grouping)\n\n[## API](#api)\n\n[Grouping API](/table/latest/docs/api/features/grouping)\n\n[## Grouping Guide](#grouping-guide)\n\nThere are 3 table features that can reorder columns, which happen in the following order:\n\n1. [Column Pinning](/table/latest/docs/guide/column-pinning) - If pinning, columns are split into left, center (unpinned), and right pinned columns.\n2. Manual [Column Ordering](/table/latest/docs/guide/column-ordering) - A manually specified column order is applied.\n3. **Grouping** - If grouping is enabled, a grouping state is active, and tableOptions.groupedColumnMode is set to 'reorder' | 'remove', then the grouped columns are reordered to the start of the column flow.\n\nGrouping in TanStack table is a feature that applies to columns and allows you to categorize and organize the table rows based on specific columns. This can be useful in cases where you have a large amount of data and you want to group them together based on certain criteria.\n\nTo use the grouping feature, you will need to use the grouped row model. This model is responsible for grouping the rows based on the grouping state.\n\ntsx\n\n```\nimport { getGroupedRowModel } from '@tanstack/react-table'\n\nconst table = useReactTable({\n  // other options...\n  getGroupedRowModel: getGroupedRowModel(),\n})\n```\n\nWhen grouping state is active, the table will add matching rows as subRows to the grouped row. The grouped row will be added to the table rows at the same index as the first matching row. The matching rows will be removed from the table rows.\nTo allow the user to expand and collapse the grouped rows, you can use the expanding feature.\n\ntsx\n\n```\nimport { getGroupedRowModel, getExpandedRowModel} from '@tanstack/react-table'\n\nconst table = useReactTable({\n  // other options...\n  getGroupedRowModel: getGroupedRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\n```\n\n[### Grouping state](#grouping-state)\n\nThe grouping state is an array of strings, where each string is the ID of a column to group by. The order of the strings in the array determines the order of the grouping. For example, if the grouping state is ['column1', 'column2'], then the table will first group by column1, and then within each group, it will group by column2. You can control the grouping state using the setGrouping function:\n\ntsx\n\n```\ntable.setGrouping(['column1', 'column2']);\n```\n\nYou can also reset the grouping state to its initial state using the resetGrouping function:\n\ntsx\n\n```\ntable.resetGrouping();\n```\n\nBy default, when a column is grouped, it is moved to the start of the table. You can control this behavior using the groupedColumnMode option. If you set it to 'reorder', then the grouped columns will be moved to the start of the table. If you set it to 'remove', then the grouped columns will be removed from the table. If you set it to false, then the grouped columns will not be moved or removed.\n\ntsx\n\n```\nconst table = useReactTable({\n  // other options...\n  groupedColumnMode: 'reorder',\n})\n```\n\n[### Aggregations](#aggregations)\n\nWhen rows are grouped, you can aggregate the data in the grouped rows by columns using the aggregationFn option. This is a string that is the ID of the aggregation function. You can define the aggregation functions using the aggregationFns option.\n\ntsx\n\n```\nconst column = columnHelper.accessor('key', {\n  aggregationFn: 'sum',\n})\n```\n\nIn the above example, the sum aggregation function will be used to aggregate the data in the grouped rows.\nBy default, numeric columns will use the sum aggregation function, and non-numeric columns will use the count aggregation function. You can override this behavior by specifying the aggregationFn option in the column definition.\n\nThere are several built-in aggregation functions that you can use:\n\n- sum - Sums the values in the grouped rows.\n- count - Counts the number of rows in the grouped rows.\n- min - Finds the minimum value in the grouped rows.\n- max - Finds the maximum value in the grouped rows.\n- extent - Finds the extent (min and max) of the values in the grouped rows.\n- mean - Finds the mean of the values in the grouped rows.\n- median - Finds the median of the values in the grouped rows.\n- unique - Returns an array of unique values in the grouped rows.\n- uniqueCount - Counts the number of unique values in the grouped rows.\n\n[#### Custom Aggregations](#custom-aggregations)\n\nWhen rows are grouped, you can aggregate the data in the grouped rows using the aggregationFns option. This is a record where the keys are the IDs of the aggregation functions, and the values are the aggregation functions themselves. You can then reference these aggregation functions in a column's aggregationFn option.\n\ntsx\n\n```\nconst table = useReactTable({\n  // other options...\n  aggregationFns: {\n    myCustomAggregation: (columnId, leafRows, childRows) => {\n      // return the aggregated value\n    },\n  },\n})\n```\n\nIn the above example, myCustomAggregation is a custom aggregation function that takes the column ID, the leaf rows, and the child rows, and returns the aggregated value. You can then use this aggregation function in a column's aggregationFn option:\n\ntsx\n\n```\nconst column = columnHelper.accessor('key', {\n  aggregationFn: 'myCustomAggregation',\n})\n```\n\n[### Manual Grouping](#manual-grouping)\n\nIf you are doing server-side grouping and aggregation, you can enable manual grouping using the manualGrouping option. When this option is set to true, the table will not automatically group rows using getGroupedRowModel() and instead will expect you to manually group the rows before passing them to the table.\n\ntsx\n\n```\nconst table = useReactTable({\n  // other options...\n  manualGrouping: true,\n})\n```\n\n> **Note:** There are not currently many known easy ways to do server-side grouping with TanStack Table. You will need to do lots of custom cell rendering to make this work.\n\n[### Grouping Change Handler](#grouping-change-handler)\n\nIf you want to manage the grouping state yourself, you can use the onGroupingChange option. This option is a function that is called when the grouping state changes. You can pass the managed state back to the table via the tableOptions.state.grouping option.\n\ntsx\n\n```\nconst [grouping, setGrouping] = useState<string[]>([])\n\nconst table = useReactTable({\n  // other options...\n  state: {\n    grouping: grouping,\n  },\n  onGroupingChange: setGrouping\n})\n```",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:31.438230+00:00",
  "content_length": 5995,
  "content_hash": "a9d77d45e20cb21f"
}