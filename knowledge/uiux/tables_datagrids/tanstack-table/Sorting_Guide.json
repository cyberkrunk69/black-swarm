{
  "id": "tanstack-table__table_latest_docs_guide_sorting",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/sorting",
  "title": "Sorting Guide",
  "content": "Examples\nWant to skip to the implementation? Check out these examples:\nsorting\nfilters\nAPI\nSorting API\nSorting Guide\nTanStack Table provides solutions for just about any sorting use-case you might have. This guide will walk you through the various options that you can use to customize the built-in client-side sorting functionality, as well as how to opt out of client-side sorting in favor of manual server-side sorting.\nSorting State\nThe sorting state is defined as an array of objects with the following shape:\ntsx\ntype ColumnSort = {\n  id: string\n  desc: boolean\n}\ntype SortingState = ColumnSort[]\nSince the sorting state is an array, it is possible to sort by multiple columns at once. Read more about the multi-sorting customizations down\nbelow\n.\nAccessing Sorting State\nYou can access the sorting state directly from the table instance just like any other state using the\ntable.getState()\nAPI.\ntsx\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n})\n\nconsole.log(table.getState().sorting) // access the sorting state from the table instance\nHowever, if you need to access the sorting state before the table is initialized, you can \"control\" the sorting state like down below.\nControlled Sorting State\nIf you need easy access to the sorting state, you can control/manage the sorting state in your own state management with the\nstate.sorting\nand\nonSortingChange\ntable options.\ntsx\nconst [sorting, setSorting] = useState<SortingState>([]) // can set initial sorting state here\n//...\n// use sorting state to fetch data from your server or something...\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n  state: {\n    sorting,\n  },\n  onSortingChange: setSorting,\n})\nInitial Sorting State\nIf you do not need to control the sorting state in your own state management or scope, but you still want to set an initial sorting state, you can use the\ninitialState\ntable option instead of\nstate\n.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n  initialState: {\n    sorting: [\n      {\n        id: 'name',\n        desc: true, // sort by name in descending order by default\n      },\n    ],\n  },\n})\nNOTE\n: Do not use both\ninitialState.sorting\nand\nstate.sorting\nat the same time, as the initialized state in the\nstate.sorting\nwill override the\ninitialState.sorting\n.\nClient-Side vs Server-Side Sorting\nWhether or not you should use client-side or server-side sorting depends entirely on whether you are also using client-side or server-side pagination or filtering. Be consistent, because using client-side sorting with server-side pagination or filtering will only sort the data that is currently loaded, and not the entire dataset.\nManual Server-Side Sorting\nIf you plan to just use your own server-side sorting in your back-end logic, you do not need to provide a sorted row model. But if you have provided a sorting row model, but you want to disable it, you can use the\nmanualSorting\ntable option.\njsx\nconst [sorting, setSorting] = useState<SortingState>([])\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  //getSortedRowModel: getSortedRowModel(), //not needed for manual sorting\n  manualSorting: true, //use pre-sorted row model instead of sorted row model\n  state: {\n    sorting,\n  },\n  onSortingChange: setSorting,\n})\nNOTE\n: When\nmanualSorting\nis set to\ntrue\n, the table will assume that the data that you provide is already sorted, and will not apply any sorting to it.\nClient-Side Sorting\nTo implement client-side sorting, first you have to provide a sorting row model to the table. You can import the\ngetSortedRowModel\nfunction from TanStack Table, and it will be used to transform your rows into sorted rows.\njsx\nimport { useReactTable } from '@tanstack/react-table'\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getSortedRowModel: getSortedRowModel(), //provide a sorting row model\n})\nSorting Fns\nThe default sorting function for all columns is inferred from the data type of the column. However, it can be useful to define the exact sorting function that you want to use for a specific column, especially if any of your data is nullable or not a standard data type.\nYou can determine a custom sorting function on a per-column basis using the\nsortingFn\ncolumn option.\nBy default, there are 6 built-in sorting functions to choose from:\nalphanumeric\n- Sorts by mixed alphanumeric values without case-sensitivity. Slower, but more accurate if your strings contain numbers that need to be naturally sorted.\nalphanumericCaseSensitive\n- Sorts by mixed alphanumeric values with case-sensitivity. Slower, but more accurate if your strings contain numbers that need to be naturally sorted.\ntext\n- Sorts by text/string values without case-sensitivity. Faster, but less accurate if your strings contain numbers that need to be naturally sorted.\ntextCaseSensitive\n- Sorts by text/string values with case-sensitivity. Faster, but less accurate if your strings contain numbers that need to be naturally sorted.\ndatetime\n- Sorts by time, use this if your values are\nDate\nobjects.\nbasic\n- Sorts using a basic/standard\na > b ? 1 : a < b ? -1 : 0\ncomparison. This is the fastest sorting function, but may not be the most accurate.\nYou can also define your own custom sorting functions either as the\nsortingFn\ncolumn option, or as a global sorting function using the\nsortingFns\ntable option.\nCustom Sorting Functions\nWhen defining a custom sorting function in either the\nsortingFns\ntable option or as a\nsortingFn\ncolumn option, it should have the following signature:\ntsx\n//optionally use the SortingFn to infer the parameter types\nconst myCustomSortingFn: SortingFn<TData> = (rowA: Row<TData>, rowB: Row<TData>, columnId: string) => {\n  return //-1, 0, or 1 - access any row data using rowA.original and rowB.original\n}\nNote: The comparison function does not need to take whether or not the column is in descending or ascending order into account. The row models will take of that logic.\nsortingFn\nfunctions only need to provide a consistent comparison.\nEvery sorting function receives 2 rows and a column ID and are expected to compare the two rows using the column ID to return\n-1\n,\n0\n, or\n1\nin ascending order. Here's a cheat sheet:\nReturn\nAscending Order\n-1\na < b\n0\na === b\n1\na > b\njsx\nconst columns = [\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n    sortingFn: 'alphanumeric', // use built-in sorting function by name\n  },\n  {\n    header: () => 'Age',\n    accessorKey: 'age',\n    sortingFn: 'myCustomSortingFn', // use custom global sorting function\n  },\n  {\n    header: () => 'Birthday',\n    accessorKey: 'birthday',\n    sortingFn: 'datetime', // recommended for date columns\n  },\n  {\n    header: () => 'Profile',\n    accessorKey: 'profile',\n    // use custom sorting function directly\n    sortingFn: (rowA, rowB, columnId) => {\n      return rowA.original.someProperty - rowB.original.someProperty\n    },\n  }\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getSortedRowModel: getSortedRowModel(),\n  sortingFns: { //add a custom sorting function\n    myCustomSortingFn: (rowA, rowB, columnId) => {\n      return rowA.original[columnId] > rowB.original[columnId] ? 1 : rowA.original[columnId] < rowB.original[columnId] ? -1 : 0\n    },\n  },\n})\nCustomize Sorting\nThere are a lot of table and column options that you can use to further customize the sorting UX and behavior.\nDisable Sorting\nYou can disable sorting for either a specific column or the entire table using the\nenableSorting\ncolumn option or table option.\njsx\nconst columns = [\n  {\n    header: () => 'ID',\n    accessorKey: 'id',\n    enableSorting: false, // disable sorting for this column\n  },\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  enableSorting: false, // disable sorting for the entire table\n})\nSorting Direction\nBy default, the first sorting direction when cycling through the sorting for a column using the\ntoggleSorting\nAPIs is ascending for string columns and descending for number columns. You can change this behavior with the\nsortDescFirst\ncolumn option or table option.\njsx\nconst columns = [\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n    sortDescFirst: true, //sort by name in descending order first (default is ascending for string columns)\n  },\n  {\n    header: () => 'Age',\n    accessorKey: 'age',\n    sortDescFirst: false, //sort by age in ascending order first (default is descending for number columns)\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  sortDescFirst: true, //sort by all columns in descending order first (default is ascending for string columns and descending for number columns)\n})\nNOTE\n: You may want to explicitly set the\nsortDescFirst\ncolumn option on any columns that have nullable values. The table may not be able to properly determine if a column is a number or a string if it contains nullable values.\nInvert Sorting\nInverting sorting is not the same as changing the default sorting direction. If\ninvertSorting\ncolumn option is\ntrue\nfor a column, then the \"desc/asc\" sorting states will still cycle like normal, but the actual sorting of the rows will be inverted. This is useful for values that have an inverted best/worst scale where lower numbers are better, eg. a ranking (1st, 2nd, 3rd) or golf-like scoring.\njsx\nconst columns = [\n  {\n    header: () => 'Rank',\n    accessorKey: 'rank',\n    invertSorting: true, // invert the sorting for this column. 1st -> 2nd -> 3rd -> ... even if \"desc\" sorting is applied\n  },\n  //...\n]\nSort Undefined Values\nAny undefined values will be sorted to the beginning or end of the list based on the\nsortUndefined\ncolumn option or table option. You can customize this behavior for your specific use-case.\nIn not specified, the default value for\nsortUndefined\nis\n1\n, and undefined values will be sorted with lower priority (descending), if ascending, undefined will appear on the end of the list.\n'first'\n- Undefined values will be pushed to the beginning of the list\n'last'\n- Undefined values will be pushed to the end of the list\nfalse\n- Undefined values will be considered tied and need to be sorted by the next column filter or original index (whichever applies)\n-1\n- Undefined values will be sorted with higher priority (ascending) (if ascending, undefined will appear on the beginning of the list)\n1\n- Undefined values will be sorted with lower priority (descending) (if ascending, undefined will appear on the end of the list)\nNOTE:\n'first'\nand\n'last'\noptions are new in v8.16.0\njsx\nconst columns = [\n  {\n    header: () => 'Rank',\n    accessorKey: 'rank',\n    sortUndefined: -1, // 'first' | 'last' | 1 | -1 | false\n  },\n]\nSorting Removal\nBy default, the ability to remove sorting while cycling through the sorting states for a column is enabled. You can disable this behavior using the\nenableSortingRemoval\ntable option. This behavior is useful if you want to ensure that at least one column is always sorted.\nThe default behavior when using either the\ngetToggleSortingHandler\nor\ntoggleSorting\nAPIs is to cycle through the sorting states like this:\n'none' -> 'desc' -> 'asc' -> 'none' -> 'desc' -> 'asc' -> ...\nIf you disable sorting removal, the behavior will be like this:\n'none' -> 'desc' -> 'asc' -> 'desc' -> 'asc' -> ...\nOnce a column is sorted and\nenableSortingRemoval\nis\nfalse\n, toggling the sorting on that column will never remove the sorting. However, if the user sorts by another column and it is not a multi-sort event, then the sorting will be removed from the previous column and just applied to the new column.\nSet\nenableSortingRemoval\nto\nfalse\nif you want to ensure that at least one column is always sorted.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  enableSortingRemoval: false, // disable the ability to remove sorting on columns (always none -> asc -> desc -> asc)\n})\nMulti-Sorting\nSorting by multiple columns at once is enabled by default if using the\ncolumn.getToggleSortingHandler\nAPI. If the user holds the\nShift\nkey while clicking on a column header, the table will sort by that column in addition to the columns that are already sorted. If you use the\ncolumn.toggleSorting\nAPI, you have to manually pass in whether or not to use multi-sorting. (\ncolumn.toggleSorting(desc, multi)\n).\nDisable Multi-Sorting\nYou can disable multi-sorting for either a specific column or the entire table using the\nenableMultiSort\ncolumn option or table option. Disabling multi-sorting for a specific column will replace all existing sorting with the new column's sorting.\njsx\nconst columns = [\n  {\n    header: () => 'Created At',\n    accessorKey: 'createdAt',\n    enableMultiSort: false, // always sort by just this column if sorting by this column\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  enableMultiSort: false, // disable multi-sorting for the entire table\n})\nCustomize Multi-Sorting Trigger\nBy default, the\nShift\nkey is used to trigger multi-sorting. You can change this behavior with the\nisMultiSortEvent\ntable option. You can even specify that all sorting events should trigger multi-sorting by returning\ntrue\nfrom the custom function.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  isMultiSortEvent: (e) => true, // normal click triggers multi-sorting\n  //or\n  isMultiSortEvent: (e) => e.ctrlKey || e.shiftKey, // also use the `Ctrl` key to trigger multi-sorting\n})\nMulti-Sorting Limit\nBy default, there is no limit to the number of columns that can be sorted at once. You can set a limit using the\nmaxMultiSortColCount\ntable option.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  maxMultiSortColCount: 3, // only allow 3 columns to be sorted at once\n})\nMulti-Sorting Removal\nBy default, the ability to remove multi-sorts is enabled. You can disable this behavior using the\nenableMultiRemove\ntable option.\njsx\nconst table = useReactTable({\n  columns,\n  data,\n  enableMultiRemove: false, // disable the ability to remove multi-sorts\n})\nSorting APIs\nThere are a lot of sorting related APIs that you can use to hook up to your UI or other logic. Here is a list of all of the sorting APIs and some of their use-cases.\ntable.setSorting\n- Set the sorting state directly.\ntable.resetSorting\n- Reset the sorting state to the initial state or clear it.\ncolumn.getCanSort\n- Useful for enabling/disabling the sorting UI for a column.\ncolumn.getIsSorted\n- Useful for showing a visual sorting indicator for a column.\ncolumn.getToggleSortingHandler\n- Useful for hooking up the sorting UI for a column. Add to a sort arrow (icon button), menu item, or simply the entire column header cell. This handler will call\ncolumn.toggleSorting\nwith the correct parameters.\ncolumn.toggleSorting\n- Useful for hooking up the sorting UI for a column. If using instead of\ncolumn.getToggleSortingHandler\n, you have to manually pass in whether or not to use multi-sorting. (\ncolumn.toggleSorting(desc, multi)\n)\ncolumn.clearSorting\n- Useful for a \"clear sorting\" button or menu item for a specific column.\ncolumn.getNextSortingOrder\n- Useful for showing which direction the column will sort by next. (asc/desc/clear in a tooltip/menu item/aria-label or something)\ncolumn.getFirstSortDir\n- Useful for showing which direction the column will sort by first. (asc/desc in a tooltip/menu item/aria-label or something)\ncolumn.getAutoSortDir\n- Determines whether the first sorting direction will be ascending or descending for a column.\ncolumn.getAutoSortingFn\n- Used internally to find the default sorting function for a column if none is specified.\ncolumn.getSortingFn\n- Returns the exact sorting function being used for a column.\ncolumn.getCanMultiSort\n- Useful for enabling/disabling the multi-sorting UI for a column.\ncolumn.getSortIndex\n- Useful for showing a badge or indicator of the column's sort order in a multi-sort scenario. i.e. whether or not it is the first, second, third, etc. column to be sorted.",
  "content_markdown": "[## Examples](#examples)\n\nWant to skip to the implementation? Check out these examples:\n\n- [sorting](/table/latest/docs/framework/react/examples/sorting)\n- [filters](/table/latest/docs/framework/react/examples/filters)\n\n[## API](#api)\n\n[Sorting API](/table/latest/docs/api/features/sorting)\n\n[## Sorting Guide](#sorting-guide)\n\nTanStack Table provides solutions for just about any sorting use-case you might have. This guide will walk you through the various options that you can use to customize the built-in client-side sorting functionality, as well as how to opt out of client-side sorting in favor of manual server-side sorting.\n\n[### Sorting State](#sorting-state)\n\nThe sorting state is defined as an array of objects with the following shape:\n\ntsx\n\n```\ntype ColumnSort = {\n  id: string\n  desc: boolean\n}\ntype SortingState = ColumnSort[]\n```\n\nSince the sorting state is an array, it is possible to sort by multiple columns at once. Read more about the multi-sorting customizations down [below](#multi-sorting).\n\n[#### Accessing Sorting State](#accessing-sorting-state)\n\nYou can access the sorting state directly from the table instance just like any other state using the table.getState() API.\n\ntsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n})\n\nconsole.log(table.getState().sorting) // access the sorting state from the table instance\n```\n\nHowever, if you need to access the sorting state before the table is initialized, you can \"control\" the sorting state like down below.\n\n[#### Controlled Sorting State](#controlled-sorting-state)\n\nIf you need easy access to the sorting state, you can control/manage the sorting state in your own state management with the state.sorting and onSortingChange table options.\n\ntsx\n\n```\nconst [sorting, setSorting] = useState<SortingState>([]) // can set initial sorting state here\n//...\n// use sorting state to fetch data from your server or something...\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n  state: {\n    sorting,\n  },\n  onSortingChange: setSorting,\n})\n```\n\n[#### Initial Sorting State](#initial-sorting-state)\n\nIf you do not need to control the sorting state in your own state management or scope, but you still want to set an initial sorting state, you can use the initialState table option instead of state.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  //...\n  initialState: {\n    sorting: [\n      {\n        id: 'name',\n        desc: true, // sort by name in descending order by default\n      },\n    ],\n  },\n})\n```\n\n> **NOTE**: Do not use both initialState.sorting and state.sorting at the same time, as the initialized state in the state.sorting will override the initialState.sorting.\n\n[### Client-Side vs Server-Side Sorting](#client-side-vs-server-side-sorting)\n\nWhether or not you should use client-side or server-side sorting depends entirely on whether you are also using client-side or server-side pagination or filtering. Be consistent, because using client-side sorting with server-side pagination or filtering will only sort the data that is currently loaded, and not the entire dataset.\n\n[### Manual Server-Side Sorting](#manual-server-side-sorting)\n\nIf you plan to just use your own server-side sorting in your back-end logic, you do not need to provide a sorted row model. But if you have provided a sorting row model, but you want to disable it, you can use the manualSorting table option.\n\njsx\n\n```\nconst [sorting, setSorting] = useState<SortingState>([])\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  //getSortedRowModel: getSortedRowModel(), //not needed for manual sorting\n  manualSorting: true, //use pre-sorted row model instead of sorted row model\n  state: {\n    sorting,\n  },\n  onSortingChange: setSorting,\n})\n```\n\n> **NOTE**: When manualSorting is set to true, the table will assume that the data that you provide is already sorted, and will not apply any sorting to it.\n\n[### Client-Side Sorting](#client-side-sorting)\n\nTo implement client-side sorting, first you have to provide a sorting row model to the table. You can import the getSortedRowModel function from TanStack Table, and it will be used to transform your rows into sorted rows.\n\njsx\n\n```\nimport { useReactTable } from '@tanstack/react-table'\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getSortedRowModel: getSortedRowModel(), //provide a sorting row model\n})\n```\n\n[### Sorting Fns](#sorting-fns)\n\nThe default sorting function for all columns is inferred from the data type of the column. However, it can be useful to define the exact sorting function that you want to use for a specific column, especially if any of your data is nullable or not a standard data type.\n\nYou can determine a custom sorting function on a per-column basis using the sortingFn column option.\n\nBy default, there are 6 built-in sorting functions to choose from:\n\n- alphanumeric - Sorts by mixed alphanumeric values without case-sensitivity. Slower, but more accurate if your strings contain numbers that need to be naturally sorted.\n- alphanumericCaseSensitive - Sorts by mixed alphanumeric values with case-sensitivity. Slower, but more accurate if your strings contain numbers that need to be naturally sorted.\n- text - Sorts by text/string values without case-sensitivity. Faster, but less accurate if your strings contain numbers that need to be naturally sorted.\n- textCaseSensitive - Sorts by text/string values with case-sensitivity. Faster, but less accurate if your strings contain numbers that need to be naturally sorted.\n- datetime - Sorts by time, use this if your values are Date objects.\n- basic - Sorts using a basic/standard a > b ? 1 : a < b ? -1 : 0 comparison. This is the fastest sorting function, but may not be the most accurate.\n\nYou can also define your own custom sorting functions either as the sortingFn column option, or as a global sorting function using the sortingFns table option.\n\n[#### Custom Sorting Functions](#custom-sorting-functions)\n\nWhen defining a custom sorting function in either the sortingFns table option or as a sortingFn column option, it should have the following signature:\n\ntsx\n\n```\n//optionally use the SortingFn to infer the parameter types\nconst myCustomSortingFn: SortingFn<TData> = (rowA: Row<TData>, rowB: Row<TData>, columnId: string) => {\n  return //-1, 0, or 1 - access any row data using rowA.original and rowB.original\n}\n```\n\n> Note: The comparison function does not need to take whether or not the column is in descending or ascending order into account. The row models will take of that logic. sortingFn functions only need to provide a consistent comparison.\n\nEvery sorting function receives 2 rows and a column ID and are expected to compare the two rows using the column ID to return -1, 0, or 1 in ascending order. Here's a cheat sheet:\n\n| Return | Ascending Order |\n| --- | --- |\n| -1 | a < b |\n| 0 | a === b |\n| 1 | a > b |\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n    sortingFn: 'alphanumeric', // use built-in sorting function by name\n  },\n  {\n    header: () => 'Age',\n    accessorKey: 'age',\n    sortingFn: 'myCustomSortingFn', // use custom global sorting function\n  },\n  {\n    header: () => 'Birthday',\n    accessorKey: 'birthday',\n    sortingFn: 'datetime', // recommended for date columns\n  },\n  {\n    header: () => 'Profile',\n    accessorKey: 'profile',\n    // use custom sorting function directly\n    sortingFn: (rowA, rowB, columnId) => {\n      return rowA.original.someProperty - rowB.original.someProperty\n    },\n  }\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  getCoreRowModel: getCoreRowModel(),\n  getSortedRowModel: getSortedRowModel(),\n  sortingFns: { //add a custom sorting function\n    myCustomSortingFn: (rowA, rowB, columnId) => {\n      return rowA.original[columnId] > rowB.original[columnId] ? 1 : rowA.original[columnId] < rowB.original[columnId] ? -1 : 0\n    },\n  },\n})\n```\n\n[### Customize Sorting](#customize-sorting)\n\nThere are a lot of table and column options that you can use to further customize the sorting UX and behavior.\n\n[#### Disable Sorting](#disable-sorting)\n\nYou can disable sorting for either a specific column or the entire table using the enableSorting column option or table option.\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'ID',\n    accessorKey: 'id',\n    enableSorting: false, // disable sorting for this column\n  },\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  enableSorting: false, // disable sorting for the entire table\n})\n```\n\n[#### Sorting Direction](#sorting-direction)\n\nBy default, the first sorting direction when cycling through the sorting for a column using the toggleSorting APIs is ascending for string columns and descending for number columns. You can change this behavior with the sortDescFirst column option or table option.\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'Name',\n    accessorKey: 'name',\n    sortDescFirst: true, //sort by name in descending order first (default is ascending for string columns)\n  },\n  {\n    header: () => 'Age',\n    accessorKey: 'age',\n    sortDescFirst: false, //sort by age in ascending order first (default is descending for number columns)\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  sortDescFirst: true, //sort by all columns in descending order first (default is ascending for string columns and descending for number columns)\n})\n```\n\n> **NOTE**: You may want to explicitly set the sortDescFirst column option on any columns that have nullable values. The table may not be able to properly determine if a column is a number or a string if it contains nullable values.\n\n[#### Invert Sorting](#invert-sorting)\n\nInverting sorting is not the same as changing the default sorting direction. If invertSorting column option is true for a column, then the \"desc/asc\" sorting states will still cycle like normal, but the actual sorting of the rows will be inverted. This is useful for values that have an inverted best/worst scale where lower numbers are better, eg. a ranking (1st, 2nd, 3rd) or golf-like scoring.\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'Rank',\n    accessorKey: 'rank',\n    invertSorting: true, // invert the sorting for this column. 1st -> 2nd -> 3rd -> ... even if \"desc\" sorting is applied\n  },\n  //...\n]\n```\n\n[#### Sort Undefined Values](#sort-undefined-values)\n\nAny undefined values will be sorted to the beginning or end of the list based on the sortUndefined column option or table option. You can customize this behavior for your specific use-case.\n\nIn not specified, the default value for sortUndefined is 1, and undefined values will be sorted with lower priority (descending), if ascending, undefined will appear on the end of the list.\n\n- 'first' - Undefined values will be pushed to the beginning of the list\n- 'last' - Undefined values will be pushed to the end of the list\n- false - Undefined values will be considered tied and need to be sorted by the next column filter or original index (whichever applies)\n- -1 - Undefined values will be sorted with higher priority (ascending) (if ascending, undefined will appear on the beginning of the list)\n- 1 - Undefined values will be sorted with lower priority (descending) (if ascending, undefined will appear on the end of the list)\n\n> NOTE: 'first' and 'last' options are new in v8.16.0\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'Rank',\n    accessorKey: 'rank',\n    sortUndefined: -1, // 'first' | 'last' | 1 | -1 | false\n  },\n]\n```\n\n[#### Sorting Removal](#sorting-removal)\n\nBy default, the ability to remove sorting while cycling through the sorting states for a column is enabled. You can disable this behavior using the enableSortingRemoval table option. This behavior is useful if you want to ensure that at least one column is always sorted.\n\nThe default behavior when using either the getToggleSortingHandler or toggleSorting APIs is to cycle through the sorting states like this:\n\n'none' -> 'desc' -> 'asc' -> 'none' -> 'desc' -> 'asc' -> ...\n\nIf you disable sorting removal, the behavior will be like this:\n\n'none' -> 'desc' -> 'asc' -> 'desc' -> 'asc' -> ...\n\nOnce a column is sorted and enableSortingRemoval is false, toggling the sorting on that column will never remove the sorting. However, if the user sorts by another column and it is not a multi-sort event, then the sorting will be removed from the previous column and just applied to the new column.\n\n> Set enableSortingRemoval to false if you want to ensure that at least one column is always sorted.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  enableSortingRemoval: false, // disable the ability to remove sorting on columns (always none -> asc -> desc -> asc)\n})\n```\n\n[#### Multi-Sorting](#multi-sorting)\n\nSorting by multiple columns at once is enabled by default if using the column.getToggleSortingHandler API. If the user holds the Shift key while clicking on a column header, the table will sort by that column in addition to the columns that are already sorted. If you use the column.toggleSorting API, you have to manually pass in whether or not to use multi-sorting. (column.toggleSorting(desc, multi)).\n\n[##### Disable Multi-Sorting](#disable-multi-sorting)\n\nYou can disable multi-sorting for either a specific column or the entire table using the enableMultiSort column option or table option. Disabling multi-sorting for a specific column will replace all existing sorting with the new column's sorting.\n\njsx\n\n```\nconst columns = [\n  {\n    header: () => 'Created At',\n    accessorKey: 'createdAt',\n    enableMultiSort: false, // always sort by just this column if sorting by this column\n  },\n  //...\n]\n//...\nconst table = useReactTable({\n  columns,\n  data,\n  enableMultiSort: false, // disable multi-sorting for the entire table\n})\n```\n\n[##### Customize Multi-Sorting Trigger](#customize-multi-sorting-trigger)\n\nBy default, the Shift key is used to trigger multi-sorting. You can change this behavior with the isMultiSortEvent table option. You can even specify that all sorting events should trigger multi-sorting by returning true from the custom function.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  isMultiSortEvent: (e) => true, // normal click triggers multi-sorting\n  //or\n  isMultiSortEvent: (e) => e.ctrlKey || e.shiftKey, // also use the `Ctrl` key to trigger multi-sorting\n})\n```\n\n[##### Multi-Sorting Limit](#multi-sorting-limit)\n\nBy default, there is no limit to the number of columns that can be sorted at once. You can set a limit using the maxMultiSortColCount table option.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  maxMultiSortColCount: 3, // only allow 3 columns to be sorted at once\n})\n```\n\n[##### Multi-Sorting Removal](#multi-sorting-removal)\n\nBy default, the ability to remove multi-sorts is enabled. You can disable this behavior using the enableMultiRemove table option.\n\njsx\n\n```\nconst table = useReactTable({\n  columns,\n  data,\n  enableMultiRemove: false, // disable the ability to remove multi-sorts\n})\n```\n\n[### Sorting APIs](#sorting-apis)\n\nThere are a lot of sorting related APIs that you can use to hook up to your UI or other logic. Here is a list of all of the sorting APIs and some of their use-cases.\n\n- table.setSorting - Set the sorting state directly.\n- table.resetSorting - Reset the sorting state to the initial state or clear it.\n- column.getCanSort - Useful for enabling/disabling the sorting UI for a column.\n- column.getIsSorted - Useful for showing a visual sorting indicator for a column.\n- column.getToggleSortingHandler - Useful for hooking up the sorting UI for a column. Add to a sort arrow (icon button), menu item, or simply the entire column header cell. This handler will call column.toggleSorting with the correct parameters.\n- column.toggleSorting - Useful for hooking up the sorting UI for a column. If using instead of column.getToggleSortingHandler, you have to manually pass in whether or not to use multi-sorting. (column.toggleSorting(desc, multi))\n- column.clearSorting - Useful for a \"clear sorting\" button or menu item for a specific column.\n- column.getNextSortingOrder - Useful for showing which direction the column will sort by next. (asc/desc/clear in a tooltip/menu item/aria-label or something)\n- column.getFirstSortDir - Useful for showing which direction the column will sort by first. (asc/desc in a tooltip/menu item/aria-label or something)\n- column.getAutoSortDir - Determines whether the first sorting direction will be ascending or descending for a column.\n- column.getAutoSortingFn - Used internally to find the default sorting function for a column if none is specified.\n- column.getSortingFn - Returns the exact sorting function being used for a column.\n- column.getCanMultiSort - Useful for enabling/disabling the multi-sorting UI for a column.\n- column.getSortIndex - Useful for showing a badge or indicator of the column's sort order in a multi-sort scenario. i.e. whether or not it is the first, second, third, etc. column to be sorted.",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:19.462582+00:00",
  "content_length": 15998,
  "content_hash": "4728605e6af33e34"
}