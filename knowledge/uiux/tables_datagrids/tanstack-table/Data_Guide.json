{
  "id": "tanstack-table__table_latest_docs_guide_data",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/data",
  "title": "Data Guide",
  "content": "Data Guide\nTables start with your data. Your column definitions and rows will depend on the shape of your data. TanStack Table has some TypeScript features that will help you create the rest of your table code with a great type-safe experience. If you set up your data and types correctly, TanStack Table will be able to infer the shape of your data and enforce that your column definitions are made correctly.\nTypeScript\nTypeScript is NOT required to use the TanStack Table packages...\nBUT\nTanStack Table is written and organized in such a way that makes the awesome TypeScript experience that you get feel like it is one of the main selling points of the library. If you are not using TypeScript, you will be missing out on a lot of great autocompletion and type-checking features that will both speed up your development time and reduce the number of bugs in your code.\nTypeScript Generics\nHaving a basic understanding of what TypeScript Generics are and how they work will help you understand this guide better, but it should be easy enough to pick up as you go. The official\nTypeScript Generics Docs\nmay be helpful for those not yet familiar with TypeScript.\nDefining Data Types\ndata\nis an array of objects that will be turned into the rows of your table. Each object in the array represents a row of data (under normal circumstances). If you are using TypeScript, we usually define a type for the shape of our data. This type is used as a generic type for all of the other table, column, row, and cell instances. This Generic is usually referred to as\nTData\nthroughout the rest of the TanStack Table types and APIs.\nFor example, if we have a table that displays a list of users in an array like this:\njson\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"age\": 33,\n    \"visits\": 100,\n    \"progress\": 50,\n    \"status\": \"Married\"\n  },\n  {\n    \"firstName\": \"Kevin\",\n    \"lastName\": \"Vandy\",\n    \"age\": 27,\n    \"visits\": 200,\n    \"progress\": 100,\n    \"status\": \"Single\"\n  }\n]\nThen we can define a User (TData) type like this:\nts\n//TData\ntype User = {\n  firstName: string\n  lastName: string\n  age: number\n  visits: number\n  progress: number\n  status: string\n}\nWe can then define our\ndata\narray with this type, and then TanStack Table will be able to intelligently infer lots of types for us later on in our columns, rows, cells, etc. This is because the\ndata\ntype is literally defined as the\nTData\ngeneric type. Whatever you pass to the\ndata\ntable option will become the\nTData\ntype for the rest of the table instance. Just make sure your column definitions use the same\nTData\ntype as the\ndata\ntype when you define them later.\nts\n//note: data needs a \"stable\" reference in order to prevent infinite re-renders\nconst data: User[] = []\n//or\nconst [data, setData] = React.useState<User[]>([])\n//or\nconst data = ref<User[]>([]) //vue\n//etc...\nDeep Keyed Data\nIf your data is not a nice flat array of objects, that's okay! Once you get around to defining your columns, there are strategies for accessing deeply nested data in your accessors.\nIf your\ndata\nlooks something like this:\njson\n[\n  {\n    \"name\": {\n      \"first\": \"Tanner\",\n      \"last\": \"Linsley\"\n    },\n    \"info\": {\n      \"age\": 33,\n      \"visits\": 100,\n    }\n  },\n  {\n    \"name\": {\n      \"first\": \"Kevin\",\n      \"last\": \"Vandy\"\n    },\n    \"info\": {\n      \"age\": 27,\n      \"visits\": 200,\n    }\n  }\n]\nYou can define a type like this:\nts\ntype User = {\n  name: {\n    first: string\n    last: string\n  }\n  info: {\n    age: number\n    visits: number\n  }\n}\nAnd you will be able to access the data in your column definitions with either dot notation in an accessorKey or simply by using an accessorFn.\nts\nconst columns = [\n  {\n    header: 'First Name',\n    accessorKey: 'name.first',\n  },\n  {\n    header: 'Last Name',\n    accessorKey: 'name.last',\n  },\n  {\n    header: 'Age',\n    accessorFn: row => row.info.age, \n  },\n  //...\n]\nThis is discussed in more detail in the\nColumn Def Guide\n.\nNOTE: The \"keys\" in your json data can usually be anything, but any periods in the keys will be interpreted as a deep key and will cause errors.\nNested Sub-Row Data\nIf you are using expanding features, it can be common to have nested sub-rows in your data. This results in a recursive type that is a bit different.\nSo if your data looks like this:\njson\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"subRows\": [\n      {\n        \"firstName\": \"Kevin\",\n        \"lastName\": \"Vandy\",\n      },\n      {\n        \"firstName\": \"John\",\n        \"lastName\": \"Doe\",\n        \"subRows\": [\n          //...\n        ]\n      }\n    ]\n  },\n  {\n    \"firstName\": \"Jane\",\n    \"lastName\": \"Doe\",\n  }\n]\nYou can define a type like this:\nts\ntype User = {\n  firstName: string\n  lastName: string\n  subRows?: User[] //does not have to be called \"subRows\", can be called anything\n}\nWhere\nsubRows\nis an optional array of\nUser\nobjects. This is discussed in more detail in the\nExpanding Guide\n.\nGive Data a \"Stable\" Reference\nThe\ndata\narray that you pass to the table instance\nMUST\nhave a \"stable\" reference in order to prevent bugs that cause infinite re-renders (especially in React).\nThis will depend on which framework adapter you are using, but in React, you should often use\nReact.useState\n,\nReact.useMemo\n, or similar to ensure that both the\ndata\nand\ncolumns\ntable options have stable references.\ntsx\nconst fallbackData = []\n\nexport default function MyComponent() {\n  //\u2705 GOOD: This will not cause an infinite loop of re-renders because `columns` is a stable reference\n  const columns = useMemo(() => [\n    // ...\n  ], []);\n\n  //\u2705 GOOD: This will not cause an infinite loop of re-renders because `data` is a stable reference\n  const [data, setData] = useState(() => [\n    // ...\n  ]);\n\n  // Columns and data are defined in a stable reference, will not cause infinite loop!\n  const table = useReactTable({\n    columns,\n    data ?? fallbackData, //also good to use a fallback array that is defined outside of the component (stable reference)\n  });\n\n  return <table>...</table>;\n}\nReact.useState\nand\nReact.useMemo\nare not the only ways to give your data a stable reference. You can also define your data outside of the component or use a 3rd party state management library like Redux, Zustand, or TanStack Query.\nThe main thing to avoid is defining the\ndata\narray inside the same scope as the\nuseReactTable\ncall. That will cause the\ndata\narray to be redefined on every render, which will cause an infinite loop of re-renders.\ntsx\nexport default function MyComponent() {\n  //\ud83d\ude35 BAD: This will cause an infinite loop of re-renders because `columns` is redefined as a new array on every render!\n  const columns = [\n    // ...\n  ];\n\n  //\ud83d\ude35 BAD: This will cause an infinite loop of re-renders because `data` is redefined as a new array on every render!\n  const data = [\n    // ...\n  ];\n\n  //\u274c Columns and data are defined in the same scope as `useReactTable` without a stable reference, will cause infinite loop!\n  const table = useReactTable({\n    columns,\n    data ?? [], //\u274c Also bad because the fallback array is re-created on every render\n  });\n\n  return <table>...</table>;\n}\nHow TanStack Table Transforms Data\nLater, in other parts of these docs, you will see how TanStack Table processes the\ndata\nthat you pass to the table and generates the row and cell objects that are used to create the table. The\ndata\nthat you pass to the table is never mutated by TanStack Table, but the actual values in the rows and cells may be transformed by the accessors in your column definitions, or by other features performed by\nrow models\nlike grouping or aggregation.\nHow Much Data Can TanStack Table Handle?\nBelieve it or not, TanStack Table was actually built to scale up to handle potentially hundreds of thousands of rows of data in the client. This is obviously not always possible, depending on the size of each column's data and the number of columns. However, the sorting, filtering, pagination, and grouping features are all built with performance in mind for large datasets.\nThe default mindset of a developer building a data grid is to implement server-side pagination, sorting, and filtering for large datasets. This is still usually a good idea, but a lot of developers underestimate how much data can actually be handled in the client with modern browsers and the right optimizations. If your table will never have more than a few thousand rows, you can probably take advantage of the client-side features in TanStack Table instead of implementing them yourself on the server. Before committing to letting TanStack Table's client-side features handle your large dataset, you should test it with your actual data to see if it performs well enough for your needs, of course.\nThis is discussed in more detail in the\nPagination Guide\n.",
  "content_markdown": "[## Data Guide](#data-guide)\n\nTables start with your data. Your column definitions and rows will depend on the shape of your data. TanStack Table has some TypeScript features that will help you create the rest of your table code with a great type-safe experience. If you set up your data and types correctly, TanStack Table will be able to infer the shape of your data and enforce that your column definitions are made correctly.\n\n[### TypeScript](#typescript)\n\nTypeScript is NOT required to use the TanStack Table packages... ***BUT*** TanStack Table is written and organized in such a way that makes the awesome TypeScript experience that you get feel like it is one of the main selling points of the library. If you are not using TypeScript, you will be missing out on a lot of great autocompletion and type-checking features that will both speed up your development time and reduce the number of bugs in your code.\n\n[#### TypeScript Generics](#typescript-generics)\n\nHaving a basic understanding of what TypeScript Generics are and how they work will help you understand this guide better, but it should be easy enough to pick up as you go. The official [TypeScript Generics Docs](https://www.typescriptlang.org/docs/handbook/2/generics.html) may be helpful for those not yet familiar with TypeScript.\n\n[### Defining Data Types](#defining-data-types)\n\ndata is an array of objects that will be turned into the rows of your table. Each object in the array represents a row of data (under normal circumstances). If you are using TypeScript, we usually define a type for the shape of our data. This type is used as a generic type for all of the other table, column, row, and cell instances. This Generic is usually referred to as TData throughout the rest of the TanStack Table types and APIs.\n\nFor example, if we have a table that displays a list of users in an array like this:\n\njson\n\n```\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"age\": 33,\n    \"visits\": 100,\n    \"progress\": 50,\n    \"status\": \"Married\"\n  },\n  {\n    \"firstName\": \"Kevin\",\n    \"lastName\": \"Vandy\",\n    \"age\": 27,\n    \"visits\": 200,\n    \"progress\": 100,\n    \"status\": \"Single\"\n  }\n]\n```\n\nThen we can define a User (TData) type like this:\n\nts\n\n```\n//TData\ntype User = {\n  firstName: string\n  lastName: string\n  age: number\n  visits: number\n  progress: number\n  status: string\n}\n```\n\nWe can then define our data array with this type, and then TanStack Table will be able to intelligently infer lots of types for us later on in our columns, rows, cells, etc. This is because the data type is literally defined as the TData generic type. Whatever you pass to the data table option will become the TData type for the rest of the table instance. Just make sure your column definitions use the same TData type as the data type when you define them later.\n\nts\n\n```\n//note: data needs a \"stable\" reference in order to prevent infinite re-renders\nconst data: User[] = []\n//or\nconst [data, setData] = React.useState<User[]>([])\n//or\nconst data = ref<User[]>([]) //vue\n//etc...\n```\n\n[#### Deep Keyed Data](#deep-keyed-data)\n\nIf your data is not a nice flat array of objects, that's okay! Once you get around to defining your columns, there are strategies for accessing deeply nested data in your accessors.\n\nIf your data looks something like this:\n\njson\n\n```\n[\n  {\n    \"name\": {\n      \"first\": \"Tanner\",\n      \"last\": \"Linsley\"\n    },\n    \"info\": {\n      \"age\": 33,\n      \"visits\": 100,\n    }\n  },\n  {\n    \"name\": {\n      \"first\": \"Kevin\",\n      \"last\": \"Vandy\"\n    },\n    \"info\": {\n      \"age\": 27,\n      \"visits\": 200,\n    }\n  }\n]\n```\n\nYou can define a type like this:\n\nts\n\n```\ntype User = {\n  name: {\n    first: string\n    last: string\n  }\n  info: {\n    age: number\n    visits: number\n  }\n}\n```\n\nAnd you will be able to access the data in your column definitions with either dot notation in an accessorKey or simply by using an accessorFn.\n\nts\n\n```\nconst columns = [\n  {\n    header: 'First Name',\n    accessorKey: 'name.first',\n  },\n  {\n    header: 'Last Name',\n    accessorKey: 'name.last',\n  },\n  {\n    header: 'Age',\n    accessorFn: row => row.info.age, \n  },\n  //...\n]\n```\n\nThis is discussed in more detail in the [Column Def Guide](/table/latest/docs/guide/column-defs).\n\n> NOTE: The \"keys\" in your json data can usually be anything, but any periods in the keys will be interpreted as a deep key and will cause errors.\n\n[#### Nested Sub-Row Data](#nested-sub-row-data)\n\nIf you are using expanding features, it can be common to have nested sub-rows in your data. This results in a recursive type that is a bit different.\n\nSo if your data looks like this:\n\njson\n\n```\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"subRows\": [\n      {\n        \"firstName\": \"Kevin\",\n        \"lastName\": \"Vandy\",\n      },\n      {\n        \"firstName\": \"John\",\n        \"lastName\": \"Doe\",\n        \"subRows\": [\n          //...\n        ]\n      }\n    ]\n  },\n  {\n    \"firstName\": \"Jane\",\n    \"lastName\": \"Doe\",\n  }\n]\n```\n\nYou can define a type like this:\n\nts\n\n```\ntype User = {\n  firstName: string\n  lastName: string\n  subRows?: User[] //does not have to be called \"subRows\", can be called anything\n}\n```\n\nWhere subRows is an optional array of User objects. This is discussed in more detail in the [Expanding Guide](/table/latest/docs/guide/expanding).\n\n[### Give Data a \"Stable\" Reference](#give-data-a-stable-reference)\n\nThe data array that you pass to the table instance ***MUST*** have a \"stable\" reference in order to prevent bugs that cause infinite re-renders (especially in React).\n\nThis will depend on which framework adapter you are using, but in React, you should often use React.useState, React.useMemo, or similar to ensure that both the data and columns table options have stable references.\n\ntsx\n\n```\nconst fallbackData = []\n\nexport default function MyComponent() {\n  //\u2705 GOOD: This will not cause an infinite loop of re-renders because `columns` is a stable reference\n  const columns = useMemo(() => [\n    // ...\n  ], []);\n\n  //\u2705 GOOD: This will not cause an infinite loop of re-renders because `data` is a stable reference\n  const [data, setData] = useState(() => [\n    // ...\n  ]);\n\n  // Columns and data are defined in a stable reference, will not cause infinite loop!\n  const table = useReactTable({\n    columns,\n    data ?? fallbackData, //also good to use a fallback array that is defined outside of the component (stable reference)\n  });\n\n  return <table>...</table>;\n}\n```\n\nReact.useState and React.useMemo are not the only ways to give your data a stable reference. You can also define your data outside of the component or use a 3rd party state management library like Redux, Zustand, or TanStack Query.\n\nThe main thing to avoid is defining the data array inside the same scope as the useReactTable call. That will cause the data array to be redefined on every render, which will cause an infinite loop of re-renders.\n\ntsx\n\n```\nexport default function MyComponent() {\n  //\ud83d\ude35 BAD: This will cause an infinite loop of re-renders because `columns` is redefined as a new array on every render!\n  const columns = [\n    // ...\n  ];\n\n  //\ud83d\ude35 BAD: This will cause an infinite loop of re-renders because `data` is redefined as a new array on every render!\n  const data = [\n    // ...\n  ];\n\n  //\u274c Columns and data are defined in the same scope as `useReactTable` without a stable reference, will cause infinite loop!\n  const table = useReactTable({\n    columns,\n    data ?? [], //\u274c Also bad because the fallback array is re-created on every render\n  });\n\n  return <table>...</table>;\n}\n```\n\n[### How TanStack Table Transforms Data](#how-tanstack-table-transforms-data)\n\nLater, in other parts of these docs, you will see how TanStack Table processes the data that you pass to the table and generates the row and cell objects that are used to create the table. The data that you pass to the table is never mutated by TanStack Table, but the actual values in the rows and cells may be transformed by the accessors in your column definitions, or by other features performed by [row models](/table/latest/docs/guide/row-models) like grouping or aggregation.\n\n[### How Much Data Can TanStack Table Handle?](#how-much-data-can-tanstack-table-handle)\n\nBelieve it or not, TanStack Table was actually built to scale up to handle potentially hundreds of thousands of rows of data in the client. This is obviously not always possible, depending on the size of each column's data and the number of columns. However, the sorting, filtering, pagination, and grouping features are all built with performance in mind for large datasets.\n\nThe default mindset of a developer building a data grid is to implement server-side pagination, sorting, and filtering for large datasets. This is still usually a good idea, but a lot of developers underestimate how much data can actually be handled in the client with modern browsers and the right optimizations. If your table will never have more than a few thousand rows, you can probably take advantage of the client-side features in TanStack Table instead of implementing them yourself on the server. Before committing to letting TanStack Table's client-side features handle your large dataset, you should test it with your actual data to see if it performs well enough for your needs, of course.\n\nThis is discussed in more detail in the [Pagination Guide](/table/latest/docs/guide/pagination#should-you-use-client-side-pagination).",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:09.521093+00:00",
  "content_length": 8769,
  "content_hash": "b7428a7557eba7cd"
}