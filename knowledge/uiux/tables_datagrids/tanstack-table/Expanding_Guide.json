{
  "id": "tanstack-table__table_latest_docs_guide_expanding",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/expanding",
  "title": "Expanding Guide",
  "content": "Examples\nWant to skip to the implementation? Check out these examples:\nexpanding\ngrouping\nsub-components\nAPI\nExpanding API\nExpanding Feature Guide\nExpanding is a feature that allows you to show and hide additional rows of data related to a specific row. This can be useful in cases where you have hierarchical data and you want to allow users to drill down into the data from a higher level. Or it can be useful for showing additional information related to a row.\nDifferent use cases for Expanding Features\nThere are multiple use cases for expanding features in TanStack Table that will be discussed below.\nExpanding sub-rows (child rows, aggregate rows, etc.)\nExpanding custom UI (detail panels, sub-tables, etc.)\nEnable Client-Side Expanding\nTo use the client-side expanding features, you need to define the getExpandedRowModel function in your table options. This function is responsible for returning the expanded row model.\nts\nconst table = useReactTable({\n  // other options...\n  getExpandedRowModel: getExpandedRowModel(),\n})\nExpanded data can either contain table rows or any other data you want to display. We will discuss how to handle both cases in this guide.\nTable rows as expanded data\nExpanded rows are essentially child rows that inherit the same column structure as their parent rows. If your data object already includes these expanded rows data, you can utilize the\ngetSubRows\nfunction to specify these child rows. However, if your data object does not contain the expanded rows data, they can be treated as custom expanded data, which is discussed in next section.\nFor example, if you have a data object like this:\nts\ntype Person = {\n  id: number\n  name: string\n  age: number\n  children?: Person[] | undefined\n}\n\nconst data: Person[] =  [\n  { id: 1, \n  name: 'John', \n  age: 30, \n  children: [\n      { id: 2, name: 'Jane', age: 5 },\n      { id: 5, name: 'Jim', age: 10 }\n    ] \n  },\n  { id: 3,\n   name: 'Doe', \n   age: 40, \n    children: [\n      { id: 4, name: 'Alice', age: 10 }\n    ] \n  },\n]\nThen you can use the getSubRows function to return the children array in each row as expanded rows. The table instance will now understand where to look for the sub rows on each row.\nts\nconst table = useReactTable({\n  // other options...\n  getSubRows: (row) => row.children, // return the children array as sub-rows\n  getCoreRowModel: getCoreRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\nNote:\nYou can have a complicated\ngetSubRows\nfunction, but keep in mind that it will run for every row and every sub-row. This can be expensive if the function is not optimized. Async functions are not supported.\nCustom Expanding UI\nIn some cases, you may wish to show extra details or information, which may or may not be part of your table data object, such as expanded data for rows. This kind of expanding row UI has gone by many names over the years including \"expandable rows\", \"detail panels\", \"sub-components\", etc.\nBy default, the\nrow.getCanExpand()\nrow instance API will return false unless it finds\nsubRows\non a row. This can be overridden by implementing your own\ngetRowCanExpand\nfunction in the table instance options.\nts\n//...\nconst table = useReactTable({\n  // other options...\n  getRowCanExpand: (row) => true, // Add your logic to determine if a row can be expanded. True means all rows include expanded data\n  getCoreRowModel: getCoreRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\n//...\n<tbody>\n  {table.getRowModel().rows.map((row) => (\n    <React.Fragment key={row.id}>\n     {/* Normal row UI */}\n      <tr>\n        {row.getVisibleCells().map((cell) => (\n          <td key={cell.id}>\n            <FlexRender\n              render={cell.column.columnDef.cell}\n              props={cell.getContext()}\n            />\n          </td>\n        ))}\n      </tr>\n      {/* If the row is expanded, render the expanded UI as a separate row with a single cell that spans the width of the table */}\n      {row.getIsExpanded() && (\n        <tr>\n          <td colSpan={row.getAllCells().length}> // The number of columns you wish to span for the expanded data if it is not a row that shares the same columns as the parent row\n            // Your custom UI goes here\n          </td>\n        </tr>\n      )}\n    </React.Fragment>\n  ))}\n</tbody>\n//...\nExpanded rows state\nIf you need to control the expanded state of the rows in your table, you can do so by using the expanded state and the\nonExpandedChange\noption. This allows you to manage the expanded state according to your requirements.\nts\nconst [expanded, setExpanded] = useState<ExpandedState>({})\n\nconst table = useReactTable({\n  // other options...\n  state: {\n    expanded: expanded, // must pass expanded state back to the table\n  },\n  onExpandedChange: setExpanded\n})\nThe ExpandedState type is defined as follows:\nts\ntype ExpandedState = true | Record<string, boolean>\nIf the ExpandedState is true, it means all rows are expanded. If it's a record, only the rows with IDs present as keys in the record and have their value set to true are expanded.  For example, if the expanded state is { row1: true, row2: false }, it means the row with ID row1 is expanded and the row with ID row2 is not expanded. This state is used by the table to determine which rows are expanded and should display their subRows, if any.\nUI toggling handler for expanded rows\nTanStack table will not add a toggling handler UI for expanded data to your table. You should manually add it within each row's UI to allow users to expand and collapse the row. For example, you can add a button UI within the columns definition.\nts\nconst columns = [\n  {\n    accessorKey: 'name',\n    header: 'Name',\n  },\n  {\n    accessorKey: 'age',\n    header: 'Age',\n  },\n  {\n    header: 'Children',\n    cell: ({ row }) => {\n      return row.getCanExpand() ?\n        <button\n          onClick={row.getToggleExpandedHandler()}\n          style={{ cursor: 'pointer' }}\n        >\n        {row.getIsExpanded() ? '\ud83d\udc47' : '\ud83d\udc49'}\n        </button>\n       : '';\n    },\n  },\n]\nFiltering Expanded Rows\nBy default, the filtering process starts from the parent rows and moves downwards. This means if a parent row is excluded by the filter, all its child rows will also be excluded. However, you can change this behavior by using the\nfilterFromLeafRows\noption. When this option is enabled, the filtering process starts from the leaf (child) rows and moves upwards. This ensures that a parent row will be included in the filtered results as long as at least one of its child or grandchild rows meets the filter criteria. Additionally, you can control how deep into the child hierarchy the filter process goes by using the\nmaxLeafRowFilterDepth\noption. This option allows you to specify the maximum depth of child rows that the filter should consider.\nts\n//...\nconst table = useReactTable({\n  // other options...\n  getSubRows: row => row.subRows,\n  getCoreRowModel: getCoreRowModel(),\n  getFilteredRowModel: getFilteredRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n  filterFromLeafRows: true, // search through the expanded rows\n  maxLeafRowFilterDepth: 1, // limit the depth of the expanded rows that are searched\n})\nPaginating Expanded Rows\nBy default, expanded rows are paginated along with the rest of the table (which means expanded rows may span multiple pages). If you want to disable this behavior (which means expanded rows will always render on their parents page. This also means more rows will be rendered than the set page size) you can use the\npaginateExpandedRows\noption.\nts\nconst table = useReactTable({\n  // other options...\n  paginateExpandedRows: false,\n})\nPinning Expanded Rows\nPinning expanded rows works the same way as pinning regular rows. You can pin expanded rows to the top or bottom of the table. Please refer to the\nPinning Guide\nfor more information on row pinning.\nSorting Expanded Rows\nBy default, expanded rows are sorted along with the rest of the table.\nManual Expanding (server-side)\nIf you are doing server-side expansion, you can enable manual row expansion by setting the manualExpanding option to true. This means that the\ngetExpandedRowModel\nwill not be used to expand rows and you would be expected to perform the expansion in your own data model.\nts\nconst table = useReactTable({\n  // other options...\n  manualExpanding: true,\n})",
  "content_markdown": "[## Examples](#examples)\n\nWant to skip to the implementation? Check out these examples:\n\n- [expanding](/table/latest/docs/framework/react/examples/expanding)\n- [grouping](/table/latest/docs/framework/react/examples/grouping)\n- [sub-components](/table/latest/docs/framework/react/examples/sub-components)\n\n[## API](#api)\n\n[Expanding API](/table/latest/docs/api/features/expanding)\n\n[## Expanding Feature Guide](#expanding-feature-guide)\n\nExpanding is a feature that allows you to show and hide additional rows of data related to a specific row. This can be useful in cases where you have hierarchical data and you want to allow users to drill down into the data from a higher level. Or it can be useful for showing additional information related to a row.\n\n[### Different use cases for Expanding Features](#different-use-cases-for-expanding-features)\n\nThere are multiple use cases for expanding features in TanStack Table that will be discussed below.\n\n1. Expanding sub-rows (child rows, aggregate rows, etc.)\n2. Expanding custom UI (detail panels, sub-tables, etc.)\n\n[### Enable Client-Side Expanding](#enable-client-side-expanding)\n\nTo use the client-side expanding features, you need to define the getExpandedRowModel function in your table options. This function is responsible for returning the expanded row model.\n\nts\n\n```\nconst table = useReactTable({\n  // other options...\n  getExpandedRowModel: getExpandedRowModel(),\n})\n```\n\nExpanded data can either contain table rows or any other data you want to display. We will discuss how to handle both cases in this guide.\n\n[### Table rows as expanded data](#table-rows-as-expanded-data)\n\nExpanded rows are essentially child rows that inherit the same column structure as their parent rows. If your data object already includes these expanded rows data, you can utilize the getSubRows function to specify these child rows. However, if your data object does not contain the expanded rows data, they can be treated as custom expanded data, which is discussed in next section.\n\nFor example, if you have a data object like this:\n\nts\n\n```\ntype Person = {\n  id: number\n  name: string\n  age: number\n  children?: Person[] | undefined\n}\n\nconst data: Person[] =  [\n  { id: 1, \n  name: 'John', \n  age: 30, \n  children: [\n      { id: 2, name: 'Jane', age: 5 },\n      { id: 5, name: 'Jim', age: 10 }\n    ] \n  },\n  { id: 3,\n   name: 'Doe', \n   age: 40, \n    children: [\n      { id: 4, name: 'Alice', age: 10 }\n    ] \n  },\n]\n```\n\nThen you can use the getSubRows function to return the children array in each row as expanded rows. The table instance will now understand where to look for the sub rows on each row.\n\nts\n\n```\nconst table = useReactTable({\n  // other options...\n  getSubRows: (row) => row.children, // return the children array as sub-rows\n  getCoreRowModel: getCoreRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\n```\n\n> **Note:** You can have a complicated getSubRows function, but keep in mind that it will run for every row and every sub-row. This can be expensive if the function is not optimized. Async functions are not supported.\n\n[### Custom Expanding UI](#custom-expanding-ui)\n\nIn some cases, you may wish to show extra details or information, which may or may not be part of your table data object, such as expanded data for rows. This kind of expanding row UI has gone by many names over the years including \"expandable rows\", \"detail panels\", \"sub-components\", etc.\n\nBy default, the row.getCanExpand() row instance API will return false unless it finds subRows on a row. This can be overridden by implementing your own getRowCanExpand function in the table instance options.\n\nts\n\n```\n//...\nconst table = useReactTable({\n  // other options...\n  getRowCanExpand: (row) => true, // Add your logic to determine if a row can be expanded. True means all rows include expanded data\n  getCoreRowModel: getCoreRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n})\n//...\n<tbody>\n  {table.getRowModel().rows.map((row) => (\n    <React.Fragment key={row.id}>\n     {/* Normal row UI */}\n      <tr>\n        {row.getVisibleCells().map((cell) => (\n          <td key={cell.id}>\n            <FlexRender\n              render={cell.column.columnDef.cell}\n              props={cell.getContext()}\n            />\n          </td>\n        ))}\n      </tr>\n      {/* If the row is expanded, render the expanded UI as a separate row with a single cell that spans the width of the table */}\n      {row.getIsExpanded() && (\n        <tr>\n          <td colSpan={row.getAllCells().length}> // The number of columns you wish to span for the expanded data if it is not a row that shares the same columns as the parent row\n            // Your custom UI goes here\n          </td>\n        </tr>\n      )}\n    </React.Fragment>\n  ))}\n</tbody>\n//...\n```\n\n[### Expanded rows state](#expanded-rows-state)\n\nIf you need to control the expanded state of the rows in your table, you can do so by using the expanded state and the onExpandedChange option. This allows you to manage the expanded state according to your requirements.\n\nts\n\n```\nconst [expanded, setExpanded] = useState<ExpandedState>({})\n\nconst table = useReactTable({\n  // other options...\n  state: {\n    expanded: expanded, // must pass expanded state back to the table\n  },\n  onExpandedChange: setExpanded\n})\n```\n\nThe ExpandedState type is defined as follows:\n\nts\n\n```\ntype ExpandedState = true | Record<string, boolean>\n```\n\nIf the ExpandedState is true, it means all rows are expanded. If it's a record, only the rows with IDs present as keys in the record and have their value set to true are expanded. For example, if the expanded state is { row1: true, row2: false }, it means the row with ID row1 is expanded and the row with ID row2 is not expanded. This state is used by the table to determine which rows are expanded and should display their subRows, if any.\n\n[### UI toggling handler for expanded rows](#ui-toggling-handler-for-expanded-rows)\n\nTanStack table will not add a toggling handler UI for expanded data to your table. You should manually add it within each row's UI to allow users to expand and collapse the row. For example, you can add a button UI within the columns definition.\n\nts\n\n```\nconst columns = [\n  {\n    accessorKey: 'name',\n    header: 'Name',\n  },\n  {\n    accessorKey: 'age',\n    header: 'Age',\n  },\n  {\n    header: 'Children',\n    cell: ({ row }) => {\n      return row.getCanExpand() ?\n        <button\n          onClick={row.getToggleExpandedHandler()}\n          style={{ cursor: 'pointer' }}\n        >\n        {row.getIsExpanded() ? '\ud83d\udc47' : '\ud83d\udc49'}\n        </button>\n       : '';\n    },\n  },\n]\n```\n\n[### Filtering Expanded Rows](#filtering-expanded-rows)\n\nBy default, the filtering process starts from the parent rows and moves downwards. This means if a parent row is excluded by the filter, all its child rows will also be excluded. However, you can change this behavior by using the filterFromLeafRows option. When this option is enabled, the filtering process starts from the leaf (child) rows and moves upwards. This ensures that a parent row will be included in the filtered results as long as at least one of its child or grandchild rows meets the filter criteria. Additionally, you can control how deep into the child hierarchy the filter process goes by using the maxLeafRowFilterDepth option. This option allows you to specify the maximum depth of child rows that the filter should consider.\n\nts\n\n```\n//...\nconst table = useReactTable({\n  // other options...\n  getSubRows: row => row.subRows,\n  getCoreRowModel: getCoreRowModel(),\n  getFilteredRowModel: getFilteredRowModel(),\n  getExpandedRowModel: getExpandedRowModel(),\n  filterFromLeafRows: true, // search through the expanded rows\n  maxLeafRowFilterDepth: 1, // limit the depth of the expanded rows that are searched\n})\n```\n\n[### Paginating Expanded Rows](#paginating-expanded-rows)\n\nBy default, expanded rows are paginated along with the rest of the table (which means expanded rows may span multiple pages). If you want to disable this behavior (which means expanded rows will always render on their parents page. This also means more rows will be rendered than the set page size) you can use the paginateExpandedRows option.\n\nts\n\n```\nconst table = useReactTable({\n  // other options...\n  paginateExpandedRows: false,\n})\n```\n\n[### Pinning Expanded Rows](#pinning-expanded-rows)\n\nPinning expanded rows works the same way as pinning regular rows. You can pin expanded rows to the top or bottom of the table. Please refer to the [Pinning Guide](/table/latest/docs/guide/pinning) for more information on row pinning.\n\n[### Sorting Expanded Rows](#sorting-expanded-rows)\n\nBy default, expanded rows are sorted along with the rest of the table.\n\n[### Manual Expanding (server-side)](#manual-expanding-server-side)\n\nIf you are doing server-side expansion, you can enable manual row expansion by setting the manualExpanding option to true. This means that the getExpandedRowModel will not be used to expand rows and you would be expected to perform the expansion in your own data model.\n\nts\n\n```\nconst table = useReactTable({\n  // other options...\n  manualExpanding: true,\n})\n```",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:28.896209+00:00",
  "content_length": 8309,
  "content_hash": "ffbe42d23a71220d"
}