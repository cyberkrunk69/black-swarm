{
  "id": "tanstack-table__table_latest_docs_guide_tables",
  "source_id": "tanstack-table",
  "source_name": "TanStack Table",
  "category": "tables_datagrids",
  "url": "https://tanstack.com/table/latest/docs/guide/tables",
  "title": "Table Instance Guide",
  "content": "API\nTable API\nTable Instance Guide\nTanStack Table is a headless UI library. When we talk about the\ntable\nor \"table instance\", we're not talking about a literal\n<table>\nelement. Instead, we're referring to the core table object that contains the table state and APIs. The\ntable\ninstance is created by calling your adapter's\ncreateTable\nfunction (e.g.\nuseReactTable\n,\ncreateSolidTable\n,\ncreateSvelteTable\n,\nuseQwikTable\n,\nuseVueTable\n).\nCreating a Table Instance\nTo create a table instance, 2\noptions\nare required:\ncolumns\nand\ndata\n. There are dozens of other table options to configure features and behavior, but these 2 are required.\nDefining Data\ndata\nis an array of objects that will be turned into the rows of your table. Each object in the array represents a row of data (under normal circumstances). If you are using TypeScript, we usually define a type for the shape of our data. This type is used as a generic type for all of the other table, column, row, and cell instances. This type is usually referred to as\nTData\n.\nFor example, if we have a table that displays a list of users in an array like this:\njson\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"age\": 33,\n    \"visits\": 100,\n    \"progress\": 50,\n    \"status\": \"Married\"\n  },\n  {\n    \"firstName\": \"Kevin\",\n    \"lastName\": \"Vandy\",\n    \"age\": 27,\n    \"visits\": 200,\n    \"progress\": 100,\n    \"status\": \"Single\"\n  }\n]\nThen we can define a User (TData) type like this:\nts\n//TData\ntype User = {\n  firstName: string\n  lastName: string\n  age: number\n  visits: number\n  progress: number\n  status: string\n}\nWe can then define our\ndata\narray with this type, and then TanStack Table will be able to intelligently infer lots of types for us later on in our columns, rows, cells, etc.\nts\n//note: data needs a \"stable\" reference in order to prevent infinite re-renders\nconst data: User[] = []\n//or\nconst [data, setData] = React.useState<User[]>([])\n//or\nconst data = ref<User[]>([])\n//etc...\nNote:\ndata\nneeds a \"stable\" reference (especially in React) in order to prevent infinite re-renders. This is why we recommend using\nReact.useState\nor\nReact.useMemo\n, or defining your data outside of the same react component that creates the table instance, or using a library like TanStack Query to manage your data state.\nDefining Columns\nColumn definitions are covered in detail in the next section in the\nColumn Def Guide\n. We'll note here, however, that when you define the type of your columns, you should use the same\nTData\ntype that you used for you data.\nts\nconst columns: ColumnDef<User>[] = [] //Pass User type as the generic TData type\n//or\nconst columnHelper = createColumnHelper<User>() //Pass User type as the generic TData type\nThe column definitions are where we will tell TanStack Table how each column should access and/or transform row data with either an\naccessorKey\nor\naccessorFn\n. See the\nColumn Def Guide\nfor more info.\nCreating the Table Instance\nWith our\ncolumns\nand\ndata\ndefined, we can now create our basic table instance.\nts\n//vanilla js\nconst table = createTable({ columns, data })\n\n//react\nconst table = useReactTable({ columns, data })\n\n//solid\nconst table = createSolidTable({ columns, data })\n\n//svelte\nconst table = createSvelteTable({ columns, data })\n\n//vue\nconst table = useVueTable({ columns, data })\nSo what's in the\ntable\ninstance? Let's take a look at what interactions we can have with the table instance.\nTable State\nThe table instance contains all of the table state, which can be accessed via the\ntable.getState()\nAPI. Each table feature registers various states in the table state. For example, the row selection feature registers\nrowSelection\nstate, the pagination feature registers\npagination\nstate, etc.\nEach feature will also have corresponding state setter APIs and state resetter APIs on the table instance. For example, the row selection feature will have a\nsetRowSelection\nAPI and a\nresetRowSelection\n.\nts\ntable.getState().rowSelection //read the row selection state\ntable.setRowSelection((old) => ({...old})) //set the row selection state\ntable.resetRowSelection() //reset the row selection state\nTable APIs\nThere are dozens of table APIs created by each feature to help you either read or mutate the table state in different ways.\nAPI reference docs for the core table instance and all other feature APIs can be found throughout the API docs.\nFor example, you can find the core table instance API docs here:\nTable API\nTable Row Models\nThere is a special set of table instance APIs for reading rows out of the table instance called row models. TanStack Table has advanced features where the rows that are generated may be very different than the array of\ndata\nthat you originally passed in. To learn more about the different row models that you can pass in as a table option, see the\nRow Models Guide\n.",
  "content_markdown": "[## API](#api)\n\n[Table API](/table/latest/docs/api/core/table)\n\n[## Table Instance Guide](#table-instance-guide)\n\nTanStack Table is a headless UI library. When we talk about the table or \"table instance\", we're not talking about a literal <table> element. Instead, we're referring to the core table object that contains the table state and APIs. The table instance is created by calling your adapter's createTable function (e.g. useReactTable, createSolidTable, createSvelteTable, useQwikTable, useVueTable).\n\n[### Creating a Table Instance](#creating-a-table-instance)\n\nTo create a table instance, 2 options are required: columns and data. There are dozens of other table options to configure features and behavior, but these 2 are required.\n\n[#### Defining Data](#defining-data)\n\ndata is an array of objects that will be turned into the rows of your table. Each object in the array represents a row of data (under normal circumstances). If you are using TypeScript, we usually define a type for the shape of our data. This type is used as a generic type for all of the other table, column, row, and cell instances. This type is usually referred to as TData.\n\nFor example, if we have a table that displays a list of users in an array like this:\n\njson\n\n```\n[\n  {\n    \"firstName\": \"Tanner\",\n    \"lastName\": \"Linsley\",\n    \"age\": 33,\n    \"visits\": 100,\n    \"progress\": 50,\n    \"status\": \"Married\"\n  },\n  {\n    \"firstName\": \"Kevin\",\n    \"lastName\": \"Vandy\",\n    \"age\": 27,\n    \"visits\": 200,\n    \"progress\": 100,\n    \"status\": \"Single\"\n  }\n]\n```\n\nThen we can define a User (TData) type like this:\n\nts\n\n```\n//TData\ntype User = {\n  firstName: string\n  lastName: string\n  age: number\n  visits: number\n  progress: number\n  status: string\n}\n```\n\nWe can then define our data array with this type, and then TanStack Table will be able to intelligently infer lots of types for us later on in our columns, rows, cells, etc.\n\nts\n\n```\n//note: data needs a \"stable\" reference in order to prevent infinite re-renders\nconst data: User[] = []\n//or\nconst [data, setData] = React.useState<User[]>([])\n//or\nconst data = ref<User[]>([])\n//etc...\n```\n\n> Note: data needs a \"stable\" reference (especially in React) in order to prevent infinite re-renders. This is why we recommend using React.useState or React.useMemo, or defining your data outside of the same react component that creates the table instance, or using a library like TanStack Query to manage your data state.\n\n[#### Defining Columns](#defining-columns)\n\nColumn definitions are covered in detail in the next section in the [Column Def Guide](/table/latest/docs/guide/column-defs). We'll note here, however, that when you define the type of your columns, you should use the same TData type that you used for you data.\n\nts\n\n```\nconst columns: ColumnDef<User>[] = [] //Pass User type as the generic TData type\n//or\nconst columnHelper = createColumnHelper<User>() //Pass User type as the generic TData type\n```\n\nThe column definitions are where we will tell TanStack Table how each column should access and/or transform row data with either an accessorKey or accessorFn. See the [Column Def Guide](/table/latest/docs/guide/column-defs) for more info.\n\n[#### Creating the Table Instance](#creating-the-table-instance)\n\nWith our columns and data defined, we can now create our basic table instance.\n\nts\n\n```\n//vanilla js\nconst table = createTable({ columns, data })\n\n//react\nconst table = useReactTable({ columns, data })\n\n//solid\nconst table = createSolidTable({ columns, data })\n\n//svelte\nconst table = createSvelteTable({ columns, data })\n\n//vue\nconst table = useVueTable({ columns, data })\n```\n\nSo what's in the table instance? Let's take a look at what interactions we can have with the table instance.\n\n[### Table State](#table-state)\n\nThe table instance contains all of the table state, which can be accessed via the table.getState() API. Each table feature registers various states in the table state. For example, the row selection feature registers rowSelection state, the pagination feature registers pagination state, etc.\n\nEach feature will also have corresponding state setter APIs and state resetter APIs on the table instance. For example, the row selection feature will have a setRowSelection API and a resetRowSelection.\n\nts\n\n```\ntable.getState().rowSelection //read the row selection state\ntable.setRowSelection((old) => ({...old})) //set the row selection state\ntable.resetRowSelection() //reset the row selection state\n```\n\n[### Table APIs](#table-apis)\n\nThere are dozens of table APIs created by each feature to help you either read or mutate the table state in different ways.\n\nAPI reference docs for the core table instance and all other feature APIs can be found throughout the API docs.\n\nFor example, you can find the core table instance API docs here: [Table API](/table/latest/docs/api/core/table#table-api)\n\n[### Table Row Models](#table-row-models)\n\nThere is a special set of table instance APIs for reading rows out of the table instance called row models. TanStack Table has advanced features where the rows that are generated may be very different than the array of data that you originally passed in. To learn more about the different row models that you can pass in as a table option, see the [Row Models Guide](/table/latest/docs/guide/row-models).",
  "tags": [
    "tanstack",
    "table",
    "headless",
    "react"
  ],
  "extracted_at": "2026-02-03T12:51:05.229367+00:00",
  "content_length": 4819,
  "content_hash": "e12cd7aeadab7950"
}