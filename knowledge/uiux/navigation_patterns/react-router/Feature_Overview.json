{
  "id": "react-router__en_main_start_overview",
  "source_id": "react-router",
  "source_name": "React Router",
  "category": "navigation_patterns",
  "url": "https://reactrouter.com/en/main/start/overview",
  "title": "Feature Overview",
  "content": "6.28.0\nBranches\nlatest (\n7.13.0\n)\ndev\nVersions\n7.13.0\n6.30.3\nv4/5.x\nv3.x\nSearch\nLight\nDark\nSystem\nFeature Overview\nCopy Page\nCopy Page\nCopy Page as Markdown\nClient Side Routing\nNested Routes\nDynamic Segments\nRanked Route Matching\nActive Links\nRelative Links\nData Loading\nRedirects\nPending Navigation UI\nSkeleton UI with\n<Suspense>\nData Mutations\nData Revalidation\nBusy Indicators\nOptimistic UI\nData Fetchers\nRace Condition Handling\nError Handling\nScroll Restoration\nWeb Standard APIs\nSearch Params\nLocation State\nOn this page\nClient Side Routing\nNested Routes\nDynamic Segments\nRanked Route Matching\nActive Links\nRelative Links\nData Loading\nRedirects\nPending Navigation UI\nSkeleton UI with\n<Suspense>\nData Mutations\nData Revalidation\nBusy Indicators\nOptimistic UI\nData Fetchers\nRace Condition Handling\nError Handling\nScroll Restoration\nWeb Standard APIs\nSearch Params\nLocation State\nFeature Overview\nClient Side Routing\nReact Router enables \"client side routing\".\nIn traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.\nClient side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with\nfetch\nto update the page with new information.\nThis enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation.\nClient side routing is enabled by creating a\nRouter\nand linking/submitting to pages with\nLink\nand\n<Form>\n:\nimport\n*\nas\nReact\nfrom\n\"\nreact\n\";\nimport\n{\ncreateRoot\n}\nfrom\n\"\nreact-dom/client\n\";\nimport\n{\ncreateBrowserRouter\n,\nRouterProvider\n,\nRoute\n,\nLink\n,\n}\nfrom\n\"\nreact-router-dom\n\";\nconst\nrouter\n=\ncreateBrowserRouter\n([\n{\npath: \"\n/\n\",\nelement\n: (\n<\ndiv\n>\n<\nh1\n>Hello World</\nh1\n>\n<\nLink\nto\n=\n\"\nabout\n\">About Us</\nLink\n>\n</\ndiv\n>\n),\n},\n{\npath: \"\nabout\n\",\nelement: <\ndiv\n>About</\ndiv\n>,\n},\n]);\ncreateRoot\n(\ndocument\n.\ngetElementById\n(\"\nroot\n\")).\nrender\n(\n<\nRouterProvider\nrouter\n=\n{\nrouter\n}\n/>\n);\nNested Routes\nNested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:\nThe layouts to render on the page\nThe data dependencies of those layouts\nReact Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data.\n// Configure nested routes with JSX\ncreateBrowserRouter\n(\ncreateRoutesFromElements\n(\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nRoot\n/>\n}\n>\n<\nRoute\npath\n=\n\"\ncontact\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\ndashboard\n\"\nelement\n=\n{\n<\nDashboard\n/>\n}\nloader\n=\n{\n({\nrequest\n})\n=>\nfetch\n(\"\n/api/dashboard.json\n\", {\nsignal:\nrequest\n.\nsignal\n,\n})\n}\n/>\n<\nRoute\nelement\n=\n{\n<\nAuthLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\nlogin\n\"\nelement\n=\n{\n<\nLogin\n/>\n}\nloader\n=\n{\nredirectIfUser\n}\n/>\n<\nRoute\npath\n=\n\"\nlogout\n\"\naction\n=\n{\nlogoutUser\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n)\n);\n// Or use plain objects\ncreateBrowserRouter\n([\n{\npath: \"\n/\n\",\nelement: <\nRoot\n/>,\nchildren: [\n{\npath: \"\ncontact\n\",\nelement: <\nContact\n/>,\n},\n{\npath: \"\ndashboard\n\",\nelement: <\nDashboard\n/>,\nloader\n: ({\nrequest\n})\n=>\nfetch\n(\"\n/api/dashboard.json\n\", {\nsignal:\nrequest\n.\nsignal\n,\n}),\n},\n{\nelement: <\nAuthLayout\n/>,\nchildren: [\n{\npath: \"\nlogin\n\",\nelement: <\nLogin\n/>,\nloader:\nredirectIfUser\n,\n},\n{\npath: \"\nlogout\n\",\naction:\nlogoutUser\n,\n},\n],\n},\n],\n},\n]);\nThis\nvisualization\nmight be helpful.\nDynamic Segments\nSegments of the URL can be dynamic placeholders that are parsed and provided to various apis.\n<\nRoute\npath\n=\n\"\nprojects/:projectId/tasks/:taskId\n\" />\nThe two segments with\n:\nare dynamic, and provided to the following APIs:\n// If the current location is /projects/abc/tasks/3\n<\nRoute\n// sent to loaders\nloader\n=\n{\n({\nparams\n})\n=>\n{\nparams\n.\nprojectId\n;\n// abc\nparams\n.\ntaskId\n;\n// 3\n}\n}\n// and actions\naction\n=\n{\n({\nparams\n})\n=>\n{\nparams\n.\nprojectId\n;\n// abc\nparams\n.\ntaskId\n;\n// 3\n}\n}\nelement\n=\n{\n<\nTask\n/>\n}\n/>;\nfunction\nTask\n() {\n// returned from `useParams`\nconst\nparams\n=\nuseParams\n();\nparams\n.\nprojectId\n;\n// abc\nparams\n.\ntaskId\n;\n// 3\n}\nfunction\nRandom\n() {\nconst\nmatch\n=\nuseMatch\n(\n\"\n/projects/:projectId/tasks/:taskId\n\"\n);\nmatch\n.\nparams\n.\nprojectId\n;\n// abc\nmatch\n.\nparams\n.\ntaskId\n;\n// 3\n}\nSee:\n<Route path>\n<Route loader>\n<Route action>\nuseParams\nuseMatch\nRanked Route Matching\nWhen matching URLs to routes, React Router will rank the routes according to the number of segments, static segments, dynamic segments, splats, etc. and pick the\nmost specific\nmatch.\nFor example, consider these two routes:\n<\nRoute\npath\n=\n\"\n/teams/:teamId\n\" />\n<\nRoute\npath\n=\n\"\n/teams/new\n\" />\nNow consider the URL is\nhttp://example.com/teams/new\n.\nEven though both routes technically match the URL (\nnew\ncould be the\n:teamId\n), you intuitively know that we want the second route (\n/teams/new\n) to be picked. React Router's matching algorithm knows that, too.\nWith ranked routes, you don't have to worry about route ordering.\nActive Links\nMost web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (\nisActive\n) or where they're going (\nisPending\n) in the app is done easily with\n<NavLink>\n.\n<\nNavLink\nstyle\n=\n{\n({\nisActive\n,\nisPending\n})\n=>\n{\nreturn\n{\ncolor:\nisActive\n?\n\"\nred\n\"\n:\n\"\ninherit\n\",\n};\n}\n}\nclassName\n=\n{\n({\nisActive\n,\nisPending\n})\n=>\n{\nreturn\nisActive\n?\n\"\nactive\n\"\n:\nisPending\n?\n\"\npending\n\"\n:\n\"\";\n}\n}\n/>\nYou can also\nuseMatch\nfor any other \"active\" indication outside of links.\nfunction\nSomeComp\n() {\nconst\nmatch\n=\nuseMatch\n(\"\n/messages\n\");\nreturn\n<\nli\nclassName\n=\n{\nBoolean\n(\nmatch\n)\n?\n\"\nactive\n\"\n:\n\"\"\n}\n/>;\n}\nSee:\nNavLink\nuseMatch\nRelative Links\nLike HTML\n<a href>\n,\n<Link to>\nand\n<NavLink to>\ncan take relative paths, with enhanced behavior with nested routes.\nGiven the following route config:\n<\nRoute\npath\n=\n\"\nhome\n\"\nelement\n=\n{\n<\nHome\n/>\n}\n>\n<\nRoute\npath\n=\n\"\nproject/:projectId\n\"\nelement\n=\n{\n<\nProject\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:taskId\n\"\nelement\n=\n{\n<\nTask\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\nConsider the url\nhttps://example.com/home/project/123\n, which renders the following route component hierarchy:\n<\nHome\n>\n<\nProject\n/>\n</\nHome\n>\nIf\n<Project />\nrenders the following links, the hrefs of the links will resolve like so:\nIn\n<Project>\n@\n/home/project/123\nResolved\n<a href>\n<Link to=\"abc\">\n/home/project/123/abc\n<Link to=\".\">\n/home/project/123\n<Link to=\"..\">\n/home\n<Link to=\"..\" relative=\"path\">\n/home/project\nNote that the first\n..\nremoves both segments of the\nproject/:projectId\nroute. By default, the\n..\nin relative links traverse the route hierarchy, not the URL segments. Adding\nrelative=\"path\"\nin the next example allows you to traverse the path segments instead.\nRelative links are always relative to the route path they are\nrendered in\n, not to the full URL. That means if the user navigates deeper with\n<Link to=\"abc\">\nto\n<Task />\nat the URL\n/home/project/123/abc\n, the hrefs in\n<Project>\nwill not change (contrary to plain\n<a href>\n, a common problem with client side routers).\nData Loading\nBecause URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel.\n<\nRoute\npath\n=\n\"\n/\n\"\nloader\n=\n{\nasync\n({\nrequest\n})\n=>\n{\n// loaders can be async functions\nconst\nres\n=\nawait\nfetch\n(\"\n/api/user.json\n\", {\nsignal:\nrequest\n.\nsignal\n,\n});\nconst\nuser\n=\nawait\nres\n.\njson\n();\nreturn\nuser\n;\n}\n}\nelement\n=\n{\n<\nRoot\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\n// loaders understand Fetch Responses and will automatically\n// unwrap the res.json(), so you can simply return a fetch\nloader\n=\n{\n({\nparams\n})\n=>\n{\nreturn\nfetch\n(`\n/api/teams/\n${\nparams\n.\nteamId\n}`);\n}\n}\nelement\n=\n{\n<\nTeam\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:gameId\n\"\nloader\n=\n{\n({\nparams\n})\n=>\n{\n// of course you can use any data store\nreturn\nfakeSdk\n.\ngetTeam\n(\nparams\n.\ngameId\n);\n}\n}\nelement\n=\n{\n<\nGame\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\nData is made available to your components through\nuseLoaderData\n.\nfunction\nRoot\n() {\nconst\nuser\n=\nuseLoaderData\n();\n// data from <Route path=\"/\">\n}\nfunction\nTeam\n() {\nconst\nteam\n=\nuseLoaderData\n();\n// data from <Route path=\":teamId\">\n}\nfunction\nGame\n() {\nconst\ngame\n=\nuseLoaderData\n();\n// data from <Route path=\":gameId\">\n}\nWhen the user visits or clicks links to\nhttps://example.com/real-salt-lake/45face3\n, all three route loaders will be called and loaded in parallel, before the UI for that URL renders.\nRedirects\nWhile loading or changing data, it's common to\nredirect\nthe user to a different route.\n<\nRoute\npath\n=\n\"\ndashboard\n\"\nloader\n=\n{\nasync\n()\n=>\n{\nconst\nuser\n=\nawait\nfake\n.\ngetUser\n();\nif\n(\n!\nuser\n) {\n// if you know you can't render the route, you can\n// throw a redirect to stop executing code here,\n// sending the user to a new route\nthrow\nredirect\n(\"\n/login\n\");\n}\n// otherwise continue\nconst\nstats\n=\nawait\nfake\n.\ngetDashboardStats\n();\nreturn\n{\nuser\n,\nstats\n};\n}\n}\n/>\n<\nRoute\npath\n=\n\"\nproject/new\n\"\naction\n=\n{\nasync\n({\nrequest\n})\n=>\n{\nconst\ndata\n=\nawait\nrequest\n.\nformData\n();\nconst\nnewProject\n=\nawait\ncreateProject\n(\ndata\n);\n// it's common to redirect after actions complete,\n// sending the user to the new record\nreturn\nredirect\n(`\n/projects/\n${\nnewProject\n.\nid\n}`);\n}\n}\n/>\nSee:\nredirect\nThrowing in Loaders\nuseNavigate\nPending Navigation UI\nWhen users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive.\nfunction\nRoot\n() {\nconst\nnavigation\n=\nuseNavigation\n();\nreturn\n(\n<\ndiv\n>\n{\nnavigation\n.\nstate\n===\n\"\nloading\n\"\n&&\n<\nGlobalSpinner\n/>\n}\n<\nFakeSidebar\n/>\n<\nOutlet\n/>\n<\nFakeFooter\n/>\n</\ndiv\n>\n);\n}\nSee:\nuseNavigation\nSkeleton UI with\n<Suspense>\nInstead of waiting for the data for the next page, you can\ndefer\ndata so the UI flips over to the next screen with placeholder UI immediately while the data loads.\n<\nRoute\npath\n=\n\"\nissue/:issueId\n\"\nelement\n=\n{\n<\nIssue\n/>\n}\nloader\n=\n{\nasync\n({\nparams\n})\n=>\n{\n// these are promises, but *not* awaited\nconst\ncomments\n=\nfake\n.\ngetIssueComments\n(\nparams\n.\nissueId\n);\nconst\nhistory\n=\nfake\n.\ngetIssueHistory\n(\nparams\n.\nissueId\n);\n// the issue, however, *is* awaited\nconst\nissue\n=\nawait\nfake\n.\ngetIssue\n(\nparams\n.\nissueId\n);\n// defer enables suspense for the un-awaited promises\nreturn\ndefer\n({\nissue\n,\ncomments\n,\nhistory\n});\n}\n}\n/>;\nfunction\nIssue\n() {\nconst\n{\nissue\n,\nhistory\n,\ncomments\n}\n=\nuseLoaderData\n();\nreturn\n(\n<\ndiv\n>\n<\nIssueDescription\nissue\n=\n{\nissue\n}\n/>\n{\n/* Suspense provides the placeholder fallback */\n}\n<\nSuspense\nfallback\n=\n{\n<\nIssueHistorySkeleton\n/>\n}\n>\n{\n/* Await manages the deferred data (promise) */\n}\n<\nAwait\nresolve\n=\n{\nhistory\n}\n>\n{\n/* this calls back when the data is resolved */\n}\n{\n(\nresolvedHistory\n)\n=>\n(\n<\nIssueHistory\nhistory\n=\n{\nresolvedHistory\n}\n/>\n)\n}\n</\nAwait\n>\n</\nSuspense\n>\n<\nSuspense\nfallback\n=\n{\n<\nIssueCommentsSkeleton\n/>\n}\n>\n<\nAwait\nresolve\n=\n{\ncomments\n}\n>\n{\n/* ... or you can use hooks to access the data */\n}\n<\nIssueComments\n/>\n</\nAwait\n>\n</\nSuspense\n>\n</\ndiv\n>\n);\n}\nfunction\nIssueComments\n() {\nconst\ncomments\n=\nuseAsyncValue\n();\nreturn\n<\ndiv\n>\n{\n/* ... */\n}\n</\ndiv\n>;\n}\nSee\nDeferred Data Guide\ndefer\nAwait\nuseAsyncValue\nData Mutations\nHTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing.\nWhen a form is submitted, the normal browser navigation event is prevented and a\nRequest\n, with a body containing the\nFormData\nof the submission, is created. This request is sent to the\n<Route action>\nthat matches the form's\n<Form action>\n.\nForm elements's\nname\nprop are submitted to the action:\n<\nForm\naction\n=\n\"\n/project/new\n\">\n<\nlabel\n>\nProject title\n<\nbr\n/>\n<\ninput\ntype\n=\n\"\ntext\n\"\nname\n=\n\"\ntitle\n\" />\n</\nlabel\n>\n<\nlabel\n>\nTarget Finish Date\n<\nbr\n/>\n<\ninput\ntype\n=\n\"\ndate\n\"\nname\n=\n\"\ndue\n\" />\n</\nlabel\n>\n</\nForm\n>\nThe normal HTML document request is prevented and sent to the matching route's action (\n<Route path>\nthat matches the\n<form action>\n), including the\nrequest.formData\n.\n<\nRoute\npath\n=\n\"\nproject/new\n\"\naction\n=\n{\nasync\n({\nrequest\n})\n=>\n{\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\nnewProject\n=\nawait\ncreateProject\n({\ntitle:\nformData\n.\nget\n(\"\ntitle\n\"),\ndue:\nformData\n.\nget\n(\"\ndue\n\"),\n});\nreturn\nredirect\n(`\n/projects/\n${\nnewProject\n.\nid\n}`);\n}\n}\n/>\nData Revalidation\nDecades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs.\nAfter route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload.\nSee:\nTutorial \"Creating Contacts\"\nBusy Indicators\nWhen forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc.\nfunction\nNewProjectForm\n() {\nconst\nnavigation\n=\nuseNavigation\n();\nconst\nbusy\n=\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\";\nreturn\n(\n<\nForm\naction\n=\n\"\n/project/new\n\">\n<\nfieldset\ndisabled\n=\n{\nbusy\n}\n>\n<\nlabel\n>\nProject title\n<\nbr\n/>\n<\ninput\ntype\n=\n\"\ntext\n\"\nname\n=\n\"\ntitle\n\" />\n</\nlabel\n>\n<\nlabel\n>\nTarget Finish Date\n<\nbr\n/>\n<\ninput\ntype\n=\n\"\ndate\n\"\nname\n=\n\"\ndue\n\" />\n</\nlabel\n>\n</\nfieldset\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\ndisabled\n=\n{\nbusy\n}\n>\n{\nbusy\n?\n\"\nCreating...\n\"\n:\n\"\nCreate\n\"\n}\n</\nbutton\n>\n</\nForm\n>\n);\n}\nSee:\nuseNavigation\nOptimistic UI\nKnowing the\nformData\nbeing sent to an\naction\nis often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called \"optimistic UI\".\nfunction\nLikeButton\n({\ntweet\n}) {\nconst\nfetcher\n=\nuseFetcher\n();\n// if there is `formData` then it is posting to the action\nconst\nliked\n=\nfetcher\n.\nformData\n?\n// check the formData to be optimistic\nfetcher\n.\nformData\n.\nget\n(\"\nliked\n\")\n===\n\"\nyes\n\"\n:\n// if its not posting to the action, use the record's value\ntweet\n.\nliked\n;\nreturn\n(\n<\nfetcher.Form\nmethod\n=\n\"\npost\n\"\naction\n=\n\"\ntoggle-liked\n\">\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\nname\n=\n\"\nliked\n\"\nvalue\n=\n{\nliked\n?\n\"\nyes\n\"\n:\n\"\nno\n\"\n}\n/>\n</\nfetcher.Form\n>\n);\n}\n(Yes, HTML buttons can have a\nname\nand a\nvalue\n).\nWhile it is more common to do optimistic UI with a\nfetcher\n, you can do the same with a normal form using\nnavigation.formData\n.\nData Fetchers\nHTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation.\nMost web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc.\nFetchers\nallow you to interact with the route\nactions\nand\nloaders\nwithout causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling.\nImagine a list of tasks:\nfunction\nTasks\n() {\nconst\ntasks\n=\nuseLoaderData\n();\nreturn\ntasks\n.\nmap\n((\ntask\n)\n=>\n(\n<\ndiv\n>\n<\np\n>\n{\ntask\n.\nname\n}\n</\np\n>\n<\nToggleCompleteButton\ntask\n=\n{\ntask\n}\n/>\n</\ndiv\n>\n));\n}\nEach task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a\nfetcher\n:\nfunction\nToggleCompleteButton\n({\ntask\n}) {\nconst\nfetcher\n=\nuseFetcher\n();\nreturn\n(\n<\nfetcher.Form\nmethod\n=\n\"\npost\n\"\naction\n=\n\"\n/toggle-complete\n\">\n<\nfieldset\ndisabled\n=\n{\nfetcher\n.\nstate\n!==\n\"\nidle\n\"\n}\n>\n<\ninput\ntype\n=\n\"\nhidden\n\"\nname\n=\n\"\nid\n\"\nvalue\n=\n{\ntask\n.\nid\n}\n/>\n<\ninput\ntype\n=\n\"\nhidden\n\"\nname\n=\n\"\nstatus\n\"\nvalue\n=\n{\ntask\n.\ncomplete\n?\n\"\nincomplete\n\"\n:\n\"\ncomplete\n\"\n}\n/>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">\n{\ntask\n.\nstatus\n===\n\"\ncomplete\n\"\n?\n\"\nMark Incomplete\n\"\n:\n\"\nMark Complete\n\"\n}\n</\nbutton\n>\n</\nfieldset\n>\n</\nfetcher.Form\n>\n);\n}\nSee:\nuseFetcher\nRace Condition Handling\nReact Router will cancel stale operations and only commit fresh data automatically.\nAny time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state.\nConsider a search field that updates a list as the user types:\n?q=ry    |---------------|\n                         ^ commit wrong state\n?q=ryan     |--------|\n                     ^ lose correct state\nEven though the query for\nq?=ryan\nwent out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for\n?q=ryan\nbut then flip over the incorrect results for\n?q=ry\n. Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need cancellation.\nIf you're using React Router's data conventions you avoid this problem completely and automatically.\n?q=ry    |-----------X\n                     ^ cancel wrong state when\n                       correct state completes earlier\n?q=ryan     |--------|\n                     ^ commit correct state\nNot only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with\nfetcher\n(and its automatic, concurrent revalidations).\nError Handling\nThe vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:\nrendering\nloading data\nupdating data\nIn practice, this is pretty much every error in your app except those thrown in event handlers (\n<button onClick>\n) or\nuseEffect\n. React Router apps tend to have very few of either.\nWhen an error is thrown, instead of rendering the route's\nelement\n, the\nerrorElement\nis rendered.\n<\nRoute\npath\n=\n\"\n/\n\"\nloader\n=\n{\n()\n=>\n{\nsomething\n.\nthat\n.\nthrows\n.\nan\n.\nerror\n();\n}\n}\n// this will not be rendered\nelement\n=\n{\n<\nHappyPath\n/>\n}\n// but this will instead\nerrorElement\n=\n{\n<\nErrorBoundary\n/>\n}\n/>\nIf a route doesn't have an\nerrorElement\n, the error will bubble to the nearest parent route with an\nerrorElement\n:\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nHappyPath\n/>\n}\nerrorElement\n=\n{\n<\nErrorBoundary\n/>\n}\n>\n{\n/* Errors here bubble up to the parent route */\n}\n<\nRoute\npath\n=\n\"\nlogin\n\"\nelement\n=\n{\n<\nLogin\n/>\n}\n/>\n</\nRoute\n>\nSee:\n<Route errorElement>\nuseRouteError\nScroll Restoration\nReact Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot.\nYou can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page).\nSee:\n<ScrollRestoration>\nWeb Standard APIs\nReact Router is built on web standard APIs.\nLoaders\nand\nactions\nreceive standard Web Fetch API\nRequest\nobjects and can return\nResponse\nobjects, too. Cancellation is done with\nAbort Signals\n, search params are handled with\nURLSearchParams\n, and data mutations are handled with\nHTML Forms\n.\nWhen you get better at React Router, you get better at the web platform.\nSearch Params\nTODO:\nLocation State\nTODO:\nBrand Assets\n\u2022\nDocs and examples\nCC 4.0\nEdit",
  "content_markdown": "![](/assets/icons-DI88m4Yf.svg)\n\n6.28.0\n\nBranches\n\n[latest (7.13.0)](/home)[dev](/dev/)\n\nVersions\n\n[7.13.0](/7.13.0/home)[6.30.3](/6.30.3)[v4/5.x](https://v5.reactrouter.com/)[v3.x](https://github.com/remix-run/react-router/tree/v3.2.6/docs)\n\nSearch\n\nLight Dark System\n\nFeature Overview\n\nCopy Page\n\n[Copy PageCopy Page as Markdown](https://raw.githubusercontent.com/remix-run/react-router/refs/tags/react-router@6.28.0/docs/start/overview.md)\n\n- [Client Side Routing](/6.28.0/start/overview#client-side-routing)\n- [Nested Routes](/6.28.0/start/overview#nested-routes)\n- [Dynamic Segments](/6.28.0/start/overview#dynamic-segments)\n- [Ranked Route Matching](/6.28.0/start/overview#ranked-route-matching)\n- [Active Links](/6.28.0/start/overview#active-links)\n- [Relative Links](/6.28.0/start/overview#relative-links)\n- [Data Loading](/6.28.0/start/overview#data-loading)\n- [Redirects](/6.28.0/start/overview#redirects)\n- [Pending Navigation UI](/6.28.0/start/overview#pending-navigation-ui)\n- [Skeleton UI with `<Suspense>`](/6.28.0/start/overview#skeleton-ui-with-suspense)\n- [Data Mutations](/6.28.0/start/overview#data-mutations)\n- [Data Revalidation](/6.28.0/start/overview#data-revalidation)\n- [Busy Indicators](/6.28.0/start/overview#busy-indicators)\n- [Optimistic UI](/6.28.0/start/overview#optimistic-ui)\n- [Data Fetchers](/6.28.0/start/overview#data-fetchers)\n- [Race Condition Handling](/6.28.0/start/overview#race-condition-handling)\n- [Error Handling](/6.28.0/start/overview#error-handling)\n- [Scroll Restoration](/6.28.0/start/overview#scroll-restoration)\n- [Web Standard APIs](/6.28.0/start/overview#web-standard-apis)\n- [Search Params](/6.28.0/start/overview#search-params)\n- [Location State](/6.28.0/start/overview#location-state)\n\nOn this page\n\n- [Client Side Routing](/6.28.0/start/overview#client-side-routing)\n- [Nested Routes](/6.28.0/start/overview#nested-routes)\n- [Dynamic Segments](/6.28.0/start/overview#dynamic-segments)\n- [Ranked Route Matching](/6.28.0/start/overview#ranked-route-matching)\n- [Active Links](/6.28.0/start/overview#active-links)\n- [Relative Links](/6.28.0/start/overview#relative-links)\n- [Data Loading](/6.28.0/start/overview#data-loading)\n- [Redirects](/6.28.0/start/overview#redirects)\n- [Pending Navigation UI](/6.28.0/start/overview#pending-navigation-ui)\n- [Skeleton UI with `<Suspense>`](/6.28.0/start/overview#skeleton-ui-with-suspense)\n- [Data Mutations](/6.28.0/start/overview#data-mutations)\n- [Data Revalidation](/6.28.0/start/overview#data-revalidation)\n- [Busy Indicators](/6.28.0/start/overview#busy-indicators)\n- [Optimistic UI](/6.28.0/start/overview#optimistic-ui)\n- [Data Fetchers](/6.28.0/start/overview#data-fetchers)\n- [Race Condition Handling](/6.28.0/start/overview#race-condition-handling)\n- [Error Handling](/6.28.0/start/overview#error-handling)\n- [Scroll Restoration](/6.28.0/start/overview#scroll-restoration)\n- [Web Standard APIs](/6.28.0/start/overview#web-standard-apis)\n- [Search Params](/6.28.0/start/overview#search-params)\n- [Location State](/6.28.0/start/overview#location-state)\n\n# Feature Overview\n\n## Client Side Routing\n\nReact Router enables \"client side routing\".\n\nIn traditional websites, the browser requests a document from a web server, downloads and evaluates CSS and JavaScript assets, and renders the HTML sent from the server. When the user clicks a link, it starts the process all over again for a new page.\n\nClient side routing allows your app to update the URL from a link click without making another request for another document from the server. Instead, your app can immediately render some new UI and make data requests with `fetch` to update the page with new information.\n\nThis enables faster user experiences because the browser doesn't need to request an entirely new document or re-evaluate CSS and JavaScript assets for the next page. It also enables more dynamic user experiences with things like animation.\n\nClient side routing is enabled by creating a `Router` and linking/submitting to pages with `Link` and `<Form>`:\n\n```\nimport * as React from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport {\n  createBrowserRouter,\n  RouterProvider,\n  Route,\n  Link,\n} from \"react-router-dom\";\n\nconst router = createBrowserRouter([\n  {\n    path: \"/\",\n    element: (\n      <div>\n        <h1>Hello World</h1>\n        <Link to=\"about\">About Us</Link>\n      </div>\n    ),\n  },\n  {\n    path: \"about\",\n    element: <div>About</div>,\n  },\n]);\n\ncreateRoot(document.getElementById(\"root\")).render(\n  <RouterProvider router={router} />\n);\n```\n\n## Nested Routes\n\nNested Routing is the general idea of coupling segments of the URL to component hierarchy and data. React Router's nested routes were inspired by the routing system in Ember.js circa 2014. The Ember team realized that in nearly every case, segments of the URL determine:\n\n- The layouts to render on the page\n- The data dependencies of those layouts\n\nReact Router embraces this convention with APIs for creating nested layouts coupled to URL segments and data.\n\n```\n// Configure nested routes with JSX\ncreateBrowserRouter(\n  createRoutesFromElements(\n    <Route path=\"/\" element={<Root />}>\n      <Route path=\"contact\" element={<Contact />} />\n      <Route\n        path=\"dashboard\"\n        element={<Dashboard />}\n        loader={({ request }) =>\n          fetch(\"/api/dashboard.json\", {\n            signal: request.signal,\n          })\n        }\n      />\n      <Route element={<AuthLayout />}>\n        <Route\n          path=\"login\"\n          element={<Login />}\n          loader={redirectIfUser}\n        />\n        <Route path=\"logout\" action={logoutUser} />\n      </Route>\n    </Route>\n  )\n);\n\n// Or use plain objects\ncreateBrowserRouter([\n  {\n    path: \"/\",\n    element: <Root />,\n    children: [\n      {\n        path: \"contact\",\n        element: <Contact />,\n      },\n      {\n        path: \"dashboard\",\n        element: <Dashboard />,\n        loader: ({ request }) =>\n          fetch(\"/api/dashboard.json\", {\n            signal: request.signal,\n          }),\n      },\n      {\n        element: <AuthLayout />,\n        children: [\n          {\n            path: \"login\",\n            element: <Login />,\n            loader: redirectIfUser,\n          },\n          {\n            path: \"logout\",\n            action: logoutUser,\n          },\n        ],\n      },\n    ],\n  },\n]);\n```\n\nThis [visualization](https://remix.run/_docs/routing) might be helpful.\n\n## Dynamic Segments\n\nSegments of the URL can be dynamic placeholders that are parsed and provided to various apis.\n\n```\n<Route path=\"projects/:projectId/tasks/:taskId\" />\n```\n\nThe two segments with `:` are dynamic, and provided to the following APIs:\n\n```\n// If the current location is /projects/abc/tasks/3\n<Route\n  // sent to loaders\n  loader={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  // and actions\n  action={({ params }) => {\n    params.projectId; // abc\n    params.taskId; // 3\n  }}\n  element={<Task />}\n/>;\n\nfunction Task() {\n  // returned from `useParams`\n  const params = useParams();\n  params.projectId; // abc\n  params.taskId; // 3\n}\n\nfunction Random() {\n  const match = useMatch(\n    \"/projects/:projectId/tasks/:taskId\"\n  );\n  match.params.projectId; // abc\n  match.params.taskId; // 3\n}\n```\n\nSee:\n\n- [`<Route path>`](../route/route#path)\n- [`<Route loader>`](../route/loader)\n- [`<Route action>`](../route/action)\n- [`useParams`](../hooks/use-params)\n- [`useMatch`](../hooks/use-match)\n\n## Ranked Route Matching\n\nWhen matching URLs to routes, React Router will rank the routes according to the number of segments, static segments, dynamic segments, splats, etc. and pick the *most specific* match.\n\nFor example, consider these two routes:\n\n```\n<Route path=\"/teams/:teamId\" />\n<Route path=\"/teams/new\" />\n```\n\nNow consider the URL is <http://example.com/teams/new>.\n\nEven though both routes technically match the URL (`new` could be the `:teamId`), you intuitively know that we want the second route (`/teams/new`) to be picked. React Router's matching algorithm knows that, too.\n\nWith ranked routes, you don't have to worry about route ordering.\n\n## Active Links\n\nMost web apps have persistent navigation sections at the top of the UI, the sidebar, and often multiple levels. Styling the active navigation items so the user knows where they are (`isActive`) or where they're going (`isPending`) in the app is done easily with `<NavLink>`.\n\n```\n<NavLink\n  style={({ isActive, isPending }) => {\n    return {\n      color: isActive ? \"red\" : \"inherit\",\n    };\n  }}\n  className={({ isActive, isPending }) => {\n    return isActive ? \"active\" : isPending ? \"pending\" : \"\";\n  }}\n/>\n```\n\nYou can also [`useMatch`](../hooks/use-match) for any other \"active\" indication outside of links.\n\n```\nfunction SomeComp() {\n  const match = useMatch(\"/messages\");\n  return <li className={Boolean(match) ? \"active\" : \"\"} />;\n}\n```\n\nSee:\n\n- [`NavLink`](../components/nav-link)\n- [`useMatch`](../hooks/use-match)\n\n## Relative Links\n\nLike HTML `<a href>`, `<Link to>` and `<NavLink to>` can take relative paths, with enhanced behavior with nested routes.\n\nGiven the following route config:\n\n```\n<Route path=\"home\" element={<Home />}>\n  <Route path=\"project/:projectId\" element={<Project />}>\n    <Route path=\":taskId\" element={<Task />} />\n  </Route>\n</Route>\n```\n\nConsider the url <https://example.com/home/project/123>, which renders the following route component hierarchy:\n\n```\n<Home>\n  <Project />\n</Home>\n```\n\nIf `<Project />` renders the following links, the hrefs of the links will resolve like so:\n\n| In `<Project>` @ `/home/project/123` | Resolved `<a href>` |\n| --- | --- |\n| `<Link to=\"abc\">` | `/home/project/123/abc` |\n| `<Link to=\".\">` | `/home/project/123` |\n| `<Link to=\"..\">` | `/home` |\n| `<Link to=\"..\" relative=\"path\">` | `/home/project` |\n\nNote that the first `..` removes both segments of the `project/:projectId` route. By default, the `..` in relative links traverse the route hierarchy, not the URL segments. Adding `relative=\"path\"` in the next example allows you to traverse the path segments instead.\n\nRelative links are always relative to the route path they are *rendered in*, not to the full URL. That means if the user navigates deeper with `<Link to=\"abc\">` to `<Task />` at the URL `/home/project/123/abc`, the hrefs in `<Project>` will not change (contrary to plain `<a href>`, a common problem with client side routers).\n\n## Data Loading\n\nBecause URL segments usually map to your app's persistent data, React Router provides conventional data loading hooks to initiate data loading during a navigation. Combined with nested routes, all of the data for multiple layouts at a specific URL can be loaded in parallel.\n\n```\n<Route\n  path=\"/\"\n  loader={async ({ request }) => {\n    // loaders can be async functions\n    const res = await fetch(\"/api/user.json\", {\n      signal: request.signal,\n    });\n    const user = await res.json();\n    return user;\n  }}\n  element={<Root />}\n>\n  <Route\n    path=\":teamId\"\n    // loaders understand Fetch Responses and will automatically\n    // unwrap the res.json(), so you can simply return a fetch\n    loader={({ params }) => {\n      return fetch(`/api/teams/${params.teamId}`);\n    }}\n    element={<Team />}\n  >\n    <Route\n      path=\":gameId\"\n      loader={({ params }) => {\n        // of course you can use any data store\n        return fakeSdk.getTeam(params.gameId);\n      }}\n      element={<Game />}\n    />\n  </Route>\n</Route>\n```\n\nData is made available to your components through `useLoaderData`.\n\n```\nfunction Root() {\n  const user = useLoaderData();\n  // data from <Route path=\"/\">\n}\n\nfunction Team() {\n  const team = useLoaderData();\n  // data from <Route path=\":teamId\">\n}\n\nfunction Game() {\n  const game = useLoaderData();\n  // data from <Route path=\":gameId\">\n}\n```\n\nWhen the user visits or clicks links to <https://example.com/real-salt-lake/45face3>, all three route loaders will be called and loaded in parallel, before the UI for that URL renders.\n\n## Redirects\n\nWhile loading or changing data, it's common to [redirect](../fetch/redirect) the user to a different route.\n\n```\n<Route\n  path=\"dashboard\"\n  loader={async () => {\n    const user = await fake.getUser();\n    if (!user) {\n      // if you know you can't render the route, you can\n      // throw a redirect to stop executing code here,\n      // sending the user to a new route\n      throw redirect(\"/login\");\n    }\n\n    // otherwise continue\n    const stats = await fake.getDashboardStats();\n    return { user, stats };\n  }}\n/>\n```\n\n```\n<Route\n  path=\"project/new\"\n  action={async ({ request }) => {\n    const data = await request.formData();\n    const newProject = await createProject(data);\n    // it's common to redirect after actions complete,\n    // sending the user to the new record\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n```\n\nSee:\n\n- [`redirect`](../fetch/redirect)\n- [Throwing in Loaders](../route/loader#throwing-in-loaders)\n- [`useNavigate`](../hooks/use-navigate)\n\n## Pending Navigation UI\n\nWhen users navigate around the app, the data for the next page is loaded before the page is rendered. It's important to provide user feedback during this time so the app doesn't feel like it's unresponsive.\n\n```\nfunction Root() {\n  const navigation = useNavigation();\n  return (\n    <div>\n      {navigation.state === \"loading\" && <GlobalSpinner />}\n      <FakeSidebar />\n      <Outlet />\n      <FakeFooter />\n    </div>\n  );\n}\n```\n\nSee:\n\n- [`useNavigation`](../hooks/use-navigation)\n\n## Skeleton UI with `<Suspense>`\n\nInstead of waiting for the data for the next page, you can [`defer`](../utils/defer) data so the UI flips over to the next screen with placeholder UI immediately while the data loads.\n\n```\n<Route\n  path=\"issue/:issueId\"\n  element={<Issue />}\n  loader={async ({ params }) => {\n    // these are promises, but *not* awaited\n    const comments = fake.getIssueComments(params.issueId);\n    const history = fake.getIssueHistory(params.issueId);\n    // the issue, however, *is* awaited\n    const issue = await fake.getIssue(params.issueId);\n\n    // defer enables suspense for the un-awaited promises\n    return defer({ issue, comments, history });\n  }}\n/>;\n\nfunction Issue() {\n  const { issue, history, comments } = useLoaderData();\n  return (\n    <div>\n      <IssueDescription issue={issue} />\n\n      {/* Suspense provides the placeholder fallback */}\n      <Suspense fallback={<IssueHistorySkeleton />}>\n        {/* Await manages the deferred data (promise) */}\n        <Await resolve={history}>\n          {/* this calls back when the data is resolved */}\n          {(resolvedHistory) => (\n            <IssueHistory history={resolvedHistory} />\n          )}\n        </Await>\n      </Suspense>\n\n      <Suspense fallback={<IssueCommentsSkeleton />}>\n        <Await resolve={comments}>\n          {/* ... or you can use hooks to access the data */}\n          <IssueComments />\n        </Await>\n      </Suspense>\n    </div>\n  );\n}\n\nfunction IssueComments() {\n  const comments = useAsyncValue();\n  return <div>{/* ... */}</div>;\n}\n```\n\nSee\n\n- [Deferred Data Guide](../guides/deferred)\n- [`defer`](../utils/defer)\n- [`Await`](../components/await)\n- [`useAsyncValue`](../hooks/use-async-value)\n\n## Data Mutations\n\nHTML forms are navigation events, just like links. React Router supports HTML form workflows with client side routing.\n\nWhen a form is submitted, the normal browser navigation event is prevented and a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), with a body containing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) of the submission, is created. This request is sent to the `<Route action>` that matches the form's `<Form action>`.\n\nForm elements's `name` prop are submitted to the action:\n\n```\n<Form action=\"/project/new\">\n  <label>\n    Project title\n    <br />\n    <input type=\"text\" name=\"title\" />\n  </label>\n\n  <label>\n    Target Finish Date\n    <br />\n    <input type=\"date\" name=\"due\" />\n  </label>\n</Form>\n```\n\nThe normal HTML document request is prevented and sent to the matching route's action (`<Route path>` that matches the `<form action>`), including the `request.formData`.\n\n```\n<Route\n  path=\"project/new\"\n  action={async ({ request }) => {\n    const formData = await request.formData();\n    const newProject = await createProject({\n      title: formData.get(\"title\"),\n      due: formData.get(\"due\"),\n    });\n    return redirect(`/projects/${newProject.id}`);\n  }}\n/>\n```\n\n## Data Revalidation\n\nDecades old web conventions indicate that when a form is posted to the server, data is changing and a new page is rendered. That convention is followed in React Router's HTML-based data mutation APIs.\n\nAfter route actions are called, the loaders for all of the data on the page is called again to ensure the UI stays up-to-date with the data automatically. No cache keys to expire, no context providers to reload.\n\nSee:\n\n- [Tutorial \"Creating Contacts\"](../start/tutorial#creating-contacts)\n\n## Busy Indicators\n\nWhen forms are being submitted to route actions, you have access to the navigation state to display busy indicators, disable fieldsets, etc.\n\n```\nfunction NewProjectForm() {\n  const navigation = useNavigation();\n  const busy = navigation.state === \"submitting\";\n  return (\n    <Form action=\"/project/new\">\n      <fieldset disabled={busy}>\n        <label>\n          Project title\n          <br />\n          <input type=\"text\" name=\"title\" />\n        </label>\n\n        <label>\n          Target Finish Date\n          <br />\n          <input type=\"date\" name=\"due\" />\n        </label>\n      </fieldset>\n      <button type=\"submit\" disabled={busy}>\n        {busy ? \"Creating...\" : \"Create\"}\n      </button>\n    </Form>\n  );\n}\n```\n\nSee:\n\n- [`useNavigation`](../hooks/use-navigation)\n\n## Optimistic UI\n\nKnowing the [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being sent to an [action](../route/action) is often enough to skip the busy indicators and render the UI in the next state immediately, even if your asynchronous work is still pending. This is called \"optimistic UI\".\n\n```\nfunction LikeButton({ tweet }) {\n  const fetcher = useFetcher();\n\n  // if there is `formData` then it is posting to the action\n  const liked = fetcher.formData\n    ? // check the formData to be optimistic\n      fetcher.formData.get(\"liked\") === \"yes\"\n    : // if its not posting to the action, use the record's value\n      tweet.liked;\n\n  return (\n    <fetcher.Form method=\"post\" action=\"toggle-liked\">\n      <button\n        type=\"submit\"\n        name=\"liked\"\n        value={liked ? \"yes\" : \"no\"}\n      />\n    </fetcher.Form>\n  );\n}\n```\n\n(Yes, HTML buttons can have a `name` and a `value`).\n\nWhile it is more common to do optimistic UI with a [`fetcher`](../hooks/use-fetcher), you can do the same with a normal form using [`navigation.formData`](../hooks/use-navigation#navigationformdata).\n\n## Data Fetchers\n\nHTML Forms are the model for mutations but they have one major limitation: you can have only one at a time because a form submission is a navigation.\n\nMost web apps need to allow for multiple mutations to be happening at the same time, like a list of records where each can be independently deleted, marked complete, liked, etc.\n\n[Fetchers](../hooks/use-fetcher) allow you to interact with the route [actions](../route/action) and [loaders](../route/loader) without causing a navigation in the browser, but still getting all the conventional benefits like error handling, revalidation, interruption handling, and race condition handling.\n\nImagine a list of tasks:\n\n```\nfunction Tasks() {\n  const tasks = useLoaderData();\n  return tasks.map((task) => (\n    <div>\n      <p>{task.name}</p>\n      <ToggleCompleteButton task={task} />\n    </div>\n  ));\n}\n```\n\nEach task can be marked complete independently of the rest, with its own pending state and without causing a navigation with a [fetcher](../hooks/use-fetcher):\n\n```\nfunction ToggleCompleteButton({ task }) {\n  const fetcher = useFetcher();\n\n  return (\n    <fetcher.Form method=\"post\" action=\"/toggle-complete\">\n      <fieldset disabled={fetcher.state !== \"idle\"}>\n        <input type=\"hidden\" name=\"id\" value={task.id} />\n        <input\n          type=\"hidden\"\n          name=\"status\"\n          value={task.complete ? \"incomplete\" : \"complete\"}\n        />\n        <button type=\"submit\">\n          {task.status === \"complete\"\n            ? \"Mark Incomplete\"\n            : \"Mark Complete\"}\n        </button>\n      </fieldset>\n    </fetcher.Form>\n  );\n}\n```\n\nSee:\n\n- [`useFetcher`](../hooks/use-fetcher)\n\n## Race Condition Handling\n\nReact Router will cancel stale operations and only commit fresh data automatically.\n\nAny time you have asynchronous UI you have the risk of race conditions: when an async operation starts after but completes before an earlier operation. The result is a user interface that shows the wrong state.\n\nConsider a search field that updates a list as the user types:\n\n```\n?q=ry    |---------------|\n                         ^ commit wrong state\n?q=ryan     |--------|\n                     ^ lose correct state\n```\n\nEven though the query for `q?=ryan` went out later, it completed earlier. If not handled correctly, the results will briefly be the correct values for `?q=ryan` but then flip over the incorrect results for `?q=ry`. Throttling and debouncing are not enough (you can still interrupt the requests that get through). You need cancellation.\n\nIf you're using React Router's data conventions you avoid this problem completely and automatically.\n\n```\n?q=ry    |-----------X\n                     ^ cancel wrong state when\n                       correct state completes earlier\n?q=ryan     |--------|\n                     ^ commit correct state\n```\n\nNot only does React Router handle race conditions for a navigation like this, it also handles it for many other cases like loading results for an autocomplete or performing multiple concurrent mutations with [`fetcher`](../hooks/use-fetcher) (and its automatic, concurrent revalidations).\n\n## Error Handling\n\nThe vast majority of your application errors are handled automatically by React Router. It will catch any errors that are thrown while:\n\n- rendering\n- loading data\n- updating data\n\nIn practice, this is pretty much every error in your app except those thrown in event handlers (`<button onClick>`) or `useEffect`. React Router apps tend to have very few of either.\n\nWhen an error is thrown, instead of rendering the route's [`element`](../route/route#element), the [`errorElement`](../route/error-element) is rendered.\n\n```\n<Route\n  path=\"/\"\n  loader={() => {\n    something.that.throws.an.error();\n  }}\n  // this will not be rendered\n  element={<HappyPath />}\n  // but this will instead\n  errorElement={<ErrorBoundary />}\n/>\n```\n\nIf a route doesn't have an `errorElement`, the error will bubble to the nearest parent route with an `errorElement`:\n\n```\n<Route\n  path=\"/\"\n  element={<HappyPath />}\n  errorElement={<ErrorBoundary />}\n>\n  {/* Errors here bubble up to the parent route */}\n  <Route path=\"login\" element={<Login />} />\n</Route>\n```\n\nSee:\n\n- [`<Route errorElement>`](../route/error-element)\n- [`useRouteError`](../hooks/use-route-error)\n\n## Scroll Restoration\n\nReact Router will emulate the browser's scroll restoration on navigation, waiting for data to load before scrolling. This ensures the scroll position is restored to the right spot.\n\nYou can also customize the behavior by restoring based on something other than locations (like a url pathname) and preventing the scroll from happening on certain links (like tabs in the middle of a page).\n\nSee:\n\n- [`<ScrollRestoration>`](../components/scroll-restoration)\n\n## Web Standard APIs\n\nReact Router is built on web standard APIs. [Loaders](../route/loader) and [actions](../route/action) receive standard Web Fetch API [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) objects and can return [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) objects, too. Cancellation is done with [Abort Signals](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal), search params are handled with [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), and data mutations are handled with [HTML Forms](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).\n\nWhen you get better at React Router, you get better at the web platform.\n\n## Search Params\n\nTODO:\n\n## Location State\n\nTODO:\n\n[Brand Assets](/brand)\n\n\u2022\n\nDocs and examples [CC 4.0](https://creativecommons.org/licenses/by/4.0/)\n\nEdit",
  "tags": [
    "react-router",
    "routing",
    "react"
  ],
  "extracted_at": "2026-02-03T12:52:08.915802+00:00",
  "content_length": 19678,
  "content_hash": "60e79d5bb5541077"
}