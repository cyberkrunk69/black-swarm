{
  "id": "react-router__en_main_start_concepts",
  "source_id": "react-router",
  "source_name": "React Router",
  "category": "navigation_patterns",
  "url": "https://reactrouter.com/en/main/start/concepts",
  "title": "Main Concepts",
  "content": "6.28.0\nBranches\nlatest (\n7.13.0\n)\ndev\nVersions\n7.13.0\n6.30.3\nv4/5.x\nv3.x\nSearch\nLight\nDark\nSystem\nMain Concepts\nCopy Page\nCopy Page\nCopy Page as Markdown\nDefinitions\nHistory and Locations\nHistory Object\nLocations\nMatching\nDefining Routes\nMatch Params\nRanking Routes\nPathless Routes\nRoute Matches\nRendering\nOutlets\nIndex Routes\nLayout Routes\nNavigating\nLink\nNavigate Function\nData Access\nReview\nOn this page\nDefinitions\nHistory and Locations\nHistory Object\nLocations\nMatching\nDefining Routes\nMatch Params\nRanking Routes\nPathless Routes\nRoute Matches\nRendering\nOutlets\nIndex Routes\nLayout Routes\nNavigating\nLink\nNavigate Function\nData Access\nReview\nMain Concepts\nThis document needs to be updated for 6.4 data APIs\nThis document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our\nquick start tutorial\n.\nYou might be wondering what exactly React Router does. How can it help you build your app? What exactly is a\nrouter\n, anyway?\nIf you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.\nPlease don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it.\nReact Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:\nSubscribing and manipulating the\nhistory stack\nMatching the\nURL\nto your\nroutes\nRendering a nested UI from the\nroute matches\nDefinitions\nBut first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.\nHere are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.\nURL\n- The URL in the address bar. A lot of people use the term \"URL\" and \"route\" interchangeably, but this is not a route in React Router, it's just a URL.\nLocation\n- This is a React Router specific object that is based on the built-in browser's\nwindow.location\nobject. It represents \"where the user is at\". It's mostly an object representation of the URL but has a bit more to it than that.\nLocation State\n- A value that persists with a\nlocation\nthat isn't encoded in the\nURL\n. Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.\nHistory Stack\n- As the user navigates, the browser keeps track of each\nlocation\nin a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.\nClient Side Routing (CSR)\n- A plain HTML document can link to other documents and the browser handles the\nhistory stack\nitself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.\nHistory\n- An object that allows React Router to subscribe to changes in the\nURL\nas well as providing APIs to manipulate the browser\nhistory stack\nprogrammatically.\nHistory Action\n- One of\nPOP\n,\nPUSH\n, or\nREPLACE\n. Users can arrive at a\nURL\nfor one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.\nSegment\n- The parts of a\nURL\nor\npath pattern\nbetween the\n/\ncharacters. For example, \"/users/123\" has two segments.\nPath Pattern\n- These look like URLs but can have special characters for matching URLs to routes, like\ndynamic segments\n(\n\"/users/:userId\"\n) or\nstar segments\n(\n\"/docs/*\"\n). They aren't URLs, they're patterns that React Router will match.\nDynamic Segment\n- A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern\n/users/:userId\nwill match URLs like\n/users/123\nURL Params\n- The parsed values from the URL that matched a\ndynamic segment\n.\nRouter\n- Stateful, top-level component that makes all the other components and hooks work.\nRoute Config\n- A tree of\nroutes objects\nthat will be ranked and matched (with nesting) against the current location to create a branch of\nroute matches\n.\nRoute\n- An object or Route Element typically with a shape of\n{ path, element }\nor\n<Route path element>\n. The\npath\nis a path pattern. When the path pattern matches the current URL, the element will be rendered.\nRoute Element\n- Or\n<Route>\n. This element's props are read to create a\nroute\nby\n<Routes>\n, but otherwise does nothing.\nNested Routes\n- Because routes can have children and each route defines a portion of the\nURL\nthrough\nsegments\n, a single URL can match multiple routes in a nested \"branch\" of the tree. This enables automatic layout nesting through\noutlet\n,\nrelative links\n, and more.\nRelative links\n- Links that don't start with\n/\nwill inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.\nMatch\n- An object that holds information when a route matches the URL, like the\nurl params\nand pathname that matched.\nMatches\n- An array of routes (or branch of the\nroute config\n) that matches the current\nlocation\n. This structure enables\nnested routes\n.\nParent Route\n- A route with child routes.\nOutlet\n- A component that renders the next match in a set of\nmatches\n.\nIndex Route\n- A child route with no path that renders in the parent's\noutlet\nat the parent's\nURL\n.\nLayout Route\n- A\nparent route\nwithout a path, used exclusively for grouping child routes inside a specific layout.\nHistory and Locations\nBefore React Router can do anything, it has to be able to subscribe to changes in the browser\nhistory stack\n.\nBrowsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.\nFor example, consider the user:\nclicks a link to\n/dashboard\nclicks a link to\n/accounts\nclicks a link to\n/customers/123\nclicks the back button\nclicks a link to\n/dashboard\nThe history stack will change as follows where\nbold\nentries denote the current\nURL\n:\n/dashboard\n/dashboard\n,\n/accounts\n/dashboard\n,\n/accounts\n,\n/customers/123\n/dashboard\n,\n/accounts\n,\n/customers/123\n/dashboard\n,\n/accounts\n,\n/dashboard\nHistory Object\nWith\nclient side routing\n, developers are able to manipulate the browser\nhistory stack\nprogrammatically. For example, we can write some code like this to change the\nURL\nwithout the browsers default behavior of making a request to the server:\n<\na\nhref\n=\n\"\n/contact\n\"\nonClick\n=\n{\n(\nevent\n)\n=>\n{\n// stop the browser from changing the URL and requesting the new document\nevent\n.\npreventDefault\n();\n// push an entry into the browser history stack and change the URL\nwindow\n.\nhistory\n.\npushState\n({},\nundefined\n, \"\n/contact\n\");\n}\n}\n/>\nFor illustration only, don't use\nwindow.history.pushState\ndirectly in React Router\nThis code changes the\nURL\nbut doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to \"listen to the URL\" and subscribe to changes like this.\nWell, that's not totally true. We can listen for changes to the URL via\npop\nevents:\nwindow\n.\naddEventListener\n(\"\npopstate\n\", ()\n=>\n{\n// URL changed!\n});\nBut that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called\nwindow.history.pushState\nor\nwindow.history.replaceState\n.\nThat's where a React Router specific\nhistory\nobject comes into play. It provides a way to \"listen for\nURL\n\" changes whether the\nhistory action\nis\npush\n,\npop\n, or\nreplace\n.\nlet\nhistory\n=\ncreateBrowserHistory\n();\nhistory\n.\nlisten\n(({\nlocation\n,\naction\n})\n=>\n{\n// this is called whenever new locations come in\n// the action is POP, PUSH, or REPLACE\n});\nApps don't need to set up their own history objects--that's the job of\n<Router>\n. It sets up one of these objects, subscribe to changes in the\nhistory stack\n, and finally updates its state when the\nURL\nchanges. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a\nlocation\n, everything else works from that single object.\nLocations\nThe browser has a location object on\nwindow.location\n. It tells you information about the\nURL\nbut also has some methods to change it:\nwindow\n.\nlocation\n.\npathname\n;\n// /getting-started/concepts/\nwindow\n.\nlocation\n.\nhash\n;\n// #location\nwindow\n.\nlocation\n.\nreload\n();\n// force a refresh w/ the server\n// and a lot more\nFor illustration. You don't typically work with\nwindow.location\nin a React Router app\nInstead of using\nwindow.location\n, React Router has the concept of a\nlocation\nthat's patterned after\nwindow.location\nbut is much simpler. It looks like this:\n{\npathname\n: \"\n/bbq/pig-pickins\n\",\nsearch\n: \"\n?campaign=instagram\n\",\nhash\n: \"\n#menu\n\",\nstate\n:\nnull\n,\nkey\n: \"\naefz24ie\n\"\n}\nThe first three:\n{ pathname, search, hash }\nare exactly like\nwindow.location\n. If you just add up the three you'll get the\nURL\nthe user sees in the browser:\nlocation\n.\npathname\n+\nlocation\n.\nsearch\n+\nlocation\n.\nhash\n;\n// /bbq/pig-pickins?campaign=instagram#menu\nThe last two,\n{ state, key }\n, are React Router specific.\nLocation Pathname\nThis is the part of\nURL\nafter the origin, so for\nhttps://example.com/teams/hotspurs\nthe pathname is\n/teams/hotspurs\n. This is the only part of the location that routes match against.\nLocation Search\nPeople use a lot of different terms for this part of the\nURL\n:\nlocation search\nsearch params\nURL search params\nquery string\nIn React Router we call it the \"location search\". However, location search is a serialized version of\nURLSearchParams\n. So sometimes we might call it \"URL search params\" as well.\n// given a location like this:\nlet\nlocation\n=\n{\npathname: \"\n/bbq/pig-pickins\n\",\nsearch: \"\n?campaign=instagram&popular=true\n\",\nhash: \"\",\nstate:\nnull\n,\nkey: \"\naefz24ie\n\",\n};\n// we can turn the location.search into URLSearchParams\nlet\nparams\n=\nnew\nURLSearchParams\n(\nlocation\n.\nsearch\n);\nparams\n.\nget\n(\"\ncampaign\n\");\n// \"instagram\"\nparams\n.\nget\n(\"\npopular\n\");\n// \"true\"\nparams\n.\ntoString\n();\n// \"campaign=instagram&popular=true\",\nWhen being precise, refer to the serialized string version as \"search\" and the parsed version as \"search params\", but it's common to use the terms interchangeably when precision isn't important.\nLocation Hash\nHashes in URLs indicate a scroll position\non the current page\n. Before the\nwindow.history.pushState\nAPI was introduced, web developers did client side routing exclusively with the hash portion of the\nURL\n, it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.\nLocation State\nYou may have wondered why the\nwindow.history.pushState()\nAPI is called \"push state\". State? Aren't we just changing the\nURL\n? Shouldn't it be\nhistory.push\n? Well, we weren't in the room when the API was designed, so we're not sure why \"state\" was the focus, but it is a cool feature of browsers nonetheless.\nBrowsers let us persist information about a navigation by passing a value to\npushState\n. When the user clicks back, the value on\nhistory.state\nchanges to whatever was \"pushed\" before.\nwindow\n.\nhistory\n.\npushState\n(\"\nlook ma!\n\",\nundefined\n, \"\n/contact\n\");\nwindow\n.\nhistory\n.\nstate\n;\n// \"look ma!\"\n// user clicks back\nwindow\n.\nhistory\n.\nstate\n;\n// undefined\n// user clicks forward\nwindow\n.\nhistory\n.\nstate\n;\n// \"look ma!\"\nFor illustration. You don't read\nhistory.state\ndirectly in React Router apps\nReact Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the\nlocation\ninstead of\nhistory\n.\nYou can think about\nlocation.state\njust like\nlocation.hash\nor\nlocation.search\nexcept instead of putting the values in the\nURL\nit's hidden--like a super secret piece of the URL only the programmer knows about.\nA couple of great use-cases for location state are:\nTelling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).\nSending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.\nYou set location state in two ways: on\n<Link>\nor\nnavigate\n:\n<\nLink\nto\n=\n\"\n/pins/123\n\"\nstate\n=\n{\n{ fromDashboard:\ntrue\n}\n}\n/>;\nlet\nnavigate\n=\nuseNavigate\n();\nnavigate\n(\"\n/users/123\n\", { state:\npartialUser\n});\nAnd on the next page you can access it with\nuseLocation\n:\nlet\nlocation\n=\nuseLocation\n();\nlocation\n.\nstate\n;\nLocation state values will get serialized, so something like\nnew Date()\nwill be turned into a string.\nLocation Key\nEach location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object,\nnew Map()\n, or even\nlocationStorage\n.\nFor example, a very basic client side data cache could store values by location key (and the fetch\nURL\n) and skip fetching the data when the user clicks back into it:\nlet\ncache\n=\nnew\nMap\n();\nfunction\nuseFakeFetch\n(\nURL\n) {\nlet\nlocation\n=\nuseLocation\n();\nlet\ncacheKey\n=\nlocation\n.\nkey\n+\nURL\n;\nlet\ncached\n=\ncache\n.\nget\n(\ncacheKey\n);\nlet\n[\ndata\n,\nsetData\n]\n=\nuseState\n(()\n=>\n{\n// initialize from the cache\nreturn\ncached\n||\nnull\n;\n});\nlet\n[\nstate\n,\nsetState\n]\n=\nuseState\n(()\n=>\n{\n// avoid the fetch if cached\nreturn\ncached\n?\n\"\ndone\n\"\n:\n\"\nloading\n\";\n});\nuseEffect\n(()\n=>\n{\nif\n(\nstate\n===\n\"\nloading\n\") {\nlet\ncontroller\n=\nnew\nAbortController\n();\nfetch\n(\nURL\n, { signal:\ncontroller\n.\nsignal\n})\n.\nthen\n((\nres\n)\n=>\nres\n.\njson\n())\n.\nthen\n((\ndata\n)\n=>\n{\nif\n(\ncontroller\n.\nsignal\n.\naborted\n)\nreturn\n;\n// set the cache\ncache\n.\nset\n(\ncacheKey\n,\ndata\n);\nsetData\n(\ndata\n);\n});\nreturn\n()\n=>\ncontroller\n.\nabort\n();\n}\n}, [\nstate\n,\ncacheKey\n]);\nuseEffect\n(()\n=>\n{\nsetState\n(\"\nloading\n\");\n}, [\nURL\n]);\nreturn\ndata\n;\n}\nMatching\nOn the initial render, and when the\nhistory stack\nchanges, React Router will match the\nlocation\nagainst your\nroute config\nto come up with a set of\nmatches\nto render.\nDefining Routes\nA route config is a tree of\nroutes\nthat looks something like this:\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n:teamId/edit\n\"\nelement\n=\n{\n<\nEditTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPrivacy\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nTos\n/>\n}\n/>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\nThe\n<Routes>\ncomponent recurses through its\nprops.children\n, strips their props, and generates an object like this:\nlet\nroutes\n=\n[\n{\nelement: <\nApp\n/>,\npath: \"\n/\n\",\nchildren: [\n{\nindex:\ntrue\n,\nelement: <\nHome\n/>,\n},\n{\npath: \"\nteams\n\",\nelement: <\nTeams\n/>,\nchildren: [\n{\nindex:\ntrue\n,\nelement: <\nLeagueStandings\n/>,\n},\n{\npath: \"\n:teamId\n\",\nelement: <\nTeam\n/>,\n},\n{\npath: \"\n:teamId/edit\n\",\nelement: <\nEditTeam\n/>,\n},\n{\npath: \"\nnew\n\",\nelement: <\nNewTeamForm\n/>,\n},\n],\n},\n],\n},\n{\nelement: <\nPageLayout\n/>,\nchildren: [\n{\nelement: <\nPrivacy\n/>,\npath: \"\n/privacy\n\",\n},\n{\nelement: <\nTos\n/>,\npath: \"\n/tos\n\",\n},\n],\n},\n{\nelement: <\nContact\n/>,\npath: \"\n/contact-us\n\",\n},\n];\nIn fact, instead of\n<Routes>\nyou can use the hook\nuseRoutes(routesGoHere)\ninstead. That's all\n<Routes>\nis doing.\nAs you can see, routes can define multiple\nsegments\nlike\n:teamId/edit\n, or just one like\n:teamId\n. All of the segments down a branch of the\nroute config\nare added together to create a final\npath pattern\nfor a route.\nMatch Params\nNote the\n:teamId\nsegments. This is what we call a\ndynamic segment\nof the\npath pattern\n, meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for\n:teamId\n. Both\n/teams/123\nor\n/teams/cupcakes\nwill match. We call the parsed values\nURL params\n. So in this case our\nteamId\nparam would be\n\"123\"\nor\n\"cupcakes\"\n. We'll see how to use them in your app in the\nRendering\nsection.\nRanking Routes\nIf we add up all the segments of all the branches of our\nroute config\n, we end up with the following path patterns that our app responds to:\n[\n\"\n/\n\",\n\"\n/teams\n\",\n\"\n/teams/:teamId\n\",\n\"\n/teams/:teamId/edit\n\",\n\"\n/teams/new\n\",\n\"\n/privacy\n\",\n\"\n/tos\n\",\n\"\n/contact-us\n\",\n];\nNow this is where things get really interesting. Consider the\nURL\n/teams/new\n. Which pattern in that list matches the URL?\nThat's right, two of them!\n/teams/new\n/teams/:teamId\nReact Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match\n/\nand render the\n<Home/>\ncomponent. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.\nLooking at those patterns, you intuitively know that we want\n/teams/new\nto match the URL\n/teams/new\n. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.\nPathless Routes\nYou may have noticed the weird routes from earlier:\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n/>\nThey don't even have a path, how can they be a route? This is where the word \"route\" in React Router is used pretty loosely.\n<Home/>\nand\n<LeagueStandings/>\nare\nindex routes\nand\n<PageLayout/>\nis a\nlayout route\n. We'll discuss how they work in the\nRendering\nsection. Neither really has much to do with matching.\nRoute Matches\nWhen a route matches the URL, it's represented by a\nmatch\nobject. A match for\n<Route path=\":teamId\" element={<Team/>}/>\nwould look something like this:\n{\npathname\n: \"\n/teams/firebirds\n\",\nparams\n: {\nteamId\n: \"\nfirebirds\n\"\n},\nroute\n: {\nelement\n: <\nTeam\n/>,\npath\n: \"\n:teamId\n\"\n}\n}\npathname\nholds the portion of the URL that matched this route (in our case it's all of it).\nparams\nholds the parsed values from any\ndynamic segments\nthat matched. Note that the param's object keys map directly to the name of the segment:\n:teamId\nbecomes\nparams.teamId\n.\nBecause our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL\n/teams/firebirds\n, it would be the following route branch:\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n:teamId/edit\n\"\nelement\n=\n{\n<\nEditTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPrivacy\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nTos\n/>\n}\n/>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\nReact Router will create an array of\nmatches\nfrom these routes and the url so it can render a nested UI that matches the route nesting.\n[\n{\npathname: \"\n/\n\",\nparams:\nnull\n,\nroute: {\nelement: <\nApp\n/>,\npath: \"\n/\n\",\n},\n},\n{\npathname: \"\n/teams\n\",\nparams:\nnull\n,\nroute: {\nelement: <\nTeams\n/>,\npath: \"\nteams\n\",\n},\n},\n{\npathname: \"\n/teams/firebirds\n\",\nparams: {\nteamId: \"\nfirebirds\n\",\n},\nroute: {\nelement: <\nTeam\n/>,\npath: \"\n:teamId\n\",\n},\n},\n];\nRendering\nThe final concept is rendering. Consider that the entry to your app looks like this:\nconst\nroot\n=\nReactDOM\n.\ncreateRoot\n(\ndocument\n.\ngetElementById\n(\"\nroot\n\")\n);\nroot\n.\nrender\n(\n<\nBrowserRouter\n>\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPrivacy\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nTos\n/>\n}\n/>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\n</\nBrowserRouter\n>\n);\nLet's use the\n/teams/firebirds\nURL as an example again.\n<Routes>\nwill match the\nlocation\nto your\nroute config\n, get a set of\nmatches\n, and then render a React element tree like this:\n<\nApp\n>\n<\nTeams\n>\n<\nTeam\n/>\n</\nTeams\n>\n</\nApp\n>\nEach match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.\nOutlets\nThis nested element tree won't happen automatically.\n<Routes>\nwill render the first match's element for you (In our case that's\n<App/>\n). The next match's element is\n<Teams>\n. In order to render that,\nApp\nneeds to render an\noutlet\n.\nfunction\nApp\n() {\nreturn\n(\n<\ndiv\n>\n<\nGlobalNav\n/>\n<\nOutlet\n/>\n<\nGlobalFooter\n/>\n</\ndiv\n>\n);\n}\nThe\nOutlet\ncomponent will always render the next match. That means\n<Teams>\nalso needs an outlet to render\n<Team/>\n.\nIf the URL were\n/contact-us\n, the element tree would change to:\n<\nContact\n/>\nBecause the contact form is not under the main\n<App>\nroute.\nIf the URL were\n/teams/firebirds/edit\n, the element tree would change to:\n<\nApp\n>\n<\nTeams\n>\n<\nEditTeam\n/>\n</\nTeams\n>\n</\nApp\n>\nThe outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.\nIndex Routes\nRemember the\nroute config\nfor\n/teams\n:\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\nIf the URL were\n/teams/firebirds\n, the element tree would be:\n<\nApp\n>\n<\nTeams\n>\n<\nTeam\n/>\n</\nTeams\n>\n</\nApp\n>\nBut if the URL were\n/teams\n, the element tree would be:\n<\nApp\n>\n<\nTeams\n>\n<\nLeagueStandings\n/>\n</\nTeams\n>\n</\nApp\n>\nLeague standings? How the heck did\n<Route index element={<LeagueStandings>}/>\npop in there? It doesn't even have a path! The reason is that it's an\nindex route\n. Index routes render in their parent route's\noutlet\nat the parent route's path.\nThink of it this way, if you're not at one of the child routes' paths, the\n<Outlet>\nwill render nothing in the UI:\n<\nApp\n>\n<\nTeams\n/>\n</\nApp\n>\nIf all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.\nAnother way to think of an index route is that it's the default child route when the parent matches but none of its children do.\nDepending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want an index route to fill the space when the user hasn't clicked one of the items yet.\nLayout Routes\nHere's a part of our route config we haven't matched yet:\n/privacy\n. Let's look at the route config again, highlighting the matched routes:\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n:teamId/edit\n\"\nelement\n=\n{\n<\nEditTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPrivacy\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nTos\n/>\n}\n/>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\nAnd the resulting element tree rendered will be:\n<\nPageLayout\n>\n<\nPrivacy\n/>\n</\nPageLayout\n>\nDon't forget to add an\n<Outlet>\nto your layout where you would like child route elements to be rendered. Using\n{children}\nwill not work as expected.\nThe\nPageLayout\nroute is admittedly weird. We call it a\nlayout route\nbecause it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:\nYou can do it like this, but we recommend using a layout route\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n:teamId/edit\n\"\nelement\n=\n{\n<\nEditTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPageLayout\n>\n<\nPrivacy\n/>\n</\nPageLayout\n>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nPageLayout\n>\n<\nTos\n/>\n</\nPageLayout\n>\n}\n/>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\nSo, yeah, the semantics of a layout \"route\" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.\nNavigating\nWhen the\nURL\nchanges we call that a \"navigation\". There are two ways to navigate in React Router:\n<Link>\nnavigate\nLink\nThis is the primary means of navigation. Rendering a\n<Link>\nallows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the\nhistory\nto push a new entry into the\nhistory stack\n. The\nlocation\nchanges and the new\nmatches\nwill render.\nHowever, links are accessible in that they:\nStill render a\n<a href>\nso all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)\nDon't prevent the browser's default behavior if it's a right click or command/control click to \"open in new tab\"\nNested routes\naren't just about rendering layouts; they also enable \"relative links\". Consider our\nteams\nroute from before:\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n</\nRoute\n>\nThe\n<Teams>\ncomponent can render links like:\n<\nLink\nto\n=\n\"\npsg\n\" />\n<\nLink\nto\n=\n\"\nnew\n\" />\nThe full path it links to will be\n/teams/psg\nand\n/teams/new\n. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more\nsegment\ndeeper. You can rearrange your whole\nroute config\nand these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.\nNavigate Function\nThis function is returned from the\nuseNavigate\nhook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:\nlet\nnavigate\n=\nuseNavigate\n();\nuseEffect\n(()\n=>\n{\nsetTimeout\n(()\n=>\n{\nnavigate\n(\"\n/logout\n\");\n},\n30000\n);\n}, []);\nOr after a form is submitted:\n<\nform\nonSubmit\n=\n{\nevent\n=>\n{\nevent\n.\npreventDefault\n();\nlet\ndata\n=\nnew\nFormData\n(\nevent\n.\ntarget\n)\nlet\nurlEncoded\n=\nnew\nURLSearchParams\n(\ndata\n)\nnavigate\n(\"\n/create\n\", { state:\nurlEncoded\n})\n}\n}\n>\nLike\nLink\n,\nnavigate\nworks with nested \"to\" values as well.\nnavigate\n(\"\npsg\n\");\nYou should have a good reason to use\nnavigate\ninstead of\n<Link>\n. This makes us very sad:\n<\nli\nonClick\n=\n{\n()\n=>\nnavigate\n(\"\n/somewhere\n\")\n}\n/>\nAside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.\nData Access\nFinally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks\nlet\nlocation\n=\nuseLocation\n();\nlet\nurlParams\n=\nuseParams\n();\nlet\n[\nurlSearchParams\n]\n=\nuseSearchParams\n();\nReview\nLet's put it all together from the top!\nYou render your app:\nconst\nroot\n=\nReactDOM\n.\ncreateRoot\n(\ndocument\n.\ngetElementById\n(\"\nroot\n\")\n);\nroot\n.\nrender\n(\n<\nBrowserRouter\n>\n<\nRoutes\n>\n<\nRoute\npath\n=\n\"\n/\n\"\nelement\n=\n{\n<\nApp\n/>\n}\n>\n<\nRoute\nindex\nelement\n=\n{\n<\nHome\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nteams\n\"\nelement\n=\n{\n<\nTeams\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n:teamId\n\"\nelement\n=\n{\n<\nTeam\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\nnew\n\"\nelement\n=\n{\n<\nNewTeamForm\n/>\n}\n/>\n<\nRoute\nindex\nelement\n=\n{\n<\nLeagueStandings\n/>\n}\n/>\n</\nRoute\n>\n</\nRoute\n>\n<\nRoute\nelement\n=\n{\n<\nPageLayout\n/>\n}\n>\n<\nRoute\npath\n=\n\"\n/privacy\n\"\nelement\n=\n{\n<\nPrivacy\n/>\n}\n/>\n<\nRoute\npath\n=\n\"\n/tos\n\"\nelement\n=\n{\n<\nTos\n/>\n}\n/>\n</\nRoute\n>\n<\nRoute\npath\n=\n\"\ncontact-us\n\"\nelement\n=\n{\n<\nContact\n/>\n}\n/>\n</\nRoutes\n>\n</\nBrowserRouter\n>\n);\n<BrowserRouter>\ncreates a\nhistory\n, puts the initial\nlocation\nin to state, and subscribes to the\nURL\n.\n<Routes>\nrecurses its\nchild routes\nto build a\nroute config\n, matches those routes against the\nlocation\n, creates some route\nmatches\n, and renders the first match's route element.\nYou render an\n<Outlet/>\nin each\nparent route\n.\nThe outlets render the next match in the route\nmatches\n.\nThe user clicks a link\nThe link calls\nnavigate()\nThe\nhistory\nchanges the URL and notifies\n<BrowserRouter>\n.\n<BrowserRouter>\nrerenders, start over at (2)!\nThat's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.\nBrand Assets\n\u2022\nDocs and examples\nCC 4.0\nEdit",
  "content_markdown": "![](/assets/icons-DI88m4Yf.svg)\n\n6.28.0\n\nBranches\n\n[latest (7.13.0)](/home)[dev](/dev/)\n\nVersions\n\n[7.13.0](/7.13.0/home)[6.30.3](/6.30.3)[v4/5.x](https://v5.reactrouter.com/)[v3.x](https://github.com/remix-run/react-router/tree/v3.2.6/docs)\n\nSearch\n\nLight Dark System\n\nMain Concepts\n\nCopy Page\n\n[Copy PageCopy Page as Markdown](https://raw.githubusercontent.com/remix-run/react-router/refs/tags/react-router@6.28.0/docs/start/concepts.md)\n\n- [Definitions](/6.28.0/start/concepts#definitions)\n- [History and Locations](/6.28.0/start/concepts#history-and-locations)\n- [History Object](/6.28.0/start/concepts#history-object)\n- [Locations](/6.28.0/start/concepts#locations)\n- [Matching](/6.28.0/start/concepts#matching)\n- [Defining Routes](/6.28.0/start/concepts#defining-routes)\n- [Match Params](/6.28.0/start/concepts#match-params)\n- [Ranking Routes](/6.28.0/start/concepts#ranking-routes)\n- [Pathless Routes](/6.28.0/start/concepts#pathless-routes)\n- [Route Matches](/6.28.0/start/concepts#route-matches)\n- [Rendering](/6.28.0/start/concepts#rendering)\n- [Outlets](/6.28.0/start/concepts#outlets)\n- [Index Routes](/6.28.0/start/concepts#index-routes)\n- [Layout Routes](/6.28.0/start/concepts#layout-routes)\n- [Navigating](/6.28.0/start/concepts#navigating)\n- [Link](/6.28.0/start/concepts#link)\n- [Navigate Function](/6.28.0/start/concepts#navigate-function)\n- [Data Access](/6.28.0/start/concepts#data-access)\n- [Review](/6.28.0/start/concepts#review)\n\nOn this page\n\n- [Definitions](/6.28.0/start/concepts#definitions)\n- [History and Locations](/6.28.0/start/concepts#history-and-locations)\n- [History Object](/6.28.0/start/concepts#history-object)\n- [Locations](/6.28.0/start/concepts#locations)\n- [Matching](/6.28.0/start/concepts#matching)\n- [Defining Routes](/6.28.0/start/concepts#defining-routes)\n- [Match Params](/6.28.0/start/concepts#match-params)\n- [Ranking Routes](/6.28.0/start/concepts#ranking-routes)\n- [Pathless Routes](/6.28.0/start/concepts#pathless-routes)\n- [Route Matches](/6.28.0/start/concepts#route-matches)\n- [Rendering](/6.28.0/start/concepts#rendering)\n- [Outlets](/6.28.0/start/concepts#outlets)\n- [Index Routes](/6.28.0/start/concepts#index-routes)\n- [Layout Routes](/6.28.0/start/concepts#layout-routes)\n- [Navigating](/6.28.0/start/concepts#navigating)\n- [Link](/6.28.0/start/concepts#link)\n- [Navigate Function](/6.28.0/start/concepts#navigate-function)\n- [Data Access](/6.28.0/start/concepts#data-access)\n- [Review](/6.28.0/start/concepts#review)\n\n# Main Concepts\n\nThis document needs to be updated for 6.4 data APIs\n\nThis document is a deep dive into the core concepts behind routing as implemented in React Router. It's pretty long, so if you're looking for a more practical guide check out our [quick start tutorial](./tutorial).\n\nYou might be wondering what exactly React Router does. How can it help you build your app? What exactly is a **router**, anyway?\n\nIf you've ever had any of these questions, or you'd just like to dig into the fundamental pieces of routing, you're in the right place. This document contains detailed explanations of all the core concepts behind routing as implemented in React Router.\n\nPlease don't let this document overwhelm you! For everyday use, React Router is pretty simple. You don't need to go this deep to use it.\n\nReact Router isn't just about matching a url to a function or component: it's about building a full user interface that maps to the URL, so it might have more concepts in it than you're used to. We'll go into detail on the three main jobs of React Router:\n\n1. Subscribing and manipulating the [history stack](#history-stack)\n2. Matching the [URL](#url) to your [routes](#route-config)\n3. Rendering a nested UI from the [route matches](#matches)\n\n## Definitions\n\nBut first, some definitions! There are a lot of different ideas around routing from back and front end frameworks. Sometimes a word in one context might have different meaning than another.\n\nHere are some words we use a lot when we talk about React Router. The rest of this guide will go into more detail on each one.\n\n- **URL** - The URL in the address bar. A lot of people use the term \"URL\" and \"route\" interchangeably, but this is not a route in React Router, it's just a URL.\n- **Location** - This is a React Router specific object that is based on the built-in browser's `window.location` object. It represents \"where the user is at\". It's mostly an object representation of the URL but has a bit more to it than that.\n- **Location State** - A value that persists with a [location](#location) that isn't encoded in the [URL](#url). Much like hash or search params (data encoded in the URL), but stored invisibly in the browser's memory.\n- **History Stack** - As the user navigates, the browser keeps track of each [location](#location) in a stack. If you click and hold the back button in a browser you can see the browser's history stack right there.\n- **Client Side Routing (CSR)** - A plain HTML document can link to other documents and the browser handles the [history stack](#history-stack) itself. Client Side Routing enables developers to manipulate the browser history stack without making a document request to the server.\n- **History** - An object that allows React Router to subscribe to changes in the [URL](#url) as well as providing APIs to manipulate the browser [history stack](#history-stack) programmatically.\n- **History Action** - One of `POP`, `PUSH`, or `REPLACE`. Users can arrive at a [URL](#url) for one of these three reasons. A push when a new entry is added to the history stack (typically a link click or the programmer forced a navigation). A replace is similar except it replaces the current entry on the stack instead of pushing a new one. Finally, a pop happens when the user clicks the back or forward buttons in the browser chrome.\n- **Segment** - The parts of a [URL](#url) or [path pattern](#path-pattern) between the `/` characters. For example, \"/users/123\" has two segments.\n- **Path Pattern** - These look like URLs but can have special characters for matching URLs to routes, like **dynamic segments** (`\"/users/:userId\"`) or **star segments** (`\"/docs/*\"`). They aren't URLs, they're patterns that React Router will match.\n- **Dynamic Segment** - A segment of a path pattern that is dynamic, meaning it can match any values in the segment. For example the pattern `/users/:userId` will match URLs like `/users/123`\n- **URL Params** - The parsed values from the URL that matched a [dynamic segment](#dynamic-segment).\n- **Router** - Stateful, top-level component that makes all the other components and hooks work.\n- **Route Config** - A tree of **routes objects** that will be ranked and matched (with nesting) against the current location to create a branch of **route matches**.\n- **Route** - An object or Route Element typically with a shape of `{ path, element }` or `<Route path element>`. The `path` is a path pattern. When the path pattern matches the current URL, the element will be rendered.\n- **Route Element** - Or `<Route>`. This element's props are read to create a [route](#route) by `<Routes>`, but otherwise does nothing.\n- **Nested Routes** - Because routes can have children and each route defines a portion of the [URL](#url) through [segments](#segment), a single URL can match multiple routes in a nested \"branch\" of the tree. This enables automatic layout nesting through [outlet](#outlet), [relative links](#relative-links), and more.\n- **Relative links** - Links that don't start with `/` will inherit the closest route in which they are rendered. This makes it easy to link to deeper URLs without having to know and build up the entire path.\n- **Match** - An object that holds information when a route matches the URL, like the [url params](#url-params) and pathname that matched.\n- **Matches** - An array of routes (or branch of the [route config](#route-config)) that matches the current [location](#location). This structure enables [nested routes](#nested-routes).\n- **Parent Route** - A route with child routes.\n- **Outlet** - A component that renders the next match in a set of [matches](#match).\n- **Index Route** - A child route with no path that renders in the parent's [outlet](#outlet) at the parent's [URL](#url).\n- **Layout Route** - A **parent route** without a path, used exclusively for grouping child routes inside a specific layout.\n\n## History and Locations\n\nBefore React Router can do anything, it has to be able to subscribe to changes in the browser [history stack](#history-stack).\n\nBrowsers maintain their own history stack as the user navigates around. That's how the back and forward buttons can work. In a traditional website (HTML documents without JavaScript) the browser will make requests to the server every time the user clicks a link, submits a form, or clicks the back and forward buttons.\n\nFor example, consider the user:\n\n1. clicks a link to `/dashboard`\n2. clicks a link to `/accounts`\n3. clicks a link to `/customers/123`\n4. clicks the back button\n5. clicks a link to `/dashboard`\n\nThe history stack will change as follows where **bold** entries denote the current [URL](#url):\n\n1. **`/dashboard`**\n2. `/dashboard`, **`/accounts`**\n3. `/dashboard`, `/accounts`, **`/customers/123`**\n4. `/dashboard`, **`/accounts`**, `/customers/123`\n5. `/dashboard`, `/accounts`, **`/dashboard`**\n\n### History Object\n\nWith **client side routing**, developers are able to manipulate the browser [history stack](#history-stack) programmatically. For example, we can write some code like this to change the [URL](#url) without the browsers default behavior of making a request to the server:\n\n```\n<a\n  href=\"/contact\"\n  onClick={(event) => {\n    // stop the browser from changing the URL and requesting the new document\n    event.preventDefault();\n    // push an entry into the browser history stack and change the URL\n    window.history.pushState({}, undefined, \"/contact\");\n  }}\n/>\n```\n\nFor illustration only, don't use `window.history.pushState` directly in React Router\n\nThis code changes the [URL](#url) but doesn't do anything for the UI. We would need to write some more code that changed some state somewhere to get the UI to change to the contact page. The trouble is, the browser doesn't give us a way to \"listen to the URL\" and subscribe to changes like this.\n\nWell, that's not totally true. We can listen for changes to the URL via [pop](#history-actions) events:\n\n```\nwindow.addEventListener(\"popstate\", () => {\n  // URL changed!\n});\n```\n\nBut that only fires when the user clicks the back or forward buttons. There is no event for when the programmer called `window.history.pushState` or `window.history.replaceState`.\n\nThat's where a React Router specific `history` object comes into play. It provides a way to \"listen for [URL](#url)\" changes whether the [history action](#history-actions) is **push**, **pop**, or **replace**.\n\n```\nlet history = createBrowserHistory();\nhistory.listen(({ location, action }) => {\n  // this is called whenever new locations come in\n  // the action is POP, PUSH, or REPLACE\n});\n```\n\nApps don't need to set up their own history objects--that's the job of `<Router>`. It sets up one of these objects, subscribe to changes in the [history stack](#history-stack), and finally updates its state when the [URL](#url) changes. This causes the app to re-render and the correct UI to display. The only thing it needs to put on state is a `location`, everything else works from that single object.\n\n### Locations\n\nThe browser has a location object on `window.location`. It tells you information about the [URL](#url) but also has some methods to change it:\n\n```\nwindow.location.pathname; // /getting-started/concepts/\nwindow.location.hash; // #location\nwindow.location.reload(); // force a refresh w/ the server\n// and a lot more\n```\n\nFor illustration. You don't typically work with `window.location` in a React Router app\n\nInstead of using `window.location`, React Router has the concept of a [location](#location) that's patterned after `window.location` but is much simpler. It looks like this:\n\n```\n{\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram\",\n  hash: \"#menu\",\n  state: null,\n  key: \"aefz24ie\"\n}\n```\n\nThe first three: `{ pathname, search, hash }` are exactly like `window.location`. If you just add up the three you'll get the [URL](#url) the user sees in the browser:\n\n```\nlocation.pathname + location.search + location.hash;\n// /bbq/pig-pickins?campaign=instagram#menu\n```\n\nThe last two, `{ state, key }`, are React Router specific.\n\n**Location Pathname**\n\nThis is the part of [URL](#url) after the origin, so for `https://example.com/teams/hotspurs` the pathname is `/teams/hotspurs`. This is the only part of the location that routes match against.\n\n**Location Search**\n\nPeople use a lot of different terms for this part of the [URL](#url):\n\n- location search\n- search params\n- URL search params\n- query string\n\nIn React Router we call it the \"location search\". However, location search is a serialized version of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). So sometimes we might call it \"URL search params\" as well.\n\n```\n// given a location like this:\nlet location = {\n  pathname: \"/bbq/pig-pickins\",\n  search: \"?campaign=instagram&popular=true\",\n  hash: \"\",\n  state: null,\n  key: \"aefz24ie\",\n};\n\n// we can turn the location.search into URLSearchParams\nlet params = new URLSearchParams(location.search);\nparams.get(\"campaign\"); // \"instagram\"\nparams.get(\"popular\"); // \"true\"\nparams.toString(); // \"campaign=instagram&popular=true\",\n```\n\nWhen being precise, refer to the serialized string version as \"search\" and the parsed version as \"search params\", but it's common to use the terms interchangeably when precision isn't important.\n\n**Location Hash**\n\nHashes in URLs indicate a scroll position *on the current page*. Before the `window.history.pushState` API was introduced, web developers did client side routing exclusively with the hash portion of the [URL](#url), it was the only part we could manipulate without making a new request to the server. However, today we can use it for its designed purpose.\n\n**Location State**\n\nYou may have wondered why the `window.history.pushState()` API is called \"push state\". State? Aren't we just changing the [URL](#url)? Shouldn't it be `history.push`? Well, we weren't in the room when the API was designed, so we're not sure why \"state\" was the focus, but it is a cool feature of browsers nonetheless.\n\nBrowsers let us persist information about a navigation by passing a value to `pushState`. When the user clicks back, the value on `history.state` changes to whatever was \"pushed\" before.\n\n```\nwindow.history.pushState(\"look ma!\", undefined, \"/contact\");\nwindow.history.state; // \"look ma!\"\n// user clicks back\nwindow.history.state; // undefined\n// user clicks forward\nwindow.history.state; // \"look ma!\"\n```\n\nFor illustration. You don't read `history.state` directly in React Router apps\n\nReact Router takes advantage of this browser feature, abstracts it a bit, and surfaces the values on the `location` instead of `history`.\n\nYou can think about `location.state` just like `location.hash` or `location.search` except instead of putting the values in the [URL](#url) it's hidden--like a super secret piece of the URL only the programmer knows about.\n\nA couple of great use-cases for location state are:\n\n- Telling the next page where the user came from and branching the UI. The most popular implementation here is showing a record in a modal if the user clicked on an item in a grid view, but if they show up to the URL directly, show the record in its own layout (pinterest, old instagram).\n- Sending a partial record from a list to the next screen so it can render the partial data immediately and then fetching the rest of the data afterward.\n\nYou set location state in two ways: on `<Link>` or `navigate`:\n\n```\n<Link to=\"/pins/123\" state={{ fromDashboard: true }} />;\n\nlet navigate = useNavigate();\nnavigate(\"/users/123\", { state: partialUser });\n```\n\nAnd on the next page you can access it with `useLocation`:\n\n```\nlet location = useLocation();\nlocation.state;\n```\n\nLocation state values will get serialized, so something like `new Date()` will be turned into a string.\n\n**Location Key**\n\nEach location gets a unique key. This is useful for advanced cases like location-based scroll management, client side data caching, and more. Because each new location gets a unique key, you can build abstractions that store information in a plain object, `new Map()`, or even `locationStorage`.\n\nFor example, a very basic client side data cache could store values by location key (and the fetch [URL](#url)) and skip fetching the data when the user clicks back into it:\n\n```\nlet cache = new Map();\n\nfunction useFakeFetch(URL) {\n  let location = useLocation();\n  let cacheKey = location.key + URL;\n  let cached = cache.get(cacheKey);\n\n  let [data, setData] = useState(() => {\n    // initialize from the cache\n    return cached || null;\n  });\n\n  let [state, setState] = useState(() => {\n    // avoid the fetch if cached\n    return cached ? \"done\" : \"loading\";\n  });\n\n  useEffect(() => {\n    if (state === \"loading\") {\n      let controller = new AbortController();\n      fetch(URL, { signal: controller.signal })\n        .then((res) => res.json())\n        .then((data) => {\n          if (controller.signal.aborted) return;\n          // set the cache\n          cache.set(cacheKey, data);\n          setData(data);\n        });\n      return () => controller.abort();\n    }\n  }, [state, cacheKey]);\n\n  useEffect(() => {\n    setState(\"loading\");\n  }, [URL]);\n\n  return data;\n}\n```\n\n## Matching\n\nOn the initial render, and when the [history stack](#history-stack) changes, React Router will match the [location](#location) against your [route config](#route-config) to come up with a set of [matches](#match) to render.\n\n### Defining Routes\n\nA route config is a tree of [routes](#route) that looks something like this:\n\n```\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nThe `<Routes>` component recurses through its `props.children`, strips their props, and generates an object like this:\n\n```\nlet routes = [\n  {\n    element: <App />,\n    path: \"/\",\n    children: [\n      {\n        index: true,\n        element: <Home />,\n      },\n      {\n        path: \"teams\",\n        element: <Teams />,\n        children: [\n          {\n            index: true,\n            element: <LeagueStandings />,\n          },\n          {\n            path: \":teamId\",\n            element: <Team />,\n          },\n          {\n            path: \":teamId/edit\",\n            element: <EditTeam />,\n          },\n          {\n            path: \"new\",\n            element: <NewTeamForm />,\n          },\n        ],\n      },\n    ],\n  },\n  {\n    element: <PageLayout />,\n    children: [\n      {\n        element: <Privacy />,\n        path: \"/privacy\",\n      },\n      {\n        element: <Tos />,\n        path: \"/tos\",\n      },\n    ],\n  },\n  {\n    element: <Contact />,\n    path: \"/contact-us\",\n  },\n];\n```\n\nIn fact, instead of `<Routes>` you can use the hook `useRoutes(routesGoHere)` instead. That's all `<Routes>` is doing.\n\nAs you can see, routes can define multiple [segments](#segment) like `:teamId/edit`, or just one like `:teamId`. All of the segments down a branch of the [route config](#route-config) are added together to create a final [path pattern](#path-pattern) for a route.\n\n### Match Params\n\nNote the `:teamId` segments. This is what we call a [dynamic segment](#dynamic-segment) of the [path pattern](#path-pattern), meaning it doesn't match the URL statically (the actual characters) but it matches it dynamically. Any value can fill in for `:teamId`. Both `/teams/123` or `/teams/cupcakes` will match. We call the parsed values [URL params](#url-params). So in this case our `teamId` param would be `\"123\"` or `\"cupcakes\"`. We'll see how to use them in your app in the [Rendering](#rendering) section.\n\n### Ranking Routes\n\nIf we add up all the segments of all the branches of our [route config](#route-config), we end up with the following path patterns that our app responds to:\n\n```\n[\n  \"/\",\n  \"/teams\",\n  \"/teams/:teamId\",\n  \"/teams/:teamId/edit\",\n  \"/teams/new\",\n  \"/privacy\",\n  \"/tos\",\n  \"/contact-us\",\n];\n```\n\nNow this is where things get really interesting. Consider the [URL](#url) `/teams/new`. Which pattern in that list matches the URL?\n\nThat's right, two of them!\n\n```\n/teams/new\n/teams/:teamId\n```\n\nReact Router has to make a decision here, there can be only one. Many routers, both client side and server side, will simply process the patterns in the order in which they were defined. First to match wins. In this case we would match `/` and render the `<Home/>` component. Definitely not what we wanted. These kinds of routers require us to order our routes perfectly to get the expected result. This is how React Router has worked up until v6, but now it's much smarter.\n\nLooking at those patterns, you intuitively know that we want `/teams/new` to match the URL `/teams/new`. It's a perfect match! React Router also knows that. When matching, it will rank your routes according the number of segments, static segments, dynamic segments, star patterns, etc. and pick the most specific match. You'll never have to think about ordering your routes.\n\n### Pathless Routes\n\nYou may have noticed the weird routes from earlier:\n\n```\n<Route index element={<Home />} />\n<Route index element={<LeagueStandings />} />\n<Route element={<PageLayout />} />\n```\n\nThey don't even have a path, how can they be a route? This is where the word \"route\" in React Router is used pretty loosely. `<Home/>` and `<LeagueStandings/>` are [index routes](#index-route) and `<PageLayout/>` is a [layout route](#layout-route). We'll discuss how they work in the [Rendering](#rendering) section. Neither really has much to do with matching.\n\n### Route Matches\n\nWhen a route matches the URL, it's represented by a [match](#match) object. A match for `<Route path=\":teamId\" element={<Team/>}/>` would look something like this:\n\n```\n{\n  pathname: \"/teams/firebirds\",\n  params: {\n    teamId: \"firebirds\"\n  },\n  route: {\n    element: <Team />,\n    path: \":teamId\"\n  }\n}\n```\n\n`pathname` holds the portion of the URL that matched this route (in our case it's all of it). `params` holds the parsed values from any [dynamic segments](#dynamic-segment) that matched. Note that the param's object keys map directly to the name of the segment: `:teamId` becomes `params.teamId`.\n\nBecause our routes are a tree, a single URL can match an entire branch of the tree. Consider the URL `/teams/firebirds`, it would be the following route branch:\n\n```\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nReact Router will create an array of [matches](#match) from these routes and the url so it can render a nested UI that matches the route nesting.\n\n```\n[\n  {\n    pathname: \"/\",\n    params: null,\n    route: {\n      element: <App />,\n      path: \"/\",\n    },\n  },\n  {\n    pathname: \"/teams\",\n    params: null,\n    route: {\n      element: <Teams />,\n      path: \"teams\",\n    },\n  },\n  {\n    pathname: \"/teams/firebirds\",\n    params: {\n      teamId: \"firebirds\",\n    },\n    route: {\n      element: <Team />,\n      path: \":teamId\",\n    },\n  },\n];\n```\n\n## Rendering\n\nThe final concept is rendering. Consider that the entry to your app looks like this:\n\n```\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\")\n);\nroot.render(\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<App />}>\n        <Route index element={<Home />} />\n        <Route path=\"teams\" element={<Teams />}>\n          <Route path=\":teamId\" element={<Team />} />\n          <Route path=\"new\" element={<NewTeamForm />} />\n          <Route index element={<LeagueStandings />} />\n        </Route>\n      </Route>\n      <Route element={<PageLayout />}>\n        <Route path=\"/privacy\" element={<Privacy />} />\n        <Route path=\"/tos\" element={<Tos />} />\n      </Route>\n      <Route path=\"contact-us\" element={<Contact />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\nLet's use the `/teams/firebirds` URL as an example again. `<Routes>` will match the [location](#location) to your [route config](#route-config), get a set of [matches](#match), and then render a React element tree like this:\n\n```\n<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n```\n\nEach match rendered inside the parent route's element is a really powerful abstraction. Most websites and apps share this characteristic: boxes inside of boxes inside of boxes, each with a navigation section that changes a child section of the page.\n\n### Outlets\n\nThis nested element tree won't happen automatically. `<Routes>` will render the first match's element for you (In our case that's `<App/>`). The next match's element is `<Teams>`. In order to render that, `App` needs to render an [outlet](#outlet).\n\n```\nfunction App() {\n  return (\n    <div>\n      <GlobalNav />\n      <Outlet />\n      <GlobalFooter />\n    </div>\n  );\n}\n```\n\nThe `Outlet` component will always render the next match. That means `<Teams>` also needs an outlet to render `<Team/>`.\n\nIf the URL were `/contact-us`, the element tree would change to:\n\n```\n<Contact />\n```\n\nBecause the contact form is not under the main `<App>` route.\n\nIf the URL were `/teams/firebirds/edit`, the element tree would change to:\n\n```\n<App>\n  <Teams>\n    <EditTeam />\n  </Teams>\n</App>\n```\n\nThe outlet swaps out the child for the new child that matches, but the parent layout persists. It's subtle but very effective at cleaning up your components.\n\n### Index Routes\n\nRemember the [route config](#route-config) for `/teams`:\n\n```\n<Route path=\"teams\" element={<Teams />}>\n  <Route path=\":teamId\" element={<Team />} />\n  <Route path=\"new\" element={<NewTeamForm />} />\n  <Route index element={<LeagueStandings />} />\n</Route>\n```\n\nIf the URL were `/teams/firebirds`, the element tree would be:\n\n```\n<App>\n  <Teams>\n    <Team />\n  </Teams>\n</App>\n```\n\nBut if the URL were `/teams`, the element tree would be:\n\n```\n<App>\n  <Teams>\n    <LeagueStandings />\n  </Teams>\n</App>\n```\n\nLeague standings? How the heck did `<Route index element={<LeagueStandings>}/>` pop in there? It doesn't even have a path! The reason is that it's an [index route](#index-route). Index routes render in their parent route's [outlet](#outlet) at the parent route's path.\n\nThink of it this way, if you're not at one of the child routes' paths, the `<Outlet>` will render nothing in the UI:\n\n```\n<App>\n  <Teams />\n</App>\n```\n\nIf all the teams are in a list on the left then an empty outlet means you've got a blank page on the right! Your UI needs something to fill the space: index routes to the rescue.\n\nAnother way to think of an index route is that it's the default child route when the parent matches but none of its children do.\n\nDepending on the user interface, you might not need an index route, but if there is any sort of persistent navigation in the parent route you'll most likely want an index route to fill the space when the user hasn't clicked one of the items yet.\n\n### Layout Routes\n\nHere's a part of our route config we haven't matched yet: `/privacy`. Let's look at the route config again, highlighting the matched routes:\n\n```\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route element={<PageLayout />}>\n    <Route path=\"/privacy\" element={<Privacy />} />\n    <Route path=\"/tos\" element={<Tos />} />\n  </Route>\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nAnd the resulting element tree rendered will be:\n\n```\n<PageLayout>\n  <Privacy />\n</PageLayout>\n```\n\nDon't forget to add an `<Outlet>` to your layout where you would like child route elements to be rendered. Using `{children}` will not work as expected.\n\nThe `PageLayout` route is admittedly weird. We call it a [layout route](#layout-route) because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app:\n\nYou can do it like this, but we recommend using a layout route\n\n```\n<Routes>\n  <Route path=\"/\" element={<App />}>\n    <Route index element={<Home />} />\n    <Route path=\"teams\" element={<Teams />}>\n      <Route path=\":teamId\" element={<Team />} />\n      <Route path=\":teamId/edit\" element={<EditTeam />} />\n      <Route path=\"new\" element={<NewTeamForm />} />\n      <Route index element={<LeagueStandings />} />\n    </Route>\n  </Route>\n  <Route\n    path=\"/privacy\"\n    element={\n      <PageLayout>\n        <Privacy />\n      </PageLayout>\n    }\n  />\n  <Route\n    path=\"/tos\"\n    element={\n      <PageLayout>\n        <Tos />\n      </PageLayout>\n    }\n  />\n  <Route path=\"contact-us\" element={<Contact />} />\n</Routes>\n```\n\nSo, yeah, the semantics of a layout \"route\" is a bit silly since it has nothing to do with the URL matching, but it's just too convenient to disallow.\n\n## Navigating\n\nWhen the [URL](#url) changes we call that a \"navigation\". There are two ways to navigate in React Router:\n\n- `<Link>`\n- `navigate`\n\n### Link\n\nThis is the primary means of navigation. Rendering a `<Link>` allows the user to change the URL when they click it. React Router will prevent the browser's default behavior and tell the [history](#history) to push a new entry into the [history stack](#history-stack). The [location](#location) changes and the new [matches](#match) will render.\n\nHowever, links are accessible in that they:\n\n- Still render a `<a href>` so all default accessibility concerns are met (like keyboard, focusability, SEO, etc.)\n- Don't prevent the browser's default behavior if it's a right click or command/control click to \"open in new tab\"\n\n[Nested routes](#nested-routes) aren't just about rendering layouts; they also enable \"relative links\". Consider our `teams` route from before:\n\n```\n<Route path=\"teams\" element={<Teams />}>\n  <Route path=\":teamId\" element={<Team />} />\n</Route>\n```\n\nThe `<Teams>` component can render links like:\n\n```\n<Link to=\"psg\" />\n<Link to=\"new\" />\n```\n\nThe full path it links to will be `/teams/psg` and `/teams/new`. They inherit the route within which they are rendered. This makes it so your route components don't have to really know anything about the rest of the routes in the app. A very large amount of links just go one more [segment](#segment) deeper. You can rearrange your whole [route config](#route-config) and these links will likely still work just fine. This is very valuable when building out a site in the beginning and the designs and layouts are shifting around.\n\n### Navigate Function\n\nThis function is returned from the `useNavigate` hook and allows you, the programmer, to change the URL whenever you want. You could do it on a timeout:\n\n```\nlet navigate = useNavigate();\nuseEffect(() => {\n  setTimeout(() => {\n    navigate(\"/logout\");\n  }, 30000);\n}, []);\n```\n\nOr after a form is submitted:\n\n```\n<form onSubmit={event => {\n  event.preventDefault();\n  let data = new FormData(event.target)\n  let urlEncoded = new URLSearchParams(data)\n  navigate(\"/create\", { state: urlEncoded })\n}}>\n```\n\nLike `Link`, `navigate` works with nested \"to\" values as well.\n\n```\nnavigate(\"psg\");\n```\n\nYou should have a good reason to use `navigate` instead of `<Link>`. This makes us very sad:\n\n```\n<li onClick={() => navigate(\"/somewhere\")} />\n```\n\nAside from links and forms, very few interactions should change the URL because it introduces complexity around accessibility and user expectations.\n\n## Data Access\n\nFinally, an application is going to want to ask React Router for a few pieces of information in order to build out the full UI. For this, React Router has a pile of hooks\n\n```\nlet location = useLocation();\nlet urlParams = useParams();\nlet [urlSearchParams] = useSearchParams();\n```\n\n## Review\n\nLet's put it all together from the top!\n\n1. You render your app:\n\n   ```\n   const root = ReactDOM.createRoot(\n     document.getElementById(\"root\")\n   );\n   root.render(\n     <BrowserRouter>\n       <Routes>\n         <Route path=\"/\" element={<App />}>\n           <Route index element={<Home />} />\n           <Route path=\"teams\" element={<Teams />}>\n             <Route path=\":teamId\" element={<Team />} />\n             <Route path=\"new\" element={<NewTeamForm />} />\n             <Route index element={<LeagueStandings />} />\n           </Route>\n         </Route>\n         <Route element={<PageLayout />}>\n           <Route path=\"/privacy\" element={<Privacy />} />\n           <Route path=\"/tos\" element={<Tos />} />\n         </Route>\n         <Route path=\"contact-us\" element={<Contact />} />\n       </Routes>\n     </BrowserRouter>\n   );\n   ```\n2. `<BrowserRouter>` creates a [history](#history), puts the initial [location](#location) in to state, and subscribes to the [URL](#url).\n3. `<Routes>` recurses its [child routes](#child-route) to build a [route config](#route-config), matches those routes against the [location](#location), creates some route [matches](#match), and renders the first match's route element.\n4. You render an [`<Outlet/>`](#outlet) in each [parent route](#parent-route).\n5. The outlets render the next match in the route [matches](#match).\n6. The user clicks a link\n7. The link calls `navigate()`\n8. The [history](#history) changes the URL and notifies `<BrowserRouter>`.\n9. `<BrowserRouter>` rerenders, start over at (2)!\n\nThat's it! We hope this guide has helped you gain a deeper understanding of the main concepts in React Router.\n\n[Brand Assets](/brand)\n\n\u2022\n\nDocs and examples [CC 4.0](https://creativecommons.org/licenses/by/4.0/)\n\nEdit",
  "tags": [
    "react-router",
    "routing",
    "react"
  ],
  "extracted_at": "2026-02-03T12:52:11.441831+00:00",
  "content_length": 30709,
  "content_hash": "4af1adffcc694ed0"
}