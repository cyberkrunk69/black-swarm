{
  "id": "tanstack-router__router_latest_docs_framework_react_guide_navigati",
  "source_id": "tanstack-router",
  "source_name": "TanStack Router",
  "category": "navigation_patterns",
  "url": "https://tanstack.com/router/latest/docs/framework/react/guide/navigation",
  "title": "Navigation",
  "content": "Everything is Relative\nBelieve it or not, every navigation within an app is\nrelative\n, even if you aren't using explicit relative path syntax (\n../../somewhere\n). Any time a link is clicked or an imperative navigation call is made, you will always have an\norigin\npath and a\ndestination\npath which means you are navigating\nfrom\none route\nto\nanother route.\nTanStack Router keeps this constant concept of relative navigation in mind for every navigation, so you'll constantly see two properties in the API:\nfrom\n- The origin route path\nto\n- The destination route path\n\u26a0\ufe0f If a\nfrom\nroute path isn't provided the router will assume you are navigating from the root\n/\nroute and only auto-complete absolute paths. After all, you need to know where you are from in order to know where you're going \ud83d\ude09.\nShared Navigation API\nEvery navigation and route matching API in TanStack Router uses the same core interface with minor differences depending on the API. This means that you can learn navigation and route matching once and use the same syntax and concepts across the library.\nToOptions\nInterface\nThis is the core\nToOptions\ninterface that is used in every navigation and route matching API:\nts\ntype ToOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = {\n  // `from` is an optional route ID or path. If it is not supplied, only absolute paths will be auto-completed and type-safe. It's common to supply the route.fullPath of the origin route you are rendering from for convenience. If you don't know the origin route, leave this empty and work with absolute paths or unsafe relative paths.\n  from?: string\n  // `to` can be an absolute route path or a relative path from the `from` option to a valid route path. \u26a0\ufe0f Do not interpolate path params, hash or search params into the `to` options. Use the `params`, `search`, and `hash` options instead.\n  to: string\n  // `params` is either an object of path params to interpolate into the `to` option or a function that supplies the previous params and allows you to return new ones. This is the only way to interpolate dynamic parameters into the final URL. Depending on the `from` and `to` route, you may need to supply none, some or all of the path params. TypeScript will notify you of the required params if there are any.\n  params:\n    | Record<string, unknown>\n    | ((prevParams: Record<string, unknown>) => Record<string, unknown>)\n  // `search` is either an object of query params or a function that supplies the previous search and allows you to return new ones. Depending on the `from` and `to` route, you may need to supply none, some or all of the query params. TypeScript will notify you of the required search params if there are any.\n  search:\n    | Record<string, unknown>\n    | ((prevSearch: Record<string, unknown>) => Record<string, unknown>)\n  // `hash` is either a string or a function that supplies the previous hash and allows you to return a new one.\n  hash?: string | ((prevHash: string) => string)\n  // `state` is either an object of state or a function that supplies the previous state and allows you to return a new one. State is stored in the history API and can be useful for passing data between routes that you do not want to permanently store in URL search params.\n  state?:\n    | Record<string, any>\n    | ((prevState: Record<string, unknown>) => Record<string, unknown>)\n}\n\ud83e\udde0 Every route object has a\nto\nproperty, which can be used as the\nto\nfor any navigation or route matching API. Where possible, this will allow you to avoid plain strings and use type-safe route references instead:\ntsx\nimport { Route as aboutRoute } from './routes/about.tsx'\n\nfunction Comp() {\n  return <Link to={aboutRoute.to}>About</Link>\n}\nNavigateOptions\nInterface\nThis is the core\nNavigateOptions\ninterface that extends\nToOptions\n. Any API that is actually performing a navigation will use this interface:\nts\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  // `resetScroll` is a boolean that determines whether scroll position will be reset to 0,0 after the location is committed to browser history.\n  resetScroll?: boolean\n  // `hashScrollIntoView` is a boolean or object that determines whether an id matching the hash will be scrolled into view after the location is committed to history.\n  hashScrollIntoView?: boolean | ScrollIntoViewOptions\n  // `viewTransition` is either a boolean or function that determines if and how the browser will call document.startViewTransition() when navigating.\n  viewTransition?: boolean | ViewTransitionOptions\n  // `ignoreBlocker` is a boolean that determines if navigation should ignore any blockers that might prevent it.\n  ignoreBlocker?: boolean\n  // `reloadDocument` is a boolean that determines if navigation to a route inside of router will trigger a full page load instead of the traditional SPA navigation.\n  reloadDocument?: boolean\n  // `href` is a string that can be used in place of `to` to navigate to a full built href, e.g. pointing to an external target.\n  href?: string\n}\nLinkOptions\nInterface\nAnywhere an actual\n<a>\ntag the\nLinkOptions\ninterface which extends\nNavigateOptions\nwill be available:\ntsx\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: {\n    exact?: boolean\n    includeHash?: boolean\n    includeSearch?: boolean\n    explicitUndefined?: boolean\n  }\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\nNavigation API\nWith relative navigation and all of the interfaces in mind now, let's talk about the different flavors of navigation API at your disposal:\nThe\n<Link>\ncomponent\nGenerates an actual\n<a>\ntag with a valid\nhref\nwhich can be click or even cmd/ctrl + clicked to open in a new tab\nThe\nuseNavigate()\nhook\nWhen possible,\nLink\ncomponent should be used for navigation, but sometimes you need to navigate imperatively as a result of a side-effect.\nuseNavigate\nreturns a function that can be called to perform an immediate client-side navigation.\nThe\n<Navigate>\ncomponent\nRenders nothing and performs an immediate client-side navigation.\nThe\nRouter.navigate()\nmethod\nThis is the most powerful navigation API in TanStack Router. Similar to\nuseNavigate\n, it imperatively navigates, but is available everywhere you have access to your router.\n\u26a0\ufe0f None of these APIs are a replacement for server-side redirects. If you need to redirect a user immediately from one route to another before mounting your application, use a server-side redirect instead of a client-side navigation.\n<Link>\nComponent\nThe\nLink\ncomponent is the most common way to navigate within an app. It renders an actual\n<a>\ntag with a valid\nhref\nattribute which can be clicked or even cmd/ctrl + clicked to open in a new tab. It also supports any normal\n<a>\nattributes including\ntarget\nto open links in new windows, etc.\nIn addition to the\nLinkOptions\ninterface, the\nLink\ncomponent also supports the following props:\ntsx\nexport type LinkProps<\n  TFrom extends RoutePaths<RegisteredRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = LinkOptions<RegisteredRouter['routeTree'], TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | FrameworkHTMLAnchorTagAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | FrameworkHTMLAnchorAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n}\nAbsolute Links\nLet's make a simple static link!\ntsx\nimport { Link } from '@tanstack/react-router'\n\nconst link = <Link to=\"/about\">About</Link>\nDynamic Links\nDynamic links are links that have dynamic segments in them. For example, a link to a blog post might look like this:\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n  >\n    Blog Post\n  </Link>\n)\nKeep in mind that normally dynamic segment params are\nstring\nvalues, but they can also be any other type that you parse them to in your route options. Either way, the type will be checked at compile time to ensure that you are passing the correct type.\nRelative Links\nBy default, all links are absolute unless a\nfrom\nroute path is provided. This means that the above link will always navigate to the\n/about\nroute regardless of what route you are currently on.\nRelative links can be combined with a\nfrom\nroute path. If a from route path isn't provided, relative paths default to the current active location.\nNote\nKeep in mind that when calling useNavigate as a method on the route, for example\nRoute.useNavigate\n, then the\nfrom\nlocation is predefined to be the route it's called on.\nAnother common pitfall is when using this in a pathless layout route, since the pathless layout route does not have an actual path, the\nfrom\nlocation is regarded as the parent of the pathless layout route. Hence relative routing will be resolved from this parent.\ntsx\nconst postIdRoute = createRoute({\n  path: '/blog/post/$postId',\n})\n\nconst link = (\n  <Link from={postIdRoute.fullPath} to=\"../categories\">\n    Categories\n  </Link>\n)\nAs seen above, it's common to provide the\nroute.fullPath\nas the\nfrom\nroute path. This is because the\nroute.fullPath\nis a reference that will update if you refactor your application. However, sometimes it's not possible to import the route directly, in which case it's fine to provide the route path directly as a string. It will still get type-checked as per usual!\nSpecial relative paths:\n\".\"\nand\n\"..\"\nQuite often you might want to reload the current location or another\nfrom\npath, for example, to rerun the loaders on the current and/or parent routes, or maybe navigate back to a parent route. This can be achieved by specifying a\nto\nroute path of\n\".\"\nwhich will reload the current location or provided\nfrom\npath.\nAnother common need is to navigate one route back relative to the current location or another path. By specifying a\nto\nroute path of\n\"..\"\nnavigation will be resolved to the first parent route preceding the current location.\ntsx\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  return (\n    <div>\n      <Link to=\".\">Reload the current route of /posts/$postId</Link>\n      <Link to=\"..\">Navigate back to /posts</Link>\n      // the below are all equivalent\n      <Link to=\"/posts\">Navigate back to /posts</Link>\n      <Link from=\"/posts\" to=\".\">\n        Navigate back to /posts\n      </Link>\n      // the below are all equivalent\n      <Link to=\"/\">Navigate to root</Link>\n      <Link from=\"/posts\" to=\"..\">\n        Navigate to root\n      </Link>\n    </div>\n  )\n}\nSearch Param Links\nSearch params are a great way to provide additional context to a route. For example, you might want to provide a search query to a search page:\ntsx\nconst link = (\n  <Link\n    to=\"/search\"\n    search={{\n      query: 'tanstack',\n    }}\n  >\n    Search\n  </Link>\n)\nIt's also common to want to update a single search param without supplying any other information about the existing route. For example, you might want to update the page number of a search result:\ntsx\nconst link = (\n  <Link\n    to=\".\"\n    search={(prev) => ({\n      ...prev,\n      page: prev.page + 1,\n    })}\n  >\n    Next Page\n  </Link>\n)\nSearch Param Type Safety\nSearch params are a highly dynamic state management mechanism, so it's important to ensure that you are passing the correct types to your search params. We'll see in a later section in detail how to validate and ensure search params typesafety, among other great features!\nHash Links\nHash links are a great way to link to a specific section of a page. For example, you might want to link to a specific section of a blog post:\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    hash=\"section-1\"\n  >\n    Section 1\n  </Link>\n)\n\u26a0\ufe0f When directly navigating to a URL with a hash fragment, the fragment is only available on the client; the browser does not send the fragment to the server as part of the request URL.\nThis means that if you are using a server-side rendering approach, the hash fragment will not be available on the server-side, and hydration mismatches can occur when using the hash for rendering markup.\nExamples of this would be:\nreturning the hash value in the markup,\nconditional rendering based on the hash value, or\nsetting the Link as active based on the hash value.\nNavigating with Optional Parameters\nOptional path parameters provide flexible navigation patterns where you can include or omit parameters as needed. Optional parameters use the\n{-$paramName}\nsyntax and offer fine-grained control over URL structure.\nParameter Inheritance vs Removal\nWhen navigating with optional parameters, you have two main strategies:\nInheriting Current Parameters\nUse\nparams: {}\nto inherit all current route parameters:\ntsx\n// Inherits current route parameters\n<Link to=\"/posts/{-$category}\" params={{}}>\n  All Posts\n</Link>\nRemoving Parameters\nSet parameters to\nundefined\nto explicitly remove them:\ntsx\n// Removes the category parameter\n<Link to=\"/posts/{-$category}\" params={{ category: undefined }}>\n  All Posts\n</Link>\nBasic Optional Parameter Navigation\ntsx\n// Navigate with optional parameter\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: 'tech' }}\n>\n  Tech Posts\n</Link>\n\n// Navigate without optional parameter\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: undefined }}\n>\n  All Posts\n</Link>\n\n// Navigate using parameter inheritance\n<Link\n  to=\"/posts/{-$category}\"\n  params={{}}\n>\n  Current Category\n</Link>\nFunction-Style Parameter Updates\nFunction-style parameter updates are particularly useful with optional parameters:\ntsx\n// Remove a parameter using function syntax\n<Link\n  to=\"/posts/{-$category}\"\n  params={(prev) => ({ ...prev, category: undefined })}\n>\n  Clear Category\n</Link>\n\n// Update a parameter while keeping others\n<Link\n  to=\"/articles/{-$category}/{-$slug}\"\n  params={(prev) => ({ ...prev, category: 'news' })}\n>\n  News Articles\n</Link>\n\n// Conditionally set parameters\n<Link\n  to=\"/posts/{-$category}\"\n  params={(prev) => ({\n    ...prev,\n    category: someCondition ? 'tech' : undefined\n  })}\n>\n  Conditional Category\n</Link>\nMultiple Optional Parameters\nWhen working with multiple optional parameters, you can mix and match which ones to include:\ntsx\n// Navigate with some optional parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: 'tech', slug: undefined }}\n>\n  Tech Posts\n</Link>\n\n// Remove all optional parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: undefined, slug: undefined }}\n>\n  All Posts\n</Link>\n\n// Set multiple parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: 'tech', slug: 'react-tips' }}\n>\n  Specific Post\n</Link>\nMixed Required and Optional Parameters\nOptional parameters work seamlessly with required parameters:\ntsx\n// Required 'id', optional 'tab'\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={{ id: '123', tab: 'settings' }}\n>\n  User Settings\n</Link>\n\n// Remove optional parameter while keeping required\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={{ id: '123', tab: undefined }}\n>\n  User Profile\n</Link>\n\n// Use function style with mixed parameters\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={(prev) => ({ ...prev, tab: 'notifications' })}\n>\n  User Notifications\n</Link>\nAdvanced Optional Parameter Patterns\nPrefix and Suffix Parameters\nOptional parameters with prefix/suffix work with navigation:\ntsx\n// Navigate to file with optional name\n<Link\n  to=\"/files/prefix{-$name}.txt\"\n  params={{ name: 'document' }}\n>\n  Document File\n</Link>\n\n// Navigate to file without optional name\n<Link\n  to=\"/files/prefix{-$name}.txt\"\n  params={{ name: undefined }}\n>\n  Default File\n</Link>\nAll Optional Parameters\nRoutes where all parameters are optional:\ntsx\n// Navigate to specific date\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: '2023', month: '12', day: '25' }}\n>\n  Christmas 2023\n</Link>\n\n// Navigate to partial date\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: '2023', month: '12', day: undefined }}\n>\n  December 2023\n</Link>\n\n// Navigate to root with all parameters removed\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: undefined, month: undefined, day: undefined }}\n>\n  Home\n</Link>\nNavigation with Search Params and Optional Parameters\nOptional parameters work great in combination with search params:\ntsx\n// Combine optional path params with search params\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: 'tech' }}\n  search={{ page: 1, sort: 'newest' }}\n>\n  Tech Posts - Page 1\n</Link>\n\n// Remove path param but keep search params\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: undefined }}\n  search={(prev) => prev}\n>\n  All Posts - Same Filters\n</Link>\nImperative Navigation with Optional Parameters\nAll the same patterns work with imperative navigation:\ntsx\nfunction Component() {\n  const navigate = useNavigate()\n\n  const clearFilters = () => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: { category: undefined, tag: undefined },\n    })\n  }\n\n  const setCategory = (category: string) => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: (prev) => ({ ...prev, category }),\n    })\n  }\n\n  const applyFilters = (category?: string, tag?: string) => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: { category, tag },\n    })\n  }\n}\nActive & Inactive Props\nThe\nLink\ncomponent supports two additional props:\nactiveProps\nand\ninactiveProps\n. These props are functions that return additional props for the\nactive\nand\ninactive\nstates of the link. All props other than styles and classes passed here will override the original props passed to\nLink\n. Any styles or classes passed are merged together.\nHere's an example:\ntsx\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    activeProps={{\n      style: {\n        fontWeight: 'bold',\n      },\n    }}\n  >\n    Section 1\n  </Link>\n)\nThe\ndata-status\nattribute\nIn addition to the\nactiveProps\nand\ninactiveProps\nprops, the\nLink\ncomponent also adds a\ndata-status\nattribute to the rendered element when it is in an active state. This attribute will be\nactive\nor\nundefined\ndepending on the current state of the link. This can come in handy if you prefer to use data-attributes to style your links instead of props.\nActive Options\nThe\nLink\ncomponent comes with an\nactiveOptions\nproperty that offers a few options of determining if a link is active or not. The following interface describes those options:\ntsx\nexport interface ActiveOptions {\n  // If true, the link will be active if the current route matches the `to` route path exactly (no children routes)\n  // Defaults to `false`\n  exact?: boolean\n  // If true, the link will only be active if the current URL hash matches the `hash` prop\n  // Defaults to `false`\n  includeHash?: boolean // Defaults to false\n  // If true, the link will only be active if the current URL search params inclusively match the `search` prop\n  // Defaults to `true`\n  includeSearch?: boolean\n  // This modifies the `includeSearch` behavior.\n  // If true,  properties in `search` that are explicitly `undefined` must NOT be present in the current URL search params for the link to be active.\n  // defaults to `false`\n  explicitUndefined?: boolean\n}\nBy default, it will check if the resulting\npathname\nis a prefix of the current route. If any search params are provided, it will check that they\ninclusively\nmatch those in the current location. Hashes are not checked by default.\nFor example, if you are on the\n/blog/post/my-first-blog-post\nroute, the following links will be active:\ntsx\nconst link1 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-first-blog-post' }}>\n    Blog Post\n  </Link>\n)\nconst link2 = <Link to=\"/blog/post\">Blog Post</Link>\nconst link3 = <Link to=\"/blog\">Blog Post</Link>\nHowever, the following links will not be active:\ntsx\nconst link4 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-second-blog-post' }}>\n    Blog Post\n  </Link>\n)\nIt's common for some links to only be active if they are an exact match. A good example of this would be a link to the home page. In scenarios like these, you can pass the\nexact: true\noption:\ntsx\nconst link = (\n  <Link to=\"/\" activeOptions={{ exact: true }}>\n    Home\n  </Link>\n)\nThis will ensure that the link is not active when you are a child route.\nA few more options to be aware of:\nIf you want to include the hash in your matching, you can pass the\nincludeHash: true\noption\nIf you do\nnot\nwant to include the search params in your matching, you can pass the\nincludeSearch: false\noption\nPassing\nisActive\nto children\nThe\nLink\ncomponent accepts a function for its children, allowing you to propagate its\nisActive\nproperty to children. For example, you could style a child component based on whether the parent link is active:\ntsx\nconst link = (\n  <Link to=\"/blog/post\">\n    {({ isActive }) => {\n      return (\n        <>\n          <span>My Blog Post</span>\n          <icon className={isActive ? 'active' : 'inactive'} />\n        </>\n      )\n    }}\n  </Link>\n)\nLink Preloading\nThe\nLink\ncomponent supports automatically preloading routes on intent (hovering or touchstart for now). This can be configured as a default in the router options (which we'll talk more about soon) or by passing a\npreload='intent'\nprop to the\nLink\ncomponent. Here's an example:\ntsx\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\">\n    Blog Post\n  </Link>\n)\nWith preloading enabled and relatively quick asynchronous route dependencies (if any), this simple trick can increase the perceived performance of your application with very little effort.\nWhat's even better is that by using a cache-first library like\n@tanstack/query\n, preloaded routes will stick around and be ready for a stale-while-revalidate experience if the user decides to navigate to the route later on.\nLink Preloading Delay\nAlong with preloading is a configurable delay which determines how long a user must hover over a link to trigger the intent-based preloading. The default delay is 50 milliseconds, but you can change this by passing a\npreloadDelay\nprop to the\nLink\ncomponent with the number of milliseconds you'd like to wait:\ntsx\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\" preloadDelay={100}>\n    Blog Post\n  </Link>\n)\nuseNavigate\n\u26a0\ufe0f Because of the\nLink\ncomponent's built-in affordances around\nhref\n, cmd/ctrl + click-ability, and active/inactive capabilities, it's recommended to use the\nLink\ncomponent instead of\nuseNavigate\nfor anything the user can interact with (e.g. links, buttons). However, there are some cases where\nuseNavigate\nis necessary to handle side-effect navigations (e.g. a successful async action that results in a navigation).\nThe\nuseNavigate\nhook returns a\nnavigate\nfunction that can be called to imperatively navigate. It's a great way to navigate to a route from a side-effect (e.g. a successful async action). Here's an example:\ntsx\nfunction Component() {\n  const navigate = useNavigate({ from: '/posts/$postId' })\n\n  const handleSubmit = async (e: FrameworkFormEvent) => {\n    e.preventDefault()\n\n    const response = await fetch('/posts', {\n      method: 'POST',\n      body: JSON.stringify({ title: 'My First Post' }),\n    })\n\n    const { id: postId } = await response.json()\n\n    if (response.ok) {\n      navigate({ to: '/posts/$postId', params: { postId } })\n    }\n  }\n}\n\ud83e\udde0 As shown above, you can pass the\nfrom\noption to specify the route to navigate from in the hook call. While this is also possible to pass in the resulting\nnavigate\nfunction each time you call it, it's recommended to pass it here to reduce on potential error and also not type as much!\nnavigate\nOptions\nThe\nnavigate\nfunction returned by\nuseNavigate\naccepts the\nNavigateOptions\ninterface\nNavigate\nComponent\nOccasionally, you may find yourself needing to navigate immediately when a component mounts. Your first instinct might be to reach for\nuseNavigate\nand an immediate side-effect (e.g. useEffect), but this is unnecessary. Instead, you can render the\nNavigate\ncomponent to achieve the same result:\ntsx\nfunction Component() {\n  return <Navigate to=\"/posts/$postId\" params={{ postId: 'my-first-post' }} />\n}\nThink of the\nNavigate\ncomponent as a way to navigate to a route immediately when a component mounts. It's a great way to handle client-only redirects. It is\ndefinitely not\na substitute for handling server-aware redirects responsibly on the server.\nrouter.navigate\nThe\nrouter.navigate\nmethod is the same as the\nnavigate\nfunction returned by\nuseNavigate\nand accepts the same\nNavigateOptions\ninterface\n. Unlike the\nuseNavigate\nhook, it is available anywhere your\nrouter\ninstance is available and is thus a great way to navigate imperatively from anywhere in your application, including outside of your framework.\nuseMatchRoute\nand\n<MatchRoute>\nThe\nuseMatchRoute\nhook and\n<MatchRoute>\ncomponent are the same thing, but the hook is a bit more flexible. They both accept the standard navigation\nToOptions\ninterface either as options or props and return\ntrue/false\nif that route is currently matched. It also has a handy\npending\noption that will return\ntrue\nif the route is currently pending (e.g. a route is currently transitioning to that route). This can be extremely useful for showing optimistic UI around where a user is navigating:\ntsx\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          <Spinner />\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\nThe component version\n<MatchRoute>\ncan also be used with a function as children to render something when the route is matched:\ntsx\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          {(match) => {\n            return <Spinner show={match} />\n          }}\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\nThe hook version\nuseMatchRoute\nreturns a function that can be called programmatically to check if a route is matched:\ntsx\nfunction Component() {\n  const matchRoute = useMatchRoute()\n\n  useEffect(() => {\n    if (matchRoute({ to: '/users', pending: true })) {\n      console.info('The /users route is matched and pending')\n    }\n  })\n\n  return (\n    <div>\n      <Link to=\"/users\">Users</Link>\n    </div>\n  )\n}\nPhew! That's a lot of navigating! That said, hopefully you're feeling pretty good about getting around your application now. Let's move on!",
  "content_markdown": "[## Everything is Relative](#everything-is-relative)\n\nBelieve it or not, every navigation within an app is **relative**, even if you aren't using explicit relative path syntax (../../somewhere). Any time a link is clicked or an imperative navigation call is made, you will always have an **origin** path and a **destination** path which means you are navigating **from** one route **to** another route.\n\nTanStack Router keeps this constant concept of relative navigation in mind for every navigation, so you'll constantly see two properties in the API:\n\n- from - The origin route path\n- to - The destination route path\n\n> \u26a0\ufe0f If a from route path isn't provided the router will assume you are navigating from the root / route and only auto-complete absolute paths. After all, you need to know where you are from in order to know where you're going \ud83d\ude09.\n\n[## Shared Navigation API](#shared-navigation-api)\n\nEvery navigation and route matching API in TanStack Router uses the same core interface with minor differences depending on the API. This means that you can learn navigation and route matching once and use the same syntax and concepts across the library.\n\n[### ToOptions Interface](#tooptions-interface)\n\nThis is the core ToOptions interface that is used in every navigation and route matching API:\n\nts\n\n```\ntype ToOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = {\n  // `from` is an optional route ID or path. If it is not supplied, only absolute paths will be auto-completed and type-safe. It's common to supply the route.fullPath of the origin route you are rendering from for convenience. If you don't know the origin route, leave this empty and work with absolute paths or unsafe relative paths.\n  from?: string\n  // `to` can be an absolute route path or a relative path from the `from` option to a valid route path. \u26a0\ufe0f Do not interpolate path params, hash or search params into the `to` options. Use the `params`, `search`, and `hash` options instead.\n  to: string\n  // `params` is either an object of path params to interpolate into the `to` option or a function that supplies the previous params and allows you to return new ones. This is the only way to interpolate dynamic parameters into the final URL. Depending on the `from` and `to` route, you may need to supply none, some or all of the path params. TypeScript will notify you of the required params if there are any.\n  params:\n    | Record<string, unknown>\n    | ((prevParams: Record<string, unknown>) => Record<string, unknown>)\n  // `search` is either an object of query params or a function that supplies the previous search and allows you to return new ones. Depending on the `from` and `to` route, you may need to supply none, some or all of the query params. TypeScript will notify you of the required search params if there are any.\n  search:\n    | Record<string, unknown>\n    | ((prevSearch: Record<string, unknown>) => Record<string, unknown>)\n  // `hash` is either a string or a function that supplies the previous hash and allows you to return a new one.\n  hash?: string | ((prevHash: string) => string)\n  // `state` is either an object of state or a function that supplies the previous state and allows you to return a new one. State is stored in the history API and can be useful for passing data between routes that you do not want to permanently store in URL search params.\n  state?:\n    | Record<string, any>\n    | ((prevState: Record<string, unknown>) => Record<string, unknown>)\n}\n```\n\n> \ud83e\udde0 Every route object has a to property, which can be used as the to for any navigation or route matching API. Where possible, this will allow you to avoid plain strings and use type-safe route references instead:\n\ntsx\n\n```\nimport { Route as aboutRoute } from './routes/about.tsx'\n\nfunction Comp() {\n  return <Link to={aboutRoute.to}>About</Link>\n}\n```\n\n[### NavigateOptions Interface](#navigateoptions-interface)\n\nThis is the core NavigateOptions interface that extends ToOptions. Any API that is actually performing a navigation will use this interface:\n\nts\n\n```\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  // `resetScroll` is a boolean that determines whether scroll position will be reset to 0,0 after the location is committed to browser history.\n  resetScroll?: boolean\n  // `hashScrollIntoView` is a boolean or object that determines whether an id matching the hash will be scrolled into view after the location is committed to history.\n  hashScrollIntoView?: boolean | ScrollIntoViewOptions\n  // `viewTransition` is either a boolean or function that determines if and how the browser will call document.startViewTransition() when navigating.\n  viewTransition?: boolean | ViewTransitionOptions\n  // `ignoreBlocker` is a boolean that determines if navigation should ignore any blockers that might prevent it.\n  ignoreBlocker?: boolean\n  // `reloadDocument` is a boolean that determines if navigation to a route inside of router will trigger a full page load instead of the traditional SPA navigation.\n  reloadDocument?: boolean\n  // `href` is a string that can be used in place of `to` to navigate to a full built href, e.g. pointing to an external target.\n  href?: string\n}\n```\n\n[### LinkOptions Interface](#linkoptions-interface)\n\nAnywhere an actual <a> tag the LinkOptions interface which extends NavigateOptions will be available:\n\ntsx\n\n```\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: {\n    exact?: boolean\n    includeHash?: boolean\n    includeSearch?: boolean\n    explicitUndefined?: boolean\n  }\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n```\n\n[## Navigation API](#navigation-api)\n\nWith relative navigation and all of the interfaces in mind now, let's talk about the different flavors of navigation API at your disposal:\n\n- The <Link> component\n  - Generates an actual <a> tag with a valid href which can be click or even cmd/ctrl + clicked to open in a new tab\n- The useNavigate() hook\n  - When possible, Link component should be used for navigation, but sometimes you need to navigate imperatively as a result of a side-effect. useNavigate returns a function that can be called to perform an immediate client-side navigation.\n- The <Navigate> component\n  - Renders nothing and performs an immediate client-side navigation.\n- The Router.navigate() method\n  - This is the most powerful navigation API in TanStack Router. Similar to useNavigate, it imperatively navigates, but is available everywhere you have access to your router.\n\n\u26a0\ufe0f None of these APIs are a replacement for server-side redirects. If you need to redirect a user immediately from one route to another before mounting your application, use a server-side redirect instead of a client-side navigation.\n\n[## <Link> Component](#link-component)\n\nThe Link component is the most common way to navigate within an app. It renders an actual <a> tag with a valid href attribute which can be clicked or even cmd/ctrl + clicked to open in a new tab. It also supports any normal <a> attributes including target to open links in new windows, etc.\n\nIn addition to the [LinkOptions](#linkoptions-interface) interface, the Link component also supports the following props:\n\ntsx\n\n```\nexport type LinkProps<\n  TFrom extends RoutePaths<RegisteredRouter['routeTree']> | string = string,\n  TTo extends string = '',\n> = LinkOptions<RegisteredRouter['routeTree'], TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | FrameworkHTMLAnchorTagAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | FrameworkHTMLAnchorAttributes\n    | (() => FrameworkHTMLAnchorAttributes)\n}\n```\n\n[### Absolute Links](#absolute-links)\n\nLet's make a simple static link!\n\ntsx\n\n```\nimport { Link } from '@tanstack/react-router'\n\nconst link = <Link to=\"/about\">About</Link>\n```\n\n[### Dynamic Links](#dynamic-links)\n\nDynamic links are links that have dynamic segments in them. For example, a link to a blog post might look like this:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n  >\n    Blog Post\n  </Link>\n)\n```\n\nKeep in mind that normally dynamic segment params are string values, but they can also be any other type that you parse them to in your route options. Either way, the type will be checked at compile time to ensure that you are passing the correct type.\n\n[### Relative Links](#relative-links)\n\nBy default, all links are absolute unless a from route path is provided. This means that the above link will always navigate to the /about route regardless of what route you are currently on.\n\nRelative links can be combined with a from route path. If a from route path isn't provided, relative paths default to the current active location.\n\nNote\n\nKeep in mind that when calling useNavigate as a method on the route, for example Route.useNavigate, then the from location is predefined to be the route it's called on.\n\nAnother common pitfall is when using this in a pathless layout route, since the pathless layout route does not have an actual path, the from location is regarded as the parent of the pathless layout route. Hence relative routing will be resolved from this parent.\n\ntsx\n\n```\nconst postIdRoute = createRoute({\n  path: '/blog/post/$postId',\n})\n\nconst link = (\n  <Link from={postIdRoute.fullPath} to=\"../categories\">\n    Categories\n  </Link>\n)\n```\n\nAs seen above, it's common to provide the route.fullPath as the from route path. This is because the route.fullPath is a reference that will update if you refactor your application. However, sometimes it's not possible to import the route directly, in which case it's fine to provide the route path directly as a string. It will still get type-checked as per usual!\n\n[### Special relative paths: \".\" and \"..\"](#special-relative-paths--and-)\n\nQuite often you might want to reload the current location or another from path, for example, to rerun the loaders on the current and/or parent routes, or maybe navigate back to a parent route. This can be achieved by specifying a to route path of \".\" which will reload the current location or provided from path.\n\nAnother common need is to navigate one route back relative to the current location or another path. By specifying a to route path of \"..\" navigation will be resolved to the first parent route preceding the current location.\n\ntsx\n\n```\nexport const Route = createFileRoute('/posts/$postId')({\n  component: PostComponent,\n})\n\nfunction PostComponent() {\n  return (\n    <div>\n      <Link to=\".\">Reload the current route of /posts/$postId</Link>\n      <Link to=\"..\">Navigate back to /posts</Link>\n      // the below are all equivalent\n      <Link to=\"/posts\">Navigate back to /posts</Link>\n      <Link from=\"/posts\" to=\".\">\n        Navigate back to /posts\n      </Link>\n      // the below are all equivalent\n      <Link to=\"/\">Navigate to root</Link>\n      <Link from=\"/posts\" to=\"..\">\n        Navigate to root\n      </Link>\n    </div>\n  )\n}\n```\n\n[### Search Param Links](#search-param-links)\n\nSearch params are a great way to provide additional context to a route. For example, you might want to provide a search query to a search page:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\"/search\"\n    search={{\n      query: 'tanstack',\n    }}\n  >\n    Search\n  </Link>\n)\n```\n\nIt's also common to want to update a single search param without supplying any other information about the existing route. For example, you might want to update the page number of a search result:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\".\"\n    search={(prev) => ({\n      ...prev,\n      page: prev.page + 1,\n    })}\n  >\n    Next Page\n  </Link>\n)\n```\n\n[### Search Param Type Safety](#search-param-type-safety)\n\nSearch params are a highly dynamic state management mechanism, so it's important to ensure that you are passing the correct types to your search params. We'll see in a later section in detail how to validate and ensure search params typesafety, among other great features!\n\n[### Hash Links](#hash-links)\n\nHash links are a great way to link to a specific section of a page. For example, you might want to link to a specific section of a blog post:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    hash=\"section-1\"\n  >\n    Section 1\n  </Link>\n)\n```\n\n> \u26a0\ufe0f When directly navigating to a URL with a hash fragment, the fragment is only available on the client; the browser does not send the fragment to the server as part of the request URL.\n>\n> This means that if you are using a server-side rendering approach, the hash fragment will not be available on the server-side, and hydration mismatches can occur when using the hash for rendering markup.\n>\n> Examples of this would be:\n>\n> - returning the hash value in the markup,\n> - conditional rendering based on the hash value, or\n> - setting the Link as active based on the hash value.\n\n[### Navigating with Optional Parameters](#navigating-with-optional-parameters)\n\nOptional path parameters provide flexible navigation patterns where you can include or omit parameters as needed. Optional parameters use the {-$paramName} syntax and offer fine-grained control over URL structure.\n\n[#### Parameter Inheritance vs Removal](#parameter-inheritance-vs-removal)\n\nWhen navigating with optional parameters, you have two main strategies:\n\n**Inheriting Current Parameters**\nUse params: {} to inherit all current route parameters:\n\ntsx\n\n```\n// Inherits current route parameters\n<Link to=\"/posts/{-$category}\" params={{}}>\n  All Posts\n</Link>\n```\n\n**Removing Parameters**  \nSet parameters to undefined to explicitly remove them:\n\ntsx\n\n```\n// Removes the category parameter\n<Link to=\"/posts/{-$category}\" params={{ category: undefined }}>\n  All Posts\n</Link>\n```\n\n[#### Basic Optional Parameter Navigation](#basic-optional-parameter-navigation)\n\ntsx\n\n```\n// Navigate with optional parameter\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: 'tech' }}\n>\n  Tech Posts\n</Link>\n\n// Navigate without optional parameter\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: undefined }}\n>\n  All Posts\n</Link>\n\n// Navigate using parameter inheritance\n<Link\n  to=\"/posts/{-$category}\"\n  params={{}}\n>\n  Current Category\n</Link>\n```\n\n[#### Function-Style Parameter Updates](#function-style-parameter-updates)\n\nFunction-style parameter updates are particularly useful with optional parameters:\n\ntsx\n\n```\n// Remove a parameter using function syntax\n<Link\n  to=\"/posts/{-$category}\"\n  params={(prev) => ({ ...prev, category: undefined })}\n>\n  Clear Category\n</Link>\n\n// Update a parameter while keeping others\n<Link\n  to=\"/articles/{-$category}/{-$slug}\"\n  params={(prev) => ({ ...prev, category: 'news' })}\n>\n  News Articles\n</Link>\n\n// Conditionally set parameters\n<Link\n  to=\"/posts/{-$category}\"\n  params={(prev) => ({\n    ...prev,\n    category: someCondition ? 'tech' : undefined\n  })}\n>\n  Conditional Category\n</Link>\n```\n\n[#### Multiple Optional Parameters](#multiple-optional-parameters)\n\nWhen working with multiple optional parameters, you can mix and match which ones to include:\n\ntsx\n\n```\n// Navigate with some optional parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: 'tech', slug: undefined }}\n>\n  Tech Posts\n</Link>\n\n// Remove all optional parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: undefined, slug: undefined }}\n>\n  All Posts\n</Link>\n\n// Set multiple parameters\n<Link\n  to=\"/posts/{-$category}/{-$slug}\"\n  params={{ category: 'tech', slug: 'react-tips' }}\n>\n  Specific Post\n</Link>\n```\n\n[#### Mixed Required and Optional Parameters](#mixed-required-and-optional-parameters)\n\nOptional parameters work seamlessly with required parameters:\n\ntsx\n\n```\n// Required 'id', optional 'tab'\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={{ id: '123', tab: 'settings' }}\n>\n  User Settings\n</Link>\n\n// Remove optional parameter while keeping required\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={{ id: '123', tab: undefined }}\n>\n  User Profile\n</Link>\n\n// Use function style with mixed parameters\n<Link\n  to=\"/users/$id/{-$tab}\"\n  params={(prev) => ({ ...prev, tab: 'notifications' })}\n>\n  User Notifications\n</Link>\n```\n\n[#### Advanced Optional Parameter Patterns](#advanced-optional-parameter-patterns)\n\n**Prefix and Suffix Parameters**\nOptional parameters with prefix/suffix work with navigation:\n\ntsx\n\n```\n// Navigate to file with optional name\n<Link\n  to=\"/files/prefix{-$name}.txt\"\n  params={{ name: 'document' }}\n>\n  Document File\n</Link>\n\n// Navigate to file without optional name\n<Link\n  to=\"/files/prefix{-$name}.txt\"\n  params={{ name: undefined }}\n>\n  Default File\n</Link>\n```\n\n**All Optional Parameters**\nRoutes where all parameters are optional:\n\ntsx\n\n```\n// Navigate to specific date\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: '2023', month: '12', day: '25' }}\n>\n  Christmas 2023\n</Link>\n\n// Navigate to partial date\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: '2023', month: '12', day: undefined }}\n>\n  December 2023\n</Link>\n\n// Navigate to root with all parameters removed\n<Link\n  to=\"/{-$year}/{-$month}/{-$day}\"\n  params={{ year: undefined, month: undefined, day: undefined }}\n>\n  Home\n</Link>\n```\n\n[#### Navigation with Search Params and Optional Parameters](#navigation-with-search-params-and-optional-parameters)\n\nOptional parameters work great in combination with search params:\n\ntsx\n\n```\n// Combine optional path params with search params\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: 'tech' }}\n  search={{ page: 1, sort: 'newest' }}\n>\n  Tech Posts - Page 1\n</Link>\n\n// Remove path param but keep search params\n<Link\n  to=\"/posts/{-$category}\"\n  params={{ category: undefined }}\n  search={(prev) => prev}\n>\n  All Posts - Same Filters\n</Link>\n```\n\n[#### Imperative Navigation with Optional Parameters](#imperative-navigation-with-optional-parameters)\n\nAll the same patterns work with imperative navigation:\n\ntsx\n\n```\nfunction Component() {\n  const navigate = useNavigate()\n\n  const clearFilters = () => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: { category: undefined, tag: undefined },\n    })\n  }\n\n  const setCategory = (category: string) => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: (prev) => ({ ...prev, category }),\n    })\n  }\n\n  const applyFilters = (category?: string, tag?: string) => {\n    navigate({\n      to: '/posts/{-$category}/{-$tag}',\n      params: { category, tag },\n    })\n  }\n}\n```\n\n[### Active & Inactive Props](#active--inactive-props)\n\nThe Link component supports two additional props: activeProps and inactiveProps. These props are functions that return additional props for the active and inactive states of the link. All props other than styles and classes passed here will override the original props passed to Link. Any styles or classes passed are merged together.\n\nHere's an example:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\"/blog/post/$postId\"\n    params={{\n      postId: 'my-first-blog-post',\n    }}\n    activeProps={{\n      style: {\n        fontWeight: 'bold',\n      },\n    }}\n  >\n    Section 1\n  </Link>\n)\n```\n\n[### The data-status attribute](#the-data-status-attribute)\n\nIn addition to the activeProps and inactiveProps props, the Link component also adds a data-status attribute to the rendered element when it is in an active state. This attribute will be active or undefined depending on the current state of the link. This can come in handy if you prefer to use data-attributes to style your links instead of props.\n\n[### Active Options](#active-options)\n\nThe Link component comes with an activeOptions property that offers a few options of determining if a link is active or not. The following interface describes those options:\n\ntsx\n\n```\nexport interface ActiveOptions {\n  // If true, the link will be active if the current route matches the `to` route path exactly (no children routes)\n  // Defaults to `false`\n  exact?: boolean\n  // If true, the link will only be active if the current URL hash matches the `hash` prop\n  // Defaults to `false`\n  includeHash?: boolean // Defaults to false\n  // If true, the link will only be active if the current URL search params inclusively match the `search` prop\n  // Defaults to `true`\n  includeSearch?: boolean\n  // This modifies the `includeSearch` behavior.\n  // If true,  properties in `search` that are explicitly `undefined` must NOT be present in the current URL search params for the link to be active.\n  // defaults to `false`\n  explicitUndefined?: boolean\n}\n```\n\nBy default, it will check if the resulting **pathname** is a prefix of the current route. If any search params are provided, it will check that they *inclusively* match those in the current location. Hashes are not checked by default.\n\nFor example, if you are on the /blog/post/my-first-blog-post route, the following links will be active:\n\ntsx\n\n```\nconst link1 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-first-blog-post' }}>\n    Blog Post\n  </Link>\n)\nconst link2 = <Link to=\"/blog/post\">Blog Post</Link>\nconst link3 = <Link to=\"/blog\">Blog Post</Link>\n```\n\nHowever, the following links will not be active:\n\ntsx\n\n```\nconst link4 = (\n  <Link to=\"/blog/post/$postId\" params={{ postId: 'my-second-blog-post' }}>\n    Blog Post\n  </Link>\n)\n```\n\nIt's common for some links to only be active if they are an exact match. A good example of this would be a link to the home page. In scenarios like these, you can pass the exact: true option:\n\ntsx\n\n```\nconst link = (\n  <Link to=\"/\" activeOptions={{ exact: true }}>\n    Home\n  </Link>\n)\n```\n\nThis will ensure that the link is not active when you are a child route.\n\nA few more options to be aware of:\n\n- If you want to include the hash in your matching, you can pass the includeHash: true option\n- If you do **not** want to include the search params in your matching, you can pass the includeSearch: false option\n\n[### Passing isActive to children](#passing-isactive-to-children)\n\nThe Link component accepts a function for its children, allowing you to propagate its isActive property to children. For example, you could style a child component based on whether the parent link is active:\n\ntsx\n\n```\nconst link = (\n  <Link to=\"/blog/post\">\n    {({ isActive }) => {\n      return (\n        <>\n          <span>My Blog Post</span>\n          <icon className={isActive ? 'active' : 'inactive'} />\n        </>\n      )\n    }}\n  </Link>\n)\n```\n\n[### Link Preloading](#link-preloading)\n\nThe Link component supports automatically preloading routes on intent (hovering or touchstart for now). This can be configured as a default in the router options (which we'll talk more about soon) or by passing a preload='intent' prop to the Link component. Here's an example:\n\ntsx\n\n```\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\">\n    Blog Post\n  </Link>\n)\n```\n\nWith preloading enabled and relatively quick asynchronous route dependencies (if any), this simple trick can increase the perceived performance of your application with very little effort.\n\nWhat's even better is that by using a cache-first library like @tanstack/query, preloaded routes will stick around and be ready for a stale-while-revalidate experience if the user decides to navigate to the route later on.\n\n[### Link Preloading Delay](#link-preloading-delay)\n\nAlong with preloading is a configurable delay which determines how long a user must hover over a link to trigger the intent-based preloading. The default delay is 50 milliseconds, but you can change this by passing a preloadDelay prop to the Link component with the number of milliseconds you'd like to wait:\n\ntsx\n\n```\nconst link = (\n  <Link to=\"/blog/post/$postId\" preload=\"intent\" preloadDelay={100}>\n    Blog Post\n  </Link>\n)\n```\n\n[## useNavigate](#usenavigate)\n> \u26a0\ufe0f Because of the Link component's built-in affordances around href, cmd/ctrl + click-ability, and active/inactive capabilities, it's recommended to use the Link component instead of useNavigate for anything the user can interact with (e.g. links, buttons). However, there are some cases where useNavigate is necessary to handle side-effect navigations (e.g. a successful async action that results in a navigation).\n\nThe useNavigate hook returns a navigate function that can be called to imperatively navigate. It's a great way to navigate to a route from a side-effect (e.g. a successful async action). Here's an example:\n\ntsx\n\n```\nfunction Component() {\n  const navigate = useNavigate({ from: '/posts/$postId' })\n\n  const handleSubmit = async (e: FrameworkFormEvent) => {\n    e.preventDefault()\n\n    const response = await fetch('/posts', {\n      method: 'POST',\n      body: JSON.stringify({ title: 'My First Post' }),\n    })\n\n    const { id: postId } = await response.json()\n\n    if (response.ok) {\n      navigate({ to: '/posts/$postId', params: { postId } })\n    }\n  }\n}\n```\n\n> \ud83e\udde0 As shown above, you can pass the from option to specify the route to navigate from in the hook call. While this is also possible to pass in the resulting navigate function each time you call it, it's recommended to pass it here to reduce on potential error and also not type as much!\n\n[### navigate Options](#navigate-options)\n\nThe navigate function returned by useNavigate accepts the [NavigateOptions interface](#navigateoptions-interface)\n\n[## Navigate Component](#navigate-component)\n\nOccasionally, you may find yourself needing to navigate immediately when a component mounts. Your first instinct might be to reach for useNavigate and an immediate side-effect (e.g. useEffect), but this is unnecessary. Instead, you can render the Navigate component to achieve the same result:\n\ntsx\n\n```\nfunction Component() {\n  return <Navigate to=\"/posts/$postId\" params={{ postId: 'my-first-post' }} />\n}\n```\n\nThink of the Navigate component as a way to navigate to a route immediately when a component mounts. It's a great way to handle client-only redirects. It is *definitely not* a substitute for handling server-aware redirects responsibly on the server.\n\n[## router.navigate](#routernavigate)\n\nThe router.navigate method is the same as the navigate function returned by useNavigate and accepts the same [NavigateOptions interface](#navigateoptions-interface). Unlike the useNavigate hook, it is available anywhere your router instance is available and is thus a great way to navigate imperatively from anywhere in your application, including outside of your framework.\n\n[## useMatchRoute and <MatchRoute>](#usematchroute-and-matchroute)\n\nThe useMatchRoute hook and <MatchRoute> component are the same thing, but the hook is a bit more flexible. They both accept the standard navigation ToOptions interface either as options or props and return true/false if that route is currently matched. It also has a handy pending option that will return true if the route is currently pending (e.g. a route is currently transitioning to that route). This can be extremely useful for showing optimistic UI around where a user is navigating:\n\ntsx\n\n```\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          <Spinner />\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\n```\n\nThe component version <MatchRoute> can also be used with a function as children to render something when the route is matched:\n\ntsx\n\n```\nfunction Component() {\n  return (\n    <div>\n      <Link to=\"/users\">\n        Users\n        <MatchRoute to=\"/users\" pending>\n          {(match) => {\n            return <Spinner show={match} />\n          }}\n        </MatchRoute>\n      </Link>\n    </div>\n  )\n}\n```\n\nThe hook version useMatchRoute returns a function that can be called programmatically to check if a route is matched:\n\ntsx\n\n```\nfunction Component() {\n  const matchRoute = useMatchRoute()\n\n  useEffect(() => {\n    if (matchRoute({ to: '/users', pending: true })) {\n      console.info('The /users route is matched and pending')\n    }\n  })\n\n  return (\n    <div>\n      <Link to=\"/users\">Users</Link>\n    </div>\n  )\n}\n```\n\n---\n\nPhew! That's a lot of navigating! That said, hopefully you're feeling pretty good about getting around your application now. Let's move on!",
  "tags": [
    "tanstack",
    "router",
    "react",
    "navigation"
  ],
  "extracted_at": "2026-02-03T12:51:59.327013+00:00",
  "content_length": 27742,
  "content_hash": "f88e6c9a4e26f53b"
}