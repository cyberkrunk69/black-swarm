{
  "id": "tanstack-router__router_latest_docs_framework_react_overview",
  "source_id": "tanstack-router",
  "source_name": "TanStack Router",
  "category": "navigation_patterns",
  "url": "https://tanstack.com/router/latest/docs/framework/react/overview",
  "title": "Overview",
  "content": "TanStack Router is a router for building React and Solid applications\n. Some of its features include:\n100% inferred TypeScript support\nTypesafe navigation\nNested Routing and layout routes (with pathless layouts)\nBuilt-in Route Loaders w/ SWR Caching\nDesigned for client-side data caches (TanStack Query, SWR, etc.)\nAutomatic route prefetching\nAsynchronous route elements and error boundaries\nFile-based Route Generation\nTypesafe JSON-first Search Params state management APIs\nPath and Search Parameter Schema Validation\nSearch Param Navigation APIs\nCustom Search Param parser/serializer support\nSearch param middleware\nRoute matching/loading middleware\nTo get started quickly, head to the next page. For a more lengthy explanation, buckle up while I bring you up to speed!\n\"A Fork in the Route\"\nUsing a router to build applications is widely regarded as a must-have and is usually one of the first choices you\u2019ll make in your tech stack.\nWhy TanStack Router?\nTanStack Router delivers on the same fundamental expectations as other routers that you\u2019ve come to expect:\nNested routes, layout routes, grouped routes\nFile-based Routing\nParallel data loading\nPrefetching\nURL Path Params\nError Boundaries and Handling\nSSR\nRoute Masking\nAnd it also delivers some new features that raise the bar:\n100% inferred TypeScript support\nTypesafe navigation\nBuilt-in SWR Caching for loaders\nDesigned for client-side data caches (TanStack Query, SWR, etc.)\nTypesafe JSON-first Search Params state management APIs\nPath and Search Parameter Schema Validation\nSearch Parameter Navigation APIs\nCustom Search Param parser/serializer support\nSearch param middleware\nInherited Route Context\nMixed file-based and code-based routing\nLet\u2019s dive into some of the more important ones in more detail!\n100% Inferred TypeScript Support\nEverything these days is written \u201cin Typescript\u201d or at the very least offers type definitions that are veneered over runtime functionality, but too few packages in the ecosystem actually design their APIs with TypeScript in mind. So while I\u2019m pleased that your router is auto-completing your option fields and catching a few property/method typos here and there, there is much more to be had.\nTanStack Router is fully aware of all of your routes and their configuration at any given point in your code. This includes the path, path params, search params, context, and any other configuration you\u2019ve provided. Ultimately this means that you can navigate to any route in your app with 100% type safety and confidence that your link or navigate call will succeed.\nTanStack Router provides lossless type-inference. It uses countless generic type parameters to enforce and propagate any type information you give it throughout the rest of its API and ultimately your app. No other router offers this level of type safety and developer confidence.\nWhat does all of that mean for you?\nFaster feature development with auto-completion and type hints\nSafer and faster refactors\nConfidence that your code will work as expected\n1st Class Search Parameters\nSearch parameters are often an afterthought, treated like a black box of strings (or string) that you can parse and update, but not much else. Existing solutions are\nnot\ntype-safe either, adding to the caution that is required to deal with them. Even the most \"modern\" frameworks and routers leave it up to you to figure out how to manage this state. Sometimes they'll parse the search string into an object for you, or sometimes you're left to do it yourself with\nURLSearchParams\n.\nLet's step back and remember that\nsearch params are the most powerful state manager in your entire application.\nThey are global, serializable, bookmarkable, and shareable making them the perfect place to store any kind of state that needs to survive a page refresh or a social share.\nTo live up to that responsibility, search parameters are a first-class citizen in TanStack Router. While still based on standard URLSearchParams, TanStack Router uses a powerful parser/serializer to manage deeper and more complex data structures in your search params, all while keeping them type-safe and easy to work with.\nIt's like having\nuseState\nright in the URL!\nSearch parameters are:\nAutomatically parsed and serialized as JSON\nValidated and typed\nInherited from parent routes\nAccessible in loaders, components, and hooks\nEasily modified with the useSearch hook, Link, navigate, and router.navigate APIs\nCustomizable with a custom search filters and middleware\nSubscribed via fine-grained search param selectors for efficient re-renders\nOnce you start using TanStack Router's search parameters, you'll wonder how you ever lived without them.\nBuilt-In Caching and Friendly Data Loading\nData loading is a critical part of any application and while most existing routers offer some form of critical data loading APIs, they often fall short when it comes to caching and data lifecycle management. Existing solutions suffer from a few common problems:\nNo caching at all. Data is always fresh, but your users are left waiting for frequently accessed data to load over and over again.\nOverly-aggressive caching. Data is cached for too long, leading to stale data and a poor user experience.\nBlunt invalidation strategies and APIs. Data may be invalidated too often, leading to unnecessary network requests and wasted resources, or you may not have any fine-grained control over when data is invalidated at all.\nTanStack Router solves these problems with a two-prong approach to caching and data loading:\nBuilt-in Cache\nTanStack Router provides a light-weight built-in caching layer that works seamlessly with the Router. This caching layer is loosely based on TanStack Query, but with fewer features and a much smaller API surface area. Like TanStack Query, sane but powerful defaults guarantee that your data is cached for reuse, invalidated when necessary, and garbage collected when not in use. It also provides a simple API for invalidating the cache manually when needed.\nFlexible & Powerful Data Lifecycle APIs\nTanStack Router is designed with a flexible and powerful data loading API that more easily integrates with existing data fetching libraries like TanStack Query, SWR, Apollo, Relay, or even your own custom data fetching solution. Configurable APIs like\ncontext\n,\nbeforeLoad\n,\nloaderDeps\nand\nloader\nwork in unison to make it easy to define declarative data dependencies, prefetch data, and manage the lifecycle of an external data source with ease.\nInherited Route Context\nTanStack Router's router and route context is a powerful feature that allows you to define context that is specific to a route which is then inherited by all child routes. Even the router and root routes themselves can provide context. Context can be built up both synchronously and asynchronously, and can be used to share data, configuration, or even functions between routes and route configurations. This is especially useful for scenarios like:\nAuthentication and Authorization\nHybrid SSR/CSR data fetching and preloading\nTheming\nSingletons and global utilities\nCurried or partial application across preloading, loading, and rendering stages\nAlso, what would route context be if it weren't type-safe? TanStack Router's route context is fully type-safe and inferred at zero cost to you.\nFile-based and/or Code-Based Routing\nTanStack Router supports both file-based and code-based routing at the same time. This flexibility allows you to choose the approach that best fits your project's needs.\nTanStack Router's file-based routing approach is uniquely user-facing. Route configuration is generated for you either by the Vite plugin or TanStack Router CLI, leaving the usage of said generated code up to you! This means that you're always in total control of your routes and router, even if you use file-based routing.\nAcknowledgements\nTanStack Router builds on concepts and patterns popularized by many other OSS projects, including:\nTRPC\nRemix\nChicane\nNext.js\nWe acknowledge the investment, risk and research that went into their development, but are excited to push the bar they have set even higher.\nLet's go!\nEnough overview, there's so much more to do with TanStack Router. Hit that next button and let's get started!",
  "content_markdown": "**TanStack Router is a router for building React and Solid applications**. Some of its features include:\n\n- 100% inferred TypeScript support\n- Typesafe navigation\n- Nested Routing and layout routes (with pathless layouts)\n- Built-in Route Loaders w/ SWR Caching\n- Designed for client-side data caches (TanStack Query, SWR, etc.)\n- Automatic route prefetching\n- Asynchronous route elements and error boundaries\n- File-based Route Generation\n- Typesafe JSON-first Search Params state management APIs\n- Path and Search Parameter Schema Validation\n- Search Param Navigation APIs\n- Custom Search Param parser/serializer support\n- Search param middleware\n- Route matching/loading middleware\n\nTo get started quickly, head to the next page. For a more lengthy explanation, buckle up while I bring you up to speed!\n\n[## \"A Fork in the Route\"](#a-fork-in-the-route)\n\nUsing a router to build applications is widely regarded as a must-have and is usually one of the first choices you\u2019ll make in your tech stack.\n\n[## Why TanStack Router?](#why-tanstack-router)\n\nTanStack Router delivers on the same fundamental expectations as other routers that you\u2019ve come to expect:\n\n- Nested routes, layout routes, grouped routes\n- File-based Routing\n- Parallel data loading\n- Prefetching\n- URL Path Params\n- Error Boundaries and Handling\n- SSR\n- Route Masking\n\nAnd it also delivers some new features that raise the bar:\n\n- 100% inferred TypeScript support\n- Typesafe navigation\n- Built-in SWR Caching for loaders\n- Designed for client-side data caches (TanStack Query, SWR, etc.)\n- Typesafe JSON-first Search Params state management APIs\n- Path and Search Parameter Schema Validation\n- Search Parameter Navigation APIs\n- Custom Search Param parser/serializer support\n- Search param middleware\n- Inherited Route Context\n- Mixed file-based and code-based routing\n\nLet\u2019s dive into some of the more important ones in more detail!\n\n[## 100% Inferred TypeScript Support](#100-inferred-typescript-support)\n\nEverything these days is written \u201cin Typescript\u201d or at the very least offers type definitions that are veneered over runtime functionality, but too few packages in the ecosystem actually design their APIs with TypeScript in mind. So while I\u2019m pleased that your router is auto-completing your option fields and catching a few property/method typos here and there, there is much more to be had.\n\n- TanStack Router is fully aware of all of your routes and their configuration at any given point in your code. This includes the path, path params, search params, context, and any other configuration you\u2019ve provided. Ultimately this means that you can navigate to any route in your app with 100% type safety and confidence that your link or navigate call will succeed.\n- TanStack Router provides lossless type-inference. It uses countless generic type parameters to enforce and propagate any type information you give it throughout the rest of its API and ultimately your app. No other router offers this level of type safety and developer confidence.\n\nWhat does all of that mean for you?\n\n- Faster feature development with auto-completion and type hints\n- Safer and faster refactors\n- Confidence that your code will work as expected\n\n[## 1st Class Search Parameters](#1st-class-search-parameters)\n\nSearch parameters are often an afterthought, treated like a black box of strings (or string) that you can parse and update, but not much else. Existing solutions are **not** type-safe either, adding to the caution that is required to deal with them. Even the most \"modern\" frameworks and routers leave it up to you to figure out how to manage this state. Sometimes they'll parse the search string into an object for you, or sometimes you're left to do it yourself with URLSearchParams.\n\nLet's step back and remember that **search params are the most powerful state manager in your entire application.** They are global, serializable, bookmarkable, and shareable making them the perfect place to store any kind of state that needs to survive a page refresh or a social share.\n\nTo live up to that responsibility, search parameters are a first-class citizen in TanStack Router. While still based on standard URLSearchParams, TanStack Router uses a powerful parser/serializer to manage deeper and more complex data structures in your search params, all while keeping them type-safe and easy to work with.\n\n**It's like having useState right in the URL!**\n\nSearch parameters are:\n\n- Automatically parsed and serialized as JSON\n- Validated and typed\n- Inherited from parent routes\n- Accessible in loaders, components, and hooks\n- Easily modified with the useSearch hook, Link, navigate, and router.navigate APIs\n- Customizable with a custom search filters and middleware\n- Subscribed via fine-grained search param selectors for efficient re-renders\n\nOnce you start using TanStack Router's search parameters, you'll wonder how you ever lived without them.\n\n[## Built-In Caching and Friendly Data Loading](#built-in-caching-and-friendly-data-loading)\n\nData loading is a critical part of any application and while most existing routers offer some form of critical data loading APIs, they often fall short when it comes to caching and data lifecycle management. Existing solutions suffer from a few common problems:\n\n- No caching at all. Data is always fresh, but your users are left waiting for frequently accessed data to load over and over again.\n- Overly-aggressive caching. Data is cached for too long, leading to stale data and a poor user experience.\n- Blunt invalidation strategies and APIs. Data may be invalidated too often, leading to unnecessary network requests and wasted resources, or you may not have any fine-grained control over when data is invalidated at all.\n\nTanStack Router solves these problems with a two-prong approach to caching and data loading:\n\n[### Built-in Cache](#built-in-cache)\n\nTanStack Router provides a light-weight built-in caching layer that works seamlessly with the Router. This caching layer is loosely based on TanStack Query, but with fewer features and a much smaller API surface area. Like TanStack Query, sane but powerful defaults guarantee that your data is cached for reuse, invalidated when necessary, and garbage collected when not in use. It also provides a simple API for invalidating the cache manually when needed.\n\n[### Flexible & Powerful Data Lifecycle APIs](#flexible--powerful-data-lifecycle-apis)\n\nTanStack Router is designed with a flexible and powerful data loading API that more easily integrates with existing data fetching libraries like TanStack Query, SWR, Apollo, Relay, or even your own custom data fetching solution. Configurable APIs like context, beforeLoad, loaderDeps and loader work in unison to make it easy to define declarative data dependencies, prefetch data, and manage the lifecycle of an external data source with ease.\n\n[## Inherited Route Context](#inherited-route-context)\n\nTanStack Router's router and route context is a powerful feature that allows you to define context that is specific to a route which is then inherited by all child routes. Even the router and root routes themselves can provide context. Context can be built up both synchronously and asynchronously, and can be used to share data, configuration, or even functions between routes and route configurations. This is especially useful for scenarios like:\n\n- Authentication and Authorization\n- Hybrid SSR/CSR data fetching and preloading\n- Theming\n- Singletons and global utilities\n- Curried or partial application across preloading, loading, and rendering stages\n\nAlso, what would route context be if it weren't type-safe? TanStack Router's route context is fully type-safe and inferred at zero cost to you.\n\n[## File-based and/or Code-Based Routing](#file-based-andor-code-based-routing)\n\nTanStack Router supports both file-based and code-based routing at the same time. This flexibility allows you to choose the approach that best fits your project's needs.\n\nTanStack Router's file-based routing approach is uniquely user-facing. Route configuration is generated for you either by the Vite plugin or TanStack Router CLI, leaving the usage of said generated code up to you! This means that you're always in total control of your routes and router, even if you use file-based routing.\n\n[## Acknowledgements](#acknowledgements)\n\nTanStack Router builds on concepts and patterns popularized by many other OSS projects, including:\n\n- [TRPC](https://trpc.io/)\n- [Remix](https://remix.run)\n- [Chicane](https://swan-io.github.io/chicane/)\n- [Next.js](https://nextjs.org)\n\nWe acknowledge the investment, risk and research that went into their development, but are excited to push the bar they have set even higher.\n\n[## Let's go!](#lets-go)\n\nEnough overview, there's so much more to do with TanStack Router. Hit that next button and let's get started!",
  "tags": [
    "tanstack",
    "router",
    "react",
    "navigation"
  ],
  "extracted_at": "2026-02-03T12:51:57.447344+00:00",
  "content_length": 8228,
  "content_hash": "2d6e7fd3c4a7082a"
}