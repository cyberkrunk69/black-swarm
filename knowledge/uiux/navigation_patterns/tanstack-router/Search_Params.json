{
  "id": "tanstack-router__router_latest_docs_framework_react_guide_search-p",
  "source_id": "tanstack-router",
  "source_name": "TanStack Router",
  "category": "navigation_patterns",
  "url": "https://tanstack.com/router/latest/docs/framework/react/guide/search-params",
  "title": "Search Params",
  "content": "Similar to how TanStack Query made handling server-state in your React and Solid applications a breeze, TanStack Router aims to unlock the power of URL search params in your applications.\n\ud83e\udde0 If you are on a really old browser, like IE11, you may need to use a polyfill for\nURLSearchParams\n.\nWhy not just use\nURLSearchParams\n?\nWe get it, you've been hearing a lot of \"use the platform\" lately and for the most part, we agree. However, we also believe it's important to recognize where the platform falls short for more advanced use-cases and we believe\nURLSearchParams\nis one of these circumstances.\nTraditional Search Param APIs usually assume a few things:\nSearch params are always strings\nThey are\nmostly\nflat\nSerializing and deserializing using\nURLSearchParams\nis good enough (Spoiler alert: it's not.)\nSearch params modifications are tightly coupled with the URL's pathname and must be updated together, even if the pathname is not changing.\nReality is very different from these assumptions though.\nSearch params represent application state, so inevitably, we will expect them to have the same DX associated with other state managers. This means having the capability of distinguishing between primitive value types and efficiently storing and manipulating complex data structures like nested arrays and objects.\nThere are many ways to serialize and deserialize state with different tradeoffs. You should be able to choose the best one for your application or at the very least get a better default than\nURLSearchParams\n.\nImmutability & Structural Sharing. Every time you stringify and parse url search params, referential integrity and object identity is lost because each new parse creates a brand new data structure with a unique memory reference. If not properly managed over its lifetime, this constant serialization and parsing can result in unexpected and undesirable performance issues, especially in frameworks like React that choose to track reactivity via immutability or in Solid that normally relies on reconciliation to detect changes from deserialized data sources.\nSearch params, while an important part of the URL, do frequently change independently of the URL's pathname. For example, a user may want to change the page number of a paginated list without touching the URL's pathname.\nSearch Params, the \"OG\" State Manager\nYou've probably seen search params like\n?page=3\nor\n?filter-name=tanner\nin the URL. There is no question that this is truly\na form of global state\nliving inside of the URL. It's valuable to store specific pieces of state in the URL because:\nUsers should be able to:\nCmd/Ctrl + Click to open a link in a new tab and reliably see the state they expected\nBookmark and share links from your application with others with assurances that they will see exactly the state as when the link was copied.\nRefresh your app or navigate back and forth between pages without losing their state\nDevelopers should be able to easily:\nAdd, remove or modify state in the URL with the same great DX as other state managers\nEasily validate search params coming from the URL in a format and type that is safe for their application to consume\nRead and write to search params without having to worry about the underlying serialization format\nJSON-first Search Params\nTo achieve the above, the first step built in to TanStack Router is a powerful search param parser that automatically converts the search string of your URL to structured JSON. This means that you can store any JSON-serializable data structure in your search params and it will be parsed and serialized as JSON. This is a huge improvement over\nURLSearchParams\nwhich has limited support for array-like structures and nested data.\nFor example, navigating to the following route:\ntsx\nconst link = (\n  <Link\n    to=\"/shop\"\n    search={{\n      pageIndex: 3,\n      includeCategories: ['electronics', 'gifts'],\n      sortBy: 'price',\n      desc: true,\n    }}\n  />\n)\nWill result in the following URL:\n/shop?pageIndex=3&includeCategories=%5B%22electronics%22%2C%22gifts%22%5D&sortBy=price&desc=true\nWhen this URL is parsed, the search params will be accurately converted back to the following JSON:\njson\n{\n  \"pageIndex\": 3,\n  \"includeCategories\": [\"electronics\", \"gifts\"],\n  \"sortBy\": \"price\",\n  \"desc\": true\n}\nIf you noticed, there are a few things going on here:\nThe first level of the search params is flat and string based, just like\nURLSearchParams\n.\nFirst level values that are not strings are accurately preserved as actual numbers and booleans.\nNested data structures are automatically converted to URL-safe JSON strings\n\ud83e\udde0 It's common for other tools to assume that search params are always flat and string-based which is why we've chosen to keep things URLSearchParam compliant at the first level. This ultimately means that even though TanStack Router is managing your nested search params as JSON, other tools will still be able to write to the URL and read first-level params normally.\nValidating and Typing Search Params\nDespite TanStack Router being able to parse search params into reliable JSON, they ultimately still came from\na user-facing raw-text input\n. Similar to other serialization boundaries, this means that before you consume search params, they should be validated into a format that your application can trust and rely on.\nEnter Validation + TypeScript!\nTanStack Router provides convenient APIs for validating and typing search params. This all starts with the\nRoute\n's\nvalidateSearch\noption:\ntsx\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\nIn the above example, we're validating the search params of the\nRoute\nand returning a typed\nProductSearch\nobject. This typed object is then made available to this route's other options\nand any child routes, too!\nValidating Search Params\nThe\nvalidateSearch\noption is a function that is provided the JSON parsed (but non-validated) search params as a\nRecord<string, unknown>\nand returns a typed object of your choice. It's usually best to provide sensible fallbacks for malformed or unexpected search params so your users' experience stays non-interrupted.\nHere's an example:\ntsx\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\nHere's an example using the\nZod\nlibrary (but feel free to use any validation library you want) to both validate and type the search params in a single step:\ntsx\n// /routes/shop.products.tsx\n\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search) => productSearchSchema.parse(search),\n})\nBecause\nvalidateSearch\nalso accepts an object with the\nparse\nproperty, this can be shortened to:\ntsx\nvalidateSearch: productSearchSchema\nIn the above example, we used Zod's\n.catch()\nmodifier instead of\n.default()\nto avoid showing an error to the user because we firmly believe that if a search parameter is malformed, you probably don't want to halt the user's experience through the app to show a big fat error message. That said, there may be times that you\ndo want to show an error message\n. In that case, you can use\n.default()\ninstead of\n.catch()\n.\nThe underlying mechanics why this works relies on the\nvalidateSearch\nfunction throwing an error. If an error is thrown, the route's\nonError\noption will be triggered (and\nerror.routerCode\nwill be set to\nVALIDATE_SEARCH\nand the\nerrorComponent\nwill be rendered instead of the route's\ncomponent\nwhere you can handle the search param error however you'd like.\nAdapters\nWhen using a library like\nZod\nto validate search params you might want to\ntransform\nsearch params before committing the search params to the URL. A common\nzod\ntransform\nis\ndefault\nfor example.\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\nIt might be surprising that when you try to navigate to this route,\nsearch\nis required. The following\nLink\nwill type error as\nsearch\nis missing.\ntsx\n<Link to=\"/shop/products\" />\nFor validation libraries we recommend using adapters which infer the correct\ninput\nand\noutput\ntypes.\nZod\nAn adapter is provided for\nZod\nwhich will pipe through the correct\ninput\ntype and\noutput\ntype\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\nThe important part here is the following use of\nLink\nno longer requires\nsearch\nparams\ntsx\n<Link to=\"/shop/products\" />\nHowever the use of\ncatch\nhere overrides the types and makes\npage\n,\nfilter\nand\nsort\nunknown\ncausing type loss. We have handled this case by providing a\nfallback\ngeneric function which retains the types but provides a\nfallback\nvalue when validation fails\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { fallback, zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\nTherefore when navigating to this route,\nsearch\nis optional and retains the correct types.\nWhile not recommended, it is also possible to configure\ninput\nand\noutput\ntype in case the\noutput\ntype is more accurate than the\ninput\ntype\ntsx\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator({\n    schema: productSearchSchema,\n    input: 'output',\n    output: 'input',\n  }),\n})\nThis provides flexibility in which type you want to infer for navigation and which types you want to infer for reading search params.\nValibot\nWarning\nRouter expects the valibot 1.0 package to be installed.\nWhen using\nValibot\nan adapter is not needed to ensure the correct\ninput\nand\noutput\ntypes are used for navigation and reading search params. This is because\nvalibot\nimplements\nStandard Schema\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport * as v from 'valibot'\n\nconst productSearchSchema = v.object({\n  page: v.optional(v.fallback(v.number(), 1), 1),\n  filter: v.optional(v.fallback(v.string(), ''), ''),\n  sort: v.optional(\n    v.fallback(v.picklist(['newest', 'oldest', 'price']), 'newest'),\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\nArktype\nWarning\nRouter expects the arktype 2.0-rc package to be installed.\nWhen using\nArkType\nan adapter is not needed to ensure the correct\ninput\nand\noutput\ntypes are used for navigation and reading search params. This is because\nArkType\nimplements\nStandard Schema\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { type } from 'arktype'\n\nconst productSearchSchema = type({\n  page: 'number = 1',\n  filter: 'string = \"\"',\n  sort: '\"newest\" | \"oldest\" | \"price\" = \"newest\"',\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\nEffect/Schema\nWhen using\nEffect/Schema\nan adapter is not needed to ensure the correct\ninput\nand\noutput\ntypes are used for navigation and reading search params. This is because\nEffect/Schema\nimplements\nStandard Schema\ntsx\nimport { createFileRoute } from '@tanstack/react-router'\nimport { Schema as S } from 'effect'\n\nconst productSearchSchema = S.standardSchemaV1(\n  S.Struct({\n    page: S.NumberFromString.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 1,\n        decoding: () => 1,\n      }),\n    ),\n    filter: S.String.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => '',\n        decoding: () => '',\n      }),\n    ),\n    sort: S.Literal('newest', 'oldest', 'price').pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 'newest' as const,\n        decoding: () => 'newest' as const,\n      }),\n    ),\n  }),\n)\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\nReading Search Params\nOnce your search params have been validated and typed, you're finally ready to start reading and writing to them. There are a few ways to do this in TanStack Router, so let's check them out.\nUsing Search Params in Loaders\nPlease read the\nSearch Params in Loaders\nsection for more information about how to read search params in loaders with the\nloaderDeps\noption.\nSearch Params are inherited from Parent Routes\nThe search parameters and types of parents are merged as you go down the route tree, so child routes also have access to their parent's search params:\nshop.products.tsx\ntsx\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\nshop.products.$productId.tsx\ntsx\nexport const Route = createFileRoute('/shop/products/$productId')({\n  beforeLoad: ({ search }) => {\n    search\n    // ^? ProductSearch \u2705\n  },\n})\nSearch Params in Components\nYou can access your route's validated search params in your route's\ncomponent\nvia the\nuseSearch\nhook.\ntsx\n// /routes/shop.products.tsx\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const { page, filter, sort } = Route.useSearch()\n\n  return <div>...</div>\n}\nTip\nIf your component is code-split, you can use the\ngetRouteApi function\nto avoid having to import the\nRoute\nconfiguration to get access to the typed\nuseSearch()\nhook.\nSearch Params outside of Route Components\nYou can access your route's validated search params anywhere in your app using the\nuseSearch\nhook. By passing the\nfrom\nid/path of your origin route, you'll get even better type safety:\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n  // ...\n})\n\n// Somewhere else...\n\n// /components/product-list-sidebar.tsx\nconst routeApi = getRouteApi('/shop/products')\n\nconst ProductList = () => {\n  const routeSearch = routeApi.useSearch()\n\n  // OR\n\n  const { page, filter, sort } = useSearch({\n    from: Route.fullPath,\n  })\n\n  return <div>...</div>\n}\nOr, you can loosen up the type-safety and get an optional\nsearch\nobject by passing\nstrict: false\n:\ntsx\nfunction ProductList() {\n  const search = useSearch({\n    strict: false,\n  })\n  // {\n  //   page: number | undefined\n  //   filter: string | undefined\n  //   sort: 'newest' | 'oldest' | 'price' | undefined\n  // }\n\n  return <div>...</div>\n}\nWriting Search Params\nNow that you've learned how to read your route's search params, you'll be happy to know that you've already seen the primary APIs to modify and update them. Let's remind ourselves a bit\n<Link search />\nThe best way to update search params is to use the\nsearch\nprop on the\n<Link />\ncomponent.\nIf the search for the current page shall be updated and the\nfrom\nprop is specified, the\nto\nprop can be omitted.\nHere's an example:\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  return (\n    <div>\n      <Link from={Route.fullPath} search={(prev) => ({ page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\nIf you want to update the search params in a generic component that is rendered on multiple routes, specifying\nfrom\ncan be challenging.\nIn this scenario you can set\nto=\".\"\nwhich will give you access to loosely typed search params.\nHere is an example that illustrates this:\ntsx\n// `page` is a search param that is defined in the __root route and hence available on all routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link to=\".\" search={(prev) => ({ ...prev, page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\nIf the generic component is only rendered in a specific subtree of the route tree, you can specify that subtree using\nfrom\n. Here you can omit\nto='.'\nif you want.\ntsx\n// `page` is a search param that is defined in the /posts route and hence available on all of its child routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link\n        from=\"/posts\"\n        to=\".\"\n        search={(prev) => ({ ...prev, page: prev.page + 1 })}\n      >\n        Next Page\n      </Link>\n    </div>\n  )\nuseNavigate(), navigate({ search })\nThe\nnavigate\nfunction also accepts a\nsearch\noption that works the same way as the\nsearch\nprop on\n<Link />\n:\ntsx\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products/$productId')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const navigate = useNavigate({ from: Route.fullPath })\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          navigate({\n            search: (prev) => ({ page: prev.page + 1 }),\n          })\n        }}\n      >\n        Next Page\n      </button>\n    </div>\n  )\n}\nrouter.navigate({ search })\nThe\nrouter.navigate\nfunction works exactly the same way as the\nuseNavigate\n/\nnavigate\nhook/function above.\n<Navigate search />\nThe\n<Navigate search />\ncomponent works exactly the same way as the\nuseNavigate\n/\nnavigate\nhook/function above, but accepts its options as props instead of a function argument.\nTransforming search with search middlewares\nWhen link hrefs are built, by default the only thing that matters for the query string part is the\nsearch\nproperty of a\n<Link>\n.\nTanStack Router provides a way to manipulate search params before the href is generated via\nsearch middlewares\n.\nSearch middlewares are functions that transform the search parameters when generating new links for a route or its descendants.\nThey are also executed upon navigation after search validation to allow manipulation of the query string.\nThe following example shows how to make sure that for\nevery\nlink that is being built, the\nrootValue\nsearch param is added\nif\nit is part of the current search params. If a link specifies\nrootValue\ninside\nsearch\n, then that value is used for building the link.\ntsx\nimport { z } from 'zod'\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [\n      ({ search, next }) => {\n        const result = next(search)\n        return {\n          rootValue: search.rootValue,\n          ...result,\n        }\n      },\n    ],\n  },\n})\nSince this specific use case is quite common, TanStack Router provides a generic implementation to retain search params via\nretainSearchParams\n:\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, retainSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [retainSearchParams(['rootValue'])],\n  },\n})\nAnother common use case is to strip out search params from links if their default value is set. TanStack Router provides a generic implementation for this use case via\nstripSearchParams\n:\ntsx\nimport { z } from 'zod'\nimport { createFileRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = {\n  one: 'abc',\n  two: 'xyz',\n}\n\nconst searchSchema = z.object({\n  one: z.string().default(defaultValues.one),\n  two: z.string().default(defaultValues.two),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // strip default values\n    middlewares: [stripSearchParams(defaultValues)],\n  },\n})\nMultiple middlewares can be chained. The following example shows how to combine both\nretainSearchParams\nand\nstripSearchParams\n.\ntsx\nimport {\n  Link,\n  createFileRoute,\n  retainSearchParams,\n  stripSearchParams,\n} from '@tanstack/react-router'\nimport { z } from 'zod'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = ['foo', 'bar']\n\nexport const Route = createFileRoute('/search')({\n  validateSearch: zodValidator(\n    z.object({\n      retainMe: z.string().optional(),\n      arrayWithDefaults: z.string().array().default(defaultValues),\n      required: z.string(),\n    }),\n  ),\n  search: {\n    middlewares: [\n      retainSearchParams(['retainMe']),\n      stripSearchParams({ arrayWithDefaults: defaultValues }),\n    ],\n  },\n})",
  "content_markdown": "Similar to how TanStack Query made handling server-state in your React and Solid applications a breeze, TanStack Router aims to unlock the power of URL search params in your applications.\n\n> \ud83e\udde0 If you are on a really old browser, like IE11, you may need to use a polyfill for URLSearchParams.\n\n[## Why not just use URLSearchParams?](#why-not-just-use-urlsearchparams)\n\nWe get it, you've been hearing a lot of \"use the platform\" lately and for the most part, we agree. However, we also believe it's important to recognize where the platform falls short for more advanced use-cases and we believe URLSearchParams is one of these circumstances.\n\nTraditional Search Param APIs usually assume a few things:\n\n- Search params are always strings\n- They are *mostly* flat\n- Serializing and deserializing using URLSearchParams is good enough (Spoiler alert: it's not.)\n- Search params modifications are tightly coupled with the URL's pathname and must be updated together, even if the pathname is not changing.\n\nReality is very different from these assumptions though.\n\n- Search params represent application state, so inevitably, we will expect them to have the same DX associated with other state managers. This means having the capability of distinguishing between primitive value types and efficiently storing and manipulating complex data structures like nested arrays and objects.\n- There are many ways to serialize and deserialize state with different tradeoffs. You should be able to choose the best one for your application or at the very least get a better default than URLSearchParams.\n- Immutability & Structural Sharing. Every time you stringify and parse url search params, referential integrity and object identity is lost because each new parse creates a brand new data structure with a unique memory reference. If not properly managed over its lifetime, this constant serialization and parsing can result in unexpected and undesirable performance issues, especially in frameworks like React that choose to track reactivity via immutability or in Solid that normally relies on reconciliation to detect changes from deserialized data sources.\n- Search params, while an important part of the URL, do frequently change independently of the URL's pathname. For example, a user may want to change the page number of a paginated list without touching the URL's pathname.\n\n[## Search Params, the \"OG\" State Manager](#search-params-the-og-state-manager)\n\nYou've probably seen search params like ?page=3 or ?filter-name=tanner in the URL. There is no question that this is truly **a form of global state** living inside of the URL. It's valuable to store specific pieces of state in the URL because:\n\n- Users should be able to:\n  - Cmd/Ctrl + Click to open a link in a new tab and reliably see the state they expected\n  - Bookmark and share links from your application with others with assurances that they will see exactly the state as when the link was copied.\n  - Refresh your app or navigate back and forth between pages without losing their state\n- Developers should be able to easily:\n  - Add, remove or modify state in the URL with the same great DX as other state managers\n  - Easily validate search params coming from the URL in a format and type that is safe for their application to consume\n  - Read and write to search params without having to worry about the underlying serialization format\n\n[## JSON-first Search Params](#json-first-search-params)\n\nTo achieve the above, the first step built in to TanStack Router is a powerful search param parser that automatically converts the search string of your URL to structured JSON. This means that you can store any JSON-serializable data structure in your search params and it will be parsed and serialized as JSON. This is a huge improvement over URLSearchParams which has limited support for array-like structures and nested data.\n\nFor example, navigating to the following route:\n\ntsx\n\n```\nconst link = (\n  <Link\n    to=\"/shop\"\n    search={{\n      pageIndex: 3,\n      includeCategories: ['electronics', 'gifts'],\n      sortBy: 'price',\n      desc: true,\n    }}\n  />\n)\n```\n\nWill result in the following URL:\n\n```\n/shop?pageIndex=3&includeCategories=%5B%22electronics%22%2C%22gifts%22%5D&sortBy=price&desc=true\n```\n\nWhen this URL is parsed, the search params will be accurately converted back to the following JSON:\n\njson\n\n```\n{\n  \"pageIndex\": 3,\n  \"includeCategories\": [\"electronics\", \"gifts\"],\n  \"sortBy\": \"price\",\n  \"desc\": true\n}\n```\n\nIf you noticed, there are a few things going on here:\n\n- The first level of the search params is flat and string based, just like URLSearchParams.\n- First level values that are not strings are accurately preserved as actual numbers and booleans.\n- Nested data structures are automatically converted to URL-safe JSON strings\n\n> \ud83e\udde0 It's common for other tools to assume that search params are always flat and string-based which is why we've chosen to keep things URLSearchParam compliant at the first level. This ultimately means that even though TanStack Router is managing your nested search params as JSON, other tools will still be able to write to the URL and read first-level params normally.\n\n[## Validating and Typing Search Params](#validating-and-typing-search-params)\n\nDespite TanStack Router being able to parse search params into reliable JSON, they ultimately still came from **a user-facing raw-text input**. Similar to other serialization boundaries, this means that before you consume search params, they should be validated into a format that your application can trust and rely on.\n\n[### Enter Validation + TypeScript!](#enter-validation--typescript)\n\nTanStack Router provides convenient APIs for validating and typing search params. This all starts with the Route's validateSearch option:\n\ntsx\n\n```\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n```\n\nIn the above example, we're validating the search params of the Route and returning a typed ProductSearch object. This typed object is then made available to this route's other options **and any child routes, too!**\n\n[### Validating Search Params](#validating-search-params)\n\nThe validateSearch option is a function that is provided the JSON parsed (but non-validated) search params as a Record<string, unknown> and returns a typed object of your choice. It's usually best to provide sensible fallbacks for malformed or unexpected search params so your users' experience stays non-interrupted.\n\nHere's an example:\n\ntsx\n\n```\n// /routes/shop.products.tsx\n\ntype ProductSearchSortOptions = 'newest' | 'oldest' | 'price'\n\ntype ProductSearch = {\n  page: number\n  filter: string\n  sort: ProductSearchSortOptions\n}\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search: Record<string, unknown>): ProductSearch => {\n    // validate and parse the search params into a typed state\n    return {\n      page: Number(search?.page ?? 1),\n      filter: (search.filter as string) || '',\n      sort: (search.sort as ProductSearchSortOptions) || 'newest',\n    }\n  },\n})\n```\n\nHere's an example using the [Zod](https://zod.dev/) library (but feel free to use any validation library you want) to both validate and type the search params in a single step:\n\ntsx\n\n```\n// /routes/shop.products.tsx\n\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: (search) => productSearchSchema.parse(search),\n})\n```\n\nBecause validateSearch also accepts an object with the parse property, this can be shortened to:\n\ntsx\n\n```\nvalidateSearch: productSearchSchema\n```\n\nIn the above example, we used Zod's .catch() modifier instead of .default() to avoid showing an error to the user because we firmly believe that if a search parameter is malformed, you probably don't want to halt the user's experience through the app to show a big fat error message. That said, there may be times that you **do want to show an error message**. In that case, you can use .default() instead of .catch().\n\nThe underlying mechanics why this works relies on the validateSearch function throwing an error. If an error is thrown, the route's onError option will be triggered (and error.routerCode will be set to VALIDATE\\_SEARCH and the errorComponent will be rendered instead of the route's component where you can handle the search param error however you'd like.\n\n[#### Adapters](#adapters)\n\nWhen using a library like [Zod](https://zod.dev/) to validate search params you might want to transform search params before committing the search params to the URL. A common zod transform is default for example.\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n```\n\nIt might be surprising that when you try to navigate to this route, search is required. The following Link will type error as search is missing.\n\ntsx\n\n```\n<Link to=\"/shop/products\" />\n```\n\nFor validation libraries we recommend using adapters which infer the correct input and output types.\n\n[### Zod](#zod)\n\nAn adapter is provided for [Zod](https://zod.dev/) which will pipe through the correct input type and output type\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: z.number().default(1),\n  filter: z.string().default(''),\n  sort: z.enum(['newest', 'oldest', 'price']).default('newest'),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\n```\n\nThe important part here is the following use of Link no longer requires search params\n\ntsx\n\n```\n<Link to=\"/shop/products\" />\n```\n\nHowever the use of catch here overrides the types and makes page, filter and sort unknown causing type loss. We have handled this case by providing a fallback generic function which retains the types but provides a fallback value when validation fails\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport { fallback, zodValidator } from '@tanstack/zod-adapter'\nimport { z } from 'zod'\n\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator(productSearchSchema),\n})\n```\n\nTherefore when navigating to this route, search is optional and retains the correct types.\n\nWhile not recommended, it is also possible to configure input and output type in case the output type is more accurate than the input type\n\ntsx\n\n```\nconst productSearchSchema = z.object({\n  page: fallback(z.number(), 1).default(1),\n  filter: fallback(z.string(), '').default(''),\n  sort: fallback(z.enum(['newest', 'oldest', 'price']), 'newest').default(\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: zodValidator({\n    schema: productSearchSchema,\n    input: 'output',\n    output: 'input',\n  }),\n})\n```\n\nThis provides flexibility in which type you want to infer for navigation and which types you want to infer for reading search params.\n\n[### Valibot](#valibot)\n\nWarning\n\nRouter expects the valibot 1.0 package to be installed.\n\nWhen using [Valibot](https://valibot.dev/) an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because valibot implements [Standard Schema](https://github.com/standard-schema/standard-schema)\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport * as v from 'valibot'\n\nconst productSearchSchema = v.object({\n  page: v.optional(v.fallback(v.number(), 1), 1),\n  filter: v.optional(v.fallback(v.string(), ''), ''),\n  sort: v.optional(\n    v.fallback(v.picklist(['newest', 'oldest', 'price']), 'newest'),\n    'newest',\n  ),\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n```\n\n[### Arktype](#arktype)\n\nWarning\n\nRouter expects the arktype 2.0-rc package to be installed.\n\nWhen using [ArkType](https://arktype.io/) an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because [ArkType](https://arktype.io/) implements [Standard Schema](https://github.com/standard-schema/standard-schema)\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport { type } from 'arktype'\n\nconst productSearchSchema = type({\n  page: 'number = 1',\n  filter: 'string = \"\"',\n  sort: '\"newest\" | \"oldest\" | \"price\" = \"newest\"',\n})\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n```\n\n[### Effect/Schema](#effectschema)\n\nWhen using [Effect/Schema](https://effect.website/docs/schema/introduction/) an adapter is not needed to ensure the correct input and output types are used for navigation and reading search params. This is because [Effect/Schema](https://effect.website/docs/schema/standard-schema/) implements [Standard Schema](https://github.com/standard-schema/standard-schema)\n\ntsx\n\n```\nimport { createFileRoute } from '@tanstack/react-router'\nimport { Schema as S } from 'effect'\n\nconst productSearchSchema = S.standardSchemaV1(\n  S.Struct({\n    page: S.NumberFromString.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 1,\n        decoding: () => 1,\n      }),\n    ),\n    filter: S.String.pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => '',\n        decoding: () => '',\n      }),\n    ),\n    sort: S.Literal('newest', 'oldest', 'price').pipe(\n      S.optional,\n      S.withDefaults({\n        constructor: () => 'newest' as const,\n        decoding: () => 'newest' as const,\n      }),\n    ),\n  }),\n)\n\nexport const Route = createFileRoute('/shop/products/')({\n  validateSearch: productSearchSchema,\n})\n```\n\n[## Reading Search Params](#reading-search-params)\n\nOnce your search params have been validated and typed, you're finally ready to start reading and writing to them. There are a few ways to do this in TanStack Router, so let's check them out.\n\n[### Using Search Params in Loaders](#using-search-params-in-loaders)\n\nPlease read the [Search Params in Loaders](/router/latest/docs/framework/react/guide/data-loading#using-loaderdeps-to-access-search-params) section for more information about how to read search params in loaders with the loaderDeps option.\n\n[### Search Params are inherited from Parent Routes](#search-params-are-inherited-from-parent-routes)\n\nThe search parameters and types of parents are merged as you go down the route tree, so child routes also have access to their parent's search params:\n\n- shop.products.tsx\n\ntsx\n\n```\nconst productSearchSchema = z.object({\n  page: z.number().catch(1),\n  filter: z.string().catch(''),\n  sort: z.enum(['newest', 'oldest', 'price']).catch('newest'),\n})\n\ntype ProductSearch = z.infer<typeof productSearchSchema>\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n```\n\n- shop.products.$productId.tsx\n\ntsx\n\n```\nexport const Route = createFileRoute('/shop/products/$productId')({\n  beforeLoad: ({ search }) => {\n    search\n    // ^? ProductSearch \u2705\n  },\n})\n```\n\n[### Search Params in Components](#search-params-in-components)\n\nYou can access your route's validated search params in your route's component via the useSearch hook.\n\ntsx\n\n```\n// /routes/shop.products.tsx\n\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const { page, filter, sort } = Route.useSearch()\n\n  return <div>...</div>\n}\n```\n\nTip\n\nIf your component is code-split, you can use the [getRouteApi function](/router/latest/docs/framework/react/guide/code-splitting#manually-accessing-route-apis-in-other-files-with-the-getrouteapi-helper) to avoid having to import the Route configuration to get access to the typed useSearch() hook.\n\n[### Search Params outside of Route Components](#search-params-outside-of-route-components)\n\nYou can access your route's validated search params anywhere in your app using the useSearch hook. By passing the from id/path of your origin route, you'll get even better type safety:\n\ntsx\n\n```\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n  // ...\n})\n\n// Somewhere else...\n\n// /components/product-list-sidebar.tsx\nconst routeApi = getRouteApi('/shop/products')\n\nconst ProductList = () => {\n  const routeSearch = routeApi.useSearch()\n\n  // OR\n\n  const { page, filter, sort } = useSearch({\n    from: Route.fullPath,\n  })\n\n  return <div>...</div>\n}\n```\n\nOr, you can loosen up the type-safety and get an optional search object by passing strict: false:\n\ntsx\n\n```\nfunction ProductList() {\n  const search = useSearch({\n    strict: false,\n  })\n  // {\n  //   page: number | undefined\n  //   filter: string | undefined\n  //   sort: 'newest' | 'oldest' | 'price' | undefined\n  // }\n\n  return <div>...</div>\n}\n```\n\n[## Writing Search Params](#writing-search-params)\n\nNow that you've learned how to read your route's search params, you'll be happy to know that you've already seen the primary APIs to modify and update them. Let's remind ourselves a bit\n\n[### <Link search />](#link-search-)\n\nThe best way to update search params is to use the search prop on the <Link /> component.\n\nIf the search for the current page shall be updated and the from prop is specified, the to prop can be omitted.  \nHere's an example:\n\ntsx\n\n```\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  return (\n    <div>\n      <Link from={Route.fullPath} search={(prev) => ({ page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\n```\n\nIf you want to update the search params in a generic component that is rendered on multiple routes, specifying from can be challenging.\n\nIn this scenario you can set to=\".\" which will give you access to loosely typed search params.  \nHere is an example that illustrates this:\n\ntsx\n\n```\n// `page` is a search param that is defined in the __root route and hence available on all routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link to=\".\" search={(prev) => ({ ...prev, page: prev.page + 1 })}>\n        Next Page\n      </Link>\n    </div>\n  )\n}\n```\n\nIf the generic component is only rendered in a specific subtree of the route tree, you can specify that subtree using from. Here you can omit to='.' if you want.\n\ntsx\n\n```\n// `page` is a search param that is defined in the /posts route and hence available on all of its child routes.\nconst PageSelector = () => {\n  return (\n    <div>\n      <Link\n        from=\"/posts\"\n        to=\".\"\n        search={(prev) => ({ ...prev, page: prev.page + 1 })}\n      >\n        Next Page\n      </Link>\n    </div>\n  )\n```\n\n[### useNavigate(), navigate({ search })](#usenavigate-navigate-search-)\n\nThe navigate function also accepts a search option that works the same way as the search prop on <Link />:\n\ntsx\n\n```\n// /routes/shop.products.tsx\nexport const Route = createFileRoute('/shop/products/$productId')({\n  validateSearch: productSearchSchema,\n})\n\nconst ProductList = () => {\n  const navigate = useNavigate({ from: Route.fullPath })\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          navigate({\n            search: (prev) => ({ page: prev.page + 1 }),\n          })\n        }}\n      >\n        Next Page\n      </button>\n    </div>\n  )\n}\n```\n\n[### router.navigate({ search })](#routernavigate-search-)\n\nThe router.navigate function works exactly the same way as the useNavigate/navigate hook/function above.\n\n[### <Navigate search />](#navigate-search-)\n\nThe <Navigate search /> component works exactly the same way as the useNavigate/navigate hook/function above, but accepts its options as props instead of a function argument.\n\n[## Transforming search with search middlewares](#transforming-search-with-search-middlewares)\n\nWhen link hrefs are built, by default the only thing that matters for the query string part is the search property of a <Link>.\n\nTanStack Router provides a way to manipulate search params before the href is generated via **search middlewares**.\nSearch middlewares are functions that transform the search parameters when generating new links for a route or its descendants.\nThey are also executed upon navigation after search validation to allow manipulation of the query string.\n\nThe following example shows how to make sure that for **every** link that is being built, the rootValue search param is added *if* it is part of the current search params. If a link specifies rootValue inside search, then that value is used for building the link.\n\ntsx\n\n```\nimport { z } from 'zod'\nimport { createFileRoute } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [\n      ({ search, next }) => {\n        const result = next(search)\n        return {\n          rootValue: search.rootValue,\n          ...result,\n        }\n      },\n    ],\n  },\n})\n```\n\nSince this specific use case is quite common, TanStack Router provides a generic implementation to retain search params via retainSearchParams:\n\ntsx\n\n```\nimport { z } from 'zod'\nimport { createFileRoute, retainSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst searchSchema = z.object({\n  rootValue: z.string().optional(),\n})\n\nexport const Route = createRootRoute({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    middlewares: [retainSearchParams(['rootValue'])],\n  },\n})\n```\n\nAnother common use case is to strip out search params from links if their default value is set. TanStack Router provides a generic implementation for this use case via stripSearchParams:\n\ntsx\n\n```\nimport { z } from 'zod'\nimport { createFileRoute, stripSearchParams } from '@tanstack/react-router'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = {\n  one: 'abc',\n  two: 'xyz',\n}\n\nconst searchSchema = z.object({\n  one: z.string().default(defaultValues.one),\n  two: z.string().default(defaultValues.two),\n})\n\nexport const Route = createFileRoute('/hello')({\n  validateSearch: zodValidator(searchSchema),\n  search: {\n    // strip default values\n    middlewares: [stripSearchParams(defaultValues)],\n  },\n})\n```\n\nMultiple middlewares can be chained. The following example shows how to combine both retainSearchParams and stripSearchParams.\n\ntsx\n\n```\nimport {\n  Link,\n  createFileRoute,\n  retainSearchParams,\n  stripSearchParams,\n} from '@tanstack/react-router'\nimport { z } from 'zod'\nimport { zodValidator } from '@tanstack/zod-adapter'\n\nconst defaultValues = ['foo', 'bar']\n\nexport const Route = createFileRoute('/search')({\n  validateSearch: zodValidator(\n    z.object({\n      retainMe: z.string().optional(),\n      arrayWithDefaults: z.string().array().default(defaultValues),\n      required: z.string(),\n    }),\n  ),\n  search: {\n    middlewares: [\n      retainSearchParams(['retainMe']),\n      stripSearchParams({ arrayWithDefaults: defaultValues }),\n    ],\n  },\n})\n```",
  "tags": [
    "tanstack",
    "router",
    "react",
    "navigation"
  ],
  "extracted_at": "2026-02-03T12:52:03.492991+00:00",
  "content_length": 22627,
  "content_hash": "70a19252c3a5ff3e"
}