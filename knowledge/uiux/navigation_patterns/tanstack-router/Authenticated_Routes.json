{
  "id": "tanstack-router__router_latest_docs_framework_react_guide_authenti",
  "source_id": "tanstack-router",
  "source_name": "TanStack Router",
  "category": "navigation_patterns",
  "url": "https://tanstack.com/router/latest/docs/framework/react/guide/authenticated-routes",
  "title": "Authenticated Routes",
  "content": "Authentication is an extremely common requirement for web applications. In this guide, we'll walk through how to use TanStack Router to build protected routes, and how to redirect users to login if they try to access them.\nThe\nroute.beforeLoad\nOption\nThe\nroute.beforeLoad\noption allows you to specify a function that will be called before a route is loaded. It receives all of the same arguments that the\nroute.loader\nfunction does. This is a great place to check if a user is authenticated, and redirect them to a login page if they are not.\nThe\nbeforeLoad\nfunction runs in relative order to these other route loading functions:\nRoute Matching (Top-Down)\nroute.params.parse\nroute.validateSearch\nRoute Loading (including Preloading)\nroute.beforeLoad\nroute.onError\nRoute Loading (Parallel)\nroute.component.preload?\nroute.load\nIt's important to know that the\nbeforeLoad\nfunction for a route is called\nbefore any of its child routes'\nbeforeLoad\nfunctions\n.\nIt is essentially a middleware function for the route and all of its children.\nIf you throw an error in\nbeforeLoad\n, none of its children will attempt to load\n.\nRedirecting\nWhile not required, some authentication flows require redirecting to a login page. To do this, you can\nthrow a\nredirect()\nfrom\nbeforeLoad\n:\ntsx\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  beforeLoad: async ({ location }) => {\n    if (!isAuthenticated()) {\n      throw redirect({\n        to: '/login',\n        search: {\n          // Use the current location to power a redirect after login\n          // (Do not use `router.state.resolvedLocation` as it can\n          // potentially lag behind the actual current location)\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\nTip\nThe\nredirect()\nfunction takes all of the same options as the\nnavigate\nfunction, so you can pass options like\nreplace: true\nif you want to replace the current history entry instead of adding a new one.\nHandling Auth Check Failures\nIf your authentication check can throw errors (network failures, token validation, etc.), wrap it in try/catch:\ntsx\nimport { createFileRoute, redirect, isRedirect } from '@tanstack/react-router'\n\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  beforeLoad: async ({ location }) => {\n    try {\n      const user = await verifySession() // might throw on network error\n      if (!user) {\n        throw redirect({\n          to: '/login',\n          search: { redirect: location.href },\n        })\n      }\n      return { user }\n    } catch (error) {\n      // Re-throw redirects (they're intentional, not errors)\n      if (isRedirect(error)) throw error\n\n      // Auth check failed (network error, etc.) - redirect to login\n      throw redirect({\n        to: '/login',\n        search: { redirect: location.href },\n      })\n    }\n  },\n})\nThe\nisRedirect()\nhelper distinguishes between actual errors and intentional redirects.\nOnce you have authenticated a user, it's also common practice to redirect them back to the page they were trying to access. To do this, you can utilize the\nredirect\nsearch param that we added in our original redirect. Since we'll be replacing the entire URL with what it was,\nrouter.history.push\nis better suited for this than\nrouter.navigate\n:\ntsx\nrouter.history.push(search.redirect)\nNon-Redirected Authentication\nSome applications choose to not redirect users to a login page, and instead keep the user on the same page and show a login form that either replaces the main content or hides it via a modal. This is also possible with TanStack Router by simply short circuiting rendering the\n<Outlet />\nthat would normally render the child routes:\ntsx\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  component: () => {\n    if (!isAuthenticated()) {\n      return <Login />\n    }\n\n    return <Outlet />\n  },\n})\nThis keeps the user on the same page, but still allows you to render a login form. Once the user is authenticated, you can simply render the\n<Outlet />\nand the child routes will be rendered.\nAuthentication using React context/hooks\nIf your authentication flow relies on interactions with React context and/or hooks, you'll need to pass down your authentication state to TanStack Router using\nrouter.context\noption.\nImportant\nReact hooks are not meant to be consumed outside of React components. If you need to use a hook outside of a React component, you need to extract the returned state from the hook in a component that wraps your\n<RouterProvider />\nand then pass the returned value down to TanStack Router.\nWe'll cover the\nrouter.context\noptions in-detail in the\nRouter Context\nsection.\nHere's an example that uses React context and hooks for protecting authenticated routes in TanStack Router. See the entire working setup in the\nAuthenticated Routes example\n.\nsrc/routes/__root.tsx\ntsx\nimport { createRootRouteWithContext } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  // The ReturnType of your useAuth hook or the value of your AuthContext\n  auth: AuthState\n}\n\nexport const Route = createRootRouteWithContext<MyRouterContext>()({\n  component: () => <Outlet />,\n})\nsrc/router.tsx\ntsx\nimport { createRouter } from '@tanstack/react-router'\n\nimport { routeTree } from './routeTree.gen'\n\nexport const router = createRouter({\n  routeTree,\n  context: {\n    // auth will initially be undefined\n    // We'll be passing down the auth state from within a React component\n    auth: undefined!,\n  },\n})\nsrc/App.tsx\ntsx\nimport { RouterProvider } from '@tanstack/react-router'\n\nimport { AuthProvider, useAuth } from './auth'\n\nimport { router } from './router'\n\nfunction InnerApp() {\n  const auth = useAuth()\n  return <RouterProvider router={router} context={{ auth }} />\n}\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <InnerApp />\n    </AuthProvider>\n  )\n}\nThen in the authenticated route, you can check the auth state using the\nbeforeLoad\nfunction, and\nthrow a\nredirect()\nto your\nLogin route\nif the user is not signed-in.\nsrc/routes/dashboard.route.tsx\ntsx\nimport { createFileRoute, redirect } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/dashboard')({\n  beforeLoad: ({ context, location }) => {\n    if (!context.auth.isAuthenticated) {\n      throw redirect({\n        to: '/login',\n        search: {\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\nYou can\noptionally\n, also use the\nNon-Redirected Authentication\napproach to show a login form instead of calling a\nredirect\n.\nThis approach can also be used in conjunction with Pathless or Layout Route to protect all routes under their parent route.\nRelated How-To Guides\nFor detailed, step-by-step implementation guides, see:\nHow to Set Up Basic Authentication\n- Complete setup with React Context and protected routes\nHow to Integrate Authentication Providers\n- Use Auth0, Clerk, or Supabase\nHow to Set Up Role-Based Access Control\n- Implement permissions and role-based routing\nExamples\nWorking authentication examples are available in the repository:\nBasic Authentication Example\n- Simple authentication with context\nFirebase Authentication\n- Firebase Auth integration\nTanStack Start Auth Examples\n- Various auth implementations with TanStack Start",
  "content_markdown": "Authentication is an extremely common requirement for web applications. In this guide, we'll walk through how to use TanStack Router to build protected routes, and how to redirect users to login if they try to access them.\n\n[## The route.beforeLoad Option](#the-routebeforeload-option)\n\nThe route.beforeLoad option allows you to specify a function that will be called before a route is loaded. It receives all of the same arguments that the route.loader function does. This is a great place to check if a user is authenticated, and redirect them to a login page if they are not.\n\nThe beforeLoad function runs in relative order to these other route loading functions:\n\n- Route Matching (Top-Down)\n  - route.params.parse\n  - route.validateSearch\n- Route Loading (including Preloading)\n  - **route.beforeLoad**\n  - route.onError\n- Route Loading (Parallel)\n  - route.component.preload?\n  - route.load\n\n**It's important to know that the beforeLoad function for a route is called *before any of its child routes' beforeLoad functions*.** It is essentially a middleware function for the route and all of its children.\n\n**If you throw an error in beforeLoad, none of its children will attempt to load**.\n\n[## Redirecting](#redirecting)\n\nWhile not required, some authentication flows require redirecting to a login page. To do this, you can **throw a redirect()** from beforeLoad:\n\ntsx\n\n```\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  beforeLoad: async ({ location }) => {\n    if (!isAuthenticated()) {\n      throw redirect({\n        to: '/login',\n        search: {\n          // Use the current location to power a redirect after login\n          // (Do not use `router.state.resolvedLocation` as it can\n          // potentially lag behind the actual current location)\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\n```\n\nTip\n\nThe redirect() function takes all of the same options as the navigate function, so you can pass options like replace: true if you want to replace the current history entry instead of adding a new one.\n\n[### Handling Auth Check Failures](#handling-auth-check-failures)\n\nIf your authentication check can throw errors (network failures, token validation, etc.), wrap it in try/catch:\n\ntsx\n\n```\nimport { createFileRoute, redirect, isRedirect } from '@tanstack/react-router'\n\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  beforeLoad: async ({ location }) => {\n    try {\n      const user = await verifySession() // might throw on network error\n      if (!user) {\n        throw redirect({\n          to: '/login',\n          search: { redirect: location.href },\n        })\n      }\n      return { user }\n    } catch (error) {\n      // Re-throw redirects (they're intentional, not errors)\n      if (isRedirect(error)) throw error\n\n      // Auth check failed (network error, etc.) - redirect to login\n      throw redirect({\n        to: '/login',\n        search: { redirect: location.href },\n      })\n    }\n  },\n})\n```\n\nThe [isRedirect()](/router/latest/docs/framework/react/api/router/isRedirectFunction) helper distinguishes between actual errors and intentional redirects.\n\nOnce you have authenticated a user, it's also common practice to redirect them back to the page they were trying to access. To do this, you can utilize the redirect search param that we added in our original redirect. Since we'll be replacing the entire URL with what it was, router.history.push is better suited for this than router.navigate:\n\ntsx\n\n```\nrouter.history.push(search.redirect)\n```\n\n[## Non-Redirected Authentication](#non-redirected-authentication)\n\nSome applications choose to not redirect users to a login page, and instead keep the user on the same page and show a login form that either replaces the main content or hides it via a modal. This is also possible with TanStack Router by simply short circuiting rendering the <Outlet /> that would normally render the child routes:\n\ntsx\n\n```\n// src/routes/_authenticated.tsx\nexport const Route = createFileRoute('/_authenticated')({\n  component: () => {\n    if (!isAuthenticated()) {\n      return <Login />\n    }\n\n    return <Outlet />\n  },\n})\n```\n\nThis keeps the user on the same page, but still allows you to render a login form. Once the user is authenticated, you can simply render the <Outlet /> and the child routes will be rendered.\n\n[## Authentication using React context/hooks](#authentication-using-react-contexthooks)\n\nIf your authentication flow relies on interactions with React context and/or hooks, you'll need to pass down your authentication state to TanStack Router using router.context option.\n\nImportant\n\nReact hooks are not meant to be consumed outside of React components. If you need to use a hook outside of a React component, you need to extract the returned state from the hook in a component that wraps your <RouterProvider /> and then pass the returned value down to TanStack Router.\n\nWe'll cover the router.context options in-detail in the [Router Context](/router/latest/docs/framework/react/guide/router-context) section.\n\nHere's an example that uses React context and hooks for protecting authenticated routes in TanStack Router. See the entire working setup in the [Authenticated Routes example](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes).\n\n- src/routes/\\_\\_root.tsx\n\ntsx\n\n```\nimport { createRootRouteWithContext } from '@tanstack/react-router'\n\ninterface MyRouterContext {\n  // The ReturnType of your useAuth hook or the value of your AuthContext\n  auth: AuthState\n}\n\nexport const Route = createRootRouteWithContext<MyRouterContext>()({\n  component: () => <Outlet />,\n})\n```\n\n- src/router.tsx\n\ntsx\n\n```\nimport { createRouter } from '@tanstack/react-router'\n\nimport { routeTree } from './routeTree.gen'\n\nexport const router = createRouter({\n  routeTree,\n  context: {\n    // auth will initially be undefined\n    // We'll be passing down the auth state from within a React component\n    auth: undefined!,\n  },\n})\n```\n\n- src/App.tsx\n\ntsx\n\n```\nimport { RouterProvider } from '@tanstack/react-router'\n\nimport { AuthProvider, useAuth } from './auth'\n\nimport { router } from './router'\n\nfunction InnerApp() {\n  const auth = useAuth()\n  return <RouterProvider router={router} context={{ auth }} />\n}\n\nfunction App() {\n  return (\n    <AuthProvider>\n      <InnerApp />\n    </AuthProvider>\n  )\n}\n```\n\nThen in the authenticated route, you can check the auth state using the beforeLoad function, and **throw a redirect()** to your **Login route** if the user is not signed-in.\n\n- src/routes/dashboard.route.tsx\n\ntsx\n\n```\nimport { createFileRoute, redirect } from '@tanstack/react-router'\n\nexport const Route = createFileRoute('/dashboard')({\n  beforeLoad: ({ context, location }) => {\n    if (!context.auth.isAuthenticated) {\n      throw redirect({\n        to: '/login',\n        search: {\n          redirect: location.href,\n        },\n      })\n    }\n  },\n})\n```\n\nYou can *optionally*, also use the [Non-Redirected Authentication](#non-redirected-authentication) approach to show a login form instead of calling a **redirect**.\n\nThis approach can also be used in conjunction with Pathless or Layout Route to protect all routes under their parent route.\n\n[## Related How-To Guides](#related-how-to-guides)\n\nFor detailed, step-by-step implementation guides, see:\n\n- [How to Set Up Basic Authentication](/router/latest/docs/framework/react/how-to/setup-authentication) - Complete setup with React Context and protected routes\n- [How to Integrate Authentication Providers](/router/latest/docs/framework/react/how-to/setup-auth-providers) - Use Auth0, Clerk, or Supabase\n- [How to Set Up Role-Based Access Control](/router/latest/docs/framework/react/how-to/setup-rbac) - Implement permissions and role-based routing\n\n[## Examples](#examples)\n\nWorking authentication examples are available in the repository:\n\n- [Basic Authentication Example](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes) - Simple authentication with context\n- [Firebase Authentication](https://github.com/TanStack/router/tree/main/examples/react/authenticated-routes-firebase) - Firebase Auth integration\n- [TanStack Start Auth Examples](https://github.com/TanStack/router/tree/main/examples/react) - Various auth implementations with TanStack Start",
  "tags": [
    "tanstack",
    "router",
    "react",
    "navigation"
  ],
  "extracted_at": "2026-02-03T12:52:05.342396+00:00",
  "content_length": 7279,
  "content_hash": "b9ba41b34ae85b22"
}