{
  "id": "gh-cmdk_readme",
  "source_id": "gh-cmdk",
  "source_name": "cmdk",
  "category": "github_repos",
  "url": "https://github.com/pacocoursey/cmdk",
  "title": "\u2318K [![cmdk minzip package size](https://img.shields.io/bundlephobia/minzip/cmdk)](https://www.npmjs.com/package/cmdk?activeTab=code) [![cmdk package version](https://img.shields.io/npm/v/cmdk.svg?colorB=green)](https://www.npmjs.com/package/cmdk)",
  "content": "<p align=\"center\">\n<img src=\"./website/public/og.png\" />\n</p>\n\n \u2318K !cmdk minzip package sizehttps://img.shields.io/bundlephobia/minzip/cmdkhttps://www.npmjs.com/package/cmdk?activeTab=code !cmdk package versionhttps://img.shields.io/npm/v/cmdk.svg?colorB=greenhttps://www.npmjs.com/package/cmdk\n\n\u2318K is a command menu React component that can also be used as an accessible combobox. You render items, it filters and sorts them automatically. \u2318K supports a fully composable API <sup><sup>How?/ARCHITECTURE.md</sup></sup>, so you can wrap items in other components or even as static JSX.\n\n Install\n\nbash\npnpm install cmdk\n\n Use\n\ntsx\nimport { Command } from 'cmdk'\n\nconst CommandMenu =  => {\n  return \n    <Command label=\"Command Menu\">\n      <Command.Input />\n      <Command.List>\n        <Command.Empty>No results found.</Command.Empty>\n\n        <Command.Group heading=\"Letters\">\n          <Command.Item>a</Command.Item>\n          <Command.Item>b</Command.Item>\n          <Command.Separator />\n          <Command.Item>c</Command.Item>\n        </Command.Group>\n\n        <Command.Item>Apple</Command.Item>\n      </Command.List>\n    </Command>\n  \n}\n\nOr in a dialog:\n\ntsx\nimport { Command } from 'cmdk'\n\nconst CommandMenu =  => {\n  const open, setOpen = React.useStatefalse\n\n  // Toggle the menu when \u2318K is pressed\n  React.useEffect => {\n    const down = e => {\n      if e.key === 'k' && e.metaKey || e.ctrlKey {\n        e.preventDefault\n        setOpenopen => !open\n      }\n    }\n\n    document.addEventListener'keydown', down\n    return  => document.removeEventListener'keydown', down\n  }, \n\n  return \n    <Command.Dialog open={open} onOpenChange={setOpen} label=\"Global Command Menu\">\n      <Command.Input />\n      <Command.List>\n        <Command.Empty>No results found.</Command.Empty>\n\n        <Command.Group heading=\"Letters\">\n          <Command.Item>a</Command.Item>\n          <Command.Item>b</Command.Item>\n          <Command.Separator />\n          <Command.Item>c</Command.Item>\n        </Command.Group>\n\n        <Command.Item>Apple</Command.Item>\n      </Command.List>\n    </Command.Dialog>\n  \n}\n\n Parts and styling\n\nAll parts forward props, including ref, to an appropriate element. Each part has a specific data-attribute starting with cmdk- that can be used for styling.\n\n Command cmdk-root\n\nRender this to show the command menu inline, or use Dialogdialog-cmdk-dialog-cmdk-overlay to render in a elevated context. Can be controlled with the value and onValueChange props.\n\n> Note\n>\n> Values are always trimmed with the trimhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim method.\n\ntsx\nconst value, setValue = React.useState'apple'\n\nreturn \n  <Command value={value} onValueChange={setValue}>\n    <Command.Input />\n    <Command.List>\n      <Command.Item>Orange</Command.Item>\n      <Command.Item>Apple</Command.Item>\n    </Command.List>\n  </Command>\n\nYou can provide a custom filter function that is called to rank each item. Note that the value will be trimmed.\n\ntsx\n<Command\n  filter={value, search => {\n    if value.includessearch return 1\n    return 0\n  }}\n/>\n\nA third argument, keywords, can also be provided to the filter function. Keywords act as aliases for the item value, and can also affect the rank of the item. Keywords are trimmed.\n\ntsx\n<Command\n  filter={value, search, keywords => {\n    const extendValue = value + ' ' + keywords.join' '\n    if extendValue.includessearch return 1\n    return 0\n  }}\n/>\n\nOr disable filtering and sorting entirely:\n\ntsx\n<Command shouldFilter={false}>\n  <Command.List>\n    {filteredItems.mapitem => {\n      return \n        <Command.Item key={item} value={item}>\n          {item}\n        </Command.Item>\n      \n    }}\n  </Command.List>\n</Command>\n\nYou can make the arrow keys wrap around the list when you reach the end, it goes back to the first item by setting the loop prop:\n\ntsx\n<Command loop />\n\n Dialog cmdk-dialog cmdk-overlay\n\nProps are forwarded to Commandcommand-cmdk-root. Composes Radix UI's Dialog component. The overlay is always rendered. See the Radix Documentationhttps://www.radix-ui.com/docs/primitives/components/dialog for more information. Can be controlled with the open and onOpenChange props.\n\ntsx\nconst open, setOpen = React.useStatefalse\n\nreturn \n  <Command.Dialog open={open} onOpenChange={setOpen}>\n    ...\n  </Command.Dialog>\n\nYou can provide a container prop that accepts an HTML element that is forwarded to Radix UI's Dialog Portal component to specify which element the Dialog should portal into defaults to body. See the Radix Documentationhttps://www.radix-ui.com/docs/primitives/components/dialogportal for more information.\n\ntsx\nconst containerElement = React.useRefnull\n\nreturn \n  <>\n    <Command.Dialog container={containerElement.current} />\n    <div ref={containerElement} />\n  </>\n\n Input cmdk-input\n\nAll props are forwarded to the underlying input element. Can be controlled with the value and onValueChange props.\n\ntsx\nconst search, setSearch = React.useState''\n\nreturn <Command.Input value={search} onValueChange={setSearch} />\n\n List cmdk-list\n\nContains items and groups. Animate height using the --cmdk-list-height CSS variable.\n\ncss\ncmdk-list {\n  min-height: 300px;\n  height: var--cmdk-list-height;\n  max-height: 500px;\n  transition: height 100ms ease;\n}\n\nTo scroll item into view earlier near the edges of the viewport, use scroll-padding:\n\ncss\ncmdk-list {\n  scroll-padding-block-start: 8px;\n  scroll-padding-block-end: 8px;\n}\n\n Item cmdk-item data-disabled? data-selected?\n\nItem that becomes active on pointer enter. You should provide a unique value for each item, but it will be automatically inferred from the .textContent.\n\ntsx\n<Command.Item\n  onSelect={value => console.log'Selected', value}\n  // Value is implicity \"apple\" because of the provided text content\n>\n  Apple\n</Command.Item>\n\nYou can also provide a keywords prop to help with filtering. Keywords are trimmed.\n\ntsx\n<Command.Item keywords={'fruit', 'apple'}>Apple</Command.Item>\n\ntsx\n<Command.Item\n  onSelect={value => console.log'Selected', value}\n  // Value is implicity \"apple\" because of the provided text content\n>\n  Apple\n</Command.Item>\n\nYou can force an item to always render, regardless of filtering, by passing the forceMount prop.\n\n Group cmdk-group hidden?\n\nGroups items together with the given heading cmdk-group-heading.\n\ntsx\n<Command.Group heading=\"Fruit\">\n  <Command.Item>Apple</Command.Item>\n</Command.Group>\n\nGroups will not unmount from the DOM, rather the hidden attribute is applied to hide it from view. This may be relevant in your styling.\n\nYou can force a group to always render, regardless of filtering, by passing the forceMount prop.\n\n Separator cmdk-separator\n\nVisible when the search query is empty or alwaysRender is true, hidden otherwise.\n\n Empty cmdk-empty\n\nAutomatically renders when there are no results for the search query.\n\n Loading cmdk-loading\n\nYou should conditionally render this with progress while loading asynchronous items.\n\ntsx\nconst loading, setLoading = React.useStatefalse\n\nreturn <Command.List>{loading && <Command.Loading>Hang on\u2026</Command.Loading>}</Command.List>\n\n useCommandStatestate => state.selectedField\n\nHook that composes useSyncExternalStorehttps://reactjs.org/docs/hooks-reference.htmlusesyncexternalstore. Pass a function that returns a slice of the command menu state to re-render when that slice changes. This hook is provided for advanced use cases and should not be commonly used.\n\nA good use case would be to render a more detailed empty state, like so:\n\ntsx\nconst search = useCommandStatestate => state.search\nreturn <Command.Empty>No results found for \"{search}\".</Command.Empty>\n\n Examples\n\nCode snippets for common use cases.\n\n Nested items\n\nOften selecting one item should navigate deeper, with a more refined set of items. For example selecting \"Change theme\u2026\" should show new items \"Dark theme\" and \"Light theme\". We call these sets of items \"pages\", and they can be implemented with simple state:\n\ntsx\nconst ref = React.useRefnull\nconst open, setOpen = React.useStatefalse\nconst search, setSearch = React.useState''\nconst pages, setPages = React.useState\nconst page = pagespages.length - 1\n\nreturn \n  <Command\n    onKeyDown={e => {\n      // Escape goes to previous page\n      // Backspace goes to previous page when search is empty\n      if e.key === 'Escape' || e.key === 'Backspace' && !search {\n        e.preventDefault\n        setPagespages => pages.slice0, -1\n      }\n    }}\n  >\n    <Command.Input value={search} onValueChange={setSearch} />\n    <Command.List>\n      {!page && \n        <>\n          <Command.Item onSelect={ => setPages...pages, 'projects'}>Search projects\u2026</Command.Item>\n          <Command.Item onSelect={ => setPages...pages, 'teams'}>Join a team\u2026</Command.Item>\n        </>\n      }\n\n      {page === 'projects' && \n        <>\n          <Command.Item>Project A</Command.Item>\n          <Command.Item>Project B</Command.Item>\n        </>\n      }\n\n      {page === 'teams' && \n        <>\n          <Command.Item>Team 1</Command.Item>\n          <Command.Item>Team 2</Command.Item>\n        </>\n      }\n    </Command.List>\n  </Command>\n\n Show sub-items when searching\n\nIf your items have nested sub-items that you only want to reveal when searching, render based on the search state:\n\ntsx\nconst SubItem = props => {\n  const search = useCommandStatestate => state.search\n  if !search return null\n  return <Command.Item {...props} />\n}\n\nreturn \n  <Command>\n    <Command.Input />\n    <Command.List>\n      <Command.Item>Change theme\u2026</Command.Item>\n      <SubItem>Change theme to dark</SubItem>\n      <SubItem>Change theme to light</SubItem>\n    </Command.List>\n  </Command>\n\n Asynchronous results\n\nRender the items as they become available. Filtering and sorting will happen automatically.\n\ntsx\nconst loading, setLoading = React.useStatefalse\nconst items, setItems = React.useState\n\nReact.useEffect => {\n  async function getItems {\n    setLoadingtrue\n    const res = await api.get'/dictionary'\n    setItemsres\n    setLoadingfalse\n  }\n\n  getItems\n}, \n\nreturn \n  <Command>\n    <Command.Input />\n    <Command.List>\n      {loading && <Command.Loading>Fetching words\u2026</Command.Loading>}\n      {items.mapitem => {\n        return \n          <Command.Item key={word-${item}} value={item}>\n            {item}\n          </Command.Item>\n        \n      }}\n    </Command.List>\n  </Command>\n\n Use inside Popover\n\nWe recommend using the Radix UI popoverhttps://www.radix-ui.com/docs/primitives/components/popover component. \u2318K relies on the Radix UI Dialog component, so this will reduce your bundle size a bit due to shared dependencies.\n\nbash\n$ pnpm install @radix-ui/react-popover\n\nRender Command inside of the popover content:\n\ntsx\nimport  as Popover from '@radix-ui/react-popover'\n\nreturn \n  <Popover.Root>\n    <Popover.Trigger>Toggle popover</Popover.Trigger>\n\n    <Popover.Content>\n      <Command>\n        <Command.Input />\n        <Command.List>\n          <Command.Item>Apple</Command.Item>\n        </Command.List>\n      </Command>\n    </Popover.Content>\n  </Popover.Root>\n\n Drop in stylesheets\n\nYou can find global stylesheets to drop in as a starting point for styling. See website/styles/cmdkwebsite/styles/cmdk for examples.\n\n FAQ\n\nAccessible? Yes. Labeling, aria attributes, and DOM ordering tested with Voice Over and Chrome DevTools. Dialogdialog-cmdk-dialog-cmdk-overlay composes an accessible Dialog implementation.\n\nVirtualization? No. Good performance up to 2,000-3,000 items, though. Read below to bring your own.\n\nFilter/sort items manually? Yes. Pass shouldFilter={false} to Commandcommand-cmdk-root. Better memory usage and performance. Bring your own virtualization this way.\n\nReact 18 safe? Yes, required. Uses React 18 hooks like useId and useSyncExternalStore.\n\nUnstyled? Yes, use the listed CSS selectors.\n\nHydration mismatch? No, likely a bug in your code. Ensure the open prop to Command.Dialog is false on the server.\n\nReact strict mode safe? Yes. Open an issue if you notice an issue.\n\nWeird/wrong behavior? Make sure your Command.Item has a key and unique value.\n\nConcurrent mode safe? Maybe, but concurrent mode is not yet real. Uses risky approaches like manual DOM ordering.\n\nReact server component? No, it's a client component.\n\nListen for \u2318K automatically? No, do it yourself to have full control over keybind context.\n\nReact Native? No, and no plans to support it. If you build a React Native version, let us know and we'll link your repository here.\n\n History\n\nWritten in 2019 by Paco @pacocourseyhttps://twitter.com/pacocoursey to see if a composable combobox API was possible. Used for the Vercel command menu and autocomplete by Rauno @raunofreiberghttps://twitter.com/raunofreiberg in 2020. Re-written independently in 2022 with a simpler and more performant approach. Ideas and help from Shu @shuding\\_https://twitter.com/shuding_.\n\nuse-descendantshttps://github.com/pacocoursey/use-descendants was extracted from the 2019 version.\n\n Testing\n\nFirst, install dependencies and Playwright browsers:\n\nbash\npnpm install\npnpm playwright install\n\nThen ensure you've built the library:\n\nbash\npnpm build\n\nThen run the tests using your local build against real browser engines:\n\nbash\npnpm test\n\n",
  "content_markdown": "<p align=\"center\">\n<img src=\"./website/public/og.png\" />\n</p>\n\n# \u2318K [![cmdk minzip package size](https://img.shields.io/bundlephobia/minzip/cmdk)](https://www.npmjs.com/package/cmdk?activeTab=code) [![cmdk package version](https://img.shields.io/npm/v/cmdk.svg?colorB=green)](https://www.npmjs.com/package/cmdk)\n\n\u2318K is a command menu React component that can also be used as an accessible combobox. You render items, it filters and sorts them automatically. \u2318K supports a fully composable API <sup><sup>[How?](/ARCHITECTURE.md)</sup></sup>, so you can wrap items in other components or even as static JSX.\n\n## Install\n\n```bash\npnpm install cmdk\n```\n\n## Use\n\n```tsx\nimport { Command } from 'cmdk'\n\nconst CommandMenu = () => {\n  return (\n    <Command label=\"Command Menu\">\n      <Command.Input />\n      <Command.List>\n        <Command.Empty>No results found.</Command.Empty>\n\n        <Command.Group heading=\"Letters\">\n          <Command.Item>a</Command.Item>\n          <Command.Item>b</Command.Item>\n          <Command.Separator />\n          <Command.Item>c</Command.Item>\n        </Command.Group>\n\n        <Command.Item>Apple</Command.Item>\n      </Command.List>\n    </Command>\n  )\n}\n```\n\nOr in a dialog:\n\n```tsx\nimport { Command } from 'cmdk'\n\nconst CommandMenu = () => {\n  const [open, setOpen] = React.useState(false)\n\n  // Toggle the menu when \u2318K is pressed\n  React.useEffect(() => {\n    const down = (e) => {\n      if (e.key === 'k' && (e.metaKey || e.ctrlKey)) {\n        e.preventDefault()\n        setOpen((open) => !open)\n      }\n    }\n\n    document.addEventListener('keydown', down)\n    return () => document.removeEventListener('keydown', down)\n  }, [])\n\n  return (\n    <Command.Dialog open={open} onOpenChange={setOpen} label=\"Global Command Menu\">\n      <Command.Input />\n      <Command.List>\n        <Command.Empty>No results found.</Command.Empty>\n\n        <Command.Group heading=\"Letters\">\n          <Command.Item>a</Command.Item>\n          <Command.Item>b</Command.Item>\n          <Command.Separator />\n          <Command.Item>c</Command.Item>\n        </Command.Group>\n\n        <Command.Item>Apple</Command.Item>\n      </Command.List>\n    </Command.Dialog>\n  )\n}\n```\n\n## Parts and styling\n\nAll parts forward props, including `ref`, to an appropriate element. Each part has a specific data-attribute (starting with `cmdk-`) that can be used for styling.\n\n### Command `[cmdk-root]`\n\nRender this to show the command menu inline, or use [Dialog](#dialog-cmdk-dialog-cmdk-overlay) to render in a elevated context. Can be controlled with the `value` and `onValueChange` props.\n\n> **Note**\n>\n> Values are always trimmed with the [trim()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim) method.\n\n```tsx\nconst [value, setValue] = React.useState('apple')\n\nreturn (\n  <Command value={value} onValueChange={setValue}>\n    <Command.Input />\n    <Command.List>\n      <Command.Item>Orange</Command.Item>\n      <Command.Item>Apple</Command.Item>\n    </Command.List>\n  </Command>\n)\n```\n\nYou can provide a custom `filter` function that is called to rank each item. Note that the value will be trimmed.\n\n```tsx\n<Command\n  filter={(value, search) => {\n    if (value.includes(search)) return 1\n    return 0\n  }}\n/>\n```\n\nA third argument, `keywords`, can also be provided to the filter function. Keywords act as aliases for the item value, and can also affect the rank of the item. Keywords are trimmed.\n\n```tsx\n<Command\n  filter={(value, search, keywords) => {\n    const extendValue = value + ' ' + keywords.join(' ')\n    if (extendValue.includes(search)) return 1\n    return 0\n  }}\n/>\n```\n\nOr disable filtering and sorting entirely:\n\n```tsx\n<Command shouldFilter={false}>\n  <Command.List>\n    {filteredItems.map((item) => {\n      return (\n        <Command.Item key={item} value={item}>\n          {item}\n        </Command.Item>\n      )\n    })}\n  </Command.List>\n</Command>\n```\n\nYou can make the arrow keys wrap around the list (when you reach the end, it goes back to the first item) by setting the `loop` prop:\n\n```tsx\n<Command loop />\n```\n\n### Dialog `[cmdk-dialog]` `[cmdk-overlay]`\n\nProps are forwarded to [Command](#command-cmdk-root). Composes Radix UI's Dialog component. The overlay is always rendered. See the [Radix Documentation](https://www.radix-ui.com/docs/primitives/components/dialog) for more information. Can be controlled with the `open` and `onOpenChange` props.\n\n```tsx\nconst [open, setOpen] = React.useState(false)\n\nreturn (\n  <Command.Dialog open={open} onOpenChange={setOpen}>\n    ...\n  </Command.Dialog>\n)\n```\n\nYou can provide a `container` prop that accepts an HTML element that is forwarded to Radix UI's Dialog Portal component to specify which element the Dialog should portal into (defaults to `body`). See the [Radix Documentation](https://www.radix-ui.com/docs/primitives/components/dialog#portal) for more information.\n\n```tsx\nconst containerElement = React.useRef(null)\n\nreturn (\n  <>\n    <Command.Dialog container={containerElement.current} />\n    <div ref={containerElement} />\n  </>\n)\n```\n\n### Input `[cmdk-input]`\n\nAll props are forwarded to the underlying `input` element. Can be controlled with the `value` and `onValueChange` props.\n\n```tsx\nconst [search, setSearch] = React.useState('')\n\nreturn <Command.Input value={search} onValueChange={setSearch} />\n```\n\n### List `[cmdk-list]`\n\nContains items and groups. Animate height using the `--cmdk-list-height` CSS variable.\n\n```css\n[cmdk-list] {\n  min-height: 300px;\n  height: var(--cmdk-list-height);\n  max-height: 500px;\n  transition: height 100ms ease;\n}\n```\n\nTo scroll item into view earlier near the edges of the viewport, use scroll-padding:\n\n```css\n[cmdk-list] {\n  scroll-padding-block-start: 8px;\n  scroll-padding-block-end: 8px;\n}\n```\n\n### Item `[cmdk-item]` `[data-disabled?]` `[data-selected?]`\n\nItem that becomes active on pointer enter. You should provide a unique `value` for each item, but it will be automatically inferred from the `.textContent`.\n\n```tsx\n<Command.Item\n  onSelect={(value) => console.log('Selected', value)}\n  // Value is implicity \"apple\" because of the provided text content\n>\n  Apple\n</Command.Item>\n```\n\nYou can also provide a `keywords` prop to help with filtering. Keywords are trimmed.\n\n```tsx\n<Command.Item keywords={['fruit', 'apple']}>Apple</Command.Item>\n```\n\n```tsx\n<Command.Item\n  onSelect={(value) => console.log('Selected', value)}\n  // Value is implicity \"apple\" because of the provided text content\n>\n  Apple\n</Command.Item>\n```\n\nYou can force an item to always render, regardless of filtering, by passing the `forceMount` prop.\n\n### Group `[cmdk-group]` `[hidden?]`\n\nGroups items together with the given `heading` (`[cmdk-group-heading]`).\n\n```tsx\n<Command.Group heading=\"Fruit\">\n  <Command.Item>Apple</Command.Item>\n</Command.Group>\n```\n\nGroups will not unmount from the DOM, rather the `hidden` attribute is applied to hide it from view. This may be relevant in your styling.\n\nYou can force a group to always render, regardless of filtering, by passing the `forceMount` prop.\n\n### Separator `[cmdk-separator]`\n\nVisible when the search query is empty or `alwaysRender` is true, hidden otherwise.\n\n### Empty `[cmdk-empty]`\n\nAutomatically renders when there are no results for the search query.\n\n### Loading `[cmdk-loading]`\n\nYou should conditionally render this with `progress` while loading asynchronous items.\n\n```tsx\nconst [loading, setLoading] = React.useState(false)\n\nreturn <Command.List>{loading && <Command.Loading>Hang on\u2026</Command.Loading>}</Command.List>\n```\n\n### `useCommandState(state => state.selectedField)`\n\nHook that composes [`useSyncExternalStore`](https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore). Pass a function that returns a slice of the command menu state to re-render when that slice changes. This hook is provided for advanced use cases and should not be commonly used.\n\nA good use case would be to render a more detailed empty state, like so:\n\n```tsx\nconst search = useCommandState((state) => state.search)\nreturn <Command.Empty>No results found for \"{search}\".</Command.Empty>\n```\n\n## Examples\n\nCode snippets for common use cases.\n\n### Nested items\n\nOften selecting one item should navigate deeper, with a more refined set of items. For example selecting \"Change theme\u2026\" should show new items \"Dark theme\" and \"Light theme\". We call these sets of items \"pages\", and they can be implemented with simple state:\n\n```tsx\nconst ref = React.useRef(null)\nconst [open, setOpen] = React.useState(false)\nconst [search, setSearch] = React.useState('')\nconst [pages, setPages] = React.useState([])\nconst page = pages[pages.length - 1]\n\nreturn (\n  <Command\n    onKeyDown={(e) => {\n      // Escape goes to previous page\n      // Backspace goes to previous page when search is empty\n      if (e.key === 'Escape' || (e.key === 'Backspace' && !search)) {\n        e.preventDefault()\n        setPages((pages) => pages.slice(0, -1))\n      }\n    }}\n  >\n    <Command.Input value={search} onValueChange={setSearch} />\n    <Command.List>\n      {!page && (\n        <>\n          <Command.Item onSelect={() => setPages([...pages, 'projects'])}>Search projects\u2026</Command.Item>\n          <Command.Item onSelect={() => setPages([...pages, 'teams'])}>Join a team\u2026</Command.Item>\n        </>\n      )}\n\n      {page === 'projects' && (\n        <>\n          <Command.Item>Project A</Command.Item>\n          <Command.Item>Project B</Command.Item>\n        </>\n      )}\n\n      {page === 'teams' && (\n        <>\n          <Command.Item>Team 1</Command.Item>\n          <Command.Item>Team 2</Command.Item>\n        </>\n      )}\n    </Command.List>\n  </Command>\n)\n```\n\n### Show sub-items when searching\n\nIf your items have nested sub-items that you only want to reveal when searching, render based on the search state:\n\n```tsx\nconst SubItem = (props) => {\n  const search = useCommandState((state) => state.search)\n  if (!search) return null\n  return <Command.Item {...props} />\n}\n\nreturn (\n  <Command>\n    <Command.Input />\n    <Command.List>\n      <Command.Item>Change theme\u2026</Command.Item>\n      <SubItem>Change theme to dark</SubItem>\n      <SubItem>Change theme to light</SubItem>\n    </Command.List>\n  </Command>\n)\n```\n\n### Asynchronous results\n\nRender the items as they become available. Filtering and sorting will happen automatically.\n\n```tsx\nconst [loading, setLoading] = React.useState(false)\nconst [items, setItems] = React.useState([])\n\nReact.useEffect(() => {\n  async function getItems() {\n    setLoading(true)\n    const res = await api.get('/dictionary')\n    setItems(res)\n    setLoading(false)\n  }\n\n  getItems()\n}, [])\n\nreturn (\n  <Command>\n    <Command.Input />\n    <Command.List>\n      {loading && <Command.Loading>Fetching words\u2026</Command.Loading>}\n      {items.map((item) => {\n        return (\n          <Command.Item key={`word-${item}`} value={item}>\n            {item}\n          </Command.Item>\n        )\n      })}\n    </Command.List>\n  </Command>\n)\n```\n\n### Use inside Popover\n\nWe recommend using the [Radix UI popover](https://www.radix-ui.com/docs/primitives/components/popover) component. \u2318K relies on the Radix UI Dialog component, so this will reduce your bundle size a bit due to shared dependencies.\n\n```bash\n$ pnpm install @radix-ui/react-popover\n```\n\nRender `Command` inside of the popover content:\n\n```tsx\nimport * as Popover from '@radix-ui/react-popover'\n\nreturn (\n  <Popover.Root>\n    <Popover.Trigger>Toggle popover</Popover.Trigger>\n\n    <Popover.Content>\n      <Command>\n        <Command.Input />\n        <Command.List>\n          <Command.Item>Apple</Command.Item>\n        </Command.List>\n      </Command>\n    </Popover.Content>\n  </Popover.Root>\n)\n```\n\n### Drop in stylesheets\n\nYou can find global stylesheets to drop in as a starting point for styling. See [website/styles/cmdk](website/styles/cmdk) for examples.\n\n## FAQ\n\n**Accessible?** Yes. Labeling, aria attributes, and DOM ordering tested with Voice Over and Chrome DevTools. [Dialog](#dialog-cmdk-dialog-cmdk-overlay) composes an accessible Dialog implementation.\n\n**Virtualization?** No. Good performance up to 2,000-3,000 items, though. Read below to bring your own.\n\n**Filter/sort items manually?** Yes. Pass `shouldFilter={false}` to [Command](#command-cmdk-root). Better memory usage and performance. Bring your own virtualization this way.\n\n**React 18 safe?** Yes, required. Uses React 18 hooks like `useId` and `useSyncExternalStore`.\n\n**Unstyled?** Yes, use the listed CSS selectors.\n\n**Hydration mismatch?** No, likely a bug in your code. Ensure the `open` prop to `Command.Dialog` is `false` on the server.\n\n**React strict mode safe?** Yes. Open an issue if you notice an issue.\n\n**Weird/wrong behavior?** Make sure your `Command.Item` has a `key` and unique `value`.\n\n**Concurrent mode safe?** Maybe, but concurrent mode is not yet real. Uses risky approaches like manual DOM ordering.\n\n**React server component?** No, it's a client component.\n\n**Listen for \u2318K automatically?** No, do it yourself to have full control over keybind context.\n\n**React Native?** No, and no plans to support it. If you build a React Native version, let us know and we'll link your repository here.\n\n## History\n\nWritten in 2019 by Paco ([@pacocoursey](https://twitter.com/pacocoursey)) to see if a composable combobox API was possible. Used for the Vercel command menu and autocomplete by Rauno ([@raunofreiberg](https://twitter.com/raunofreiberg)) in 2020. Re-written independently in 2022 with a simpler and more performant approach. Ideas and help from Shu ([@shuding\\_](https://twitter.com/shuding_)).\n\n[use-descendants](https://github.com/pacocoursey/use-descendants) was extracted from the 2019 version.\n\n## Testing\n\nFirst, install dependencies and Playwright browsers:\n\n```bash\npnpm install\npnpm playwright install\n```\n\nThen ensure you've built the library:\n\n```bash\npnpm build\n```\n\nThen run the tests using your local build against real browser engines:\n\n```bash\npnpm test\n```\n",
  "tags": [
    "command-palette",
    "github",
    "readme"
  ],
  "extracted_at": "2026-02-03T12:57:09.419724+00:00",
  "content_length": 13217,
  "content_hash": "8d0b57df1ceb28ff"
}