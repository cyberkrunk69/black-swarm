{
  "id": "remix__docs_en_main_guides_errors",
  "source_id": "remix",
  "source_name": "Remix Documentation",
  "category": "framework_specific",
  "url": "https://remix.run/docs/en/main/guides/errors",
  "title": "Error Handling",
  "content": "Docs\nBlog\nResources\nReact Router v7 has been released.\nView the docs\nDocs\nBlog\nResources\nView code on GitHub\nChat on Discord\nReact Router v7 has been released.\nView the docs\nError Handling\nError Handling\nRemix sets a new precedent in web application error handling that you are going to love. Remix automatically catches most errors in your code, on the server or in the browser, and renders the closest\nErrorBoundary\nto where the error occurred. If you're familiar with React's\ncomponentDidCatch\nand\ngetDerivedStateFromError\nclass component hooks, it's just like that but with some extra handling for errors on the server.\nRemix will automatically catch errors and render the nearest error boundary for errors thrown while:\nrendering in the browser\nrendering on the server\nin a\nloader\nduring the initial server-rendered document request\nin an\naction\nduring the initial server-rendered document request\nin a\nloader\nduring a client-side transition in the browser (Remix serializes the error and sends it over the network to the browser)\nin an\naction\nduring a client-side transition in the browser\nRoot Error Boundary\nBy default, Remix ships with a default\nErrorBoundary\nbuilt-in, but we hope you'll want to add a little branding to your own global error boundary. You can do so by exporting your own\nErrorBoundary\nfrom\napp/root.tsx\n. This is what your users will see whenever an uncaught error is thrown.\nexport\nfunction\nErrorBoundary\n() {\nconst\nerror\n=\nuseRouteError\n();\nconsole\n.\nerror\n(\nerror\n);\nreturn\n(\n<\nhtml\n>\n<\nhead\n>\n<\ntitle\n>Oh no!</\ntitle\n>\n<\nMeta\n/>\n<\nLinks\n/>\n</\nhead\n>\n<\nbody\n>\n{\n/* add the UI you want your users to see */\n}\n<\nScripts\n/>\n</\nbody\n>\n</\nhtml\n>\n);\n}\nYou'll want to make sure to still render the\nLinks\n,\nMeta\n, and\nScripts\ncomponents because the whole document will mount and unmount when the root error boundary is rendered.\nNested Error Boundaries\nEach route in the hierarchy is a potential error boundary. If a nested route exports an error boundary, then any errors below it will be caught and rendered there. This means that the rest of the surrounding UI in the parent routes\ncontinue to render normally\nso the user is able to click another link and not lose any client-side state they might have had.\nFor example, consider these routes:\napp/\n\u251c\u2500\u2500 routes/\n\u2502   \u251c\u2500\u2500 sales.tsx\n\u2502   \u251c\u2500\u2500 sales.invoices.tsx\n\u2502   \u2514\u2500\u2500 sales.invoices.$invoiceId.tsx\n\u2514\u2500\u2500 root.tsx\nIf\napp/routes/sales.invoices.$invoiceId.tsx\nexports an\nErrorBoundary\nand an error is thrown in its component,\naction\n, or\nloader\n, the rest of the app renders normally and only the invoice section of the page renders the error.\nIf a route doesn't have an error boundary, the error \"bubbles up\" to the closest error boundary, all the way to the root, so you don't have to add error boundaries to every route--only when you want to add that extra touch to your UI.\nError Sanitization\nIn production mode, any errors that happen on the server are automatically sanitized to prevent leaking any sensitive server information (such as stack traces) to the client. This means that the\nError\ninstance you receive from\nuseRouteError\nwill have a generic message and no stack trace:\nexport\nasync\nfunction\nloader\n() {\nif\n(\nbadConditionIsTrue\n()) {\nthrow\nnew\nError\n(\"\nOh no! Something went wrong!\n\");\n}\n}\nexport\nfunction\nErrorBoundary\n() {\nconst\nerror\n=\nuseRouteError\n();\n// When NODE_ENV=production:\n// error.message = \"Unexpected Server Error\"\n// error.stack = undefined\n}\nIf you need to log these errors or report them to a third-party service such as\nBugSnag\nor\nSentry\n, then you can do this through a\nhandleError\nexport in your\napp/entry.server.js\n. This method receives the unsanitized versions of the error since it is also running on the server.\nIf you want to trigger an error boundary and display a specific message or data in the browser, then you can throw a\nResponse\nfrom a\naction\n/\nloader\nwith that data instead:\nexport\nasync\nfunction\nloader\n() {\nif\n(\nbadConditionIsTrue\n()) {\nthrow\nnew\nResponse\n(\"\nOh no! Something went wrong!\n\", {\nstatus:\n500\n,\n});\n}\n}\nexport\nfunction\nErrorBoundary\n() {\nconst\nerror\n=\nuseRouteError\n();\nif\n(\nisRouteErrorResponse\n(\nerror\n)) {\n// error.status = 500\n// error.data = \"Oh no! Something went wrong!\"\n}\n}\n\u00a9\nShopify, Inc.\n\u2022\nDocs and examples licensed under\nMIT\nEdit",
  "content_markdown": "[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\n[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\n[View code on GitHub](https://github.com/remix-run/remix/tree/v2 \"View code on GitHub\")[Chat on Discord](https://rmx.as/discord \"Chat on Discord\")\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\nError Handling\n\n# Error Handling\n\nRemix sets a new precedent in web application error handling that you are going to love. Remix automatically catches most errors in your code, on the server or in the browser, and renders the closest [`ErrorBoundary`](../route/error-boundary) to where the error occurred. If you're familiar with React's [`componentDidCatch`](https://react.dev/reference/react/Component#componentdidcatch) and [`getDerivedStateFromError`](https://react.dev/reference/react/Component#static-getderivedstatefromerror) class component hooks, it's just like that but with some extra handling for errors on the server.\n\nRemix will automatically catch errors and render the nearest error boundary for errors thrown while:\n\n- rendering in the browser\n- rendering on the server\n- in a `loader` during the initial server-rendered document request\n- in an `action` during the initial server-rendered document request\n- in a `loader` during a client-side transition in the browser (Remix serializes the error and sends it over the network to the browser)\n- in an `action` during a client-side transition in the browser\n\n## Root Error Boundary\n\nBy default, Remix ships with a default `ErrorBoundary` built-in, but we hope you'll want to add a little branding to your own global error boundary. You can do so by exporting your own [`ErrorBoundary`](../route/error-boundary) from `app/root.tsx`. This is what your users will see whenever an uncaught error is thrown.\n\n```\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  console.error(error);\n  return (\n    <html>\n      <head>\n        <title>Oh no!</title>\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        {/* add the UI you want your users to see */}\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n```\n\nYou'll want to make sure to still render the [`Links`](../components/links), [`Meta`](../components/meta), and [`Scripts`](../components/scripts) components because the whole document will mount and unmount when the root error boundary is rendered.\n\n## Nested Error Boundaries\n\nEach route in the hierarchy is a potential error boundary. If a nested route exports an error boundary, then any errors below it will be caught and rendered there. This means that the rest of the surrounding UI in the parent routes *continue to render normally* so the user is able to click another link and not lose any client-side state they might have had.\n\nFor example, consider these routes:\n\n```\napp/\n\u251c\u2500\u2500 routes/\n\u2502   \u251c\u2500\u2500 sales.tsx\n\u2502   \u251c\u2500\u2500 sales.invoices.tsx\n\u2502   \u2514\u2500\u2500 sales.invoices.$invoiceId.tsx\n\u2514\u2500\u2500 root.tsx\n```\n\nIf `app/routes/sales.invoices.$invoiceId.tsx` exports an [`ErrorBoundary`](../route/error-boundary) and an error is thrown in its component, [`action`](../route/action), or [`loader`](../route/loader), the rest of the app renders normally and only the invoice section of the page renders the error.\n\n![error in a nested route where the parent route's navigation renders normally](/docs-images/error-boundary.png)\n\nIf a route doesn't have an error boundary, the error \"bubbles up\" to the closest error boundary, all the way to the root, so you don't have to add error boundaries to every route--only when you want to add that extra touch to your UI.\n\n## Error Sanitization\n\nIn production mode, any errors that happen on the server are automatically sanitized to prevent leaking any sensitive server information (such as stack traces) to the client. This means that the `Error` instance you receive from [`useRouteError`](../hooks/use-route-error) will have a generic message and no stack trace:\n\n```\nexport async function loader() {\n  if (badConditionIsTrue()) {\n    throw new Error(\"Oh no! Something went wrong!\");\n  }\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  // When NODE_ENV=production:\n  // error.message = \"Unexpected Server Error\"\n  // error.stack = undefined\n}\n```\n\nIf you need to log these errors or report them to a third-party service such as [BugSnag](https://www.bugsnag.com/) or [Sentry](https://sentry.io/), then you can do this through a [`handleError`](../file-conventions/entry.server#handleerror) export in your [`app/entry.server.js`](../file-conventions/entry.server). This method receives the unsanitized versions of the error since it is also running on the server.\n\nIf you want to trigger an error boundary and display a specific message or data in the browser, then you can throw a `Response` from a `action`/`loader` with that data instead:\n\n```\nexport async function loader() {\n  if (badConditionIsTrue()) {\n    throw new Response(\"Oh no! Something went wrong!\", {\n      status: 500,\n    });\n  }\n}\n\nexport function ErrorBoundary() {\n  const error = useRouteError();\n  if (isRouteErrorResponse(error)) {\n    // error.status = 500\n    // error.data = \"Oh no! Something went wrong!\"\n  }\n}\n```\n\n\u00a9 [Shopify, Inc.](https://remix.run)\n\n\u2022\n\nDocs and examples licensed under [MIT](https://opensource.org/licenses/MIT)\n\n[Edit](https://github.com/remix-run/remix-v2-website/edit/main/data/docs/guides/errors.md)\n\n![](/assets/icons-CZ8v8NWl.svg)",
  "tags": [
    "remix",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:55:33.245711+00:00",
  "content_length": 4276,
  "content_hash": "682e3407d3685de9"
}