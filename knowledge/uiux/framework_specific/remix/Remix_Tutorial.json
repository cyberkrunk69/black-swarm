{
  "id": "remix__docs_en_main_start_tutorial",
  "source_id": "remix",
  "source_name": "Remix Documentation",
  "category": "framework_specific",
  "url": "https://remix.run/docs/en/main/start/tutorial",
  "title": "Remix Tutorial",
  "content": "Docs\nBlog\nResources\nReact Router v7 has been released.\nView the docs\nDocs\nBlog\nResources\nView code on GitHub\nChat on Discord\nReact Router v7 has been released.\nView the docs\nTutorial (30m)\nOn this page\nSetup\nThe Root Route\nAdding Stylesheets with\nlinks\nThe Contact Route UI\nNested Routes and Outlets\nClient Side Routing\nLoading Data\nType Inference\nURL Params in Loaders\nValidating Params and Throwing Responses\nData Mutations\nCreating Contacts\nUpdating Data\nUpdating Contacts with\nFormData\nMutation Discussion\nRedirecting new records to the edit page\nActive Link Styling\nGlobal Pending UI\nDeleting Records\nIndex Routes\nCancel Button\nURLSearchParams\nand\nGET\nSubmissions\nSynchronizing URLs to Form State\nSubmitting\nForm\n's\nonChange\nAdding Search Spinner\nManaging the History Stack\nForm\ns Without Navigation\nOptimistic UI\nSetup\nThe Root Route\nAdding Stylesheets with\nlinks\nThe Contact Route UI\nNested Routes and Outlets\nClient Side Routing\nLoading Data\nType Inference\nURL Params in Loaders\nValidating Params and Throwing Responses\nData Mutations\nCreating Contacts\nUpdating Data\nUpdating Contacts with\nFormData\nMutation Discussion\nRedirecting new records to the edit page\nActive Link Styling\nGlobal Pending UI\nDeleting Records\nIndex Routes\nCancel Button\nURLSearchParams\nand\nGET\nSubmissions\nSynchronizing URLs to Form State\nSubmitting\nForm\n's\nonChange\nAdding Search Spinner\nManaging the History Stack\nForm\ns Without Navigation\nOptimistic UI\nRemix Tutorial\nJust getting started with Remix? The latest version of\nRemix is now React Router v7\n. If you want to use the latest framework features, you can follow the same\ntutorial from the React Router docs\n.\nWe'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other \"production ready\" things, so we can stay focused on Remix. We expect it to take about 30\u00a0m if you're following along, otherwise it's a quick read.\n\ud83d\udc49\nEvery time you see this, it means you need to do something in the app!\nThe rest is just there for your information and deeper understanding. Let's get to it.\nSetup\n\ud83d\udc49\nGenerate a basic template\nnpx\ncreate-remix@latest\n--template\nremix-run/remix/templates/remix-tutorial\nThis uses a pretty bare-bones template but includes our CSS and data model, so we can focus on Remix. The\nQuick Start\ncan familiarize you with the basic setup of a Remix project if you'd like to learn more.\n\ud83d\udc49\nStart the app\n# cd into the app directory\ncd\n{wherever\nyou\nput\nthe\napp}\n# install dependencies if you haven't already\nnpm\ninstall\n# start the server\nnpm\nrun\ndev\nYou should be able to open up\nhttp://localhost:5173\nand see an unstyled screen that looks like this:\nThe Root Route\nNote the file at\napp/root.tsx\n. This is what we call the \"Root Route\". It's the first component in the UI that renders, so it typically contains the global layout for the page.\nExpand here to see the root component code\nimport\n{\nForm\n,\nLinks\n,\nMeta\n,\nScripts\n,\nScrollRestoration\n,\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nApp\n() {\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n<\nhead\n>\n<\nmeta\ncharSet\n=\n\"\nutf-8\n\" />\n<\nmeta\nname\n=\n\"\nviewport\n\"\ncontent\n=\n\"\nwidth=device-width, initial-scale=1\n\"\n/>\n<\nMeta\n/>\n<\nLinks\n/>\n</\nhead\n>\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n<\nh1\n>Remix Contacts</\nh1\n>\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nrole\n=\n\"\nsearch\n\">\n<\ninput\naria-label\n=\n\"\nSearch contacts\n\"\nid\n=\n\"\nq\n\"\nname\n=\n\"\nq\n\"\nplaceholder\n=\n\"\nSearch\n\"\ntype\n=\n\"\nsearch\n\"\n/>\n<\ndiv\naria-hidden\nhidden\n=\n{\ntrue\n}\nid\n=\n\"\nsearch-spinner\n\"\n/>\n</\nForm\n>\n<\nForm\nmethod\n=\n\"\npost\n\">\n<\nbutton\ntype\n=\n\"\nsubmit\n\">New</\nbutton\n>\n</\nForm\n>\n</\ndiv\n>\n<\nnav\n>\n<\nul\n>\n<\nli\n>\n<\na\nhref\n=\n{\n`\n/contacts/1\n`\n}\n>Your Name</\na\n>\n</\nli\n>\n<\nli\n>\n<\na\nhref\n=\n{\n`\n/contacts/2\n`\n}\n>Your Friend</\na\n>\n</\nli\n>\n</\nul\n>\n</\nnav\n>\n</\ndiv\n>\n<\nScrollRestoration\n/>\n<\nScripts\n/>\n</\nbody\n>\n</\nhtml\n>\n);\n}\nAdding Stylesheets with\nlinks\nWhile there are multiple ways to style your Remix app, we're going to use a plain stylesheet that's already been written to keep things focused on Remix.\nYou can import CSS files directly into JavaScript modules. Vite will fingerprint the asset, save it to your build's client directory, and provide your module with the publicly accessible href.\n\ud83d\udc49\nImport the app styles\nimport\ntype\n{\nLinksFunction\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports\nimport\nappStylesHref\nfrom\n\"\n./app.css?url\n\";\nexport\nconst\nlinks\n:\nLinksFunction\n=\n()\n=>\n[\n{ rel: \"\nstylesheet\n\", href:\nappStylesHref\n},\n];\nEvery route can export a\nlinks\nfunction. They will be collected and rendered into the\n<Links />\ncomponent we rendered in\napp/root.tsx\n.\nThe app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you,\nJim\n\ud83d\ude4f).\nThe Contact Route UI\nIf you click on one of the sidebar items, you'll get the default 404 page. Let's create a route that matches the url\n/contacts/1\n.\n\ud83d\udc49\nCreate the\napp/routes\ndirectory and contact route module\nmkdir\napp/routes\ntouch\napp/routes/contacts.\n\\$\ncontactId.tsx\nIn the Remix\nroute file convention\n,\n.\nwill create a\n/\nin the URL and\n$\nmakes a segment dynamic. We just created a route that will match URLs that look like this:\n/contacts/123\n/contacts/abc\n\ud83d\udc49\nAdd the contact component UI\nIt's just a bunch of elements, feel free to copy/paste.\nimport\n{\nForm\n}\nfrom\n\"\n@remix-run/react\n\";\nimport\ntype\n{\nFunctionComponent\n}\nfrom\n\"\nreact\n\";\nimport\ntype\n{\nContactRecord\n}\nfrom\n\"\n../data\n\";\nexport\ndefault\nfunction\nContact\n() {\nconst\ncontact\n=\n{\nfirst: \"\nYour\n\",\nlast: \"\nName\n\",\navatar: \"\nhttps://placecats.com/200/200\n\",\ntwitter: \"\nyour_handle\n\",\nnotes: \"\nSome notes\n\",\nfavorite:\ntrue\n,\n};\nreturn\n(\n<\ndiv\nid\n=\n\"\ncontact\n\">\n<\ndiv\n>\n<\nimg\nalt\n=\n{\n`${\ncontact\n.\nfirst\n}\n${\ncontact\n.\nlast\n}\navatar\n`\n}\nkey\n=\n{\ncontact\n.\navatar\n}\nsrc\n=\n{\ncontact\n.\navatar\n}\n/>\n</\ndiv\n>\n<\ndiv\n>\n<\nh1\n>\n{\ncontact\n.\nfirst\n||\ncontact\n.\nlast\n?\n(\n<>\n{\ncontact\n.\nfirst\n}\n{\ncontact\n.\nlast\n}\n</>\n)\n:\n(\n<\ni\n>No Name</\ni\n>\n)\n}{\n\"\n\"\n}\n<\nFavorite\ncontact\n=\n{\ncontact\n}\n/>\n</\nh1\n>\n{\ncontact\n.\ntwitter\n?\n(\n<\np\n>\n<\na\nhref\n=\n{\n`\nhttps://twitter.com/\n${\ncontact\n.\ntwitter\n}`\n}\n>\n{\ncontact\n.\ntwitter\n}\n</\na\n>\n</\np\n>\n)\n:\nnull\n}\n{\ncontact\n.\nnotes\n?\n<\np\n>\n{\ncontact\n.\nnotes\n}\n</\np\n>\n:\nnull\n}\n<\ndiv\n>\n<\nForm\naction\n=\n\"\nedit\n\">\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Edit</\nbutton\n>\n</\nForm\n>\n<\nForm\naction\n=\n\"\ndestroy\n\"\nmethod\n=\n\"\npost\n\"\nonSubmit\n=\n{\n(\nevent\n)\n=>\n{\nconst\nresponse\n=\nconfirm\n(\n\"\nPlease confirm you want to delete this record.\n\"\n);\nif\n(\n!\nresponse\n) {\nevent\n.\npreventDefault\n();\n}\n}\n}\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Delete</\nbutton\n>\n</\nForm\n>\n</\ndiv\n>\n</\ndiv\n>\n</\ndiv\n>\n);\n}\nconst\nFavorite\n:\nFunctionComponent\n<{\ncontact\n:\nPick\n<\nContactRecord\n, \"\nfavorite\n\">;\n}>\n=\n({\ncontact\n})\n=>\n{\nconst\nfavorite\n=\ncontact\n.\nfavorite\n;\nreturn\n(\n<\nForm\nmethod\n=\n\"\npost\n\">\n<\nbutton\naria-label\n=\n{\nfavorite\n?\n\"\nRemove from favorites\n\"\n:\n\"\nAdd to favorites\n\"\n}\nname\n=\n\"\nfavorite\n\"\nvalue\n=\n{\nfavorite\n?\n\"\nfalse\n\"\n:\n\"\ntrue\n\"\n}\n>\n{\nfavorite\n?\n\"\n\u2605\n\"\n:\n\"\n\u2606\n\"\n}\n</\nbutton\n>\n</\nForm\n>\n);\n};\nNow if we click one of the links or visit\n/contacts/1\nwe get ... nothing new?\nNested Routes and Outlets\nSince Remix is built on top of React Router, it supports nested routing. In order for child routes to render inside parent layouts, we need to render an\nOutlet\nin the parent. Let's fix it, open up\napp/root.tsx\nand render an outlet inside.\n\ud83d\udc49\nRender an\n<Outlet />\n// existing imports\nimport\n{\nForm\n,\nLinks\n,\nMeta\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports & code\nexport\ndefault\nfunction\nApp\n() {\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* other elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* other elements */\n}\n</\ndiv\n>\n<\ndiv\nid\n=\n\"\ndetail\n\">\n<\nOutlet\n/>\n</\ndiv\n>\n{\n/* other elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nNow the child route should be rendered through the outlet.\nClient Side Routing\nYou may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing.\nClient side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render a new UI. Let's make it happen with\n<Link>\n.\n\ud83d\udc49\nChange the sidebar\n<a href>\nto\n<Link to>\n// existing imports\nimport\n{\nForm\n,\nLink\n,\nLinks\n,\nMeta\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* other elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* other elements */\n}\n<\nnav\n>\n<\nul\n>\n<\nli\n>\n<\nLink\nto\n=\n{\n`\n/contacts/1\n`\n}\n>Your Name</\nLink\n>\n</\nli\n>\n<\nli\n>\n<\nLink\nto\n=\n{\n`\n/contacts/2\n`\n}\n>Your Friend</\nLink\n>\n</\nli\n>\n</\nul\n>\n</\nnav\n>\n</\ndiv\n>\n{\n/* other elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nYou can open the network tab in the browser devtools to see that it's not requesting documents anymore.\nLoading Data\nURL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:\nURL Segment\nComponent\nData\n/\n<Root>\nlist of contacts\ncontacts/:contactId\n<Contact>\nindividual contact\nBecause of this natural coupling, Remix has data conventions to get data into your route components easily.\nThere are two APIs we'll be using to load data,\nloader\nand\nuseLoaderData\n. First we'll create and export a\nloader\nfunction in the root route and then render the data.\n\ud83d\udc49\nExport a\nloader\nfunction from\napp/root.tsx\nand render the data\nThe following code has a type error in it, we'll fix it in the next section\n// existing imports\nimport\n{\nForm\n,\nLink\n,\nLinks\n,\nMeta\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\nuseLoaderData\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports\nimport\n{\ngetContacts\n}\nfrom\n\"\n./data\n\";\n// existing exports\nexport\nconst\nloader\n=\nasync\n()\n=>\n{\nconst\ncontacts\n=\nawait\ngetContacts\n();\nreturn\n{\ncontacts\n};\n};\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n}\n=\nuseLoaderData\n();\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* other elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* other elements */\n}\n<\nnav\n>\n{\ncontacts\n.length\n?\n(\n<\nul\n>\n{\ncontacts\n.\nmap\n((\ncontact\n)\n=>\n(\n<\nli\nkey\n=\n{\ncontact\n.\nid\n}\n>\n<\nLink\nto\n=\n{\n`\ncontacts/\n${\ncontact\n.\nid\n}`\n}\n>\n{\ncontact\n.\nfirst\n||\ncontact\n.\nlast\n?\n(\n<>\n{\ncontact\n.\nfirst\n}\n{\ncontact\n.\nlast\n}\n</>\n)\n:\n(\n<\ni\n>No Name</\ni\n>\n)\n}{\n\"\n\"\n}\n{\ncontact\n.\nfavorite\n?\n(\n<\nspan\n>\u2605</\nspan\n>\n)\n:\nnull\n}\n</\nLink\n>\n</\nli\n>\n))\n}\n</\nul\n>\n)\n:\n(\n<\np\n>\n<\ni\n>No contacts</\ni\n>\n</\np\n>\n)\n}\n</\nnav\n>\n</\ndiv\n>\n{\n/* other elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nThat's it! Remix will now automatically keep that data in sync with your UI. The sidebar should now look like this:\nType Inference\nYou may have noticed TypeScript complaining about the\ncontact\ntype inside the map. We can add a quick annotation to get type inference about our data with\ntypeof loader\n:\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\n// existing code\n}\nURL Params in Loaders\n\ud83d\udc49\nClick on one of the sidebar links\nWe should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.\nRemember the\n$contactId\npart of the file name at\napp/routes/contacts.$contactId.tsx\n? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL \"URL Params\", or just \"params\" for short.\nThese\nparams\nare passed to the loader with keys that match the dynamic segment. For example, our segment is named\n$contactId\nso the value will be passed as\nparams.contactId\n.\nThese params are most often used to find a record by ID. Let's try it out.\n\ud83d\udc49\nAdd a\nloader\nfunction to the contact page and access data with\nuseLoaderData\nThe following code has type errors in it, we'll fix them in the next section\nimport\n{\nForm\n,\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports\nimport\n{\ngetContact\n}\nfrom\n\"\n../data\n\";\nexport\nconst\nloader\n=\nasync\n({\nparams\n})\n=>\n{\nconst\ncontact\n=\nawait\ngetContact\n(\nparams\n.\ncontactId\n);\nreturn\n{\ncontact\n};\n};\nexport\ndefault\nfunction\nContact\n() {\nconst\n{\ncontact\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\n// existing code\n}\n// existing code\nValidating Params and Throwing Responses\nTypeScript is very upset with us, let's make it happy and see what that forces us to consider:\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports\nimport\ninvariant\nfrom\n\"\ntiny-invariant\n\";\n// existing imports\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\ncontact\n=\nawait\ngetContact\n(\nparams\n.\ncontactId\n);\nreturn\n{\ncontact\n};\n};\n// existing code\nThe first problem this highlights is we might have gotten the param's name wrong between the file name and the code (maybe you changed the name of the file!). Invariant is a handy function for throwing an error with a custom message when you anticipated a potential issue with your code.\nNext, the\nuseLoaderData<typeof loader>()\nnow knows that we got a contact or\nnull\n(maybe there is no contact with that ID). This potential\nnull\nis cumbersome for our component code, and the TS errors are flying around still.\nWe could account for the possibility of the contact being not found in component code, but the webby thing to do is send a proper 404. We can do that in the loader and solve all of our problems at once.\n// existing imports\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\ncontact\n=\nawait\ngetContact\n(\nparams\n.\ncontactId\n);\nif\n(\n!\ncontact\n) {\nthrow\nnew\nResponse\n(\"\nNot Found\n\", { status:\n404\n});\n}\nreturn\n{\ncontact\n};\n};\n// existing code\nNow, if the user isn't found, code execution down this path stops and Remix renders the error path instead. Components in Remix can focus only on the happy path \ud83d\ude01\nData Mutations\nWe'll create our first contact in a second, but first let's talk about HTML.\nRemix emulates HTML Form navigation as the data mutation primitive, which used to be the only way prior to the JavaScript cambrian explosion. Don't be fooled by the simplicity! Forms in Remix give you the UX capabilities of client-rendered apps with the simplicity of the \"old school\" web model.\nWhile unfamiliar to some web developers, HTML\nform\ns actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while\nform\ns can also change the request method (\nGET\nvs.\nPOST\n) and the request body (\nPOST\nform data).\nWithout client side routing, the browser will serialize the\nform\n's data automatically and send it to the server as the request body for\nPOST\n, and as\nURLSearchParams\nfor\nGET\n. Remix does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's\naction\nfunction.\nWe can test this out by clicking the \"New\" button in our app.\nRemix sends a 405 because there is no code on the server to handle this form navigation.\nCreating Contacts\nWe'll create new contacts by exporting an\naction\nfunction in our root route. When the user clicks the \"new\" button, the form will\nPOST\nto the root route action.\n\ud83d\udc49\nExport an\naction\nfunction from\napp/root.tsx\n// existing imports\nimport\n{\ncreateEmptyContact\n,\ngetContacts\n}\nfrom\n\"\n./data\n\";\nexport\nconst\naction\n=\nasync\n()\n=>\n{\nconst\ncontact\n=\nawait\ncreateEmptyContact\n();\nreturn\n{\ncontact\n};\n};\n// existing code\nThat's it! Go ahead and click the \"New\" button, and you should see a new record pop into the list \ud83e\udd73\nThe\ncreateEmptyContact\nmethod just creates an empty contact with no name or data or anything. But it does still create a record, promise!\n\ud83e\uddd0 Wait a sec ... How did the sidebar update? Where did we call the\naction\nfunction? Where's the code to re-fetch the data? Where are\nuseState\n,\nonSubmit\nand\nuseEffect\n?!\nThis is where the \"old school web\" programming model shows up.\n<Form>\nprevents the browser from sending the request to the server and sends it to your route's\naction\nfunction instead with\nfetch\n.\nIn web semantics, a\nPOST\nusually means some data is changing. By convention, Remix uses this as a hint to automatically revalidate the data on the page after the\naction\nfinishes.\nIn fact, since it's all just HTML and HTTP, you could disable JavaScript and the whole thing will still work. Instead of Remix serializing the form and making a\nfetch\nrequest to your server, the browser will serialize the form and make a document request. From there Remix will render the page server side and send it down. It's the same UI in the end either way.\nWe'll keep JavaScript around, though, because we're going to make a better user experience than spinning favicons and static documents.\nUpdating Data\nLet's add a way to fill the information for our new record.\nJust like creating data, you update data with\n<Form>\n. Let's make a new route at\napp/routes/contacts.$contactId_.edit.tsx\n.\n\ud83d\udc49\nCreate the edit component\ntouch\napp/routes/contacts.\n\\$\ncontactId_.edit.tsx\nNote the weird\n_\nin\n$contactId_\n. By default, routes will automatically nest inside routes with the same prefixed name. Adding a trailing\n_\ntells the route to\nnot\nnest inside\napp/routes/contacts.$contactId.tsx\n. Read more in the\nRoute File Naming\nguide.\n\ud83d\udc49\nAdd the edit page UI\nNothing we haven't seen before, feel free to copy/paste:\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\nimport\n{\nForm\n,\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nimport\ninvariant\nfrom\n\"\ntiny-invariant\n\";\nimport\n{\ngetContact\n}\nfrom\n\"\n../data\n\";\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\ncontact\n=\nawait\ngetContact\n(\nparams\n.\ncontactId\n);\nif\n(\n!\ncontact\n) {\nthrow\nnew\nResponse\n(\"\nNot Found\n\", { status:\n404\n});\n}\nreturn\n{\ncontact\n};\n};\nexport\ndefault\nfunction\nEditContact\n() {\nconst\n{\ncontact\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\nForm\nkey\n=\n{\ncontact\n.\nid\n}\nid\n=\n\"\ncontact-form\n\"\nmethod\n=\n\"\npost\n\">\n<\np\n>\n<\nspan\n>Name</\nspan\n>\n<\ninput\naria-label\n=\n\"\nFirst name\n\"\ndefaultValue\n=\n{\ncontact\n.\nfirst\n}\nname\n=\n\"\nfirst\n\"\nplaceholder\n=\n\"\nFirst\n\"\ntype\n=\n\"\ntext\n\"\n/>\n<\ninput\naria-label\n=\n\"\nLast name\n\"\ndefaultValue\n=\n{\ncontact\n.\nlast\n}\nname\n=\n\"\nlast\n\"\nplaceholder\n=\n\"\nLast\n\"\ntype\n=\n\"\ntext\n\"\n/>\n</\np\n>\n<\nlabel\n>\n<\nspan\n>Twitter</\nspan\n>\n<\ninput\ndefaultValue\n=\n{\ncontact\n.\ntwitter\n}\nname\n=\n\"\ntwitter\n\"\nplaceholder\n=\n\"\n@jack\n\"\ntype\n=\n\"\ntext\n\"\n/>\n</\nlabel\n>\n<\nlabel\n>\n<\nspan\n>Avatar URL</\nspan\n>\n<\ninput\naria-label\n=\n\"\nAvatar URL\n\"\ndefaultValue\n=\n{\ncontact\n.\navatar\n}\nname\n=\n\"\navatar\n\"\nplaceholder\n=\n\"\nhttps://example.com/avatar.jpg\n\"\ntype\n=\n\"\ntext\n\"\n/>\n</\nlabel\n>\n<\nlabel\n>\n<\nspan\n>Notes</\nspan\n>\n<\ntextarea\ndefaultValue\n=\n{\ncontact\n.\nnotes\n}\nname\n=\n\"\nnotes\n\"\nrows\n=\n{\n6\n}\n/>\n</\nlabel\n>\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Save</\nbutton\n>\n<\nbutton\ntype\n=\n\"\nbutton\n\">Cancel</\nbutton\n>\n</\np\n>\n</\nForm\n>\n);\n}\nNow click on your new record, then click the \"Edit\" button. We should see the new route.\nUpdating Contacts with\nFormData\nThe edit route we just created already renders a\nform\n. All we need to do is add the\naction\nfunction. Remix will serialize the\nform\n,\nPOST\nit with\nfetch\n, and automatically revalidate all the data.\n\ud83d\udc49\nAdd an\naction\nfunction to the edit route\nimport\ntype\n{\nActionFunctionArgs\n,\nLoaderFunctionArgs\n,\n}\nfrom\n\"\n@remix-run/node\n\";\nimport\n{\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports\nimport\n{\ngetContact\n,\nupdateContact\n}\nfrom\n\"\n../data\n\";\nexport\nconst\naction\n=\nasync\n({\nparams\n,\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\nupdates\n=\nObject\n.\nfromEntries\n(\nformData\n);\nawait\nupdateContact\n(\nparams\n.\ncontactId\n,\nupdates\n);\nreturn\nredirect\n(`\n/contacts/\n${\nparams\n.\ncontactId\n}`);\n};\n// existing code\nFill out the form, hit save, and you should see something like this!\n(Except easier on the eyes and maybe less hairy.)\nMutation Discussion\n\ud83d\ude11 It worked, but I have no idea what is going on here...\nLet's dig in a bit...\nOpen up\ncontacts.$contactId_.edit.tsx\nand look at the\nform\nelements. Notice how they each have a name:\n<\ninput\naria-label\n=\n\"\nFirst name\n\"\ndefaultValue\n=\n{\ncontact\n.\nfirst\n}\nname\n=\n\"\nfirst\n\"\nplaceholder\n=\n\"\nFirst\n\"\ntype\n=\n\"\ntext\n\"\n/>\nWithout JavaScript, when a form is submitted, the browser will create\nFormData\nand set it as the body of the request when it sends it to the server. As mentioned before, Remix prevents that and emulates the browser by sending the request to your\naction\nfunction with\nfetch\ninstead, including the\nFormData\n.\nEach field in the\nform\nis accessible with\nformData.get(name)\n. For example, given the input field from above, you could access the first and last names like this:\nexport\nconst\naction\n=\nasync\n({\nparams\n,\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\nfirstName\n=\nformData\n.\nget\n(\"\nfirst\n\");\nconst\nlastName\n=\nformData\n.\nget\n(\"\nlast\n\");\n// ...\n};\nSince we have a handful of form fields, we used\nObject.fromEntries\nto collect them all into an object, which is exactly what our\nupdateContact\nfunction wants.\nconst\nupdates\n=\nObject\n.\nfromEntries\n(\nformData\n);\nupdates\n.\nfirst\n;\n// \"Some\"\nupdates\n.\nlast\n;\n// \"Name\"\nAside from the\naction\nfunction, Remix provides none of these APIs we're discussing:\nrequest\n,\nrequest.formData\n,\nObject.fromEntries\nare all provided by the web platform.\nAfter we finished the\naction\n, note the\nredirect\nat the end:\nexport\nconst\naction\n=\nasync\n({\nparams\n,\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\nupdates\n=\nObject\n.\nfromEntries\n(\nformData\n);\nawait\nupdateContact\n(\nparams\n.\ncontactId\n,\nupdates\n);\nreturn\nredirect\n(`\n/contacts/\n${\nparams\n.\ncontactId\n}`);\n};\naction\nand\nloader\nfunctions can both\nreturn a\nResponse\n(makes sense, since they received a\nRequest\n!). The\nredirect\nhelper just makes it easier to return a\nResponse\nthat tells the app to change locations.\nWithout client side routing, if a server redirected after a\nPOST\nrequest, the new page would fetch the latest data and render. As we learned before, Remix emulates this model and automatically revalidates the data on the page after the\naction\ncall. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing in Remix either!\nOne last thing. Without JavaScript, the\nredirect\nwould be a normal redirect. However, with JavaScript it's a client-side redirect, so the user doesn't lose client state like scroll positions or component state.\nRedirecting new records to the edit page\nNow that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:\n\ud83d\udc49\nRedirect to the new record's edit page\n// existing imports\nimport\n{\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports\nexport\nconst\naction\n=\nasync\n()\n=>\n{\nconst\ncontact\n=\nawait\ncreateEmptyContact\n();\nreturn\nredirect\n(`\n/contacts/\n${\ncontact\n.\nid\n}\n/edit\n`);\n};\n// existing code\nNow when we click \"New\", we should end up on the edit page:\nActive Link Styling\nNow that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use\nNavLink\nto fix this.\n\ud83d\udc49\nReplace\n<Link>\nwith\n<NavLink>\nin the sidebar\n// existing imports\nimport\n{\nForm\n,\nLinks\n,\nMeta\n,\nNavLink\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\nuseLoaderData\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\nul\n>\n{\ncontacts\n.\nmap\n((\ncontact\n)\n=>\n(\n<\nli\nkey\n=\n{\ncontact\n.\nid\n}\n>\n<\nNavLink\nclassName\n=\n{\n({\nisActive\n,\nisPending\n})\n=>\nisActive\n?\n\"\nactive\n\"\n:\nisPending\n?\n\"\npending\n\"\n:\n\"\"\n}\nto\n=\n{\n`\ncontacts/\n${\ncontact\n.\nid\n}`\n}\n>\n{\n/* existing elements */\n}\n</\nNavLink\n>\n</\nli\n>\n))\n}\n</\nul\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nNote that we are passing a function to\nclassName\n. When the user is at the URL that matches\n<NavLink to>\n, then\nisActive\nwill be true. When it's\nabout\nto be active (the data is still loading) then\nisPending\nwill be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked, but data needs to be loaded.\nGlobal Pending UI\nAs the user navigates the app, Remix will\nleave the old page up\nas data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.\nRemix is managing all the states behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the\nuseNavigation\nhook.\n\ud83d\udc49\nUse\nuseNavigation\nto add global pending UI\n// existing imports\nimport\n{\nForm\n,\nLinks\n,\nMeta\n,\nNavLink\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\nuseLoaderData\n,\nuseNavigation\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n{\n/* existing elements */\n}\n<\ndiv\nclassName\n=\n{\nnavigation\n.\nstate\n===\n\"\nloading\n\"\n?\n\"\nloading\n\"\n:\n\"\"\n}\nid\n=\n\"\ndetail\n\"\n>\n<\nOutlet\n/>\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nuseNavigation\nreturns the current navigation state: it can be one of\n\"idle\"\n,\n\"loading\"\nor\n\"submitting\"\n.\nIn our case, we add a\n\"loading\"\nclass to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want, though, like show a spinner or loading bar across the top.\nDeleting Records\nIf we review code in the contact route, we can find the delete button looks like this:\n<\nForm\naction\n=\n\"\ndestroy\n\"\nmethod\n=\n\"\npost\n\"\nonSubmit\n=\n{\n(\nevent\n)\n=>\n{\nconst\nresponse\n=\nconfirm\n(\n\"\nPlease confirm you want to delete this record.\n\"\n);\nif\n(\n!\nresponse\n) {\nevent\n.\npreventDefault\n();\n}\n}\n}\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Delete</\nbutton\n>\n</\nForm\n>\nNote the\naction\npoints to\n\"destroy\"\n. Like\n<Link to>\n,\n<Form action>\ncan take a\nrelative\nvalue. Since the form is rendered in\ncontacts.$contactId.tsx\n, then a relative action with\ndestroy\nwill submit the form to\ncontacts.$contactId.destroy\nwhen clicked.\nAt this point you should know everything you need to know to make the delete button work. Maybe give it a try before moving on? You'll need:\nA new route\nAn\naction\nat that route\ndeleteContact\nfrom\napp/data.ts\nredirect\nto somewhere after\n\ud83d\udc49\nCreate the \"destroy\" route module\ntouch\napp/routes/contacts.\n\\$\ncontactId_.destroy.tsx\n\ud83d\udc49\nAdd the destroy action\nimport\ntype\n{\nActionFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\nimport\n{\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\nimport\ninvariant\nfrom\n\"\ntiny-invariant\n\";\nimport\n{\ndeleteContact\n}\nfrom\n\"\n../data\n\";\nexport\nconst\naction\n=\nasync\n({\nparams\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nawait\ndeleteContact\n(\nparams\n.\ncontactId\n);\nreturn\nredirect\n(\"\n/\n\");\n};\nAlright, navigate to a record and click the \"Delete\" button. It works!\n\ud83d\ude05 I'm still confused why this all works\nWhen the user clicks the submit button:\n<Form>\nprevents the default browser behavior of sending a new document\nPOST\nrequest to the server, but instead emulates the browser by creating a\nPOST\nrequest with client side routing and\nfetch\nThe\n<Form action=\"destroy\">\nmatches the new route at\ncontacts.$contactId_.destroy.tsx\nand sends it the request\nAfter the\naction\nredirects, Remix calls all the\nloader\ns for the data on the page to get the latest values (this is \"revalidation\").\nuseLoaderData\nreturns new values and causes the components to update!\nAdd a\nForm\n, add an\naction\n, Remix does the rest.\nIndex Routes\nWhen we load up the app, you'll notice a big blank page on the right side of our list.\nWhen a route has children, and you're at the parent route's path, the\n<Outlet>\nhas nothing to render because no children match. You can think of index routes as the default child route to fill in that space.\n\ud83d\udc49\nCreate an index route for the root route\ntouch\napp/routes/_index.tsx\n\ud83d\udc49\nFill in the index component's elements\nFeel free to copy/paste, nothing special here.\nexport\ndefault\nfunction\nIndex\n() {\nreturn\n(\n<\np\nid\n=\n\"\nindex-page\n\">\nThis is a demo for Remix.\n<\nbr\n/>\nCheck out\n{\n\"\n\"\n}\n<\na\nhref\n=\n\"\nhttps://remix.run\n\">the docs at remix.run</\na\n>.\n</\np\n>\n);\n}\nThe route name\n_index\nis special. It tells Remix to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the\n<Outlet />\n.\nVoil\u00e0! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.\nCancel Button\nOn the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.\nWe'll need a click handler on the button as well as\nuseNavigate\n.\n\ud83d\udc49\nAdd the cancel button click handler with\nuseNavigate\n// existing imports\nimport\n{\nForm\n,\nuseLoaderData\n,\nuseNavigate\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nEditContact\n() {\nconst\n{\ncontact\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigate\n=\nuseNavigate\n();\nreturn\n(\n<\nForm\nkey\n=\n{\ncontact\n.\nid\n}\nid\n=\n\"\ncontact-form\n\"\nmethod\n=\n\"\npost\n\">\n{\n/* existing elements */\n}\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Save</\nbutton\n>\n<\nbutton\nonClick\n=\n{\n()\n=>\nnavigate\n(\n-\n1\n)\n}\ntype\n=\n\"\nbutton\n\">\nCancel\n</\nbutton\n>\n</\np\n>\n</\nForm\n>\n);\n}\nNow when the user clicks \"Cancel\", they'll be sent back one entry in the browser's history.\n\ud83e\uddd0 Why is there no\nevent.preventDefault()\non the button?\nA\n<button type=\"button\">\n, while seemingly redundant, is the HTML way of preventing a button from submitting its form.\nTwo more features to go. We're on the home stretch!\nURLSearchParams\nand\nGET\nSubmissions\nAll of our interactive UI so far have been either links that change the URL or\nform\ns that post data to\naction\nfunctions. The search field is interesting because it's a mix of both: it's a\nform\n, but it only changes the URL, it doesn't change data.\nLet's see what happens when we submit the search form:\n\ud83d\udc49\nType a name into the search field and hit the enter key\nNote the browser's URL now contains your query in the URL as\nURLSearchParams\n:\nhttp://localhost:5173/?q=ryan\nSince it's not\n<Form method=\"post\">\n, Remix emulates the browser by serializing the\nFormData\ninto the\nURLSearchParams\ninstead of the request body.\nloader\nfunctions have access to the search params from the\nrequest\n. Let's use it to filter the list:\n\ud83d\udc49\nFilter the list if there are\nURLSearchParams\nimport\ntype\n{\nLinksFunction\n,\nLoaderFunctionArgs\n,\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports and exports\nexport\nconst\nloader\n=\nasync\n({\nrequest\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nconst\nurl\n=\nnew\nURL\n(\nrequest\n.\nurl\n);\nconst\nq\n=\nurl\n.\nsearchParams\n.\nget\n(\"\nq\n\");\nconst\ncontacts\n=\nawait\ngetContacts\n(\nq\n);\nreturn\n{\ncontacts\n};\n};\n// existing code\nBecause this is a\nGET\n, not a\nPOST\n, Remix\ndoes not\ncall the\naction\nfunction. Submitting a\nGET\nform\nis the same as clicking a link: only the URL changes.\nThis also means it's a normal page navigation. You can click the back button to get back to where you were.\nSynchronizing URLs to Form State\nThere are a couple of UX issues here that we can take care of quickly.\nIf you click back after a search, the form field still has the value you entered even though the list is no longer filtered.\nIf you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered\nIn other words, the URL and our input's state are out of sync.\nLet's solve (2) first and start the input with the value from the URL.\n\ud83d\udc49\nReturn\nq\nfrom your\nloader\n, set it as the input's default value\n// existing imports and exports\nexport\nconst\nloader\n=\nasync\n({\nrequest\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nconst\nurl\n=\nnew\nURL\n(\nrequest\n.\nurl\n);\nconst\nq\n=\nurl\n.\nsearchParams\n.\nget\n(\"\nq\n\");\nconst\ncontacts\n=\nawait\ngetContacts\n(\nq\n);\nreturn\n{\ncontacts\n,\nq\n};\n};\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n,\nq\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nrole\n=\n\"\nsearch\n\">\n<\ninput\naria-label\n=\n\"\nSearch contacts\n\"\ndefaultValue\n=\n{\nq\n||\n\"\"\n}\nid\n=\n\"\nq\n\"\nname\n=\n\"\nq\n\"\nplaceholder\n=\n\"\nSearch\n\"\ntype\n=\n\"\nsearch\n\"\n/>\n{\n/* existing elements */\n}\n</\nForm\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nThe input field will show the query if you refresh the page after a search now.\nNow for problem (1), clicking the back button and updating the input. We can bring in\nuseEffect\nfrom React to manipulate the input's value in the DOM directly.\n\ud83d\udc49\nSynchronize input value with the\nURLSearchParams\n// existing imports\nimport\n{\nuseEffect\n}\nfrom\n\"\nreact\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n,\nq\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\nuseEffect\n(()\n=>\n{\nconst\nsearchField\n=\ndocument\n.\ngetElementById\n(\"\nq\n\");\nif\n(\nsearchField\ninstanceof\nHTMLInputElement\n) {\nsearchField\n.\nvalue\n=\nq\n||\n\"\";\n}\n}, [\nq\n]);\n// existing code\n}\n\ud83e\udd14 Shouldn't you use a controlled component and React State for this?\nYou could certainly do this as a controlled component. You will have more synchronization points, but it's up to you.\nExpand this to see what it would look like\n// We no longer need useEffect\nimport\n{\nuseState\n}\nfrom\n\"\nreact\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n,\nq\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\n// the query now needs to be kept in state\nconst\n[\nprevQ\n,\nsetPrevQ\n]\n=\nuseState\n(\nq\n);\nconst\n[\nquery\n,\nsetQuery\n]\n=\nuseState\n(\nq\n||\n\"\");\n// We can avoid using `useEffect` to synchronize the query\n// by using a separate piece of state to store the previous\n// value\nif\n(\nq\n!==\nprevQ\n) {\nsetPrevQ\n(\nq\n);\nsetQuery\n(\nq\n||\n\"\");\n}\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nrole\n=\n\"\nsearch\n\">\n<\ninput\naria-label\n=\n\"\nSearch contacts\n\"\nid\n=\n\"\nq\n\"\nname\n=\n\"\nq\n\"\n// synchronize user's input to component state\nonChange\n=\n{\n(\nevent\n)\n=>\nsetQuery\n(\nevent\n.\ncurrentTarget\n.\nvalue\n)\n}\nplaceholder\n=\n\"\nSearch\n\"\ntype\n=\n\"\nsearch\n\"\n// switched to `value` from `defaultValue`\nvalue\n=\n{\nquery\n}\n/>\n{\n/* existing elements */\n}\n</\nForm\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nAlright, you should now be able to click the back/forward/refresh buttons, and the input's value should be in sync with the URL and results.\nSubmitting\nForm\n's\nonChange\nWe've got a product decision to make here. Sometimes you want the user to submit the\nform\nto filter some results, other times you want to filter as the user types. We've already implemented the first, so let's see what it's like for the second.\nWe've seen\nuseNavigate\nalready, we'll use its cousin,\nuseSubmit\n, for this.\n// existing imports\nimport\n{\nForm\n,\nLinks\n,\nMeta\n,\nNavLink\n,\nOutlet\n,\nScripts\n,\nScrollRestoration\n,\nuseLoaderData\n,\nuseNavigation\n,\nuseSubmit\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n,\nq\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\nconst\nsubmit\n=\nuseSubmit\n();\n// existing code\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nonChange\n=\n{\n(\nevent\n)\n=>\nsubmit\n(\nevent\n.\ncurrentTarget\n)\n}\nrole\n=\n\"\nsearch\n\"\n>\n{\n/* existing elements */\n}\n</\nForm\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nAs you type, the\nform\nis automatically submitted now!\nNote the argument to\nsubmit\n. The\nsubmit\nfunction will serialize and submit any form you pass to it. We're passing in\nevent.currentTarget\n. The\ncurrentTarget\nis the DOM node the event is attached to (the\nform\n).\nAdding Search Spinner\nIn a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.\nWithout any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.\nFor a better user experience, let's add some immediate UI feedback for the search. We'll use\nuseNavigation\nagain.\n\ud83d\udc49\nAdd a variable to know if we're searching\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\nconst\n{\ncontacts\n,\nq\n}\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconst\nnavigation\n=\nuseNavigation\n();\nconst\nsubmit\n=\nuseSubmit\n();\nconst\nsearching\n=\nnavigation\n.\nlocation\n&&\nnew\nURLSearchParams\n(\nnavigation\n.\nlocation\n.\nsearch\n).\nhas\n(\n\"\nq\n\"\n);\n// existing code\n}\nWhen nothing is happening,\nnavigation.location\nwill be\nundefined\n, but when the user navigates it will be populated with the next location while data loads. Then we check if they're searching with\nlocation.search\n.\n\ud83d\udc49\nAdd classes to search form elements using the new\nsearching\nstate\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\n// existing code\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nonChange\n=\n{\n(\nevent\n)\n=>\nsubmit\n(\nevent\n.\ncurrentTarget\n)\n}\nrole\n=\n\"\nsearch\n\"\n>\n<\ninput\naria-label\n=\n\"\nSearch contacts\n\"\nclassName\n=\n{\nsearching\n?\n\"\nloading\n\"\n:\n\"\"\n}\ndefaultValue\n=\n{\nq\n||\n\"\"\n}\nid\n=\n\"\nq\n\"\nname\n=\n\"\nq\n\"\nplaceholder\n=\n\"\nSearch\n\"\ntype\n=\n\"\nsearch\n\"\n/>\n<\ndiv\naria-hidden\nhidden\n=\n{\n!\nsearching\n}\nid\n=\n\"\nsearch-spinner\n\"\n/>\n</\nForm\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nBonus points, avoid fading out the main screen when searching:\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\n// existing code\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n{\n/* existing elements */\n}\n<\ndiv\nclassName\n=\n{\nnavigation\n.\nstate\n===\n\"\nloading\n\"\n&&\n!\nsearching\n?\n\"\nloading\n\"\n:\n\"\"\n}\nid\n=\n\"\ndetail\n\"\n>\n<\nOutlet\n/>\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nYou should now have a nice spinner on the left side of the search input.\nManaging the History Stack\nSince the form is submitted for every keystroke, typing the characters \"alex\" and then deleting them with backspace results in a huge history stack \ud83d\ude02. We definitely don't want this:\nWe can avoid this by\nreplacing\nthe current entry in the history stack with the next page instead of pushing into it.\n\ud83d\udc49\nUse\nreplace\nin\nsubmit\n// existing imports and exports\nexport\ndefault\nfunction\nApp\n() {\n// existing code\nreturn\n(\n<\nhtml\nlang\n=\n\"\nen\n\">\n{\n/* existing elements */\n}\n<\nbody\n>\n<\ndiv\nid\n=\n\"\nsidebar\n\">\n{\n/* existing elements */\n}\n<\ndiv\n>\n<\nForm\nid\n=\n\"\nsearch-form\n\"\nonChange\n=\n{\n(\nevent\n)\n=>\n{\nconst\nisFirstSearch\n=\nq\n===\nnull\n;\nsubmit\n(\nevent\n.\ncurrentTarget\n, {\nreplace:\n!\nisFirstSearch\n,\n});\n}\n}\nrole\n=\n\"\nsearch\n\"\n>\n{\n/* existing elements */\n}\n</\nForm\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\ndiv\n>\n{\n/* existing elements */\n}\n</\nbody\n>\n</\nhtml\n>\n);\n}\nAfter a quick check if this is the first search or not, we decide to replace it. Now the first search will add a new entry, but every keystroke after that will replace the current entry. Instead of clicking back seven times to remove the search, users only have to click back once.\nForm\ns Without Navigation\nSo far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form\nwithout\ncausing a navigation.\nFor these cases, we have\nuseFetcher\n. It allows us to communicate with\naction\ns and\nloader\ns without causing a navigation.\nThe \u2605 button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.\n\ud83d\udc49\nChange the\n<Favorite>\nform to a fetcher form\n// existing imports\nimport\n{\nForm\n,\nuseFetcher\n,\nuseLoaderData\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// existing imports and exports\n// existing code\nconst\nFavorite\n:\nFunctionComponent\n<{\ncontact\n:\nPick\n<\nContactRecord\n, \"\nfavorite\n\">;\n}>\n=\n({\ncontact\n})\n=>\n{\nconst\nfetcher\n=\nuseFetcher\n();\nconst\nfavorite\n=\ncontact\n.\nfavorite\n;\nreturn\n(\n<\nfetcher.Form\nmethod\n=\n\"\npost\n\">\n<\nbutton\naria-label\n=\n{\nfavorite\n?\n\"\nRemove from favorites\n\"\n:\n\"\nAdd to favorites\n\"\n}\nname\n=\n\"\nfavorite\n\"\nvalue\n=\n{\nfavorite\n?\n\"\nfalse\n\"\n:\n\"\ntrue\n\"\n}\n>\n{\nfavorite\n?\n\"\n\u2605\n\"\n:\n\"\n\u2606\n\"\n}\n</\nbutton\n>\n</\nfetcher.Form\n>\n);\n};\nThis form will no longer cause a navigation, but simply fetch to the\naction\n. Speaking of which ... this won't work until we create the\naction\n.\n\ud83d\udc49\nCreate the\naction\nimport\ntype\n{\nActionFunctionArgs\n,\nLoaderFunctionArgs\n,\n}\nfrom\n\"\n@remix-run/node\n\";\n// existing imports\nimport\n{\ngetContact\n,\nupdateContact\n}\nfrom\n\"\n../data\n\";\n// existing imports\nexport\nconst\naction\n=\nasync\n({\nparams\n,\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\ncontactId\n, \"\nMissing contactId param\n\");\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nreturn\nupdateContact\n(\nparams\n.\ncontactId\n, {\nfavorite:\nformData\n.\nget\n(\"\nfavorite\n\")\n===\n\"\ntrue\n\",\n});\n};\n// existing code\nAlright, we're ready to click the star next to the user's name!\nCheck that out, both stars automatically update. Our new\n<fetcher.Form method=\"post\">\nworks almost exactly like the\n<Form>\nwe've been using: it calls the action and then all data is revalidated automatically \u2014 even your errors will be caught the same way.\nThere is one key difference, though, it's not a navigation, so the URL doesn't change, and the history stack is unaffected.\nOptimistic UI\nYou probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world.\nTo give the user some feedback, we could put the star into a loading state with\nfetcher.state\n(a lot like\nnavigation.state\nfrom before), but we can do something even better this time. We can use a strategy called \"Optimistic UI\".\nThe fetcher knows the\nFormData\nbeing submitted to the\naction\n, so it's available to you on\nfetcher.formData\n. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.\n\ud83d\udc49\nRead the optimistic value from\nfetcher.formData\n// existing code\nconst\nFavorite\n:\nFunctionComponent\n<{\ncontact\n:\nPick\n<\nContactRecord\n, \"\nfavorite\n\">;\n}>\n=\n({\ncontact\n})\n=>\n{\nconst\nfetcher\n=\nuseFetcher\n();\nconst\nfavorite\n=\nfetcher\n.\nformData\n?\nfetcher\n.\nformData\n.\nget\n(\"\nfavorite\n\")\n===\n\"\ntrue\n\"\n:\ncontact\n.\nfavorite\n;\nreturn\n(\n<\nfetcher.Form\nmethod\n=\n\"\npost\n\">\n<\nbutton\naria-label\n=\n{\nfavorite\n?\n\"\nRemove from favorites\n\"\n:\n\"\nAdd to favorites\n\"\n}\nname\n=\n\"\nfavorite\n\"\nvalue\n=\n{\nfavorite\n?\n\"\nfalse\n\"\n:\n\"\ntrue\n\"\n}\n>\n{\nfavorite\n?\n\"\n\u2605\n\"\n:\n\"\n\u2606\n\"\n}\n</\nbutton\n>\n</\nfetcher.Form\n>\n);\n};\nNow the star\nimmediately\nchanges to the new state when you click it.\nThat's it! Thanks for giving Remix a try. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do, so make sure to check out all the APIs \ud83d\ude00\n\u00a9\nShopify, Inc.\n\u2022\nDocs and examples licensed under\nMIT\nEdit",
  "content_markdown": "[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\n[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\n[View code on GitHub](https://github.com/remix-run/remix/tree/v2 \"View code on GitHub\")[Chat on Discord](https://rmx.as/discord \"Chat on Discord\")\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\nTutorial (30m)\n\nOn this page\n\n- [Setup](/docs/start/tutorial/#setup)\n- [The Root Route](/docs/start/tutorial/#the-root-route)\n- [Adding Stylesheets with `links`](/docs/start/tutorial/#adding-stylesheets-with-links)\n- [The Contact Route UI](/docs/start/tutorial/#the-contact-route-ui)\n- [Nested Routes and Outlets](/docs/start/tutorial/#nested-routes-and-outlets)\n- [Client Side Routing](/docs/start/tutorial/#client-side-routing)\n- [Loading Data](/docs/start/tutorial/#loading-data)\n- [Type Inference](/docs/start/tutorial/#type-inference)\n- [URL Params in Loaders](/docs/start/tutorial/#url-params-in-loaders)\n- [Validating Params and Throwing Responses](/docs/start/tutorial/#validating-params-and-throwing-responses)\n- [Data Mutations](/docs/start/tutorial/#data-mutations)\n- [Creating Contacts](/docs/start/tutorial/#creating-contacts)\n- [Updating Data](/docs/start/tutorial/#updating-data)\n- [Updating Contacts with `FormData`](/docs/start/tutorial/#updating-contacts-with-formdata)\n- [Mutation Discussion](/docs/start/tutorial/#mutation-discussion)\n- [Redirecting new records to the edit page](/docs/start/tutorial/#redirecting-new-records-to-the-edit-page)\n- [Active Link Styling](/docs/start/tutorial/#active-link-styling)\n- [Global Pending UI](/docs/start/tutorial/#global-pending-ui)\n- [Deleting Records](/docs/start/tutorial/#deleting-records)\n- [Index Routes](/docs/start/tutorial/#index-routes)\n- [Cancel Button](/docs/start/tutorial/#cancel-button)\n- [`URLSearchParams` and `GET` Submissions](/docs/start/tutorial/#urlsearchparams-and-get-submissions)\n- [Synchronizing URLs to Form State](/docs/start/tutorial/#synchronizing-urls-to-form-state)\n- [Submitting `Form`'s `onChange`](/docs/start/tutorial/#submitting-forms-onchange)\n- [Adding Search Spinner](/docs/start/tutorial/#adding-search-spinner)\n- [Managing the History Stack](/docs/start/tutorial/#managing-the-history-stack)\n- [`Form`s Without Navigation](/docs/start/tutorial/#forms-without-navigation)\n- [Optimistic UI](/docs/start/tutorial/#optimistic-ui)\n\n- [Setup](/docs/start/tutorial/#setup)\n- [The Root Route](/docs/start/tutorial/#the-root-route)\n- [Adding Stylesheets with `links`](/docs/start/tutorial/#adding-stylesheets-with-links)\n- [The Contact Route UI](/docs/start/tutorial/#the-contact-route-ui)\n- [Nested Routes and Outlets](/docs/start/tutorial/#nested-routes-and-outlets)\n- [Client Side Routing](/docs/start/tutorial/#client-side-routing)\n- [Loading Data](/docs/start/tutorial/#loading-data)\n- [Type Inference](/docs/start/tutorial/#type-inference)\n- [URL Params in Loaders](/docs/start/tutorial/#url-params-in-loaders)\n- [Validating Params and Throwing Responses](/docs/start/tutorial/#validating-params-and-throwing-responses)\n- [Data Mutations](/docs/start/tutorial/#data-mutations)\n- [Creating Contacts](/docs/start/tutorial/#creating-contacts)\n- [Updating Data](/docs/start/tutorial/#updating-data)\n- [Updating Contacts with `FormData`](/docs/start/tutorial/#updating-contacts-with-formdata)\n- [Mutation Discussion](/docs/start/tutorial/#mutation-discussion)\n- [Redirecting new records to the edit page](/docs/start/tutorial/#redirecting-new-records-to-the-edit-page)\n- [Active Link Styling](/docs/start/tutorial/#active-link-styling)\n- [Global Pending UI](/docs/start/tutorial/#global-pending-ui)\n- [Deleting Records](/docs/start/tutorial/#deleting-records)\n- [Index Routes](/docs/start/tutorial/#index-routes)\n- [Cancel Button](/docs/start/tutorial/#cancel-button)\n- [`URLSearchParams` and `GET` Submissions](/docs/start/tutorial/#urlsearchparams-and-get-submissions)\n- [Synchronizing URLs to Form State](/docs/start/tutorial/#synchronizing-urls-to-form-state)\n- [Submitting `Form`'s `onChange`](/docs/start/tutorial/#submitting-forms-onchange)\n- [Adding Search Spinner](/docs/start/tutorial/#adding-search-spinner)\n- [Managing the History Stack](/docs/start/tutorial/#managing-the-history-stack)\n- [`Form`s Without Navigation](/docs/start/tutorial/#forms-without-navigation)\n- [Optimistic UI](/docs/start/tutorial/#optimistic-ui)\n\n# Remix Tutorial\n\nJust getting started with Remix? The latest version of [Remix is now React Router v7](https://remix.run/blog/incremental-path-to-react-19). If you want to use the latest framework features, you can follow the same [tutorial from the React Router docs](https://reactrouter.com/tutorials/address-book).\n\nWe'll be building a small, but feature-rich app that lets you keep track of your contacts. There's no database or other \"production ready\" things, so we can stay focused on Remix. We expect it to take about 30\u00a0m if you're following along, otherwise it's a quick read.\n\n![](/docs-images/contacts/01.webp)\n\n\ud83d\udc49 **Every time you see this, it means you need to do something in the app!**\n\nThe rest is just there for your information and deeper understanding. Let's get to it.\n\n## Setup\n\n\ud83d\udc49 **Generate a basic template**\n\n```\nnpx create-remix@latest --template remix-run/remix/templates/remix-tutorial\n```\n\nThis uses a pretty bare-bones template but includes our CSS and data model, so we can focus on Remix. The [Quick Start](./quickstart) can familiarize you with the basic setup of a Remix project if you'd like to learn more.\n\n\ud83d\udc49 **Start the app**\n\n```\n# cd into the app directory\ncd {wherever you put the app}\n\n# install dependencies if you haven't already\nnpm install\n\n# start the server\nnpm run dev\n```\n\nYou should be able to open up <http://localhost:5173> and see an unstyled screen that looks like this:\n\n![](/docs-images/contacts/03.webp)\n\n## The Root Route\n\nNote the file at `app/root.tsx`. This is what we call the \"Root Route\". It's the first component in the UI that renders, so it typically contains the global layout for the page.\n\nExpand here to see the root component code\n\n```\nimport {\n  Form,\n  Links,\n  Meta,\n  Scripts,\n  ScrollRestoration,\n} from \"@remix-run/react\";\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      <head>\n        <meta charSet=\"utf-8\" />\n        <meta\n          name=\"viewport\"\n          content=\"width=device-width, initial-scale=1\"\n        />\n        <Meta />\n        <Links />\n      </head>\n      <body>\n        <div id=\"sidebar\">\n          <h1>Remix Contacts</h1>\n          <div>\n            <Form id=\"search-form\" role=\"search\">\n              <input\n                aria-label=\"Search contacts\"\n                id=\"q\"\n                name=\"q\"\n                placeholder=\"Search\"\n                type=\"search\"\n              />\n              <div\n                aria-hidden\n                hidden={true}\n                id=\"search-spinner\"\n              />\n            </Form>\n            <Form method=\"post\">\n              <button type=\"submit\">New</button>\n            </Form>\n          </div>\n          <nav>\n            <ul>\n              <li>\n                <a href={`/contacts/1`}>Your Name</a>\n              </li>\n              <li>\n                <a href={`/contacts/2`}>Your Friend</a>\n              </li>\n            </ul>\n          </nav>\n        </div>\n\n        <ScrollRestoration />\n        <Scripts />\n      </body>\n    </html>\n  );\n}\n```\n\n## Adding Stylesheets with `links`\n\nWhile there are multiple ways to style your Remix app, we're going to use a plain stylesheet that's already been written to keep things focused on Remix.\n\nYou can import CSS files directly into JavaScript modules. Vite will fingerprint the asset, save it to your build's client directory, and provide your module with the publicly accessible href.\n\n\ud83d\udc49 **Import the app styles**\n\n```\nimport type { LinksFunction } from \"@remix-run/node\";\n// existing imports\n\nimport appStylesHref from \"./app.css?url\";\n\nexport const links: LinksFunction = () => [\n  { rel: \"stylesheet\", href: appStylesHref },\n];\n```\n\nEvery route can export a [`links`](../route/links) function. They will be collected and rendered into the `<Links />` component we rendered in `app/root.tsx`.\n\nThe app should look something like this now. It sure is nice having a designer who can also write the CSS, isn't it? (Thank you, [Jim](https://blog.jim-nielsen.com) \ud83d\ude4f).\n\n![](/docs-images/contacts/04.webp)\n\n## The Contact Route UI\n\nIf you click on one of the sidebar items, you'll get the default 404 page. Let's create a route that matches the url `/contacts/1`.\n\n\ud83d\udc49 **Create the `app/routes` directory and contact route module**\n\n```\nmkdir app/routes\ntouch app/routes/contacts.\\$contactId.tsx\n```\n\nIn the Remix [route file convention](../file-conventions/routes), `.` will create a `/` in the URL and `$` makes a segment dynamic. We just created a route that will match URLs that look like this:\n\n- `/contacts/123`\n- `/contacts/abc`\n\n\ud83d\udc49 **Add the contact component UI**\n\nIt's just a bunch of elements, feel free to copy/paste.\n\n```\nimport { Form } from \"@remix-run/react\";\nimport type { FunctionComponent } from \"react\";\n\nimport type { ContactRecord } from \"../data\";\n\nexport default function Contact() {\n  const contact = {\n    first: \"Your\",\n    last: \"Name\",\n    avatar: \"https://placecats.com/200/200\",\n    twitter: \"your_handle\",\n    notes: \"Some notes\",\n    favorite: true,\n  };\n\n  return (\n    <div id=\"contact\">\n      <div>\n        <img\n          alt={`${contact.first} ${contact.last} avatar`}\n          key={contact.avatar}\n          src={contact.avatar}\n        />\n      </div>\n\n      <div>\n        <h1>\n          {contact.first || contact.last ? (\n            <>\n              {contact.first} {contact.last}\n            </>\n          ) : (\n            <i>No Name</i>\n          )}{\" \"}\n          <Favorite contact={contact} />\n        </h1>\n\n        {contact.twitter ? (\n          <p>\n            <a\n              href={`https://twitter.com/${contact.twitter}`}\n            >\n              {contact.twitter}\n            </a>\n          </p>\n        ) : null}\n\n        {contact.notes ? <p>{contact.notes}</p> : null}\n\n        <div>\n          <Form action=\"edit\">\n            <button type=\"submit\">Edit</button>\n          </Form>\n\n          <Form\n            action=\"destroy\"\n            method=\"post\"\n            onSubmit={(event) => {\n              const response = confirm(\n                \"Please confirm you want to delete this record.\"\n              );\n              if (!response) {\n                event.preventDefault();\n              }\n            }}\n          >\n            <button type=\"submit\">Delete</button>\n          </Form>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nconst Favorite: FunctionComponent<{\n  contact: Pick<ContactRecord, \"favorite\">;\n}> = ({ contact }) => {\n  const favorite = contact.favorite;\n\n  return (\n    <Form method=\"post\">\n      <button\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n      >\n        {favorite ? \"\u2605\" : \"\u2606\"}\n      </button>\n    </Form>\n  );\n};\n```\n\nNow if we click one of the links or visit `/contacts/1` we get ... nothing new?\n\n![contact route with blank main content](/docs-images/contacts/05.webp)\n\n## Nested Routes and Outlets\n\nSince Remix is built on top of React Router, it supports nested routing. In order for child routes to render inside parent layouts, we need to render an [`Outlet`](../components/outlet) in the parent. Let's fix it, open up `app/root.tsx` and render an outlet inside.\n\n\ud83d\udc49 **Render an [`<Outlet />`](../components/outlet)**\n\n```\n// existing imports\nimport {\n  Form,\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from \"@remix-run/react\";\n\n// existing imports & code\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      {/* other elements */}\n      <body>\n        <div id=\"sidebar\">{/* other elements */}</div>\n        <div id=\"detail\">\n          <Outlet />\n        </div>\n        {/* other elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nNow the child route should be rendered through the outlet.\n\n![contact route with the main content](/docs-images/contacts/06.webp)\n\n## Client Side Routing\n\nYou may or may not have noticed, but when we click the links in the sidebar, the browser is doing a full document request for the next URL instead of client side routing.\n\nClient side routing allows our app to update the URL without requesting another document from the server. Instead, the app can immediately render a new UI. Let's make it happen with [`<Link>`](../components/link).\n\n\ud83d\udc49 **Change the sidebar `<a href>` to `<Link to>`**\n\n```\n// existing imports\nimport {\n  Form,\n  Link,\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n} from \"@remix-run/react\";\n\n// existing imports and exports\n\nexport default function App() {\n  return (\n    <html lang=\"en\">\n      {/* other elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* other elements */}\n          <nav>\n            <ul>\n              <li>\n                <Link to={`/contacts/1`}>Your Name</Link>\n              </li>\n              <li>\n                <Link to={`/contacts/2`}>Your Friend</Link>\n              </li>\n            </ul>\n          </nav>\n        </div>\n        {/* other elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nYou can open the network tab in the browser devtools to see that it's not requesting documents anymore.\n\n## Loading Data\n\nURL segments, layouts, and data are more often than not coupled (tripled?) together. We can see it in this app already:\n\n| URL Segment | Component | Data |\n| --- | --- | --- |\n| / | `<Root>` | list of contacts |\n| contacts/:contactId | `<Contact>` | individual contact |\n\nBecause of this natural coupling, Remix has data conventions to get data into your route components easily.\n\nThere are two APIs we'll be using to load data, [`loader`](../route/loader) and [`useLoaderData`](../hooks/use-loader-data). First we'll create and export a `loader` function in the root route and then render the data.\n\n\ud83d\udc49 **Export a `loader` function from `app/root.tsx` and render the data**\n\nThe following code has a type error in it, we'll fix it in the next section\n\n```\n// existing imports\nimport {\n  Form,\n  Link,\n  Links,\n  Meta,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData,\n} from \"@remix-run/react\";\n\n// existing imports\nimport { getContacts } from \"./data\";\n\n// existing exports\n\nexport const loader = async () => {\n  const contacts = await getContacts();\n  return { contacts };\n};\n\nexport default function App() {\n  const { contacts } = useLoaderData();\n\n  return (\n    <html lang=\"en\">\n      {/* other elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* other elements */}\n          <nav>\n            {contacts.length ? (\n              <ul>\n                {contacts.map((contact) => (\n                  <li key={contact.id}>\n                    <Link to={`contacts/${contact.id}`}>\n                      {contact.first || contact.last ? (\n                        <>\n                          {contact.first} {contact.last}\n                        </>\n                      ) : (\n                        <i>No Name</i>\n                      )}{\" \"}\n                      {contact.favorite ? (\n                        <span>\u2605</span>\n                      ) : null}\n                    </Link>\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p>\n                <i>No contacts</i>\n              </p>\n            )}\n          </nav>\n        </div>\n        {/* other elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nThat's it! Remix will now automatically keep that data in sync with your UI. The sidebar should now look like this:\n\n![](/docs-images/contacts/07.webp)\n\n## Type Inference\n\nYou may have noticed TypeScript complaining about the `contact` type inside the map. We can add a quick annotation to get type inference about our data with `typeof loader`:\n\n```\n// existing imports and exports\n\nexport default function App() {\n  const { contacts } = useLoaderData<typeof loader>();\n\n  // existing code\n}\n```\n\n## URL Params in Loaders\n\n\ud83d\udc49 **Click on one of the sidebar links**\n\nWe should be seeing our old static contact page again, with one difference: the URL now has a real ID for the record.\n\n![](/docs-images/contacts/08.webp)\n\nRemember the `$contactId` part of the file name at `app/routes/contacts.$contactId.tsx`? These dynamic segments will match dynamic (changing) values in that position of the URL. We call these values in the URL \"URL Params\", or just \"params\" for short.\n\nThese [`params`](../route/loader#params) are passed to the loader with keys that match the dynamic segment. For example, our segment is named `$contactId` so the value will be passed as `params.contactId`.\n\nThese params are most often used to find a record by ID. Let's try it out.\n\n\ud83d\udc49 **Add a `loader` function to the contact page and access data with `useLoaderData`**\n\nThe following code has type errors in it, we'll fix them in the next section\n\n```\nimport { Form, useLoaderData } from \"@remix-run/react\";\n// existing imports\n\nimport { getContact } from \"../data\";\n\nexport const loader = async ({ params }) => {\n  const contact = await getContact(params.contactId);\n  return { contact };\n};\n\nexport default function Contact() {\n  const { contact } = useLoaderData<typeof loader>();\n\n  // existing code\n}\n\n// existing code\n```\n\n![](/docs-images/contacts/10.webp)\n\n## Validating Params and Throwing Responses\n\nTypeScript is very upset with us, let's make it happy and see what that forces us to consider:\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\";\n// existing imports\nimport invariant from \"tiny-invariant\";\n\n// existing imports\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const contact = await getContact(params.contactId);\n  return { contact };\n};\n\n// existing code\n```\n\nThe first problem this highlights is we might have gotten the param's name wrong between the file name and the code (maybe you changed the name of the file!). Invariant is a handy function for throwing an error with a custom message when you anticipated a potential issue with your code.\n\nNext, the `useLoaderData<typeof loader>()` now knows that we got a contact or `null` (maybe there is no contact with that ID). This potential `null` is cumbersome for our component code, and the TS errors are flying around still.\n\nWe could account for the possibility of the contact being not found in component code, but the webby thing to do is send a proper 404. We can do that in the loader and solve all of our problems at once.\n\n```\n// existing imports\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const contact = await getContact(params.contactId);\n  if (!contact) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n  return { contact };\n};\n\n// existing code\n```\n\nNow, if the user isn't found, code execution down this path stops and Remix renders the error path instead. Components in Remix can focus only on the happy path \ud83d\ude01\n\n## Data Mutations\n\nWe'll create our first contact in a second, but first let's talk about HTML.\n\nRemix emulates HTML Form navigation as the data mutation primitive, which used to be the only way prior to the JavaScript cambrian explosion. Don't be fooled by the simplicity! Forms in Remix give you the UX capabilities of client-rendered apps with the simplicity of the \"old school\" web model.\n\nWhile unfamiliar to some web developers, HTML `form`s actually cause a navigation in the browser, just like clicking a link. The only difference is in the request: links can only change the URL while `form`s can also change the request method (`GET` vs. `POST`) and the request body (`POST` form data).\n\nWithout client side routing, the browser will serialize the `form`'s data automatically and send it to the server as the request body for `POST`, and as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) for `GET`. Remix does the same thing, except instead of sending the request to the server, it uses client side routing and sends it to the route's [`action`](../route/action) function.\n\nWe can test this out by clicking the \"New\" button in our app.\n\n![](/docs-images/contacts/09.webp)\n\nRemix sends a 405 because there is no code on the server to handle this form navigation.\n\n## Creating Contacts\n\nWe'll create new contacts by exporting an `action` function in our root route. When the user clicks the \"new\" button, the form will `POST` to the root route action.\n\n\ud83d\udc49 **Export an `action` function from `app/root.tsx`**\n\n```\n// existing imports\n\nimport { createEmptyContact, getContacts } from \"./data\";\n\nexport const action = async () => {\n  const contact = await createEmptyContact();\n  return { contact };\n};\n\n// existing code\n```\n\nThat's it! Go ahead and click the \"New\" button, and you should see a new record pop into the list \ud83e\udd73\n\n![](/docs-images/contacts/11.webp)\n\nThe `createEmptyContact` method just creates an empty contact with no name or data or anything. But it does still create a record, promise!\n\n> \ud83e\uddd0 Wait a sec ... How did the sidebar update? Where did we call the `action` function? Where's the code to re-fetch the data? Where are `useState`, `onSubmit` and `useEffect`?!\n\nThis is where the \"old school web\" programming model shows up. [`<Form>`](../components/form) prevents the browser from sending the request to the server and sends it to your route's `action` function instead with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch).\n\nIn web semantics, a `POST` usually means some data is changing. By convention, Remix uses this as a hint to automatically revalidate the data on the page after the `action` finishes.\n\nIn fact, since it's all just HTML and HTTP, you could disable JavaScript and the whole thing will still work. Instead of Remix serializing the form and making a [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) request to your server, the browser will serialize the form and make a document request. From there Remix will render the page server side and send it down. It's the same UI in the end either way.\n\nWe'll keep JavaScript around, though, because we're going to make a better user experience than spinning favicons and static documents.\n\n## Updating Data\n\nLet's add a way to fill the information for our new record.\n\nJust like creating data, you update data with [`<Form>`](../components/form). Let's make a new route at `app/routes/contacts.$contactId_.edit.tsx`.\n\n\ud83d\udc49 **Create the edit component**\n\n```\ntouch app/routes/contacts.\\$contactId_.edit.tsx\n```\n\nNote the weird `_` in `$contactId_`. By default, routes will automatically nest inside routes with the same prefixed name. Adding a trailing `_` tells the route to **not** nest inside `app/routes/contacts.$contactId.tsx`. Read more in the [Route File Naming](../file-conventions/routes) guide.\n\n\ud83d\udc49 **Add the edit page UI**\n\nNothing we haven't seen before, feel free to copy/paste:\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\";\nimport { Form, useLoaderData } from \"@remix-run/react\";\nimport invariant from \"tiny-invariant\";\n\nimport { getContact } from \"../data\";\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const contact = await getContact(params.contactId);\n  if (!contact) {\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n  return { contact };\n};\n\nexport default function EditContact() {\n  const { contact } = useLoaderData<typeof loader>();\n\n  return (\n    <Form key={contact.id} id=\"contact-form\" method=\"post\">\n      <p>\n        <span>Name</span>\n        <input\n          aria-label=\"First name\"\n          defaultValue={contact.first}\n          name=\"first\"\n          placeholder=\"First\"\n          type=\"text\"\n        />\n        <input\n          aria-label=\"Last name\"\n          defaultValue={contact.last}\n          name=\"last\"\n          placeholder=\"Last\"\n          type=\"text\"\n        />\n      </p>\n      <label>\n        <span>Twitter</span>\n        <input\n          defaultValue={contact.twitter}\n          name=\"twitter\"\n          placeholder=\"@jack\"\n          type=\"text\"\n        />\n      </label>\n      <label>\n        <span>Avatar URL</span>\n        <input\n          aria-label=\"Avatar URL\"\n          defaultValue={contact.avatar}\n          name=\"avatar\"\n          placeholder=\"https://example.com/avatar.jpg\"\n          type=\"text\"\n        />\n      </label>\n      <label>\n        <span>Notes</span>\n        <textarea\n          defaultValue={contact.notes}\n          name=\"notes\"\n          rows={6}\n        />\n      </label>\n      <p>\n        <button type=\"submit\">Save</button>\n        <button type=\"button\">Cancel</button>\n      </p>\n    </Form>\n  );\n}\n```\n\nNow click on your new record, then click the \"Edit\" button. We should see the new route.\n\n![](/docs-images/contacts/12.webp)\n\n## Updating Contacts with `FormData`\n\nThe edit route we just created already renders a `form`. All we need to do is add the `action` function. Remix will serialize the `form`, `POST` it with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch), and automatically revalidate all the data.\n\n\ud83d\udc49 **Add an `action` function to the edit route**\n\n```\nimport type {\n  ActionFunctionArgs,\n  LoaderFunctionArgs,\n} from \"@remix-run/node\";\nimport { redirect } from \"@remix-run/node\";\n// existing imports\n\nimport { getContact, updateContact } from \"../data\";\n\nexport const action = async ({\n  params,\n  request,\n}: ActionFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  return redirect(`/contacts/${params.contactId}`);\n};\n\n// existing code\n```\n\nFill out the form, hit save, and you should see something like this! (Except easier on the eyes and maybe less hairy.)\n\n![](/docs-images/contacts/13.webp)\n\n## Mutation Discussion\n\n> \ud83d\ude11 It worked, but I have no idea what is going on here...\n\nLet's dig in a bit...\n\nOpen up `contacts.$contactId_.edit.tsx` and look at the `form` elements. Notice how they each have a name:\n\n```\n<input\n  aria-label=\"First name\"\n  defaultValue={contact.first}\n  name=\"first\"\n  placeholder=\"First\"\n  type=\"text\"\n/>\n```\n\nWithout JavaScript, when a form is submitted, the browser will create [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) and set it as the body of the request when it sends it to the server. As mentioned before, Remix prevents that and emulates the browser by sending the request to your `action` function with [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) instead, including the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).\n\nEach field in the `form` is accessible with `formData.get(name)`. For example, given the input field from above, you could access the first and last names like this:\n\n```\nexport const action = async ({\n  params,\n  request,\n}: ActionFunctionArgs) => {\n  const formData = await request.formData();\n  const firstName = formData.get(\"first\");\n  const lastName = formData.get(\"last\");\n  // ...\n};\n```\n\nSince we have a handful of form fields, we used [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) to collect them all into an object, which is exactly what our `updateContact` function wants.\n\n```\nconst updates = Object.fromEntries(formData);\nupdates.first; // \"Some\"\nupdates.last; // \"Name\"\n```\n\nAside from the `action` function, Remix provides none of these APIs we're discussing: [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request), [`request.formData`](https://developer.mozilla.org/en-US/docs/Web/API/Request/formData), [`Object.fromEntries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries) are all provided by the web platform.\n\nAfter we finished the `action`, note the [`redirect`](../utils/redirect) at the end:\n\n```\nexport const action = async ({\n  params,\n  request,\n}: ActionFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const formData = await request.formData();\n  const updates = Object.fromEntries(formData);\n  await updateContact(params.contactId, updates);\n  return redirect(`/contacts/${params.contactId}`);\n};\n```\n\n`action` and `loader` functions can both [return a `Response`](../route/loader#returning-response-instances) (makes sense, since they received a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)!). The [`redirect`](../utils/redirect) helper just makes it easier to return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) that tells the app to change locations.\n\nWithout client side routing, if a server redirected after a `POST` request, the new page would fetch the latest data and render. As we learned before, Remix emulates this model and automatically revalidates the data on the page after the `action` call. That's why the sidebar automatically updates when we save the form. The extra revalidation code doesn't exist without client side routing, so it doesn't need to exist with client side routing in Remix either!\n\nOne last thing. Without JavaScript, the [`redirect`](../utils/redirect) would be a normal redirect. However, with JavaScript it's a client-side redirect, so the user doesn't lose client state like scroll positions or component state.\n\n## Redirecting new records to the edit page\n\nNow that we know how to redirect, let's update the action that creates new contacts to redirect to the edit page:\n\n\ud83d\udc49 **Redirect to the new record's edit page**\n\n```\n// existing imports\nimport { redirect } from \"@remix-run/node\";\n// existing imports\n\nexport const action = async () => {\n  const contact = await createEmptyContact();\n  return redirect(`/contacts/${contact.id}/edit`);\n};\n\n// existing code\n```\n\nNow when we click \"New\", we should end up on the edit page:\n\n![](/docs-images/contacts/14.webp)\n\n## Active Link Styling\n\nNow that we have a bunch of records, it's not clear which one we're looking at in the sidebar. We can use [`NavLink`](../components/nav-link) to fix this.\n\n\ud83d\udc49 **Replace `<Link>` with `<NavLink>` in the sidebar**\n\n```\n// existing imports\nimport {\n  Form,\n  Links,\n  Meta,\n  NavLink,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData,\n} from \"@remix-run/react\";\n\n// existing imports and exports\n\nexport default function App() {\n  const { contacts } = useLoaderData<typeof loader>();\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <ul>\n            {contacts.map((contact) => (\n              <li key={contact.id}>\n                <NavLink\n                  className={({ isActive, isPending }) =>\n                    isActive\n                      ? \"active\"\n                      : isPending\n                      ? \"pending\"\n                      : \"\"\n                  }\n                  to={`contacts/${contact.id}`}\n                >\n                  {/* existing elements */}\n                </NavLink>\n              </li>\n            ))}\n          </ul>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nNote that we are passing a function to `className`. When the user is at the URL that matches `<NavLink to>`, then `isActive` will be true. When it's *about* to be active (the data is still loading) then `isPending` will be true. This allows us to easily indicate where the user is and also provide immediate feedback when links are clicked, but data needs to be loaded.\n\n![](/docs-images/contacts/15.webp)\n\n## Global Pending UI\n\nAs the user navigates the app, Remix will *leave the old page up* as data is loading for the next page. You may have noticed the app feels a little unresponsive as you click between the list. Let's provide the user with some feedback so the app doesn't feel unresponsive.\n\nRemix is managing all the states behind the scenes and reveals the pieces you need to build dynamic web apps. In this case, we'll use the [`useNavigation`](../hooks/use-navigation) hook.\n\n\ud83d\udc49 **Use `useNavigation` to add global pending UI**\n\n```\n// existing imports\nimport {\n  Form,\n  Links,\n  Meta,\n  NavLink,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData,\n  useNavigation,\n} from \"@remix-run/react\";\n\n// existing imports and exports\n\nexport default function App() {\n  const { contacts } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        {/* existing elements */}\n        <div\n          className={\n            navigation.state === \"loading\" ? \"loading\" : \"\"\n          }\n          id=\"detail\"\n        >\n          <Outlet />\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\n[`useNavigation`](../hooks/use-navigation) returns the current navigation state: it can be one of `\"idle\"`, `\"loading\"` or `\"submitting\"`.\n\nIn our case, we add a `\"loading\"` class to the main part of the app if we're not idle. The CSS then adds a nice fade after a short delay (to avoid flickering the UI for fast loads). You could do anything you want, though, like show a spinner or loading bar across the top.\n\n![](/docs-images/contacts/16.webp)\n\n## Deleting Records\n\nIf we review code in the contact route, we can find the delete button looks like this:\n\n```\n<Form\n  action=\"destroy\"\n  method=\"post\"\n  onSubmit={(event) => {\n    const response = confirm(\n      \"Please confirm you want to delete this record.\"\n    );\n    if (!response) {\n      event.preventDefault();\n    }\n  }}\n>\n  <button type=\"submit\">Delete</button>\n</Form>\n```\n\nNote the `action` points to `\"destroy\"`. Like `<Link to>`, `<Form action>` can take a *relative* value. Since the form is rendered in `contacts.$contactId.tsx`, then a relative action with `destroy` will submit the form to `contacts.$contactId.destroy` when clicked.\n\nAt this point you should know everything you need to know to make the delete button work. Maybe give it a try before moving on? You'll need:\n\n1. A new route\n2. An `action` at that route\n3. `deleteContact` from `app/data.ts`\n4. `redirect` to somewhere after\n\n\ud83d\udc49 **Create the \"destroy\" route module**\n\n```\ntouch app/routes/contacts.\\$contactId_.destroy.tsx\n```\n\n\ud83d\udc49 **Add the destroy action**\n\n```\nimport type { ActionFunctionArgs } from \"@remix-run/node\";\nimport { redirect } from \"@remix-run/node\";\nimport invariant from \"tiny-invariant\";\n\nimport { deleteContact } from \"../data\";\n\nexport const action = async ({\n  params,\n}: ActionFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  await deleteContact(params.contactId);\n  return redirect(\"/\");\n};\n```\n\nAlright, navigate to a record and click the \"Delete\" button. It works!\n\n> \ud83d\ude05 I'm still confused why this all works\n\nWhen the user clicks the submit button:\n\n1. `<Form>` prevents the default browser behavior of sending a new document `POST` request to the server, but instead emulates the browser by creating a `POST` request with client side routing and [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch)\n2. The `<Form action=\"destroy\">` matches the new route at `contacts.$contactId_.destroy.tsx` and sends it the request\n3. After the `action` redirects, Remix calls all the `loader`s for the data on the page to get the latest values (this is \"revalidation\"). `useLoaderData` returns new values and causes the components to update!\n\nAdd a `Form`, add an `action`, Remix does the rest.\n\n## Index Routes\n\nWhen we load up the app, you'll notice a big blank page on the right side of our list.\n\n![](/docs-images/contacts/17.webp)\n\nWhen a route has children, and you're at the parent route's path, the `<Outlet>` has nothing to render because no children match. You can think of index routes as the default child route to fill in that space.\n\n\ud83d\udc49 **Create an index route for the root route**\n\n```\ntouch app/routes/_index.tsx\n```\n\n\ud83d\udc49 **Fill in the index component's elements**\n\nFeel free to copy/paste, nothing special here.\n\n```\nexport default function Index() {\n  return (\n    <p id=\"index-page\">\n      This is a demo for Remix.\n      <br />\n      Check out{\" \"}\n      <a href=\"https://remix.run\">the docs at remix.run</a>.\n    </p>\n  );\n}\n```\n\nThe route name `_index` is special. It tells Remix to match and render this route when the user is at the parent route's exact path, so there are no other child routes to render in the `<Outlet />`.\n\n![](/docs-images/contacts/18.webp)\n\nVoil\u00e0! No more blank space. It's common to put dashboards, stats, feeds, etc. at index routes. They can participate in data loading as well.\n\n## Cancel Button\n\nOn the edit page we've got a cancel button that doesn't do anything yet. We'd like it to do the same thing as the browser's back button.\n\nWe'll need a click handler on the button as well as [`useNavigate`](../hooks/use-navigate).\n\n\ud83d\udc49 **Add the cancel button click handler with `useNavigate`**\n\n```\n// existing imports\nimport {\n  Form,\n  useLoaderData,\n  useNavigate,\n} from \"@remix-run/react\";\n// existing imports and exports\n\nexport default function EditContact() {\n  const { contact } = useLoaderData<typeof loader>();\n  const navigate = useNavigate();\n\n  return (\n    <Form key={contact.id} id=\"contact-form\" method=\"post\">\n      {/* existing elements */}\n      <p>\n        <button type=\"submit\">Save</button>\n        <button onClick={() => navigate(-1)} type=\"button\">\n          Cancel\n        </button>\n      </p>\n    </Form>\n  );\n}\n```\n\nNow when the user clicks \"Cancel\", they'll be sent back one entry in the browser's history.\n\n> \ud83e\uddd0 Why is there no `event.preventDefault()` on the button?\n\nA `<button type=\"button\">`, while seemingly redundant, is the HTML way of preventing a button from submitting its form.\n\nTwo more features to go. We're on the home stretch!\n\n## `URLSearchParams` and `GET` Submissions\n\nAll of our interactive UI so far have been either links that change the URL or `form`s that post data to `action` functions. The search field is interesting because it's a mix of both: it's a `form`, but it only changes the URL, it doesn't change data.\n\nLet's see what happens when we submit the search form:\n\n\ud83d\udc49 **Type a name into the search field and hit the enter key**\n\nNote the browser's URL now contains your query in the URL as [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):\n\n```\nhttp://localhost:5173/?q=ryan\n```\n\nSince it's not `<Form method=\"post\">`, Remix emulates the browser by serializing the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) into the [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) instead of the request body.\n\n`loader` functions have access to the search params from the `request`. Let's use it to filter the list:\n\n\ud83d\udc49 **Filter the list if there are `URLSearchParams`**\n\n```\nimport type {\n  LinksFunction,\n  LoaderFunctionArgs,\n} from \"@remix-run/node\";\n\n// existing imports and exports\n\nexport const loader = async ({\n  request,\n}: LoaderFunctionArgs) => {\n  const url = new URL(request.url);\n  const q = url.searchParams.get(\"q\");\n  const contacts = await getContacts(q);\n  return { contacts };\n};\n\n// existing code\n```\n\n![](/docs-images/contacts/19.webp)\n\nBecause this is a `GET`, not a `POST`, Remix *does not* call the `action` function. Submitting a `GET` `form` is the same as clicking a link: only the URL changes.\n\nThis also means it's a normal page navigation. You can click the back button to get back to where you were.\n\n## Synchronizing URLs to Form State\n\nThere are a couple of UX issues here that we can take care of quickly.\n\n1. If you click back after a search, the form field still has the value you entered even though the list is no longer filtered.\n2. If you refresh the page after searching, the form field no longer has the value in it, even though the list is filtered\n\nIn other words, the URL and our input's state are out of sync.\n\nLet's solve (2) first and start the input with the value from the URL.\n\n\ud83d\udc49 **Return `q` from your `loader`, set it as the input's default value**\n\n```\n// existing imports and exports\n\nexport const loader = async ({\n  request,\n}: LoaderFunctionArgs) => {\n  const url = new URL(request.url);\n  const q = url.searchParams.get(\"q\");\n  const contacts = await getContacts(q);\n  return { contacts, q };\n};\n\nexport default function App() {\n  const { contacts, q } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <div>\n            <Form id=\"search-form\" role=\"search\">\n              <input\n                aria-label=\"Search contacts\"\n                defaultValue={q || \"\"}\n                id=\"q\"\n                name=\"q\"\n                placeholder=\"Search\"\n                type=\"search\"\n              />\n              {/* existing elements */}\n            </Form>\n            {/* existing elements */}\n          </div>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nThe input field will show the query if you refresh the page after a search now.\n\nNow for problem (1), clicking the back button and updating the input. We can bring in `useEffect` from React to manipulate the input's value in the DOM directly.\n\n\ud83d\udc49 **Synchronize input value with the `URLSearchParams`**\n\n```\n// existing imports\nimport { useEffect } from \"react\";\n\n// existing imports and exports\n\nexport default function App() {\n  const { contacts, q } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n\n  useEffect(() => {\n    const searchField = document.getElementById(\"q\");\n    if (searchField instanceof HTMLInputElement) {\n      searchField.value = q || \"\";\n    }\n  }, [q]);\n\n  // existing code\n}\n```\n\n> \ud83e\udd14 Shouldn't you use a controlled component and React State for this?\n\nYou could certainly do this as a controlled component. You will have more synchronization points, but it's up to you.\n\nExpand this to see what it would look like\n\n```\n// We no longer need useEffect\nimport { useState } from \"react\";\n\n// existing imports and exports\n\nexport default function App() {\n  const { contacts, q } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n  // the query now needs to be kept in state\n  const [prevQ, setPrevQ] = useState(q);\n  const [query, setQuery] = useState(q || \"\");\n\n  // We can avoid using `useEffect` to synchronize the query\n  // by using a separate piece of state to store the previous\n  // value\n  if (q !== prevQ) {\n    setPrevQ(q);\n    setQuery(q || \"\");\n  }\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <div>\n            <Form id=\"search-form\" role=\"search\">\n              <input\n                aria-label=\"Search contacts\"\n                id=\"q\"\n                name=\"q\"\n                // synchronize user's input to component state\n                onChange={(event) =>\n                  setQuery(event.currentTarget.value)\n                }\n                placeholder=\"Search\"\n                type=\"search\"\n                // switched to `value` from `defaultValue`\n                value={query}\n              />\n              {/* existing elements */}\n            </Form>\n            {/* existing elements */}\n          </div>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nAlright, you should now be able to click the back/forward/refresh buttons, and the input's value should be in sync with the URL and results.\n\n## Submitting `Form`'s `onChange`\n\nWe've got a product decision to make here. Sometimes you want the user to submit the `form` to filter some results, other times you want to filter as the user types. We've already implemented the first, so let's see what it's like for the second.\n\nWe've seen `useNavigate` already, we'll use its cousin, [`useSubmit`](../hooks/use-submit), for this.\n\n```\n// existing imports\nimport {\n  Form,\n  Links,\n  Meta,\n  NavLink,\n  Outlet,\n  Scripts,\n  ScrollRestoration,\n  useLoaderData,\n  useNavigation,\n  useSubmit,\n} from \"@remix-run/react\";\n// existing imports and exports\n\nexport default function App() {\n  const { contacts, q } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n  const submit = useSubmit();\n\n  // existing code\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <div>\n            <Form\n              id=\"search-form\"\n              onChange={(event) =>\n                submit(event.currentTarget)\n              }\n              role=\"search\"\n            >\n              {/* existing elements */}\n            </Form>\n            {/* existing elements */}\n          </div>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nAs you type, the `form` is automatically submitted now!\n\nNote the argument to [`submit`](../hooks/use-submit). The `submit` function will serialize and submit any form you pass to it. We're passing in `event.currentTarget`. The `currentTarget` is the DOM node the event is attached to (the `form`).\n\n## Adding Search Spinner\n\nIn a production app, it's likely this search will be looking for records in a database that is too large to send all at once and filter client side. That's why this demo has some faked network latency.\n\nWithout any loading indicator, the search feels kinda sluggish. Even if we could make our database faster, we'll always have the user's network latency in the way and out of our control.\n\nFor a better user experience, let's add some immediate UI feedback for the search. We'll use [`useNavigation`](../hooks/use-navigation) again.\n\n\ud83d\udc49 **Add a variable to know if we're searching**\n\n```\n// existing imports and exports\n\nexport default function App() {\n  const { contacts, q } = useLoaderData<typeof loader>();\n  const navigation = useNavigation();\n  const submit = useSubmit();\n  const searching =\n    navigation.location &&\n    new URLSearchParams(navigation.location.search).has(\n      \"q\"\n    );\n\n  // existing code\n}\n```\n\nWhen nothing is happening, `navigation.location` will be `undefined`, but when the user navigates it will be populated with the next location while data loads. Then we check if they're searching with `location.search`.\n\n\ud83d\udc49 **Add classes to search form elements using the new `searching` state**\n\n```\n// existing imports and exports\n\nexport default function App() {\n  // existing code\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <div>\n            <Form\n              id=\"search-form\"\n              onChange={(event) =>\n                submit(event.currentTarget)\n              }\n              role=\"search\"\n            >\n              <input\n                aria-label=\"Search contacts\"\n                className={searching ? \"loading\" : \"\"}\n                defaultValue={q || \"\"}\n                id=\"q\"\n                name=\"q\"\n                placeholder=\"Search\"\n                type=\"search\"\n              />\n              <div\n                aria-hidden\n                hidden={!searching}\n                id=\"search-spinner\"\n              />\n            </Form>\n            {/* existing elements */}\n          </div>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nBonus points, avoid fading out the main screen when searching:\n\n```\n// existing imports and exports\n\nexport default function App() {\n  // existing code\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        {/* existing elements */}\n        <div\n          className={\n            navigation.state === \"loading\" && !searching\n              ? \"loading\"\n              : \"\"\n          }\n          id=\"detail\"\n        >\n          <Outlet />\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nYou should now have a nice spinner on the left side of the search input.\n\n![](/docs-images/contacts/20.webp)\n\n## Managing the History Stack\n\nSince the form is submitted for every keystroke, typing the characters \"alex\" and then deleting them with backspace results in a huge history stack \ud83d\ude02. We definitely don't want this:\n\n![](/docs-images/contacts/21.webp)\n\nWe can avoid this by *replacing* the current entry in the history stack with the next page instead of pushing into it.\n\n\ud83d\udc49 **Use `replace` in `submit`**\n\n```\n// existing imports and exports\n\nexport default function App() {\n  // existing code\n\n  return (\n    <html lang=\"en\">\n      {/* existing elements */}\n      <body>\n        <div id=\"sidebar\">\n          {/* existing elements */}\n          <div>\n            <Form\n              id=\"search-form\"\n              onChange={(event) => {\n                const isFirstSearch = q === null;\n                submit(event.currentTarget, {\n                  replace: !isFirstSearch,\n                });\n              }}\n              role=\"search\"\n            >\n              {/* existing elements */}\n            </Form>\n            {/* existing elements */}\n          </div>\n          {/* existing elements */}\n        </div>\n        {/* existing elements */}\n      </body>\n    </html>\n  );\n}\n```\n\nAfter a quick check if this is the first search or not, we decide to replace it. Now the first search will add a new entry, but every keystroke after that will replace the current entry. Instead of clicking back seven times to remove the search, users only have to click back once.\n\n## `Form`s Without Navigation\n\nSo far all of our forms have changed the URL. While these user flows are common, it's equally common to want to submit a form *without* causing a navigation.\n\nFor these cases, we have [`useFetcher`](../hooks/use-fetcher). It allows us to communicate with `action`s and `loader`s without causing a navigation.\n\nThe \u2605 button on the contact page makes sense for this. We aren't creating or deleting a new record, and we don't want to change pages. We simply want to change the data on the page we're looking at.\n\n\ud83d\udc49 **Change the `<Favorite>` form to a fetcher form**\n\n```\n// existing imports\nimport {\n  Form,\n  useFetcher,\n  useLoaderData,\n} from \"@remix-run/react\";\n// existing imports and exports\n\n// existing code\n\nconst Favorite: FunctionComponent<{\n  contact: Pick<ContactRecord, \"favorite\">;\n}> = ({ contact }) => {\n  const fetcher = useFetcher();\n  const favorite = contact.favorite;\n\n  return (\n    <fetcher.Form method=\"post\">\n      <button\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n      >\n        {favorite ? \"\u2605\" : \"\u2606\"}\n      </button>\n    </fetcher.Form>\n  );\n};\n```\n\nThis form will no longer cause a navigation, but simply fetch to the `action`. Speaking of which ... this won't work until we create the `action`.\n\n\ud83d\udc49 **Create the `action`**\n\n```\nimport type {\n  ActionFunctionArgs,\n  LoaderFunctionArgs,\n} from \"@remix-run/node\";\n// existing imports\n\nimport { getContact, updateContact } from \"../data\";\n// existing imports\n\nexport const action = async ({\n  params,\n  request,\n}: ActionFunctionArgs) => {\n  invariant(params.contactId, \"Missing contactId param\");\n  const formData = await request.formData();\n  return updateContact(params.contactId, {\n    favorite: formData.get(\"favorite\") === \"true\",\n  });\n};\n\n// existing code\n```\n\nAlright, we're ready to click the star next to the user's name!\n\n![](/docs-images/contacts/22.webp)\n\nCheck that out, both stars automatically update. Our new `<fetcher.Form method=\"post\">` works almost exactly like the `<Form>` we've been using: it calls the action and then all data is revalidated automatically \u2014 even your errors will be caught the same way.\n\nThere is one key difference, though, it's not a navigation, so the URL doesn't change, and the history stack is unaffected.\n\n## Optimistic UI\n\nYou probably noticed the app felt kind of unresponsive when we clicked the favorite button from the last section. Once again, we added some network latency because you're going to have it in the real world.\n\nTo give the user some feedback, we could put the star into a loading state with [`fetcher.state`](../hooks/use-fetcher#fetcherstate) (a lot like `navigation.state` from before), but we can do something even better this time. We can use a strategy called \"Optimistic UI\".\n\nThe fetcher knows the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) being submitted to the `action`, so it's available to you on `fetcher.formData`. We'll use that to immediately update the star's state, even though the network hasn't finished. If the update eventually fails, the UI will revert to the real data.\n\n\ud83d\udc49 **Read the optimistic value from `fetcher.formData`**\n\n```\n// existing code\n\nconst Favorite: FunctionComponent<{\n  contact: Pick<ContactRecord, \"favorite\">;\n}> = ({ contact }) => {\n  const fetcher = useFetcher();\n  const favorite = fetcher.formData\n    ? fetcher.formData.get(\"favorite\") === \"true\"\n    : contact.favorite;\n\n  return (\n    <fetcher.Form method=\"post\">\n      <button\n        aria-label={\n          favorite\n            ? \"Remove from favorites\"\n            : \"Add to favorites\"\n        }\n        name=\"favorite\"\n        value={favorite ? \"false\" : \"true\"}\n      >\n        {favorite ? \"\u2605\" : \"\u2606\"}\n      </button>\n    </fetcher.Form>\n  );\n};\n```\n\nNow the star *immediately* changes to the new state when you click it.\n\n---\n\nThat's it! Thanks for giving Remix a try. We hope this tutorial gives you a solid start to build great user experiences. There's a lot more you can do, so make sure to check out all the APIs \ud83d\ude00\n\n\u00a9 [Shopify, Inc.](https://remix.run)\n\n\u2022\n\nDocs and examples licensed under [MIT](https://opensource.org/licenses/MIT)\n\n[Edit](https://github.com/remix-run/remix-v2-website/edit/main/data/docs/start/tutorial.md)\n\n![](/assets/icons-CZ8v8NWl.svg)",
  "tags": [
    "remix",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:55:21.997909+00:00",
  "content_length": 44021,
  "content_hash": "1ac87c1bb5deb25f"
}