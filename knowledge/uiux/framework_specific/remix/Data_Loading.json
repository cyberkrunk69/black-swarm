{
  "id": "remix__docs_en_main_guides_data-loading",
  "source_id": "remix",
  "source_name": "Remix Documentation",
  "category": "framework_specific",
  "url": "https://remix.run/docs/en/main/guides/data-loading",
  "title": "Data Loading",
  "content": "Docs\nBlog\nResources\nReact Router v7 has been released.\nView the docs\nDocs\nBlog\nResources\nView code on GitHub\nChat on Discord\nReact Router v7 has been released.\nView the docs\nData Loading\nOn this page\nBasics\nRoute Params\nParam Type Safety\nExternal APIs\nDatabases\nCloudflare KV\nNot Found\nURL Search Params\nData Reloads\nSearch Params in Components\nSearch Params and Controlled Inputs\nRemix Optimizations\nData Libraries\nGotchas\nBasics\nRoute Params\nParam Type Safety\nExternal APIs\nDatabases\nCloudflare KV\nNot Found\nURL Search Params\nData Reloads\nSearch Params in Components\nSearch Params and Controlled Inputs\nRemix Optimizations\nData Libraries\nGotchas\nData Loading\nOne of the primary features of Remix is simplifying interactions with the server to get data into components. When you follow these conventions, Remix can automatically:\nServer render your pages\nBe resilient to network conditions when JavaScript fails to load\nMake optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page\nFetch data, JavaScript modules, CSS, and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI\nEnsure the data in the UI is in sync with the data on the server by revalidating after\nactions\nExcellent scroll restoration on back/forward clicks (even across domains)\nHandle server-side errors with\nerror boundaries\nEnable solid UX for \"Not Found\" and \"Unauthorized\" with\nerror boundaries\nHelp you keep the happy path of your UI happy\nBasics\nEach route module can export a component and a\nloader\n.\nuseLoaderData\nwill provide the loader's data to your component:\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\nconst\nloader\n=\nasync\n()\n=>\n{\nreturn\njson\n([\n{ id: \"\n1\n\", name: \"\nPants\n\" },\n{ id: \"\n2\n\", name: \"\nJacket\n\" },\n]);\n};\nexport\ndefault\nfunction\nProducts\n() {\nconst\nproducts\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\ndiv\n>\n<\nh1\n>Products</\nh1\n>\n{\nproducts\n.\nmap\n((\nproduct\n)\n=>\n(\n<\ndiv\nkey\n=\n{\nproduct\n.\nid\n}\n>\n{\nproduct\n.\nname\n}\n</\ndiv\n>\n))\n}\n</\ndiv\n>\n);\n}\nThe component renders on the server and in the browser. The loader\nonly runs on the server\n. That means our hard-coded products array doesn't get included in the browser bundles, and it's safe to use server-only for APIs and SDKs for things like database, payment processing, content management systems, etc.\nIf your server-side modules end up in client bundles, refer to our guide on\nserver vs. client code execution\n.\nRoute Params\nWhen you name a file with\n$\nlike\napp/routes/users.$userId.tsx\nand\napp/routes/users.$userId.projects.$projectId.tsx\nthe dynamic segments (the ones starting with\n$\n) will be parsed from the URL and passed to your loader on a\nparams\nobject.\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nconsole\n.\nlog\n(\nparams\n.\nuserId\n);\nconsole\n.\nlog\n(\nparams\n.\nprojectId\n);\n};\nGiven the following URLs, the params would be parsed as follows:\nURL\nparams.userId\nparams.projectId\n/users/123/projects/abc\n\"123\"\n\"abc\"\n/users/aec34g/projects/22cba9\n\"aec34g\"\n\"22cba9\"\nThese params are most useful for looking up data:\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nreturn\njson\n(\nawait\nfakeDb\n.\nproject\n.\nfindMany\n({\nwhere: {\nuserId:\nparams\n.\nuserId\n,\nprojectId:\nparams\n.\nprojectId\n,\n},\n})\n);\n};\nParam Type Safety\nBecause these params come from the URL and not your source code, you can't know for sure if they will be defined. That's why the types on the param's keys are\nstring | undefined\n. It's good practice to validate before using them, especially in TypeScript to get type safety. Using\ninvariant\nmakes it easy.\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\ninvariant\nfrom\n\"\ntiny-invariant\n\";\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\ninvariant\n(\nparams\n.\nuserId\n, \"\nExpected params.userId\n\");\ninvariant\n(\nparams\n.\nprojectId\n, \"\nExpected params.projectId\n\");\nparams\n.\nprojectId\n;\n// <-- TypeScript now knows this is a string\n};\nWhile you may be uncomfortable throwing errors like this with\ninvariant\nwhen it fails, remember that in Remix you know the user will end up in the\nerror boundary\nwhere they can recover from the problem instead of a broken UI.\nExternal APIs\nRemix polyfills the\nfetch\nAPI on your server, so it's straightforward to fetch data from existing JSON APIs. Instead of managing state, errors, race conditions, and more yourself, you can do the fetch from your loader (on the server) and let Remix handle the rest.\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\nasync\nfunction\nloader\n() {\nconst\nres\n=\nawait\nfetch\n(\"\nhttps://api.github.com/gists\n\");\nreturn\njson\n(\nawait\nres\n.\njson\n());\n}\nexport\ndefault\nfunction\nGistsRoute\n() {\nconst\ngists\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\nul\n>\n{\ngists\n.\nmap\n((\ngist\n)\n=>\n(\n<\nli\nkey\n=\n{\ngist\n.\nid\n}\n>\n<\na\nhref\n=\n{\ngist\n.\nhtml_url\n}\n>\n{\ngist\n.\nid\n}\n</\na\n>\n</\nli\n>\n))\n}\n</\nul\n>\n);\n}\nThis is great when you already have an API to work with and don't care or need to connect directly to your data source in your Remix app.\nDatabases\nSince Remix runs on your server, you can connect directly to a database in your route modules. For example, you could connect to a Postgres database with\nPrisma\n.\nimport\n{\nPrismaClient\n}\nfrom\n\"\n@prisma/client\n\";\nconst\ndb\n=\nnew\nPrismaClient\n();\nexport\n{\ndb\n};\nAnd then your routes can import it and make queries against it:\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nimport\n{\ndb\n}\nfrom\n\"\n~/db.server\n\";\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nreturn\njson\n(\nawait\ndb\n.\nproduct\n.\nfindMany\n({\nwhere: {\ncategoryId:\nparams\n.\ncategoryId\n,\n},\n})\n);\n};\nexport\ndefault\nfunction\nProductCategory\n() {\nconst\nproducts\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\ndiv\n>\n<\np\n>\n{\nproducts\n.length\n}\nProducts</\np\n>\n{\n/* ... */\n}\n</\ndiv\n>\n);\n}\nIf you are using TypeScript, you can use type inference to use Prisma Client generated types when calling\nuseLoaderData\n. This allows better type safety and intellisense when writing code that uses the loaded data.\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nimport\n{\ndb\n}\nfrom\n\"\n~/db.server\n\";\nasync\nfunction\ngetLoaderData\n(\nproductId\n:\nstring\n) {\nconst\nproduct\n=\nawait\ndb\n.\nproduct\n.\nfindUnique\n({\nwhere: {\nid:\nproductId\n,\n},\nselect: {\nid:\ntrue\n,\nname:\ntrue\n,\nimgSrc:\ntrue\n,\n},\n});\nreturn\nproduct\n;\n}\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nreturn\njson\n(\nawait\ngetLoaderData\n(\nparams\n.\nproductId\n));\n};\nexport\ndefault\nfunction\nProduct\n() {\nconst\nproduct\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\ndiv\n>\n<\np\n>Product\n{\nproduct\n.\nid\n}\n</\np\n>\n{\n/* ... */\n}\n</\ndiv\n>\n);\n}\nCloudflare KV\nIf you picked Cloudflare Pages or Workers as your environment,\nCloudflare Key Value\nstorage allows you to persist data at the edge as if it were a static resource.\nFor Pages, to start with local development, you need to add a\n--kv\nparameter with a name of your namespace to the package.json task, so it would look like this:\n\"dev:wrangler\": \"cross-env NODE_ENV=development wrangler pages dev ./public --kv PRODUCTS_KV\"\nFor the Cloudflare Workers environment you'll need to\ndo some other configuration\n.\nThis enables you to use the\nPRODUCTS_KV\nin a loader context (KV stores are added to loader context automatically by the Cloudflare Pages adapter):\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/cloudflare\n\";\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/cloudflare\n\";\nimport\n{\nuseLoaderData\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\nconst\nloader\n=\nasync\n({\ncontext\n,\nparams\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nreturn\njson\n(\nawait\ncontext\n.\nPRODUCTS_KV\n.\nget\n(\n`\nproduct-\n${\nparams\n.\nproductId\n}`,\n{ type: \"\njson\n\" }\n)\n);\n};\nexport\ndefault\nfunction\nProduct\n() {\nconst\nproduct\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nreturn\n(\n<\ndiv\n>\n<\np\n>Product</\np\n>\n{\nproduct\n.\nname\n}\n</\ndiv\n>\n);\n}\nNot Found\nWhile loading data, it's common for a record to be \"not found\". As soon as you know you can't render the component as expected,\nthrow\na response and Remix will stop executing code in the current loader and switch over to the nearest\nerror boundary\n.\nexport\nconst\nloader\n=\nasync\n({\nparams\n,\nrequest\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nconst\nproduct\n=\nawait\ndb\n.\nproduct\n.\nfindOne\n({\nwhere: { id:\nparams\n.\nproductId\n},\n});\nif\n(\n!\nproduct\n) {\n// we know we can't render the component\n// so throw immediately to stop executing code\n// and show the not found page\nthrow\nnew\nResponse\n(\"\nNot Found\n\", { status:\n404\n});\n}\nconst\ncart\n=\nawait\ngetCart\n(\nrequest\n);\nreturn\njson\n({\nproduct\n,\ninCart:\ncart\n.\nincludes\n(\nproduct\n.\nid\n),\n});\n};\nURL Search Params\nURL Search Params are the portion of the URL after a\n?\n. Other names for this are \"query string\", \"search string\", or \"location search\". You can access the values by creating a URL out of the\nrequest.url\n:\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nexport\nconst\nloader\n=\nasync\n({\nrequest\n,\n}\n:\nLoaderFunctionArgs\n)\n=>\n{\nconst\nurl\n=\nnew\nURL\n(\nrequest\n.\nurl\n);\nconst\nterm\n=\nurl\n.\nsearchParams\n.\nget\n(\"\nterm\n\");\nreturn\njson\n(\nawait\nfakeProductSearch\n(\nterm\n));\n};\nThere are a few web platform types at play here:\nThe\nrequest\nobject has a\nurl\nproperty\nURL constructor\nthat parses the URL string into an object\nurl.searchParams\nis an instance of\nURLSearchParams\n, which is a parsed version of the location search string that makes it easy to read and manipulate the search string\nGiven the following URLs, the search params would be parsed as follows:\nURL\nurl.searchParams.get(\"term\")\n/products?term=stretchy+pants\n\"stretchy pants\"\n/products?term=\n\"\"\n/products\nnull\nData Reloads\nWhen multiple nested routes are rendering and the search params change, all the routes will be reloaded (instead of just the new or changed routes). This is because search params are a cross-cutting concern and could affect any loader. If you would like to prevent some of your routes from reloading in this scenario, use\nshouldRevalidate\n.\nSearch Params in Components\nSometimes you need to read and change the search params from your component instead of your loaders and actions. There are a handful of ways to do this depending on your use case.\nSetting Search Params\nPerhaps the most common way to set search params is letting the user control them with a form:\nexport\ndefault\nfunction\nProductFilters\n() {\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\">\n<\nlabel\nhtmlFor\n=\n\"\nnike\n\">Nike</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nnike\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\"\n/>\n<\nlabel\nhtmlFor\n=\n\"\nadidas\n\">Adidas</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nadidas\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nadidas\n\"\n/>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Update</\nbutton\n>\n</\nForm\n>\n);\n}\nIf the user only has one selected:\nNike\nAdidas\nThen the URL will be\n/products/shoes?brand=nike\nIf the user has both selected:\nNike\nAdidas\nThen the url will be:\n/products/shoes?brand=nike&brand=adidas\nNote that\nbrand\nis repeated in the URL search string since both checkboxes were named\n\"brand\"\n. In your loader you can get access to all of those values with\nsearchParams.getAll\nimport\ntype\n{\nLoaderFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nexport\nasync\nfunction\nloader\n({\nrequest\n,\n}\n:\nLoaderFunctionArgs\n) {\nconst\nurl\n=\nnew\nURL\n(\nrequest\n.\nurl\n);\nconst\nbrands\n=\nurl\n.\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nreturn\njson\n(\nawait\ngetProducts\n({\nbrands\n}));\n}\nLinking to Search Params\nAs the developer, you can control the search params by linking to URLs with search strings in them. The link will replace the current search string in the URL (if there is one) with what is in the link:\n<\nLink\nto\n=\n\"\n?brand=nike\n\">Nike (only)</\nLink\n>\nReading Search Params in Components\nIn addition to reading search params in loaders, you often need access to them in components, too:\nimport\n{\nuseSearchParams\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nbrands\n=\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\">\n<\nlabel\nhtmlFor\n=\n\"\nnike\n\">Nike</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nnike\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\"\ndefaultChecked\n=\n{\nbrands\n.\nincludes\n(\"\nnike\n\")\n}\n/>\n<\nlabel\nhtmlFor\n=\n\"\nadidas\n\">Adidas</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nadidas\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nadidas\n\"\ndefaultChecked\n=\n{\nbrands\n.\nincludes\n(\"\nadidas\n\")\n}\n/>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Update</\nbutton\n>\n</\nForm\n>\n);\n}\nYou might want to auto submit the form on any field change, for that there is\nuseSubmit\n:\nimport\n{\nuseSubmit\n,\nuseSearchParams\n,\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\nsubmit\n=\nuseSubmit\n();\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nbrands\n=\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\"\nonChange\n=\n{\n(\ne\n)\n=>\nsubmit\n(\ne\n.\ncurrentTarget\n)\n}\n>\n{\n/* ... */\n}\n</\nForm\n>\n);\n}\nSetting Search Params Imperatively\nWhile uncommon, you can also set searchParams imperatively at any time for any reason. The use cases here are slim, so slim we couldn't even come up with a good one, but here's a silly example:\nimport\n{\nuseSearchParams\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\n[\nsearchParams\n,\nsetSearchParams\n]\n=\nuseSearchParams\n();\nuseEffect\n(()\n=>\n{\nconst\nid\n=\nsetInterval\n(()\n=>\n{\nsetSearchParams\n({ now:\nDate\n.\nnow\n() });\n},\n1000\n);\nreturn\n()\n=>\nclearInterval\n(\nid\n);\n}, [\nsetSearchParams\n]);\n// ...\n}\nSearch Params and Controlled Inputs\nOften you want to keep some inputs, like checkboxes, in sync with the search params in the URL. This can get a little tricky with React's controlled component concept.\nThis is only needed if the search params can be set in two ways, and we want the inputs to stay in sync with the search params. For example, both the\n<input type=\"checkbox\">\nand the\nLink\ncan change the brand in this component:\nimport\n{\nuseSearchParams\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nbrands\n=\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\">\n<\np\n>\n<\nlabel\nhtmlFor\n=\n\"\nnike\n\">Nike</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nnike\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\"\ndefaultChecked\n=\n{\nbrands\n.\nincludes\n(\"\nnike\n\")\n}\n/>\n<\nLink\nto\n=\n\"\n?brand=nike\n\">(only)</\nLink\n>\n</\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Update</\nbutton\n>\n</\nForm\n>\n);\n}\nIf the user clicks the checkbox and submits the form, the URL updates and the checkbox state changes too. But if the user clicks the link,\nonly the url will update and not the checkbox\n. That's not what we want. You may be familiar with React's controlled components here and think to switch it to\nchecked\ninstead of\ndefaultChecked\n:\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nadidas\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nadidas\n\"\nchecked\n=\n{\nbrands\n.\nincludes\n(\"\nadidas\n\")\n}\n/>\nNow we have the opposite problem: clicking the link updates both the URL and the checkbox state, but\nthe checkbox no longer works\nbecause React prevents the state from changing until the URL that controls it changes--and it never will because we can't change the checkbox and resubmit the form.\nReact wants you to control it with some state, but we want the user to control it until they submit the form, and then we want the URL to control it when it changes. So we're in this \"sorta-controlled\" spot.\nYou have two choices, and what you pick depends on the user experience you want.\nFirst Choice\n: The simplest thing is to auto-submit the form when the user clicks the checkbox:\nimport\n{\nuseSubmit\n,\nuseSearchParams\n,\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\nsubmit\n=\nuseSubmit\n();\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nbrands\n=\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\">\n<\np\n>\n<\nlabel\nhtmlFor\n=\n\"\nnike\n\">Nike</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nnike\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\"\nonChange\n=\n{\n(\ne\n)\n=>\nsubmit\n(\ne\n.\ncurrentTarget\n.\nform\n)\n}\nchecked\n=\n{\nbrands\n.\nincludes\n(\"\nnike\n\")\n}\n/>\n<\nLink\nto\n=\n\"\n?brand=nike\n\">(only)</\nLink\n>\n</\np\n>\n{\n/* ... */\n}\n</\nForm\n>\n);\n}\n(If you are also auto submitting on the form\nonChange\n, make sure to\ne.stopPropagation()\nso the event doesn't bubble up to the form, otherwise you'll get double submissions on every click of the checkbox.)\nSecond Choice\n: If you want the input to be \"semi controlled\", where the checkbox reflects the URL state, but the user can also toggle it on and off before submitting the form and changing the URL, you'll need to wire up some state. It's a bit of work but straightforward:\nInitialize some state from the search params\nUpdate the state when the user clicks the checkbox, so the box changes to \"checked\"\nUpdate the state when the search params change (the user submitted the form or clicked the link) to reflect what's in the url search params\nimport\n{\nuseSubmit\n,\nuseSearchParams\n,\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\ndefault\nfunction\nProductFilters\n() {\nconst\nsubmit\n=\nuseSubmit\n();\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nbrands\n=\nsearchParams\n.\ngetAll\n(\"\nbrand\n\");\nconst\n[\nnikeChecked\n,\nsetNikeChecked\n]\n=\nReact\n.\nuseState\n(\n// initialize from the URL\nbrands\n.\nincludes\n(\"\nnike\n\")\n);\n// Update the state when the params change\n// (form submission or link click)\nReact\n.\nuseEffect\n(()\n=>\n{\nsetNikeChecked\n(\nbrands\n.\nincludes\n(\"\nnike\n\"));\n}, [\nbrands\n,\nsearchParams\n]);\nreturn\n(\n<\nForm\nmethod\n=\n\"\nget\n\">\n<\np\n>\n<\nlabel\nhtmlFor\n=\n\"\nnike\n\">Nike</\nlabel\n>\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nnike\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\"\nonChange\n=\n{\n(\ne\n)\n=>\n{\n// update checkbox state w/o submitting the form\nsetNikeChecked\n(\ntrue\n);\n}\n}\nchecked\n=\n{\nnikeChecked\n}\n/>\n<\nLink\nto\n=\n\"\n?brand=nike\n\">(only)</\nLink\n>\n</\np\n>\n{\n/* ... */\n}\n</\nForm\n>\n);\n}\nYou might want to make an abstraction for checkboxes like this:\n<\ndiv\n>\n<\nSearchCheckbox\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nnike\n\" />\n<\nSearchCheckbox\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nreebok\n\" />\n<\nSearchCheckbox\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nadidas\n\" />\n</\ndiv\n>;\nfunction\nSearchCheckbox\n({\nname\n,\nvalue\n}) {\nconst\n[\nsearchParams\n]\n=\nuseSearchParams\n();\nconst\nparamsIncludeValue\n=\nsearchParams\n.\ngetAll\n(\nname\n)\n.\nincludes\n(\nvalue\n);\nconst\n[\nchecked\n,\nsetChecked\n]\n=\nReact\n.\nuseState\n(\nparamsIncludeValue\n);\nReact\n.\nuseEffect\n(()\n=>\n{\nsetChecked\n(\nparamsIncludeValue\n);\n}, [\nparamsIncludeValue\n]);\nreturn\n(\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nname\n=\n{\nname\n}\nvalue\n=\n{\nvalue\n}\nchecked\n=\n{\nchecked\n}\nonChange\n=\n{\n(\ne\n)\n=>\nsetChecked\n(\ne\n.\ntarget\n.\nchecked\n)\n}\n/>\n);\n}\nOption 3\n: We said there were only two options, but there is a third unholy option that might tempt you if you know React pretty well. You might want to blow away the input and remount it with\nkey\nprop shenanigans. While clever, this will cause accessibility issues as the user will lose focus when React removes the node from the document after they click it.\nDon't do this, it will cause accessibility issues\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\nid\n=\n\"\nadidas\n\"\nname\n=\n\"\nbrand\n\"\nvalue\n=\n\"\nadidas\n\"\nkey\n=\n{\n\"\nadidas\n\"\n+\nbrands\n.\nincludes\n(\"\nadidas\n\")\n}\ndefaultChecked\n=\n{\nbrands\n.\nincludes\n(\"\nadidas\n\")\n}\n/>\nRemix Optimizations\nRemix optimizes the user experiences by only loading the data for the parts of the page that are changing on navigation. For example, consider the UI you're using right now in these docs. The navbar on the side is in a parent route that fetched the dynamically generated menu of all the docs, and the child route fetched the document you're reading right now. If you click a link in the sidebar, Remix knows that the parent route will remain on the page \u2014 but the child route's data will change because the url param for the document will change. With this insight, Remix\nwill not refetch the parent route's data\n.\nWithout Remix, the next question is \"how do I reload all the data?\" This is built into Remix as well. Whenever an\naction\nis called (the user submitted a form or you, the programmer, called\nsubmit\nfrom\nuseSubmit\n), Remix will automatically reload all the routes on the page to capture any changes that might have happened.\nYou don't have to worry about expiring caches or avoid over-fetching data as the user interacts with your app, it's all automatic.\nThere are three cases where Remix will reload all of your routes:\nAfter an action (forms,\nuseSubmit\n,\nfetcher.submit\n)\nIf the url search params change (any loader could use them)\nThe user clicks a link to the exact same URL they are already at (this will also replace the current entry in the history stack)\nAll of these behaviors emulate the browser's default behavior. In these cases, Remix doesn't know enough about your code to optimize the data loading, but you can optimize it yourself with\nshouldRevalidate\n.\nData Libraries\nThanks to Remix's data conventions and nested routes, you'll usually find you don't need to reach for client side data libraries like React Query, SWR, Apollo, Relay,\nurql\nand others. If you're using global state management libraries like redux, primarily for interacting with data on the server, it's also unlikely you'll need those.\nOf course, Remix doesn't prevent you from using them (unless they require bundler integration). You can bring whatever React data libraries you like and use them wherever you think they'll serve your UI better than the Remix APIs. In some cases you can use Remix for the initial server render and then switch over to your favorite library for the interactions afterward.\nThat said, if you bring an external data library and sidestep Remix's own data conventions, Remix can no longer automatically\nServer render your pages\nBe resilient to network conditions when JavaScript fails to load\nMake optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page\nFetch data, JavaScript modules, CSS, and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI\nEnsure the data in the UI is in sync with the data on the server by revalidating after actions\nExcellent scroll restoration on back/forward clicks (even across domains)\nHandle server-side errors with\nerror boundaries\nEnable solid UX for \"Not Found\" and \"Unauthorized\" with\nerror boundaries\nHelp you keep the happy path of your UI happy.\nInstead, you'll need to do extra work to provide a good user experience.\nRemix is designed to meet any user experience you can design. While it's unexpected that you\nneed\nan external data library, you might still\nwant\none and that's fine!\nAs you learn Remix, you'll find you shift from thinking in client state to thinking in URLs, and you'll get a bunch of stuff for free when you do.\nGotchas\nLoaders are only called on the server, via\nfetch\nfrom the browser, so your data is serialized with\nJSON.stringify\nand sent over the network before it makes it to your component. This means your data needs to be serializable. For example:\nThis won't work!\nexport\nasync\nfunction\nloader\n() {\nreturn\n{\ndate:\nnew\nDate\n(),\nsomeMethod\n() {\nreturn\n\"\nhello!\n\";\n},\n};\n}\nexport\ndefault\nfunction\nRouteComp\n() {\nconst\ndata\n=\nuseLoaderData\n<\ntypeof\nloader\n>();\nconsole\n.\nlog\n(\ndata\n);\n// '{\"date\":\"2021-11-27T23:54:26.384Z\"}'\n}\nNot everything makes it! Loaders are for\ndata\n, and data needs to be serializable.\nSome databases (like\nFaunaDB\n) return objects with methods that you'll want to be careful to serialize before returning from your loader. Usually this isn't a problem, but it's good to understand that your data is traveling over the network.\nAdditionally, Remix will call your loaders for you; in no case should you ever try to call your loader directly:\nThis will not work\nexport\nconst\nloader\n=\nasync\n()\n=>\n{\nreturn\njson\n(\nawait\nfakeDb\n.\nproducts\n.\nfindMany\n());\n};\nexport\ndefault\nfunction\nRouteComp\n() {\nconst\ndata\n=\nloader\n();\n// ...\n}\n\u00a9\nShopify, Inc.\n\u2022\nDocs and examples licensed under\nMIT\nEdit",
  "content_markdown": "[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\n[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\n[View code on GitHub](https://github.com/remix-run/remix/tree/v2 \"View code on GitHub\")[Chat on Discord](https://rmx.as/discord \"Chat on Discord\")\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\nData Loading\n\nOn this page\n\n- [Basics](/docs/guides/data-loading/#basics)\n- [Route Params](/docs/guides/data-loading/#route-params)\n- [Param Type Safety](/docs/guides/data-loading/#param-type-safety)\n- [External APIs](/docs/guides/data-loading/#external-apis)\n- [Databases](/docs/guides/data-loading/#databases)\n- [Cloudflare KV](/docs/guides/data-loading/#cloudflare-kv)\n- [Not Found](/docs/guides/data-loading/#not-found)\n- [URL Search Params](/docs/guides/data-loading/#url-search-params)\n- [Data Reloads](/docs/guides/data-loading/#data-reloads)\n- [Search Params in Components](/docs/guides/data-loading/#search-params-in-components)\n- [Search Params and Controlled Inputs](/docs/guides/data-loading/#search-params-and-controlled-inputs)\n- [Remix Optimizations](/docs/guides/data-loading/#remix-optimizations)\n- [Data Libraries](/docs/guides/data-loading/#data-libraries)\n- [Gotchas](/docs/guides/data-loading/#gotchas)\n\n- [Basics](/docs/guides/data-loading/#basics)\n- [Route Params](/docs/guides/data-loading/#route-params)\n- [Param Type Safety](/docs/guides/data-loading/#param-type-safety)\n- [External APIs](/docs/guides/data-loading/#external-apis)\n- [Databases](/docs/guides/data-loading/#databases)\n- [Cloudflare KV](/docs/guides/data-loading/#cloudflare-kv)\n- [Not Found](/docs/guides/data-loading/#not-found)\n- [URL Search Params](/docs/guides/data-loading/#url-search-params)\n- [Data Reloads](/docs/guides/data-loading/#data-reloads)\n- [Search Params in Components](/docs/guides/data-loading/#search-params-in-components)\n- [Search Params and Controlled Inputs](/docs/guides/data-loading/#search-params-and-controlled-inputs)\n- [Remix Optimizations](/docs/guides/data-loading/#remix-optimizations)\n- [Data Libraries](/docs/guides/data-loading/#data-libraries)\n- [Gotchas](/docs/guides/data-loading/#gotchas)\n\n# Data Loading\n\nOne of the primary features of Remix is simplifying interactions with the server to get data into components. When you follow these conventions, Remix can automatically:\n\n- Server render your pages\n- Be resilient to network conditions when JavaScript fails to load\n- Make optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page\n- Fetch data, JavaScript modules, CSS, and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI\n- Ensure the data in the UI is in sync with the data on the server by revalidating after [actions](../route/action)\n- Excellent scroll restoration on back/forward clicks (even across domains)\n- Handle server-side errors with [error boundaries](../route/error-boundary)\n- Enable solid UX for \"Not Found\" and \"Unauthorized\" with [error boundaries](../route/error-boundary)\n- Help you keep the happy path of your UI happy\n\n## Basics\n\nEach route module can export a component and a [`loader`](../route/loader). [`useLoaderData`](../hooks/use-loader-data) will provide the loader's data to your component:\n\n```\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useLoaderData } from \"@remix-run/react\";\n\nexport const loader = async () => {\n  return json([\n    { id: \"1\", name: \"Pants\" },\n    { id: \"2\", name: \"Jacket\" },\n  ]);\n};\n\nexport default function Products() {\n  const products = useLoaderData<typeof loader>();\n  return (\n    <div>\n      <h1>Products</h1>\n      {products.map((product) => (\n        <div key={product.id}>{product.name}</div>\n      ))}\n    </div>\n  );\n}\n```\n\nThe component renders on the server and in the browser. The loader *only runs on the server*. That means our hard-coded products array doesn't get included in the browser bundles, and it's safe to use server-only for APIs and SDKs for things like database, payment processing, content management systems, etc.\n\nIf your server-side modules end up in client bundles, refer to our guide on [server vs. client code execution](../discussion/server-vs-client).\n\n## Route Params\n\nWhen you name a file with `$` like `app/routes/users.$userId.tsx` and `app/routes/users.$userId.projects.$projectId.tsx` the dynamic segments (the ones starting with `$`) will be parsed from the URL and passed to your loader on a `params` object.\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  console.log(params.userId);\n  console.log(params.projectId);\n};\n```\n\nGiven the following URLs, the params would be parsed as follows:\n\n| URL | `params.userId` | `params.projectId` |\n| --- | --- | --- |\n| `/users/123/projects/abc` | `\"123\"` | `\"abc\"` |\n| `/users/aec34g/projects/22cba9` | `\"aec34g\"` | `\"22cba9\"` |\n\nThese params are most useful for looking up data:\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  return json(\n    await fakeDb.project.findMany({\n      where: {\n        userId: params.userId,\n        projectId: params.projectId,\n      },\n    })\n  );\n};\n```\n\n### Param Type Safety\n\nBecause these params come from the URL and not your source code, you can't know for sure if they will be defined. That's why the types on the param's keys are `string | undefined`. It's good practice to validate before using them, especially in TypeScript to get type safety. Using `invariant` makes it easy.\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport invariant from \"tiny-invariant\";\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  invariant(params.userId, \"Expected params.userId\");\n  invariant(params.projectId, \"Expected params.projectId\");\n\n  params.projectId; // <-- TypeScript now knows this is a string\n};\n```\n\nWhile you may be uncomfortable throwing errors like this with `invariant` when it fails, remember that in Remix you know the user will end up in the [error boundary](../route/error-boundary) where they can recover from the problem instead of a broken UI.\n\n## External APIs\n\nRemix polyfills the `fetch` API on your server, so it's straightforward to fetch data from existing JSON APIs. Instead of managing state, errors, race conditions, and more yourself, you can do the fetch from your loader (on the server) and let Remix handle the rest.\n\n```\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useLoaderData } from \"@remix-run/react\";\n\nexport async function loader() {\n  const res = await fetch(\"https://api.github.com/gists\");\n  return json(await res.json());\n}\n\nexport default function GistsRoute() {\n  const gists = useLoaderData<typeof loader>();\n  return (\n    <ul>\n      {gists.map((gist) => (\n        <li key={gist.id}>\n          <a href={gist.html_url}>{gist.id}</a>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\nThis is great when you already have an API to work with and don't care or need to connect directly to your data source in your Remix app.\n\n## Databases\n\nSince Remix runs on your server, you can connect directly to a database in your route modules. For example, you could connect to a Postgres database with [Prisma](https://prisma.io).\n\n```\nimport { PrismaClient } from \"@prisma/client\";\nconst db = new PrismaClient();\nexport { db };\n```\n\nAnd then your routes can import it and make queries against it:\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useLoaderData } from \"@remix-run/react\";\n\nimport { db } from \"~/db.server\";\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  return json(\n    await db.product.findMany({\n      where: {\n        categoryId: params.categoryId,\n      },\n    })\n  );\n};\n\nexport default function ProductCategory() {\n  const products = useLoaderData<typeof loader>();\n  return (\n    <div>\n      <p>{products.length} Products</p>\n      {/* ... */}\n    </div>\n  );\n}\n```\n\nIf you are using TypeScript, you can use type inference to use Prisma Client generated types when calling `useLoaderData`. This allows better type safety and intellisense when writing code that uses the loaded data.\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useLoaderData } from \"@remix-run/react\";\n\nimport { db } from \"~/db.server\";\n\nasync function getLoaderData(productId: string) {\n  const product = await db.product.findUnique({\n    where: {\n      id: productId,\n    },\n    select: {\n      id: true,\n      name: true,\n      imgSrc: true,\n    },\n  });\n\n  return product;\n}\n\nexport const loader = async ({\n  params,\n}: LoaderFunctionArgs) => {\n  return json(await getLoaderData(params.productId));\n};\n\nexport default function Product() {\n  const product = useLoaderData<typeof loader>();\n  return (\n    <div>\n      <p>Product {product.id}</p>\n      {/* ... */}\n    </div>\n  );\n}\n```\n\n## Cloudflare KV\n\nIf you picked Cloudflare Pages or Workers as your environment, [Cloudflare Key Value](https://developers.cloudflare.com/workers/learning/how-kv-works) storage allows you to persist data at the edge as if it were a static resource.\n\nFor Pages, to start with local development, you need to add a `--kv` parameter with a name of your namespace to the package.json task, so it would look like this:\n\n```\n\"dev:wrangler\": \"cross-env NODE_ENV=development wrangler pages dev ./public --kv PRODUCTS_KV\"\n```\n\nFor the Cloudflare Workers environment you'll need to [do some other configuration](https://developers.cloudflare.com/workers/cli-wrangler/commands#kv).\n\nThis enables you to use the `PRODUCTS_KV` in a loader context (KV stores are added to loader context automatically by the Cloudflare Pages adapter):\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/cloudflare\";\nimport { json } from \"@remix-run/cloudflare\";\nimport { useLoaderData } from \"@remix-run/react\";\n\nexport const loader = async ({\n  context,\n  params,\n}: LoaderFunctionArgs) => {\n  return json(\n    await context.PRODUCTS_KV.get(\n      `product-${params.productId}`,\n      { type: \"json\" }\n    )\n  );\n};\n\nexport default function Product() {\n  const product = useLoaderData<typeof loader>();\n  return (\n    <div>\n      <p>Product</p>\n      {product.name}\n    </div>\n  );\n}\n```\n\n## Not Found\n\nWhile loading data, it's common for a record to be \"not found\". As soon as you know you can't render the component as expected, `throw` a response and Remix will stop executing code in the current loader and switch over to the nearest [error boundary](../route/error-boundary).\n\n```\nexport const loader = async ({\n  params,\n  request,\n}: LoaderFunctionArgs) => {\n  const product = await db.product.findOne({\n    where: { id: params.productId },\n  });\n\n  if (!product) {\n    // we know we can't render the component\n    // so throw immediately to stop executing code\n    // and show the not found page\n    throw new Response(\"Not Found\", { status: 404 });\n  }\n\n  const cart = await getCart(request);\n  return json({\n    product,\n    inCart: cart.includes(product.id),\n  });\n};\n```\n\n## URL Search Params\n\nURL Search Params are the portion of the URL after a `?`. Other names for this are \"query string\", \"search string\", or \"location search\". You can access the values by creating a URL out of the `request.url`:\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport const loader = async ({\n  request,\n}: LoaderFunctionArgs) => {\n  const url = new URL(request.url);\n  const term = url.searchParams.get(\"term\");\n  return json(await fakeProductSearch(term));\n};\n```\n\nThere are a few web platform types at play here:\n\n- The [`request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object has a `url` property\n- [URL constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL) that parses the URL string into an object\n- `url.searchParams` is an instance of [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams), which is a parsed version of the location search string that makes it easy to read and manipulate the search string\n\nGiven the following URLs, the search params would be parsed as follows:\n\n| URL | `url.searchParams.get(\"term\")` |\n| --- | --- |\n| `/products?term=stretchy+pants` | `\"stretchy pants\"` |\n| `/products?term=` | `\"\"` |\n| `/products` | `null` |\n\n### Data Reloads\n\nWhen multiple nested routes are rendering and the search params change, all the routes will be reloaded (instead of just the new or changed routes). This is because search params are a cross-cutting concern and could affect any loader. If you would like to prevent some of your routes from reloading in this scenario, use [shouldRevalidate](../route/should-revalidate).\n\n### Search Params in Components\n\nSometimes you need to read and change the search params from your component instead of your loaders and actions. There are a handful of ways to do this depending on your use case.\n\n**Setting Search Params**\n\nPerhaps the most common way to set search params is letting the user control them with a form:\n\n```\nexport default function ProductFilters() {\n  return (\n    <Form method=\"get\">\n      <label htmlFor=\"nike\">Nike</label>\n      <input\n        type=\"checkbox\"\n        id=\"nike\"\n        name=\"brand\"\n        value=\"nike\"\n      />\n\n      <label htmlFor=\"adidas\">Adidas</label>\n      <input\n        type=\"checkbox\"\n        id=\"adidas\"\n        name=\"brand\"\n        value=\"adidas\"\n      />\n\n      <button type=\"submit\">Update</button>\n    </Form>\n  );\n}\n```\n\nIf the user only has one selected:\n\n- Nike\n- Adidas\n\nThen the URL will be `/products/shoes?brand=nike`\n\nIf the user has both selected:\n\n- Nike\n- Adidas\n\nThen the url will be: `/products/shoes?brand=nike&brand=adidas`\n\nNote that `brand` is repeated in the URL search string since both checkboxes were named `\"brand\"`. In your loader you can get access to all of those values with [`searchParams.getAll`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams/getAll)\n\n```\nimport type { LoaderFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport async function loader({\n  request,\n}: LoaderFunctionArgs) {\n  const url = new URL(request.url);\n  const brands = url.searchParams.getAll(\"brand\");\n  return json(await getProducts({ brands }));\n}\n```\n\n**Linking to Search Params**\n\nAs the developer, you can control the search params by linking to URLs with search strings in them. The link will replace the current search string in the URL (if there is one) with what is in the link:\n\n```\n<Link to=\"?brand=nike\">Nike (only)</Link>\n```\n\n**Reading Search Params in Components**\n\nIn addition to reading search params in loaders, you often need access to them in components, too:\n\n```\nimport { useSearchParams } from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const [searchParams] = useSearchParams();\n  const brands = searchParams.getAll(\"brand\");\n\n  return (\n    <Form method=\"get\">\n      <label htmlFor=\"nike\">Nike</label>\n      <input\n        type=\"checkbox\"\n        id=\"nike\"\n        name=\"brand\"\n        value=\"nike\"\n        defaultChecked={brands.includes(\"nike\")}\n      />\n\n      <label htmlFor=\"adidas\">Adidas</label>\n      <input\n        type=\"checkbox\"\n        id=\"adidas\"\n        name=\"brand\"\n        value=\"adidas\"\n        defaultChecked={brands.includes(\"adidas\")}\n      />\n\n      <button type=\"submit\">Update</button>\n    </Form>\n  );\n}\n```\n\nYou might want to auto submit the form on any field change, for that there is [`useSubmit`](../hooks/use-submit):\n\n```\nimport {\n  useSubmit,\n  useSearchParams,\n} from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const submit = useSubmit();\n  const [searchParams] = useSearchParams();\n  const brands = searchParams.getAll(\"brand\");\n\n  return (\n    <Form\n      method=\"get\"\n      onChange={(e) => submit(e.currentTarget)}\n    >\n      {/* ... */}\n    </Form>\n  );\n}\n```\n\n**Setting Search Params Imperatively**\n\nWhile uncommon, you can also set searchParams imperatively at any time for any reason. The use cases here are slim, so slim we couldn't even come up with a good one, but here's a silly example:\n\n```\nimport { useSearchParams } from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const [searchParams, setSearchParams] = useSearchParams();\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setSearchParams({ now: Date.now() });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [setSearchParams]);\n\n  // ...\n}\n```\n\n### Search Params and Controlled Inputs\n\nOften you want to keep some inputs, like checkboxes, in sync with the search params in the URL. This can get a little tricky with React's controlled component concept.\n\nThis is only needed if the search params can be set in two ways, and we want the inputs to stay in sync with the search params. For example, both the `<input type=\"checkbox\">` and the `Link` can change the brand in this component:\n\n```\nimport { useSearchParams } from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const [searchParams] = useSearchParams();\n  const brands = searchParams.getAll(\"brand\");\n\n  return (\n    <Form method=\"get\">\n      <p>\n        <label htmlFor=\"nike\">Nike</label>\n        <input\n          type=\"checkbox\"\n          id=\"nike\"\n          name=\"brand\"\n          value=\"nike\"\n          defaultChecked={brands.includes(\"nike\")}\n        />\n        <Link to=\"?brand=nike\">(only)</Link>\n      </p>\n\n      <button type=\"submit\">Update</button>\n    </Form>\n  );\n}\n```\n\nIf the user clicks the checkbox and submits the form, the URL updates and the checkbox state changes too. But if the user clicks the link, *only the url will update and not the checkbox*. That's not what we want. You may be familiar with React's controlled components here and think to switch it to `checked` instead of `defaultChecked`:\n\n```\n<input\n  type=\"checkbox\"\n  id=\"adidas\"\n  name=\"brand\"\n  value=\"adidas\"\n  checked={brands.includes(\"adidas\")}\n/>\n```\n\nNow we have the opposite problem: clicking the link updates both the URL and the checkbox state, but *the checkbox no longer works* because React prevents the state from changing until the URL that controls it changes--and it never will because we can't change the checkbox and resubmit the form.\n\nReact wants you to control it with some state, but we want the user to control it until they submit the form, and then we want the URL to control it when it changes. So we're in this \"sorta-controlled\" spot.\n\nYou have two choices, and what you pick depends on the user experience you want.\n\n**First Choice**: The simplest thing is to auto-submit the form when the user clicks the checkbox:\n\n```\nimport {\n  useSubmit,\n  useSearchParams,\n} from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const submit = useSubmit();\n  const [searchParams] = useSearchParams();\n  const brands = searchParams.getAll(\"brand\");\n\n  return (\n    <Form method=\"get\">\n      <p>\n        <label htmlFor=\"nike\">Nike</label>\n        <input\n          type=\"checkbox\"\n          id=\"nike\"\n          name=\"brand\"\n          value=\"nike\"\n          onChange={(e) => submit(e.currentTarget.form)}\n          checked={brands.includes(\"nike\")}\n        />\n        <Link to=\"?brand=nike\">(only)</Link>\n      </p>\n\n      {/* ... */}\n    </Form>\n  );\n}\n```\n\n(If you are also auto submitting on the form `onChange`, make sure to `e.stopPropagation()` so the event doesn't bubble up to the form, otherwise you'll get double submissions on every click of the checkbox.)\n\n**Second Choice**: If you want the input to be \"semi controlled\", where the checkbox reflects the URL state, but the user can also toggle it on and off before submitting the form and changing the URL, you'll need to wire up some state. It's a bit of work but straightforward:\n\n- Initialize some state from the search params\n- Update the state when the user clicks the checkbox, so the box changes to \"checked\"\n- Update the state when the search params change (the user submitted the form or clicked the link) to reflect what's in the url search params\n\n```\nimport {\n  useSubmit,\n  useSearchParams,\n} from \"@remix-run/react\";\n\nexport default function ProductFilters() {\n  const submit = useSubmit();\n  const [searchParams] = useSearchParams();\n  const brands = searchParams.getAll(\"brand\");\n\n  const [nikeChecked, setNikeChecked] = React.useState(\n    // initialize from the URL\n    brands.includes(\"nike\")\n  );\n\n  // Update the state when the params change\n  // (form submission or link click)\n  React.useEffect(() => {\n    setNikeChecked(brands.includes(\"nike\"));\n  }, [brands, searchParams]);\n\n  return (\n    <Form method=\"get\">\n      <p>\n        <label htmlFor=\"nike\">Nike</label>\n        <input\n          type=\"checkbox\"\n          id=\"nike\"\n          name=\"brand\"\n          value=\"nike\"\n          onChange={(e) => {\n            // update checkbox state w/o submitting the form\n            setNikeChecked(true);\n          }}\n          checked={nikeChecked}\n        />\n        <Link to=\"?brand=nike\">(only)</Link>\n      </p>\n\n      {/* ... */}\n    </Form>\n  );\n}\n```\n\nYou might want to make an abstraction for checkboxes like this:\n\n```\n<div>\n  <SearchCheckbox name=\"brand\" value=\"nike\" />\n  <SearchCheckbox name=\"brand\" value=\"reebok\" />\n  <SearchCheckbox name=\"brand\" value=\"adidas\" />\n</div>;\n\nfunction SearchCheckbox({ name, value }) {\n  const [searchParams] = useSearchParams();\n  const paramsIncludeValue = searchParams\n    .getAll(name)\n    .includes(value);\n  const [checked, setChecked] = React.useState(\n    paramsIncludeValue\n  );\n\n  React.useEffect(() => {\n    setChecked(paramsIncludeValue);\n  }, [paramsIncludeValue]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      name={name}\n      value={value}\n      checked={checked}\n      onChange={(e) => setChecked(e.target.checked)}\n    />\n  );\n}\n```\n\n**Option 3**: We said there were only two options, but there is a third unholy option that might tempt you if you know React pretty well. You might want to blow away the input and remount it with `key` prop shenanigans. While clever, this will cause accessibility issues as the user will lose focus when React removes the node from the document after they click it.\n\nDon't do this, it will cause accessibility issues\n\n```\n<input\n  type=\"checkbox\"\n  id=\"adidas\"\n  name=\"brand\"\n  value=\"adidas\"\n  key={\"adidas\" + brands.includes(\"adidas\")}\n  defaultChecked={brands.includes(\"adidas\")}\n/>\n```\n\n## Remix Optimizations\n\nRemix optimizes the user experiences by only loading the data for the parts of the page that are changing on navigation. For example, consider the UI you're using right now in these docs. The navbar on the side is in a parent route that fetched the dynamically generated menu of all the docs, and the child route fetched the document you're reading right now. If you click a link in the sidebar, Remix knows that the parent route will remain on the page \u2014 but the child route's data will change because the url param for the document will change. With this insight, Remix *will not refetch the parent route's data*.\n\nWithout Remix, the next question is \"how do I reload all the data?\" This is built into Remix as well. Whenever an [action](../route/action) is called (the user submitted a form or you, the programmer, called `submit` from `useSubmit`), Remix will automatically reload all the routes on the page to capture any changes that might have happened.\n\nYou don't have to worry about expiring caches or avoid over-fetching data as the user interacts with your app, it's all automatic.\n\nThere are three cases where Remix will reload all of your routes:\n\n- After an action (forms, `useSubmit`, [`fetcher.submit`](../hooks/use-fetcher#fetchersubmit))\n- If the url search params change (any loader could use them)\n- The user clicks a link to the exact same URL they are already at (this will also replace the current entry in the history stack)\n\nAll of these behaviors emulate the browser's default behavior. In these cases, Remix doesn't know enough about your code to optimize the data loading, but you can optimize it yourself with [shouldRevalidate](../route/should-revalidate).\n\n## Data Libraries\n\nThanks to Remix's data conventions and nested routes, you'll usually find you don't need to reach for client side data libraries like React Query, SWR, Apollo, Relay, `urql` and others. If you're using global state management libraries like redux, primarily for interacting with data on the server, it's also unlikely you'll need those.\n\nOf course, Remix doesn't prevent you from using them (unless they require bundler integration). You can bring whatever React data libraries you like and use them wherever you think they'll serve your UI better than the Remix APIs. In some cases you can use Remix for the initial server render and then switch over to your favorite library for the interactions afterward.\n\nThat said, if you bring an external data library and sidestep Remix's own data conventions, Remix can no longer automatically\n\n- Server render your pages\n- Be resilient to network conditions when JavaScript fails to load\n- Make optimizations as the user interacts with your site to make it fast by only loading data for the changing parts of the page\n- Fetch data, JavaScript modules, CSS, and other assets in parallel on transitions, avoiding render+fetch waterfalls that lead to choppy UI\n- Ensure the data in the UI is in sync with the data on the server by revalidating after actions\n- Excellent scroll restoration on back/forward clicks (even across domains)\n- Handle server-side errors with [error boundaries](../route/error-boundary)\n- Enable solid UX for \"Not Found\" and \"Unauthorized\" with [error boundaries](../route/error-boundary)\n- Help you keep the happy path of your UI happy.\n\nInstead, you'll need to do extra work to provide a good user experience.\n\nRemix is designed to meet any user experience you can design. While it's unexpected that you *need* an external data library, you might still *want* one and that's fine!\n\nAs you learn Remix, you'll find you shift from thinking in client state to thinking in URLs, and you'll get a bunch of stuff for free when you do.\n\n## Gotchas\n\nLoaders are only called on the server, via `fetch` from the browser, so your data is serialized with `JSON.stringify` and sent over the network before it makes it to your component. This means your data needs to be serializable. For example:\n\nThis won't work!\n\n```\nexport async function loader() {\n  return {\n    date: new Date(),\n    someMethod() {\n      return \"hello!\";\n    },\n  };\n}\n\nexport default function RouteComp() {\n  const data = useLoaderData<typeof loader>();\n  console.log(data);\n  // '{\"date\":\"2021-11-27T23:54:26.384Z\"}'\n}\n```\n\nNot everything makes it! Loaders are for *data*, and data needs to be serializable.\n\nSome databases (like [FaunaDB](https://fauna.com)) return objects with methods that you'll want to be careful to serialize before returning from your loader. Usually this isn't a problem, but it's good to understand that your data is traveling over the network.\n\nAdditionally, Remix will call your loaders for you; in no case should you ever try to call your loader directly:\n\nThis will not work\n\n```\nexport const loader = async () => {\n  return json(await fakeDb.products.findMany());\n};\n\nexport default function RouteComp() {\n  const data = loader();\n  // ...\n}\n```\n\n\u00a9 [Shopify, Inc.](https://remix.run)\n\n\u2022\n\nDocs and examples licensed under [MIT](https://opensource.org/licenses/MIT)\n\n[Edit](https://github.com/remix-run/remix-v2-website/edit/main/data/docs/guides/data-loading.md)\n\n![](/assets/icons-CZ8v8NWl.svg)",
  "tags": [
    "remix",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:55:25.783660+00:00",
  "content_length": 24601,
  "content_hash": "fda7c8d0bfdd6d64"
}