{
  "id": "remix__docs_en_main_guides_data-writes",
  "source_id": "remix",
  "source_name": "Remix Documentation",
  "category": "framework_specific",
  "url": "https://remix.run/docs/en/main/guides/data-writes",
  "title": "Data Writes",
  "content": "Docs\nBlog\nResources\nReact Router v7 has been released.\nView the docs\nDocs\nBlog\nResources\nView code on GitHub\nChat on Discord\nReact Router v7 has been released.\nView the docs\nData Writes\nOn this page\nPlain HTML Forms\nHTML Form HTTP Verbs\nHTML Form GET\nHTML Form POST\nRemix Mutation, Start to Finish\nBuilding the form\nForm Validation\nGraduate to\n<Form>\nand add pending UI\nAnimating in the Validation Errors\nReview\nSee also\nPlain HTML Forms\nHTML Form HTTP Verbs\nHTML Form GET\nHTML Form POST\nRemix Mutation, Start to Finish\nBuilding the form\nForm Validation\nGraduate to\n<Form>\nand add pending UI\nAnimating in the Validation Errors\nReview\nSee also\nData Writes\nData writes (some people call these mutations) in Remix are built on top of two fundamental web APIs:\n<form>\nand HTTP. We then use progressive enhancement to enable optimistic UI, loading indicators, and validation feedback--but the programming model is still built on HTML forms.\nWhen the user submits a form, Remix will:\nCall the action for the form\nReload all the data for all the routes on the page\nMany times people reach for global state management libraries in React like redux, data libs like apollo, and fetch wrappers like React Query to help manage getting server state into your components and keeping the UI in sync with it when the user changes it. Remix's HTML based API replaces the majority of use cases for these tools. Remix knows how to load the data as well as how to revalidate it after it changes when you use standard HTML APIs.\nThere are a few ways to call an action and get the routes to revalidate:\n<Form>\nuseSubmit()\nuseFetcher()\nThis guide only covers\n<Form>\n. We suggest you read the docs for the other two after this guide to get a sense of how to use them. Most of this guide applies to\nuseSubmit\nbut\nuseFetcher\nis a bit different.\nPlain HTML Forms\nAfter teaching workshops with our company\nReact Training\nfor years, we've learned that a lot of newer web developers (though no fault of their own) don't actually know how\n<form>\nworks!\nSince Remix\n<Form>\nworks identically to\n<form>\n(with a couple of extra goodies for optimistic UI etc.), we're going to brush up on plain ol' HTML forms, so you can learn both HTML and Remix at the same time.\nHTML Form HTTP Verbs\nNative forms support two HTTP verbs:\nGET\nand\nPOST\n. Remix uses these verbs to understand your intent. If it's a GET, Remix will figure out what parts of the page are changing and only fetch the data for the changing layouts, and use the cached data for the layouts that don't change. When it's a POST, Remix will reload all data to ensure it captures the update from the server. Let's take a look at both.\nHTML Form GET\nA\nGET\nis just a normal navigation where the form data is passed in the URL search params. You use it for normal navigation, just like\n<a>\nexcept the user gets to provide the data in the search params through the form. Aside from search pages, its use with\n<form>\nis pretty rare.\nConsider this form:\n<\nform\nmethod\n=\"\nget\n\"\naction\n=\"\n/search\n\">\n<\nlabel\n>Search <\ninput\nname\n=\"\nterm\n\"\ntype\n=\"\ntext\n\" /></\nlabel\n>\n<\nbutton\ntype\n=\"\nsubmit\n\">Search</\nbutton\n>\n</\nform\n>\nWhen the user fills it out and clicks submit, the browser automatically serializes the form values into a URL search param string and navigates to the form's\naction\nwith the query string appended. Let's say the user typed in \"remix\". The browser would navigate to\n/search?term=remix\n. If we changed the input to\n<input name=\"q\"/>\nthen the form would navigate to\n/search?q=remix\n.\nIt's the same behavior as if we had created this link:\n<\na\nhref\n=\"\n/search?term=remix\n\">Search for \"remix\"</\na\n>\nWith the unique difference that the\nuser\ngot to supply the information.\nIf you have more fields, the browser will add them:\n<\nform\nmethod\n=\"\nget\n\"\naction\n=\"\n/search\n\">\n<\nfieldset\n>\n<\nlegend\n>Brand</\nlegend\n>\n<\nlabel\n>\n<\ninput\nname\n=\"\nbrand\n\"\nvalue\n=\"\nnike\n\"\ntype\n=\"\ncheckbox\n\" />\nNike\n</\nlabel\n>\n<\nlabel\n>\n<\ninput\nname\n=\"\nbrand\n\"\nvalue\n=\"\nreebok\n\"\ntype\n=\"\ncheckbox\n\" />\nReebok\n</\nlabel\n>\n<\nlabel\n>\n<\ninput\nname\n=\"\ncolor\n\"\nvalue\n=\"\nwhite\n\"\ntype\n=\"\ncheckbox\n\" />\nWhite\n</\nlabel\n>\n<\nlabel\n>\n<\ninput\nname\n=\"\ncolor\n\"\nvalue\n=\"\nblack\n\"\ntype\n=\"\ncheckbox\n\" />\nBlack\n</\nlabel\n>\n<\nbutton\ntype\n=\"\nsubmit\n\">Search</\nbutton\n>\n</\nfieldset\n>\n</\nform\n>\nDepending on which checkboxes the user clicks, the browser will navigate to URLs like:\n/search?brand=nike&color=black\n/search?brand=nike&brand=reebok&color=white\nHTML Form POST\nWhen you want to create, delete, or update data on your website, a form post is the way to go. And we don't just mean big forms like a user profile edit page. Even \"Like\" buttons can be handled with a form.\nLet's consider a \"new project\" form.\n<\nform\nmethod\n=\"\npost\n\"\naction\n=\"\n/projects\n\">\n<\nlabel\n><\ninput\nname\n=\"\nname\n\"\ntype\n=\"\ntext\n\" /></\nlabel\n>\n<\nlabel\n><\ntextarea\nname\n=\"\ndescription\n\"></\ntextarea\n></\nlabel\n>\n<\nbutton\ntype\n=\"\nsubmit\n\">Create</\nbutton\n>\n</\nform\n>\nWhen the user submits this form, the browser will serialize the fields into a request \"body\" (instead of URL search params) and \"POST\" it to the server. This is still a normal navigation as if the user clicked a link. The difference is two-fold: the user provided the data for the server and the browser sent the request as a \"POST\" instead of a \"GET\".\nThe data is made available to the server's request handler, so you can create the record. After that, you return a response. In this case, you'd probably redirect to the newly-created project. A remix action would look something like this:\nexport\nasync\nfunction\naction\n({\nrequest\n,\n}\n:\nActionFunctionArgs\n) {\nconst\nbody\n=\nawait\nrequest\n.\nformData\n();\nconst\nproject\n=\nawait\ncreateProject\n(\nbody\n);\nreturn\nredirect\n(`\n/projects/\n${\nproject\n.\nid\n}`);\n}\nThe browser started at\n/projects/new\n, then posted to\n/projects\nwith the form data in the request, then the server redirected the browser to\n/projects/123\n. While this is all happening, the browser goes into its normal \"loading\" state: the address progress bar fills up, the favicon turns into a spinner, etc. It's actually a decent user experience.\nIf you're newer to web development, you may not have ever used a form this way. Lots of folks have always done:\n<\nform\nonSubmit\n=\n{(event)\n=\n> { event.preventDefault(); // good\nluck! }} />\nIf this is you, you're going to be delighted when you see just how easy mutations can be when you just use what browsers (and Remix) have built in!\nRemix Mutation, Start to Finish\nWe're going to build a mutation from start to finish with:\nJavaScript optional\nValidation\nError handling\nProgressively-enhanced loading indicators\nProgressively-enhanced error display\nYou use the Remix\n<Form>\ncomponent for data mutations the same way you use HTML forms. The difference is now you get access to pending form state to build a nicer user experience: like contextual loading indicators and \"optimistic UI\".\nWhether you use\n<form>\nor\n<Form>\nthough, you write the very same code. You can start with a\n<form>\nand then graduate it to\n<Form>\nwithout changing anything. After that, add in the special loading indicators and optimistic UI. However, if you're not feeling up to it, or deadlines are tight, just use a\n<form>\nand let the browser handle the user feedback! Remix\n<Form>\nis the realization of \"progressive enhancement\" for mutations.\nBuilding the form\nLet's start with our project form from earlier but make it usable:\nLet's say you've got the route\napp/routes/projects.new.tsx\nwith this form in it:\nexport\ndefault\nfunction\nNewProject\n() {\nreturn\n(\n<\nform\nmethod\n=\n\"\npost\n\"\naction\n=\n\"\n/projects/new\n\">\n<\np\n>\n<\nlabel\n>\nName: <\ninput\nname\n=\n\"\nname\n\"\ntype\n=\n\"\ntext\n\" />\n</\nlabel\n>\n</\np\n>\n<\np\n>\n<\nlabel\n>\nDescription:\n<\nbr\n/>\n<\ntextarea\nname\n=\n\"\ndescription\n\" />\n</\nlabel\n>\n</\np\n>\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Create</\nbutton\n>\n</\np\n>\n</\nform\n>\n);\n}\nNow add the route action. Any form submissions that are \"post\" will call your data \"action\". Any \"get\" submissions (\n<Form method=\"get\">\n) will be handled by your \"loader\".\nimport\ntype\n{\nActionFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\n// Note the \"action\" export name, this will handle our form POST\nexport\nconst\naction\n=\nasync\n({\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\nproject\n=\nawait\ncreateProject\n(\nformData\n);\nreturn\nredirect\n(`\n/projects/\n${\nproject\n.\nid\n}`);\n};\nexport\ndefault\nfunction\nNewProject\n() {\n// ... same as before\n}\nAnd that's it! Assuming\ncreateProject\ndoes what we want it to, that's all you have to do. Note that no matter what kind of SPA you may have built in the past, you always need a server-side action and a form to get data from the user. The difference with Remix is\nthat's all you need\n(and that's how the web used to be, too.)\nOf course, we started complicating things to try to create better user experiences than the default browser behavior. Keep going, we'll get there, but we won\u2019t have to change any of the code we've already written to get the core functionality.\nForm Validation\nIt's common to validate forms both client-side and server-side. It's also (unfortunately) common to only validate client-side, which leads to various issues with your data that we don't have time to get into right now. Point is, if you're validating in only one place, do it on the server. You'll find with Remix that's the only place you care to anymore (the less you send to the browser the better!).\nWe know, we know, you want to animate in nice validation errors and stuff. We'll get to that. But right now we're just building a basic HTML form and user flow. We'll keep it simple first, then make it fancy.\nBack in our action, maybe we have an API that returns validation errors like this.\nconst\n[\nerrors\n,\nproject\n]\n=\nawait\ncreateProject\n(\nformData\n);\nIf there are validation errors, we want to go back to the form and display them.\nimport\n{\njson\n,\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nexport\nconst\naction\n=\nasync\n({\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\nconst\nformData\n=\nawait\nrequest\n.\nformData\n();\nconst\n[\nerrors\n,\nproject\n]\n=\nawait\ncreateProject\n(\nformData\n);\nif\n(\nerrors\n) {\nconst\nvalues\n=\nObject\n.\nfromEntries\n(\nformData\n);\nreturn\njson\n({\nerrors\n,\nvalues\n});\n}\nreturn\nredirect\n(`\n/projects/\n${\nproject\n.\nid\n}`);\n};\nJust like\nuseLoaderData\nreturns the values from the\nloader\n,\nuseActionData\nwill return the data from the action. It will only be there if the navigation was a form submission, so you always have to check if you've got it or not.\nimport\ntype\n{\nActionFunctionArgs\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\njson\n,\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseActionData\n}\nfrom\n\"\n@remix-run/react\n\";\nexport\nconst\naction\n=\nasync\n({\nrequest\n,\n}\n:\nActionFunctionArgs\n)\n=>\n{\n// ...\n};\nexport\ndefault\nfunction\nNewProject\n() {\nconst\nactionData\n=\nuseActionData\n<\ntypeof\naction\n>();\nreturn\n(\n<\nform\nmethod\n=\n\"\npost\n\"\naction\n=\n\"\n/projects/new\n\">\n<\np\n>\n<\nlabel\n>\nName:\n{\n\"\n\"\n}\n<\ninput\nname\n=\n\"\nname\n\"\ntype\n=\n\"\ntext\n\"\ndefaultValue\n=\n{\nactionData\n?.\nvalues\n.\nname\n}\n/>\n</\nlabel\n>\n</\np\n>\n{\nactionData\n?.\nerrors\n.\nname\n?\n(\n<\np\nstyle\n=\n{\n{ color: \"\nred\n\" }\n}\n>\n{\nactionData\n.\nerrors\n.\nname\n}\n</\np\n>\n)\n:\nnull\n}\n<\np\n>\n<\nlabel\n>\nDescription:\n<\nbr\n/>\n<\ntextarea\nname\n=\n\"\ndescription\n\"\ndefaultValue\n=\n{\nactionData\n?.\nvalues\n.\ndescription\n}\n/>\n</\nlabel\n>\n</\np\n>\n{\nactionData\n?.\nerrors\n.\ndescription\n?\n(\n<\np\nstyle\n=\n{\n{ color: \"\nred\n\" }\n}\n>\n{\nactionData\n.\nerrors\n.\ndescription\n}\n</\np\n>\n)\n:\nnull\n}\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">Create</\nbutton\n>\n</\np\n>\n</\nform\n>\n);\n}\nNotice how we add\ndefaultValue\nto all of our inputs. Remember, this is regular HTML\n<form>\n, so it's just normal browser/server stuff happening. We're getting the values back from the server so the user doesn't have to re-type what they had.\nYou can ship this code as-is. The browser will handle the pending UI and interruptions for you. Enjoy your weekend and make it fancy on Monday.\nGraduate to\n<Form>\nand add pending UI\nLet's use progressive enhancement to make this UX a bit more fancy. By changing it from\n<form>\nto\n<Form>\n, Remix will emulate the browser behavior with\nfetch\n. It will also give you access to the pending form data, so you can build pending UI.\nimport\n{\njson\n,\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseActionData\n,\nForm\n}\nfrom\n\"\n@remix-run/react\n\";\n// ...\nexport\ndefault\nfunction\nNewProject\n() {\nconst\nactionData\n=\nuseActionData\n<\ntypeof\naction\n>();\nreturn\n(\n// note the capital \"F\" <Form> now\n<\nForm\nmethod\n=\n\"\npost\n\">\n{\n/* ... */\n}\n</\nForm\n>\n);\n}\nHOLD UP! If all you do is change your form to Form, you made the UX a little worse!\nIf you don't have the time or drive to do the rest of the job here, use\n<Form reloadDocument>\n. This lets the browser continue to handle the pending UI state (spinner in the favicon of the tab, progress bar in the address bar, etc.) If you simply use\n<Form>\nwithout implementing pending UI, the user will have no idea anything is happening when they submit a form.\nWe recommend always using capital-F Form, and if you want to let the browser handle the pending UI, use the\n<Form reloadDocument>\nprop.\nNow let's add some pending UI so the user has a clue something happened when they submit. There's a hook called\nuseNavigation\n. When there is a pending form submission, Remix will give you the serialized version of the form as a\nFormData\nobject. You'll be most interested in the\nformData.get()\nmethod.\nimport\n{\njson\n,\nredirect\n}\nfrom\n\"\n@remix-run/node\n\";\n// or cloudflare/deno\nimport\n{\nuseActionData\n,\nForm\n,\nuseNavigation\n,\n}\nfrom\n\"\n@remix-run/react\n\";\n// ...\nexport\ndefault\nfunction\nNewProject\n() {\n// when the form is being processed on the server, this returns different\n// navigation states to help us build pending and optimistic UI.\nconst\nnavigation\n=\nuseNavigation\n();\nconst\nactionData\n=\nuseActionData\n<\ntypeof\naction\n>();\nreturn\n(\n<\nForm\nmethod\n=\n\"\npost\n\">\n<\nfieldset\ndisabled\n=\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n}\n>\n<\np\n>\n<\nlabel\n>\nName:\n{\n\"\n\"\n}\n<\ninput\nname\n=\n\"\nname\n\"\ntype\n=\n\"\ntext\n\"\ndefaultValue\n=\n{\nactionData\n?\nactionData\n.\nvalues\n.\nname\n:\nundefined\n}\n/>\n</\nlabel\n>\n</\np\n>\n{\nactionData\n&&\nactionData\n.\nerrors\n.\nname\n?\n(\n<\np\nstyle\n=\n{\n{ color: \"\nred\n\" }\n}\n>\n{\nactionData\n.\nerrors\n.\nname\n}\n</\np\n>\n)\n:\nnull\n}\n<\np\n>\n<\nlabel\n>\nDescription:\n<\nbr\n/>\n<\ntextarea\nname\n=\n\"\ndescription\n\"\ndefaultValue\n=\n{\nactionData\n?\nactionData\n.\nvalues\n.\ndescription\n:\nundefined\n}\n/>\n</\nlabel\n>\n</\np\n>\n{\nactionData\n&&\nactionData\n.\nerrors\n.\ndescription\n?\n(\n<\np\nstyle\n=\n{\n{ color: \"\nred\n\" }\n}\n>\n{\nactionData\n.\nerrors\n.\ndescription\n}\n</\np\n>\n)\n:\nnull\n}\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n?\n\"\nCreating...\n\"\n:\n\"\nCreate\n\"\n}\n</\nbutton\n>\n</\np\n>\n</\nfieldset\n>\n</\nForm\n>\n);\n}\nPretty slick! Now when the user clicks \"Create\", the inputs go disabled, and the submit button's text changes. The whole operation should be faster now too since there's just one network request happening instead of a full page reload (which involves potentially more network requests, reading assets from the browser cache, parsing JavaScript, parsing CSS, etc.).\nWe didn't do much with\nnavigation\non this page, but it's got all the information about the submission (\nnavigation.formMethod\n,\nnavigation.formAction\n,\nnavigation.formEncType\n), as well as all the values being processed on the server on\nnavigation.formData\n.\nAnimating in the Validation Errors\nNow that we're using JavaScript to submit this page, our validation errors can be animated in because the page is stateful. First we'll make a fancy component that animates height and opacity:\nfunction\nValidationMessage\n({\nerror\n,\nisSubmitting\n}) {\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\n!!\nerror\n);\nuseEffect\n(()\n=>\n{\nconst\nid\n=\nsetTimeout\n(()\n=>\n{\nconst\nhasError\n=\n!!\nerror\n;\nsetShow\n(\nhasError\n&&\n!\nisSubmitting\n);\n});\nreturn\n()\n=>\nclearTimeout\n(\nid\n);\n}, [\nerror\n,\nisSubmitting\n]);\nreturn\n(\n<\ndiv\nstyle\n=\n{\n{\nopacity:\nshow\n?\n1\n:\n0\n,\nheight:\nshow\n?\n\"\n1em\n\"\n:\n0\n,\ncolor: \"\nred\n\",\ntransition: \"\nall 300ms ease-in-out\n\",\n}\n}\n>\n{\nerror\n}\n</\ndiv\n>\n);\n}\nNow we can wrap our old error messages in this new fancy component, and even turn the borders of our fields red that have errors:\nexport\ndefault\nfunction\nNewProject\n() {\nconst\nnavigation\n=\nuseNavigation\n();\nconst\nactionData\n=\nuseActionData\n<\ntypeof\naction\n>();\nreturn\n(\n<\nForm\nmethod\n=\n\"\npost\n\">\n<\nfieldset\ndisabled\n=\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n}\n>\n<\np\n>\n<\nlabel\n>\nName:\n{\n\"\n\"\n}\n<\ninput\nname\n=\n\"\nname\n\"\ntype\n=\n\"\ntext\n\"\ndefaultValue\n=\n{\nactionData\n?\nactionData\n.\nvalues\n.\nname\n:\nundefined\n}\nstyle\n=\n{\n{\nborderColor:\nactionData\n?.\nerrors\n.\nname\n?\n\"\nred\n\"\n:\n\"\",\n}\n}\n/>\n</\nlabel\n>\n</\np\n>\n{\nactionData\n?.\nerrors\n.\nname\n?\n(\n<\nValidationMessage\nisSubmitting\n=\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n}\nerror\n=\n{\nactionData\n?.\nerrors\n?.\nname\n}\n/>\n)\n:\nnull\n}\n<\np\n>\n<\nlabel\n>\nDescription:\n<\nbr\n/>\n<\ntextarea\nname\n=\n\"\ndescription\n\"\ndefaultValue\n=\n{\nactionData\n?.\nvalues\n.\ndescription\n}\nstyle\n=\n{\n{\nborderColor:\nactionData\n?.\nerrors\n.\ndescription\n?\n\"\nred\n\"\n:\n\"\",\n}\n}\n/>\n</\nlabel\n>\n</\np\n>\n<\nValidationMessage\nisSubmitting\n=\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n}\nerror\n=\n{\nactionData\n?.\nerrors\n.\ndescription\n}\n/>\n<\np\n>\n<\nbutton\ntype\n=\n\"\nsubmit\n\">\n{\nnavigation\n.\nstate\n===\n\"\nsubmitting\n\"\n?\n\"\nCreating...\n\"\n:\n\"\nCreate\n\"\n}\n</\nbutton\n>\n</\np\n>\n</\nfieldset\n>\n</\nForm\n>\n);\n}\nBoom! Fancy UI without having to change anything about how we communicate with the server. It's also resilient to network conditions that prevent JS from loading.\nReview\nFirst we built the project form without JavaScript in mind. A simple form, posting to a server-side action. Welcome to 1998.\nOnce that worked, we used JavaScript to submit the form by changing\n<form>\nto\n<Form>\n, but we didn't have to do anything else!\nNow that there was a stateful page with React, we added loading indicators and animation for the validation errors by simply asking Remix for the state of the navigation.\nFrom your components perspective, all that happened was the\nuseNavigation\nhook caused a state update when the form was submitted, and then another state update when the data came back. Of course, a lot more happened inside of Remix, but as far as your component is concerned, that's it. Just a couple of state updates. This makes it really easy to dress up any user flow.\nSee also\nForm\nuseNavigation\nActions\nLoaders\nuseSubmit()\nuseFetcher()\n\u00a9\nShopify, Inc.\n\u2022\nDocs and examples licensed under\nMIT\nEdit",
  "content_markdown": "[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\n[Docs](/docs)[Blog](https://remix.run/blog)[Resources](/resources)\n\n[View code on GitHub](https://github.com/remix-run/remix/tree/v2 \"View code on GitHub\")[Chat on Discord](https://rmx.as/discord \"Chat on Discord\")\n\nReact Router v7 has been released. [View the docs](https://reactrouter.com/home)\n\nData Writes\n\nOn this page\n\n- [Plain HTML Forms](/docs/guides/data-writes/#plain-html-forms)\n- [HTML Form HTTP Verbs](/docs/guides/data-writes/#html-form-http-verbs)\n- [HTML Form GET](/docs/guides/data-writes/#html-form-get)\n- [HTML Form POST](/docs/guides/data-writes/#html-form-post)\n- [Remix Mutation, Start to Finish](/docs/guides/data-writes/#remix-mutation-start-to-finish)\n- [Building the form](/docs/guides/data-writes/#building-the-form)\n- [Form Validation](/docs/guides/data-writes/#form-validation)\n- [Graduate to `<Form>` and add pending UI](/docs/guides/data-writes/#graduate-to-form-and-add-pending-ui)\n- [Animating in the Validation Errors](/docs/guides/data-writes/#animating-in-the-validation-errors)\n- [Review](/docs/guides/data-writes/#review)\n- [See also](/docs/guides/data-writes/#see-also)\n\n- [Plain HTML Forms](/docs/guides/data-writes/#plain-html-forms)\n- [HTML Form HTTP Verbs](/docs/guides/data-writes/#html-form-http-verbs)\n- [HTML Form GET](/docs/guides/data-writes/#html-form-get)\n- [HTML Form POST](/docs/guides/data-writes/#html-form-post)\n- [Remix Mutation, Start to Finish](/docs/guides/data-writes/#remix-mutation-start-to-finish)\n- [Building the form](/docs/guides/data-writes/#building-the-form)\n- [Form Validation](/docs/guides/data-writes/#form-validation)\n- [Graduate to `<Form>` and add pending UI](/docs/guides/data-writes/#graduate-to-form-and-add-pending-ui)\n- [Animating in the Validation Errors](/docs/guides/data-writes/#animating-in-the-validation-errors)\n- [Review](/docs/guides/data-writes/#review)\n- [See also](/docs/guides/data-writes/#see-also)\n\n# Data Writes\n\nData writes (some people call these mutations) in Remix are built on top of two fundamental web APIs: `<form>` and HTTP. We then use progressive enhancement to enable optimistic UI, loading indicators, and validation feedback--but the programming model is still built on HTML forms.\n\nWhen the user submits a form, Remix will:\n\n1. Call the action for the form\n2. Reload all the data for all the routes on the page\n\nMany times people reach for global state management libraries in React like redux, data libs like apollo, and fetch wrappers like React Query to help manage getting server state into your components and keeping the UI in sync with it when the user changes it. Remix's HTML based API replaces the majority of use cases for these tools. Remix knows how to load the data as well as how to revalidate it after it changes when you use standard HTML APIs.\n\nThere are a few ways to call an action and get the routes to revalidate:\n\n- [`<Form>`](../components/form)\n- [`useSubmit()`](../hooks/use-submit)\n- [`useFetcher()`](../hooks/use-fetcher)\n\nThis guide only covers `<Form>`. We suggest you read the docs for the other two after this guide to get a sense of how to use them. Most of this guide applies to `useSubmit` but `useFetcher` is a bit different.\n\n## Plain HTML Forms\n\nAfter teaching workshops with our company [React Training](https://reacttraining.com) for years, we've learned that a lot of newer web developers (though no fault of their own) don't actually know how `<form>` works!\n\nSince Remix `<Form>` works identically to `<form>` (with a couple of extra goodies for optimistic UI etc.), we're going to brush up on plain ol' HTML forms, so you can learn both HTML and Remix at the same time.\n\n### HTML Form HTTP Verbs\n\nNative forms support two HTTP verbs: `GET` and `POST`. Remix uses these verbs to understand your intent. If it's a GET, Remix will figure out what parts of the page are changing and only fetch the data for the changing layouts, and use the cached data for the layouts that don't change. When it's a POST, Remix will reload all data to ensure it captures the update from the server. Let's take a look at both.\n\n### HTML Form GET\n\nA `GET` is just a normal navigation where the form data is passed in the URL search params. You use it for normal navigation, just like `<a>` except the user gets to provide the data in the search params through the form. Aside from search pages, its use with `<form>` is pretty rare.\n\nConsider this form:\n\n```\n<form method=\"get\" action=\"/search\">\n  <label>Search <input name=\"term\" type=\"text\" /></label>\n  <button type=\"submit\">Search</button>\n</form>\n```\n\nWhen the user fills it out and clicks submit, the browser automatically serializes the form values into a URL search param string and navigates to the form's `action` with the query string appended. Let's say the user typed in \"remix\". The browser would navigate to `/search?term=remix`. If we changed the input to `<input name=\"q\"/>` then the form would navigate to `/search?q=remix`.\n\nIt's the same behavior as if we had created this link:\n\n```\n<a href=\"/search?term=remix\">Search for \"remix\"</a>\n```\n\nWith the unique difference that the **user** got to supply the information.\n\nIf you have more fields, the browser will add them:\n\n```\n<form method=\"get\" action=\"/search\">\n  <fieldset>\n    <legend>Brand</legend>\n    <label>\n      <input name=\"brand\" value=\"nike\" type=\"checkbox\" />\n      Nike\n    </label>\n    <label>\n      <input name=\"brand\" value=\"reebok\" type=\"checkbox\" />\n      Reebok\n    </label>\n    <label>\n      <input name=\"color\" value=\"white\" type=\"checkbox\" />\n      White\n    </label>\n    <label>\n      <input name=\"color\" value=\"black\" type=\"checkbox\" />\n      Black\n    </label>\n    <button type=\"submit\">Search</button>\n  </fieldset>\n</form>\n```\n\nDepending on which checkboxes the user clicks, the browser will navigate to URLs like:\n\n```\n/search?brand=nike&color=black\n/search?brand=nike&brand=reebok&color=white\n```\n\n### HTML Form POST\n\nWhen you want to create, delete, or update data on your website, a form post is the way to go. And we don't just mean big forms like a user profile edit page. Even \"Like\" buttons can be handled with a form.\n\nLet's consider a \"new project\" form.\n\n```\n<form method=\"post\" action=\"/projects\">\n  <label><input name=\"name\" type=\"text\" /></label>\n  <label><textarea name=\"description\"></textarea></label>\n  <button type=\"submit\">Create</button>\n</form>\n```\n\nWhen the user submits this form, the browser will serialize the fields into a request \"body\" (instead of URL search params) and \"POST\" it to the server. This is still a normal navigation as if the user clicked a link. The difference is two-fold: the user provided the data for the server and the browser sent the request as a \"POST\" instead of a \"GET\".\n\nThe data is made available to the server's request handler, so you can create the record. After that, you return a response. In this case, you'd probably redirect to the newly-created project. A remix action would look something like this:\n\n```\nexport async function action({\n  request,\n}: ActionFunctionArgs) {\n  const body = await request.formData();\n  const project = await createProject(body);\n  return redirect(`/projects/${project.id}`);\n}\n```\n\nThe browser started at `/projects/new`, then posted to `/projects` with the form data in the request, then the server redirected the browser to `/projects/123`. While this is all happening, the browser goes into its normal \"loading\" state: the address progress bar fills up, the favicon turns into a spinner, etc. It's actually a decent user experience.\n\nIf you're newer to web development, you may not have ever used a form this way. Lots of folks have always done:\n\n```\n<form onSubmit={(event) => { event.preventDefault(); // good\nluck! }} />\n```\n\nIf this is you, you're going to be delighted when you see just how easy mutations can be when you just use what browsers (and Remix) have built in!\n\n## Remix Mutation, Start to Finish\n\nWe're going to build a mutation from start to finish with:\n\n1. JavaScript optional\n2. Validation\n3. Error handling\n4. Progressively-enhanced loading indicators\n5. Progressively-enhanced error display\n\nYou use the Remix `<Form>` component for data mutations the same way you use HTML forms. The difference is now you get access to pending form state to build a nicer user experience: like contextual loading indicators and \"optimistic UI\".\n\nWhether you use `<form>` or `<Form>` though, you write the very same code. You can start with a `<form>` and then graduate it to `<Form>` without changing anything. After that, add in the special loading indicators and optimistic UI. However, if you're not feeling up to it, or deadlines are tight, just use a `<form>` and let the browser handle the user feedback! Remix `<Form>` is the realization of \"progressive enhancement\" for mutations.\n\n### Building the form\n\nLet's start with our project form from earlier but make it usable:\n\nLet's say you've got the route `app/routes/projects.new.tsx` with this form in it:\n\n```\nexport default function NewProject() {\n  return (\n    <form method=\"post\" action=\"/projects/new\">\n      <p>\n        <label>\n          Name: <input name=\"name\" type=\"text\" />\n        </label>\n      </p>\n      <p>\n        <label>\n          Description:\n          <br />\n          <textarea name=\"description\" />\n        </label>\n      </p>\n      <p>\n        <button type=\"submit\">Create</button>\n      </p>\n    </form>\n  );\n}\n```\n\nNow add the route action. Any form submissions that are \"post\" will call your data \"action\". Any \"get\" submissions (`<Form method=\"get\">`) will be handled by your \"loader\".\n\n```\nimport type { ActionFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { redirect } from \"@remix-run/node\"; // or cloudflare/deno\n\n// Note the \"action\" export name, this will handle our form POST\nexport const action = async ({\n  request,\n}: ActionFunctionArgs) => {\n  const formData = await request.formData();\n  const project = await createProject(formData);\n  return redirect(`/projects/${project.id}`);\n};\n\nexport default function NewProject() {\n  // ... same as before\n}\n```\n\nAnd that's it! Assuming `createProject` does what we want it to, that's all you have to do. Note that no matter what kind of SPA you may have built in the past, you always need a server-side action and a form to get data from the user. The difference with Remix is **that's all you need** (and that's how the web used to be, too.)\n\nOf course, we started complicating things to try to create better user experiences than the default browser behavior. Keep going, we'll get there, but we won\u2019t have to change any of the code we've already written to get the core functionality.\n\n### Form Validation\n\nIt's common to validate forms both client-side and server-side. It's also (unfortunately) common to only validate client-side, which leads to various issues with your data that we don't have time to get into right now. Point is, if you're validating in only one place, do it on the server. You'll find with Remix that's the only place you care to anymore (the less you send to the browser the better!).\n\nWe know, we know, you want to animate in nice validation errors and stuff. We'll get to that. But right now we're just building a basic HTML form and user flow. We'll keep it simple first, then make it fancy.\n\nBack in our action, maybe we have an API that returns validation errors like this.\n\n```\nconst [errors, project] = await createProject(formData);\n```\n\nIf there are validation errors, we want to go back to the form and display them.\n\n```\nimport { json, redirect } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport const action = async ({\n  request,\n}: ActionFunctionArgs) => {\n  const formData = await request.formData();\n  const [errors, project] = await createProject(formData);\n\n  if (errors) {\n    const values = Object.fromEntries(formData);\n    return json({ errors, values });\n  }\n\n  return redirect(`/projects/${project.id}`);\n};\n```\n\nJust like `useLoaderData` returns the values from the `loader`, `useActionData` will return the data from the action. It will only be there if the navigation was a form submission, so you always have to check if you've got it or not.\n\n```\nimport type { ActionFunctionArgs } from \"@remix-run/node\"; // or cloudflare/deno\nimport { json, redirect } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useActionData } from \"@remix-run/react\";\n\nexport const action = async ({\n  request,\n}: ActionFunctionArgs) => {\n  // ...\n};\n\nexport default function NewProject() {\n  const actionData = useActionData<typeof action>();\n\n  return (\n    <form method=\"post\" action=\"/projects/new\">\n      <p>\n        <label>\n          Name:{\" \"}\n          <input\n            name=\"name\"\n            type=\"text\"\n            defaultValue={actionData?.values.name}\n          />\n        </label>\n      </p>\n\n      {actionData?.errors.name ? (\n        <p style={{ color: \"red\" }}>\n          {actionData.errors.name}\n        </p>\n      ) : null}\n\n      <p>\n        <label>\n          Description:\n          <br />\n          <textarea\n            name=\"description\"\n            defaultValue={actionData?.values.description}\n          />\n        </label>\n      </p>\n\n      {actionData?.errors.description ? (\n        <p style={{ color: \"red\" }}>\n          {actionData.errors.description}\n        </p>\n      ) : null}\n\n      <p>\n        <button type=\"submit\">Create</button>\n      </p>\n    </form>\n  );\n}\n```\n\nNotice how we add `defaultValue` to all of our inputs. Remember, this is regular HTML `<form>`, so it's just normal browser/server stuff happening. We're getting the values back from the server so the user doesn't have to re-type what they had.\n\nYou can ship this code as-is. The browser will handle the pending UI and interruptions for you. Enjoy your weekend and make it fancy on Monday.\n\n### Graduate to `<Form>` and add pending UI\n\nLet's use progressive enhancement to make this UX a bit more fancy. By changing it from `<form>` to `<Form>`, Remix will emulate the browser behavior with `fetch`. It will also give you access to the pending form data, so you can build pending UI.\n\n```\nimport { json, redirect } from \"@remix-run/node\"; // or cloudflare/deno\nimport { useActionData, Form } from \"@remix-run/react\";\n\n// ...\n\nexport default function NewProject() {\n  const actionData = useActionData<typeof action>();\n\n  return (\n    // note the capital \"F\" <Form> now\n    <Form method=\"post\">{/* ... */}</Form>\n  );\n}\n```\n\nHOLD UP! If all you do is change your form to Form, you made the UX a little worse!\n\nIf you don't have the time or drive to do the rest of the job here, use `<Form reloadDocument>`. This lets the browser continue to handle the pending UI state (spinner in the favicon of the tab, progress bar in the address bar, etc.) If you simply use `<Form>` without implementing pending UI, the user will have no idea anything is happening when they submit a form.\n\nWe recommend always using capital-F Form, and if you want to let the browser handle the pending UI, use the `<Form reloadDocument>` prop.\n\nNow let's add some pending UI so the user has a clue something happened when they submit. There's a hook called `useNavigation`. When there is a pending form submission, Remix will give you the serialized version of the form as a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object. You'll be most interested in the [`formData.get()`](https://developer.mozilla.org/en-US/docs/Web/API/FormData/get) method.\n\n```\nimport { json, redirect } from \"@remix-run/node\"; // or cloudflare/deno\nimport {\n  useActionData,\n  Form,\n  useNavigation,\n} from \"@remix-run/react\";\n\n// ...\n\nexport default function NewProject() {\n  // when the form is being processed on the server, this returns different\n  // navigation states to help us build pending and optimistic UI.\n  const navigation = useNavigation();\n  const actionData = useActionData<typeof action>();\n\n  return (\n    <Form method=\"post\">\n      <fieldset\n        disabled={navigation.state === \"submitting\"}\n      >\n        <p>\n          <label>\n            Name:{\" \"}\n            <input\n              name=\"name\"\n              type=\"text\"\n              defaultValue={\n                actionData\n                  ? actionData.values.name\n                  : undefined\n              }\n            />\n          </label>\n        </p>\n\n        {actionData && actionData.errors.name ? (\n          <p style={{ color: \"red\" }}>\n            {actionData.errors.name}\n          </p>\n        ) : null}\n\n        <p>\n          <label>\n            Description:\n            <br />\n            <textarea\n              name=\"description\"\n              defaultValue={\n                actionData\n                  ? actionData.values.description\n                  : undefined\n              }\n            />\n          </label>\n        </p>\n\n        {actionData && actionData.errors.description ? (\n          <p style={{ color: \"red\" }}>\n            {actionData.errors.description}\n          </p>\n        ) : null}\n\n        <p>\n          <button type=\"submit\">\n            {navigation.state === \"submitting\"\n              ? \"Creating...\"\n              : \"Create\"}\n          </button>\n        </p>\n      </fieldset>\n    </Form>\n  );\n}\n```\n\nPretty slick! Now when the user clicks \"Create\", the inputs go disabled, and the submit button's text changes. The whole operation should be faster now too since there's just one network request happening instead of a full page reload (which involves potentially more network requests, reading assets from the browser cache, parsing JavaScript, parsing CSS, etc.).\n\nWe didn't do much with `navigation` on this page, but it's got all the information about the submission (`navigation.formMethod`, `navigation.formAction`, `navigation.formEncType`), as well as all the values being processed on the server on `navigation.formData`.\n\n### Animating in the Validation Errors\n\nNow that we're using JavaScript to submit this page, our validation errors can be animated in because the page is stateful. First we'll make a fancy component that animates height and opacity:\n\n```\nfunction ValidationMessage({ error, isSubmitting }) {\n  const [show, setShow] = useState(!!error);\n\n  useEffect(() => {\n    const id = setTimeout(() => {\n      const hasError = !!error;\n      setShow(hasError && !isSubmitting);\n    });\n    return () => clearTimeout(id);\n  }, [error, isSubmitting]);\n\n  return (\n    <div\n      style={{\n        opacity: show ? 1 : 0,\n        height: show ? \"1em\" : 0,\n        color: \"red\",\n        transition: \"all 300ms ease-in-out\",\n      }}\n    >\n      {error}\n    </div>\n  );\n}\n```\n\nNow we can wrap our old error messages in this new fancy component, and even turn the borders of our fields red that have errors:\n\n```\nexport default function NewProject() {\n  const navigation = useNavigation();\n  const actionData = useActionData<typeof action>();\n\n  return (\n    <Form method=\"post\">\n      <fieldset\n        disabled={navigation.state === \"submitting\"}\n      >\n        <p>\n          <label>\n            Name:{\" \"}\n            <input\n              name=\"name\"\n              type=\"text\"\n              defaultValue={\n                actionData\n                  ? actionData.values.name\n                  : undefined\n              }\n              style={{\n                borderColor: actionData?.errors.name\n                  ? \"red\"\n                  : \"\",\n              }}\n            />\n          </label>\n        </p>\n\n        {actionData?.errors.name ? (\n          <ValidationMessage\n            isSubmitting={navigation.state === \"submitting\"}\n            error={actionData?.errors?.name}\n          />\n        ) : null}\n\n        <p>\n          <label>\n            Description:\n            <br />\n            <textarea\n              name=\"description\"\n              defaultValue={actionData?.values.description}\n              style={{\n                borderColor: actionData?.errors.description\n                  ? \"red\"\n                  : \"\",\n              }}\n            />\n          </label>\n        </p>\n\n        <ValidationMessage\n          isSubmitting={navigation.state === \"submitting\"}\n          error={actionData?.errors.description}\n        />\n\n        <p>\n          <button type=\"submit\">\n            {navigation.state === \"submitting\"\n              ? \"Creating...\"\n              : \"Create\"}\n          </button>\n        </p>\n      </fieldset>\n    </Form>\n  );\n}\n```\n\nBoom! Fancy UI without having to change anything about how we communicate with the server. It's also resilient to network conditions that prevent JS from loading.\n\n### Review\n\n- First we built the project form without JavaScript in mind. A simple form, posting to a server-side action. Welcome to 1998.\n- Once that worked, we used JavaScript to submit the form by changing `<form>` to `<Form>`, but we didn't have to do anything else!\n- Now that there was a stateful page with React, we added loading indicators and animation for the validation errors by simply asking Remix for the state of the navigation.\n\nFrom your components perspective, all that happened was the `useNavigation` hook caused a state update when the form was submitted, and then another state update when the data came back. Of course, a lot more happened inside of Remix, but as far as your component is concerned, that's it. Just a couple of state updates. This makes it really easy to dress up any user flow.\n\n## See also\n\n- [Form](../components/form)\n- [useNavigation](../hooks/use-navigation)\n- [Actions](../route/action)\n- [Loaders](../route/loader)\n- [`useSubmit()`](../hooks/use-submit)\n- [`useFetcher()`](../hooks/use-fetcher)\n\n\u00a9 [Shopify, Inc.](https://remix.run)\n\n\u2022\n\nDocs and examples licensed under [MIT](https://opensource.org/licenses/MIT)\n\n[Edit](https://github.com/remix-run/remix-v2-website/edit/main/data/docs/guides/data-writes.md)\n\n![](/assets/icons-CZ8v8NWl.svg)",
  "tags": [
    "remix",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:55:27.809844+00:00",
  "content_length": 18457,
  "content_hash": "71fa17ff5d9964d9"
}