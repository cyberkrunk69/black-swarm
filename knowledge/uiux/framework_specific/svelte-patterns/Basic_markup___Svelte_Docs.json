{
  "id": "svelte-patterns__docs_basic-markup",
  "source_id": "svelte-patterns",
  "source_name": "Svelte Patterns",
  "category": "framework_specific",
  "url": "https://svelte.dev/docs/basic-markup",
  "title": "Basic markup \u2022 Svelte Docs",
  "content": "Markup inside a Svelte component can be thought of as HTML++.\nTags\nA lowercase tag, like\n<div>\n, denotes a regular HTML element. A capitalised tag or a tag that uses dot notation, such as\n<Widget>\nor\n<my.stuff>\n, indicates a\ncomponent\n.\n<\nscript\n>\nimport\nWidget\nfrom\n'./Widget.svelte'\n;\n</\nscript\n>\n<\ndiv\n>\n<\nWidget\n/>\n</\ndiv\n>\nElement attributes\nBy default, attributes work exactly like their HTML counterparts.\n<\ndiv\nclass\n=\n\"foo\"\n>\n<\nbutton\ndisabled\n>can't touch this</\nbutton\n>\n</\ndiv\n>\nAs in HTML, values may be unquoted.\n<\ninput\ntype\n=\ncheckbox\n/>\nAttribute values can contain JavaScript expressions.\n<\na\nhref\n=\n\"page/{\np\n}\"\n>page {p}</\na\n>\nOr they can\nbe\nJavaScript expressions.\n<\nbutton\ndisabled\n=\n{\n!\nclickable}>...</\nbutton\n>\nBoolean attributes are included on the element if their value is\ntruthy\nand excluded if it\u2019s\nfalsy\n.\nAll other attributes are included unless their value is\nnullish\n(\nnull\nor\nundefined\n).\n<\ninput\nrequired\n=\n{\nfalse\n}\nplaceholder\n=\n\"This input field is not required\"\n/>\n<\ndiv\ntitle\n=\n{\nnull\n}>This div has no title attribute</\ndiv\n>\nQuoting a singular expression does not affect how the value is parsed, but in Svelte 6 it will cause the value to be coerced to a string:\n<\nbutton\ndisabled\n=\n\"{\nnumber\n!==\n42\n}\"\n>...</\nbutton\n>\nWhen the attribute name and value match (\nname={name}\n), they can be replaced with\n{name}\n.\n<\nbutton\n{\ndisabled\n}\n>...</\nbutton\n>\n<!-- equivalent to\n<button disabled={disabled}>...</button>\n-->\nComponent props\nBy convention, values passed to components are referred to as\nproperties\nor\nprops\nrather than\nattributes\n, which are a feature of the DOM.\nAs with elements,\nname={name}\ncan be replaced with the\n{name}\nshorthand.\n<\nWidget\nfoo\n=\n{bar}\nanswer\n=\n{\n42\n}\ntext\n=\n\"hello\"\n/>\nSpread attributes\nSpread attributes\nallow many attributes or properties to be passed to an element or component at once.\nAn element or component can have multiple spread attributes, interspersed with regular ones. Order matters \u2014 if\nthings.a\nexists it will take precedence over\na=\"b\"\n, while\nc=\"d\"\nwould take precedence over\nthings.c\n:\n<\nWidget\na\n=\n\"b\"\n{\n...\nthings\n}\nc\n=\n\"d\"\n/>\nEvents\nListening to DOM events is possible by adding attributes to the element that start with\non\n. For example, to listen to the\nclick\nevent, add the\nonclick\nattribute to a button:\n<\nbutton\nonclick\n=\n{()\n=>\nconsole\n.log\n(\n'clicked'\n)}>click me</\nbutton\n>\nEvent attributes are case sensitive.\nonclick\nlistens to the\nclick\nevent,\nonClick\nlistens to the\nClick\nevent, which is different. This ensures you can listen to custom events that have uppercase characters in them.\nBecause events are just attributes, the same rules as for attributes apply:\nyou can use the shorthand form:\n<button {onclick}>click me</button>\nyou can spread them:\n<button {...thisSpreadContainsEventAttributes}>click me</button>\nTiming-wise, event attributes always fire after events from bindings (e.g.\noninput\nalways fires after an update to\nbind:value\n). Under the hood, some event handlers are attached directly with\naddEventListener\n, while others are\ndelegated\n.\nWhen using\nontouchstart\nand\nontouchmove\nevent attributes, the handlers are\npassive\nfor better performance. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls\nevent.preventDefault()\n.\nIn the very rare cases that you need to prevent these event defaults, you should use\non\ninstead (for example inside an action).\nEvent delegation\nTo reduce memory footprint and increase performance, Svelte uses a technique called event delegation. This means that for certain events \u2014 see the list below \u2014 a single event listener at the application root takes responsibility for running any handlers on the event\u2019s path.\nThere are a few gotchas to be aware of:\nwhen you manually dispatch an event with a delegated listener, make sure to set the\n{ bubbles: true }\noption or it won\u2019t reach the application root\nwhen using\naddEventListener\ndirectly, avoid calling\nstopPropagation\nor the event won\u2019t reach the application root and handlers won\u2019t be invoked. Similarly, handlers added manually inside the application root will run\nbefore\nhandlers added declaratively deeper in the DOM (with e.g.\nonclick={...}\n), in both capturing and bubbling phases. For these reasons it\u2019s better to use the\non\nfunction imported from\nsvelte/events\nrather than\naddEventListener\n, as it will ensure that order is preserved and\nstopPropagation\nis handled correctly.\nThe following event handlers are delegated:\nbeforeinput\nclick\nchange\ndblclick\ncontextmenu\nfocusin\nfocusout\ninput\nkeydown\nkeyup\nmousedown\nmousemove\nmouseout\nmouseover\nmouseup\npointerdown\npointermove\npointerout\npointerover\npointerup\ntouchend\ntouchmove\ntouchstart\nText expressions\nA JavaScript expression can be included as text by surrounding it with curly braces.\n{expression}\nExpressions that are\nnull\nor\nundefined\nwill be omitted; all others are\ncoerced to strings\n.\nCurly braces can be included in a Svelte template by using their\nHTML entity\nstrings:\n&lbrace;\n,\n&lcub;\n, or\n&#123;\nfor\n{\nand\n&rbrace;\n,\n&rcub;\n, or\n&#125;\nfor\n}\n.\nIf you\u2019re using a regular expression (\nRegExp\n)\nliteral notation\n, you\u2019ll need to wrap it in parentheses.\n<\nh1\n>Hello {name}!</\nh1\n>\n<\np\n>{a} + {b} = {a\n+\nb}.</\np\n>\n<\ndiv\n>{(\n/\n^\n[A-Za-z ]\n+$\n/\n)\n.test\n(value)\n?\nx\n:\ny}</\ndiv\n>\nThe expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the\n{@html}\ntag instead.\n{@\nhtml\npotentiallyUnsafeHtmlString}\nMake sure that you either escape the passed string or only populate it with values that are under your control in order to prevent\nXSS attacks\nComments\nYou can use HTML comments inside components.\n<!-- this is a comment! -->\n<\nh1\n>Hello world</\nh1\n>\nComments beginning with\nsvelte-ignore\ndisable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you\u2019re disabling them for a good reason.\n<!-- svelte-ignore a11y_autofocus -->\n<\ninput\nbind\n:\nvalue\n=\n{name}\nautofocus\n/>\nYou can add a special comment starting with\n@component\nthat will show up when hovering over the component name in other files.\n<!--\n@\ncomponent\n- You can use markdown here.\n- You can also use code blocks here.\n- Usage:\n```html\n<Main name=\"Arethra\">\n```\n-->\n<\nscript\n>\nlet\n{ name }\n=\n$\nprops\n();\n</\nscript\n>\n<\nmain\n>\n<\nh1\n>\nHello, {name}\n</\nh1\n>\n</\nmain\n>\nEdit this page on GitHub\nllms.txt\nprevious\nnext\n$host\n{#if ...}",
  "content_markdown": "Markup inside a Svelte component can be thought of as HTML++.\n\n## Tags\n\nA lowercase tag, like `<div>`, denotes a regular HTML element. A capitalised tag or a tag that uses dot notation, such as `<Widget>` or `<my.stuff>`, indicates a *component*.\n\n```\n<script>\n\timport Widget from './Widget.svelte';\n</script>\n\n<div>\n\t<Widget />\n</div>\n```\n\n## Element attributes\n\nBy default, attributes work exactly like their HTML counterparts.\n\n```\n<div class=\"foo\">\n\t<button disabled>can't touch this</button>\n</div>\n```\n\nAs in HTML, values may be unquoted.\n\n```\n<input type=checkbox />\n```\n\nAttribute values can contain JavaScript expressions.\n\n```\n<a href=\"page/{p}\">page {p}</a>\n```\n\nOr they can *be* JavaScript expressions.\n\n```\n<button disabled={!clickable}>...</button>\n```\n\nBoolean attributes are included on the element if their value is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and excluded if it\u2019s [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).\n\nAll other attributes are included unless their value is [nullish](https://developer.mozilla.org/en-US/docs/Glossary/Nullish) (`null` or `undefined`).\n\n```\n<input required={false} placeholder=\"This input field is not required\" />\n<div title={null}>This div has no title attribute</div>\n```\n\n> Quoting a singular expression does not affect how the value is parsed, but in Svelte 6 it will cause the value to be coerced to a string:\n>\n> ```\n> <button disabled=\"{number !== 42}\">...</button>\n> ```\n\nWhen the attribute name and value match (`name={name}`), they can be replaced with `{name}`.\n\n```\n<button {disabled}>...</button>\n<!-- equivalent to\n<button disabled={disabled}>...</button>\n-->\n```\n\n## Component props\n\nBy convention, values passed to components are referred to as *properties* or *props* rather than *attributes*, which are a feature of the DOM.\n\nAs with elements, `name={name}` can be replaced with the `{name}` shorthand.\n\n```\n<Widget foo={bar} answer={42} text=\"hello\" />\n```\n\n## Spread attributes\n\n*Spread attributes* allow many attributes or properties to be passed to an element or component at once.\n\nAn element or component can have multiple spread attributes, interspersed with regular ones. Order matters \u2014 if `things.a` exists it will take precedence over `a=\"b\"`, while `c=\"d\"` would take precedence over `things.c`:\n\n```\n<Widget a=\"b\" {...things} c=\"d\" />\n```\n\n## Events\n\nListening to DOM events is possible by adding attributes to the element that start with `on`. For example, to listen to the `click` event, add the `onclick` attribute to a button:\n\n```\n<button onclick={() => console.log('clicked')}>click me</button>\n```\n\nEvent attributes are case sensitive. `onclick` listens to the `click` event, `onClick` listens to the `Click` event, which is different. This ensures you can listen to custom events that have uppercase characters in them.\n\nBecause events are just attributes, the same rules as for attributes apply:\n\n- you can use the shorthand form: `<button {onclick}>click me</button>`\n- you can spread them: `<button {...thisSpreadContainsEventAttributes}>click me</button>`\n\nTiming-wise, event attributes always fire after events from bindings (e.g. `oninput` always fires after an update to `bind:value`). Under the hood, some event handlers are attached directly with `addEventListener`, while others are *delegated*.\n\nWhen using `ontouchstart` and `ontouchmove` event attributes, the handlers are [passive](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#using_passive_listeners) for better performance. This greatly improves responsiveness by allowing the browser to scroll the document immediately, rather than waiting to see if the event handler calls `event.preventDefault()`.\n\nIn the very rare cases that you need to prevent these event defaults, you should use [`on`](svelte-events#on) instead (for example inside an action).\n\n### Event delegation\n\nTo reduce memory footprint and increase performance, Svelte uses a technique called event delegation. This means that for certain events \u2014 see the list below \u2014 a single event listener at the application root takes responsibility for running any handlers on the event\u2019s path.\n\nThere are a few gotchas to be aware of:\n\n- when you manually dispatch an event with a delegated listener, make sure to set the `{ bubbles: true }` option or it won\u2019t reach the application root\n- when using `addEventListener` directly, avoid calling `stopPropagation` or the event won\u2019t reach the application root and handlers won\u2019t be invoked. Similarly, handlers added manually inside the application root will run *before* handlers added declaratively deeper in the DOM (with e.g. `onclick={...}`), in both capturing and bubbling phases. For these reasons it\u2019s better to use the `on` function imported from `svelte/events` rather than `addEventListener`, as it will ensure that order is preserved and `stopPropagation` is handled correctly.\n\nThe following event handlers are delegated:\n\n- `beforeinput`\n- `click`\n- `change`\n- `dblclick`\n- `contextmenu`\n- `focusin`\n- `focusout`\n- `input`\n- `keydown`\n- `keyup`\n- `mousedown`\n- `mousemove`\n- `mouseout`\n- `mouseover`\n- `mouseup`\n- `pointerdown`\n- `pointermove`\n- `pointerout`\n- `pointerover`\n- `pointerup`\n- `touchend`\n- `touchmove`\n- `touchstart`\n\n## Text expressions\n\nA JavaScript expression can be included as text by surrounding it with curly braces.\n\n```\n{expression}\n```\n\nExpressions that are `null` or `undefined` will be omitted; all others are [coerced to strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_coercion).\n\nCurly braces can be included in a Svelte template by using their [HTML entity](https://developer.mozilla.org/docs/Glossary/Entity) strings: `&lbrace;`, `&lcub;`, or `&#123;` for `{` and `&rbrace;`, `&rcub;`, or `&#125;` for `}`.\n\nIf you\u2019re using a regular expression (`RegExp`) [literal notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#literal_notation_and_constructor), you\u2019ll need to wrap it in parentheses.\n\n```\n<h1>Hello {name}!</h1>\n<p>{a} + {b} = {a + b}.</p>\n\n<div>{(/^[A-Za-z ]+$/).test(value) ? x : y}</div>\n```\n\nThe expression will be stringified and escaped to prevent code injections. If you want to render HTML, use the `{@html}` tag instead.\n\n```\n{@html potentiallyUnsafeHtmlString}\n```\n\n> Make sure that you either escape the passed string or only populate it with values that are under your control in order to prevent [XSS attacks](https://owasp.org/www-community/attacks/xss/)\n\n## Comments\n\nYou can use HTML comments inside components.\n\n```\n<!-- this is a comment! --><h1>Hello world</h1>\n```\n\nComments beginning with `svelte-ignore` disable warnings for the next block of markup. Usually, these are accessibility warnings; make sure that you\u2019re disabling them for a good reason.\n\n```\n<!-- svelte-ignore a11y_autofocus -->\n<input bind:value={name} autofocus />\n```\n\nYou can add a special comment starting with `@component` that will show up when hovering over the component name in other files.\n\n```\n<!--\n@component\n- You can use markdown here.\n- You can also use code blocks here.\n- Usage:\n  ```html\n  <Main name=\"Arethra\">\n  ```\n-->\n<script>\n\tlet { name } = $props();\n</script>\n\n<main>\n\t<h1>\n\t\tHello, {name}\n\t</h1>\n</main>\n```\n\n[Edit this page on GitHub](https://github.com/sveltejs/svelte/edit/main/documentation/docs/03-template-syntax/01-basic-markup.md)  [llms.txt](/docs/svelte/basic-markup/llms.txt)\n\nprevious next\n\n[$host](/docs/svelte/$host) [{#if ...}](/docs/svelte/if)",
  "tags": [
    "svelte",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:18.073081+00:00",
  "content_length": 6444,
  "content_hash": "3460195c13d317e8"
}