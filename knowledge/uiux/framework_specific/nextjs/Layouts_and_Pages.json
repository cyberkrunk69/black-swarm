{
  "id": "nextjs__docs_app_building-your-application_routing",
  "source_id": "nextjs",
  "source_name": "Next.js Documentation",
  "category": "framework_specific",
  "url": "https://nextjs.org/docs/app/building-your-application/routing",
  "title": "Layouts and Pages",
  "content": "Menu\nUsing App Router\nFeatures available in /app\nLatest Version\n16.1.6\nApp Router\nGetting Started\nLayouts and Pages\nCopy page\nLayouts and Pages\nLast updated\nNovember 17, 2025\nNext.js uses\nfile-system based routing\n, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\nCreating a page\nA\npage\nis UI that is rendered on a specific route. To create a page, add a\npage\nfile\ninside the\napp\ndirectory and default export a React component. For example, to create an index page (\n/\n):\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nfunction\nPage\n() {\nreturn\n<\nh1\n>Hello Next.js!</\nh1\n>\n}\nCreating a layout\nA layout is UI that is\nshared\nbetween multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\nYou can define a layout by default exporting a React component from a\nlayout\nfile\n. The component should accept a\nchildren\nprop which can be a page or another\nlayout\n.\nFor example, to create a layout that accepts your index page as child, add a\nlayout\nfile inside the\napp\ndirectory:\napp/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nfunction\nDashboardLayout\n({\nchildren\n,\n}\n:\n{\nchildren\n:\nReact\n.\nReactNode\n}) {\nreturn\n(\n<\nhtml\nlang\n=\n\"en\"\n>\n<\nbody\n>\n{\n/* Layout UI */\n}\n{\n/* Place children where you want to render a page or nested layout */\n}\n<\nmain\n>{children}</\nmain\n>\n</\nbody\n>\n</\nhtml\n>\n)\n}\nThe layout above is called a\nroot layout\nbecause it's defined at the root of the\napp\ndirectory. The root layout is\nrequired\nand must contain\nhtml\nand\nbody\ntags.\nCreating a nested route\nA nested route is a route composed of multiple URL segments. For example, the\n/blog/[slug]\nroute is composed of three segments:\n/\n(Root Segment)\nblog\n(Segment)\n[slug]\n(Leaf Segment)\nIn Next.js:\nFolders\nare used to define the route segments that map to URL segments.\nFiles\n(like\npage\nand\nlayout\n) are used to create UI that is shown for a segment.\nTo create nested routes, you can nest folders inside each other. For example, to add a route for\n/blog\n, create a folder called\nblog\nin the\napp\ndirectory. Then, to make\n/blog\npublicly accessible, add a\npage.tsx\nfile:\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\n// Dummy imports\nimport\n{ getPosts }\nfrom\n'@/lib/posts'\nimport\n{ Post }\nfrom\n'@/ui/post'\nexport\ndefault\nasync\nfunction\nPage\n() {\nconst\nposts\n=\nawait\ngetPosts\n()\nreturn\n(\n<\nul\n>\n{\nposts\n.map\n((post)\n=>\n(\n<\nPost\nkey\n=\n{\npost\n.id}\npost\n=\n{post} />\n))}\n</\nul\n>\n)\n}\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new\n[slug]\nfolder inside\nblog\nand add a\npage\nfile:\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nfunction\ngenerateStaticParams\n() {}\nexport\ndefault\nfunction\nPage\n() {\nreturn\n<\nh1\n>Hello, Blog Post Page!</\nh1\n>\n}\nWrapping a folder name in square brackets (e.g.\n[slug]\n) creates a\ndynamic route segment\nwhich is used to generate multiple pages from data. e.g. blog posts, product pages, etc.\nNesting layouts\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their\nchildren\nprop. You can nest layouts by adding\nlayout\ninside specific route segments (folders).\nFor example, to create a layout for the\n/blog\nroute, add a new\nlayout\nfile inside the\nblog\nfolder.\napp/blog/layout.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nfunction\nBlogLayout\n({\nchildren\n,\n}\n:\n{\nchildren\n:\nReact\n.\nReactNode\n}) {\nreturn\n<\nsection\n>{children}</\nsection\n>\n}\nIf you were to combine the two layouts above, the root layout (\napp/layout.js\n) would wrap the blog layout (\napp/blog/layout.js\n), which would wrap the blog (\napp/blog/page.js\n) and blog post page (\napp/blog/[slug]/page.js\n).\nCreating a dynamic segment\nDynamic segments\nallow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.\nTo create a dynamic segment, wrap the segment (folder) name in square brackets:\n[segmentName]\n. For example, in the\napp/blog/[slug]/page.tsx\nroute, the\n[slug]\nis the dynamic segment.\napp/blog/[slug]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nasync\nfunction\nBlogPostPage\n({\nparams\n,\n}\n:\n{\nparams\n:\nPromise\n<{ slug\n:\nstring\n}>\n}) {\nconst\n{\nslug\n}\n=\nawait\nparams\nconst\npost\n=\nawait\ngetPost\n(slug)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>{\npost\n.title}</\nh1\n>\n<\np\n>{\npost\n.content}</\np\n>\n</\ndiv\n>\n)\n}\nLearn more about\nDynamic Segments\nand the\nparams\nprops.\nNested\nlayouts within Dynamic Segments\n, can also access the\nparams\nprops.\nRendering with search params\nIn a Server Component\npage\n, you can access search parameters using the\nsearchParams\nprop:\napp/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nasync\nfunction\nPage\n({\nsearchParams\n,\n}\n:\n{\nsearchParams\n:\nPromise\n<{ [key\n:\nstring\n]\n:\nstring\n|\nstring\n[]\n|\nundefined\n}>\n}) {\nconst\nfilters\n=\n(\nawait\nsearchParams).filters\n}\nUsing\nsearchParams\nopts your page into\ndynamic rendering\nbecause it requires an incoming request to read the search parameters from.\nClient Components can read search params using the\nuseSearchParams\nhook.\nLearn more about\nuseSearchParams\nin\nstatically rendered\nand\ndynamically rendered\nroutes.\nWhat to use and when\nUse the\nsearchParams\nprop when you need search parameters to\nload data for the page\n(e.g. pagination, filtering from a database).\nUse\nuseSearchParams\nwhen search parameters are used\nonly on the client\n(e.g. filtering a list already loaded via props).\nAs a small optimization, you can use\nnew URLSearchParams(window.location.search)\nin\ncallbacks or event handlers\nto read search params without triggering re-renders.\nLinking between pages\nYou can use the\n<Link>\ncomponent\nto navigate between routes.\n<Link>\nis a built-in Next.js component that extends the HTML\n<a>\ntag to provide\nprefetching\nand\nclient-side navigation\n.\nFor example, to generate a list of blog posts, import\n<Link>\nfrom\nnext/link\nand pass a\nhref\nprop to the component:\napp/ui/post.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\nLink\nfrom\n'next/link'\nexport\ndefault\nasync\nfunction\nPost\n({ post }) {\nconst\nposts\n=\nawait\ngetPosts\n()\nreturn\n(\n<\nul\n>\n{\nposts\n.map\n((post)\n=>\n(\n<\nli\nkey\n=\n{\npost\n.slug}>\n<\nLink\nhref\n=\n{\n`/blog/\n${\npost\n.slug\n}\n`\n}>{\npost\n.title}</\nLink\n>\n</\nli\n>\n))}\n</\nul\n>\n)\n}\nGood to know\n:\n<Link>\nis the primary way to navigate between routes in Next.js. You can also use the\nuseRouter\nhook\nfor more advanced navigation.\nRoute Props Helpers\nNext.js exposes utility types that infer\nparams\nand named slots from your route structure:\nPageProps\n: Props for\npage\ncomponents, including\nparams\nand\nsearchParams\n.\nLayoutProps\n: Props for\nlayout\ncomponents, including\nchildren\nand any named slots (e.g. folders like\n@analytics\n).\nThese are globally available helpers, generated when running either\nnext dev\n,\nnext build\nor\nnext typegen\n.\napp/blog/[slug]/page.tsx\nexport\ndefault\nasync\nfunction\nPage\n(props\n:\nPageProps\n<\n'/\nblog\n/[slug]'\n>) {\nconst\n{\nslug\n}\n=\nawait\nprops\n.params\nreturn\n<\nh1\n>Blog post: {slug}</\nh1\n>\n}\napp/dashboard/layout.tsx\nexport\ndefault\nfunction\nLayout\n(props\n:\nLayoutProps\n<\n'/\ndashboard\n'\n>) {\nreturn\n(\n<\nsection\n>\n{\nprops\n.children}\n{\n/* If you have app/\ndashboard\n/@analytics, it appears as a typed slot: */\n}\n{\n/* {props.analytics} */\n}\n</\nsection\n>\n)\n}\nGood to know\nStatic routes resolve\nparams\nto\n{}\n.\nPageProps\n,\nLayoutProps\nare global helpers \u2014 no imports required.\nTypes are generated during\nnext dev\n,\nnext build\nor\nnext typegen\n.\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nLinking and Navigating\nLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.\nlayout.js\nAPI reference for the layout.js file.\npage.js\nAPI reference for the page.js file.\nLink Component\nEnable fast client-side navigation with the built-in `next/link` component.\nDynamic Segments\nDynamic Route Segments can be used to programmatically generate route segments from dynamic data.\nWas this helpful?\nsupported.\nSend",
  "content_markdown": "Menu\n\nUsing App Router\n\nFeatures available in /app\n\nLatest Version\n\n16.1.6\n\n[App Router](/docs/app)[Getting Started](/docs/app/getting-started)Layouts and Pages\n\nCopy page\n\n# Layouts and Pages\n\nLast updated November 17, 2025\n\nNext.js uses **file-system based routing**, meaning you can use folders and files to define routes. This page will guide you through how to create layouts and pages, and link between them.\n\n## Creating a page\n\nA **page** is UI that is rendered on a specific route. To create a page, add a [`page` file](/docs/app/api-reference/file-conventions/page) inside the `app` directory and default export a React component. For example, to create an index page (`/`):\n\n![page.js special file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fpage-special-file.png&w=3840&q=75)![page.js special file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fpage-special-file.png&w=3840&q=75)\n\napp/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default function Page() {\n  return <h1>Hello Next.js!</h1>\n}\n```\n\n## Creating a layout\n\nA layout is UI that is **shared** between multiple pages. On navigation, layouts preserve state, remain interactive, and do not rerender.\n\nYou can define a layout by default exporting a React component from a [`layout` file](/docs/app/api-reference/file-conventions/layout). The component should accept a `children` prop which can be a page or another [layout](#nesting-layouts).\n\nFor example, to create a layout that accepts your index page as child, add a `layout` file inside the `app` directory:\n\n![layout.js special file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Flayout-special-file.png&w=3840&q=75)![layout.js special file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Flayout-special-file.png&w=3840&q=75)\n\napp/layout.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default function DashboardLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {/* Layout UI */}\n        {/* Place children where you want to render a page or nested layout */}\n        <main>{children}</main>\n      </body>\n    </html>\n  )\n}\n```\n\nThe layout above is called a [root layout](/docs/app/api-reference/file-conventions/layout#root-layout) because it's defined at the root of the `app` directory. The root layout is **required** and must contain `html` and `body` tags.\n\n## Creating a nested route\n\nA nested route is a route composed of multiple URL segments. For example, the `/blog/[slug]` route is composed of three segments:\n\n- `/` (Root Segment)\n- `blog` (Segment)\n- `[slug]` (Leaf Segment)\n\nIn Next.js:\n\n- **Folders** are used to define the route segments that map to URL segments.\n- **Files** (like `page` and `layout`) are used to create UI that is shown for a segment.\n\nTo create nested routes, you can nest folders inside each other. For example, to add a route for `/blog`, create a folder called `blog` in the `app` directory. Then, to make `/blog` publicly accessible, add a `page.tsx` file:\n\n![File hierarchy showing blog folder and a page.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fblog-nested-route.png&w=3840&q=75)![File hierarchy showing blog folder and a page.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fblog-nested-route.png&w=3840&q=75)\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n// Dummy imports\nimport { getPosts } from '@/lib/posts'\nimport { Post } from '@/ui/post'\n \nexport default async function Page() {\n  const posts = await getPosts()\n \n  return (\n    <ul>\n      {posts.map((post) => (\n        <Post key={post.id} post={post} />\n      ))}\n    </ul>\n  )\n}\n```\n\nYou can continue nesting folders to create nested routes. For example, to create a route for a specific blog post, create a new `[slug]` folder inside `blog` and add a `page` file:\n\n![File hierarchy showing blog folder with a nested slug folder and a page.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fblog-post-nested-route.png&w=3840&q=75)![File hierarchy showing blog folder with a nested slug folder and a page.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fblog-post-nested-route.png&w=3840&q=75)\n\napp/blog/[slug]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nfunction generateStaticParams() {}\n \nexport default function Page() {\n  return <h1>Hello, Blog Post Page!</h1>\n}\n```\n\nWrapping a folder name in square brackets (e.g. `[slug]`) creates a [dynamic route segment](/docs/app/api-reference/file-conventions/dynamic-routes) which is used to generate multiple pages from data. e.g. blog posts, product pages, etc.\n\n## Nesting layouts\n\nBy default, layouts in the folder hierarchy are also nested, which means they wrap child layouts via their `children` prop. You can nest layouts by adding `layout` inside specific route segments (folders).\n\nFor example, to create a layout for the `/blog` route, add a new `layout` file inside the `blog` folder.\n\n![File hierarchy showing root layout wrapping the blog layout](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fnested-layouts.png&w=3840&q=75)![File hierarchy showing root layout wrapping the blog layout](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fnested-layouts.png&w=3840&q=75)\n\napp/blog/layout.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return <section>{children}</section>\n}\n```\n\nIf you were to combine the two layouts above, the root layout (`app/layout.js`) would wrap the blog layout (`app/blog/layout.js`), which would wrap the blog (`app/blog/page.js`) and blog post page (`app/blog/[slug]/page.js`).\n\n## Creating a dynamic segment\n\n[Dynamic segments](/docs/app/api-reference/file-conventions/dynamic-routes) allow you to create routes that are generated from data. For example, instead of manually creating a route for each individual blog post, you can create a dynamic segment to generate the routes based on blog post data.\n\nTo create a dynamic segment, wrap the segment (folder) name in square brackets: `[segmentName]`. For example, in the `app/blog/[slug]/page.tsx` route, the `[slug]` is the dynamic segment.\n\napp/blog/[slug]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default async function BlogPostPage({\n  params,\n}: {\n  params: Promise<{ slug: string }>\n}) {\n  const { slug } = await params\n  const post = await getPost(slug)\n \n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n```\n\nLearn more about [Dynamic Segments](/docs/app/api-reference/file-conventions/dynamic-routes) and the [`params`](/docs/app/api-reference/file-conventions/page#params-optional) props.\n\nNested [layouts within Dynamic Segments](/docs/app/api-reference/file-conventions/layout#params-optional), can also access the `params` props.\n\n## Rendering with search params\n\nIn a Server Component **page**, you can access search parameters using the [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) prop:\n\napp/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default async function Page({\n  searchParams,\n}: {\n  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n}) {\n  const filters = (await searchParams).filters\n}\n```\n\nUsing `searchParams` opts your page into [**dynamic rendering**](/docs/app/guides/caching#dynamic-rendering) because it requires an incoming request to read the search parameters from.\n\nClient Components can read search params using the [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) hook.\n\nLearn more about `useSearchParams` in [statically rendered](/docs/app/api-reference/functions/use-search-params#static-rendering) and [dynamically rendered](/docs/app/api-reference/functions/use-search-params#dynamic-rendering) routes.\n\n### What to use and when\n\n- Use the `searchParams` prop when you need search parameters to **load data for the page** (e.g. pagination, filtering from a database).\n- Use `useSearchParams` when search parameters are used **only on the client** (e.g. filtering a list already loaded via props).\n- As a small optimization, you can use `new URLSearchParams(window.location.search)` in **callbacks or event handlers** to read search params without triggering re-renders.\n\n## Linking between pages\n\nYou can use the [`<Link>` component](/docs/app/api-reference/components/link) to navigate between routes. `<Link>` is a built-in Next.js component that extends the HTML `<a>` tag to provide [prefetching](/docs/app/getting-started/linking-and-navigating#prefetching) and [client-side navigation](/docs/app/getting-started/linking-and-navigating#client-side-transitions).\n\nFor example, to generate a list of blog posts, import `<Link>` from `next/link` and pass a `href` prop to the component:\n\napp/ui/post.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport Link from 'next/link'\n \nexport default async function Post({ post }) {\n  const posts = await getPosts()\n \n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.slug}>\n          <Link href={`/blog/${post.slug}`}>{post.title}</Link>\n        </li>\n      ))}\n    </ul>\n  )\n}\n```\n\n> **Good to know**: `<Link>` is the primary way to navigate between routes in Next.js. You can also use the [`useRouter` hook](/docs/app/api-reference/functions/use-router) for more advanced navigation.\n\n## Route Props Helpers\n\nNext.js exposes utility types that infer `params` and named slots from your route structure:\n\n- [**PageProps**](/docs/app/api-reference/file-conventions/page#page-props-helper): Props for `page` components, including `params` and `searchParams`.\n- [**LayoutProps**](/docs/app/api-reference/file-conventions/layout#layout-props-helper): Props for `layout` components, including `children` and any named slots (e.g. folders like `@analytics`).\n\nThese are globally available helpers, generated when running either `next dev`, `next build` or [`next typegen`](/docs/app/api-reference/cli/next#next-typegen-options).\n\napp/blog/[slug]/page.tsx\n\n```\nexport default async function Page(props: PageProps<'/blog/[slug]'>) {\n  const { slug } = await props.params\n  return <h1>Blog post: {slug}</h1>\n}\n```\n\napp/dashboard/layout.tsx\n\n```\nexport default function Layout(props: LayoutProps<'/dashboard'>) {\n  return (\n    <section>\n      {props.children}\n      {/* If you have app/dashboard/@analytics, it appears as a typed slot: */}\n      {/* {props.analytics} */}\n    </section>\n  )\n}\n```\n\n> **Good to know**\n>\n> - Static routes resolve `params` to `{}`.\n> - `PageProps`, `LayoutProps` are global helpers \u2014 no imports required.\n> - Types are generated during `next dev`, `next build` or `next typegen`.\n\n## API Reference\n\nLearn more about the features mentioned in this page by reading the API Reference.\n\n[### Linking and Navigating\n\nLearn how the built-in navigation optimizations work, including prefetching, prerendering, and client-side navigation, and how to optimize navigation for dynamic routes and slow networks.](/docs/app/getting-started/linking-and-navigating)[### layout.js\n\nAPI reference for the layout.js file.](/docs/app/api-reference/file-conventions/layout)[### page.js\n\nAPI reference for the page.js file.](/docs/app/api-reference/file-conventions/page)[### Link Component\n\nEnable fast client-side navigation with the built-in `next/link` component.](/docs/app/api-reference/components/link)[### Dynamic Segments\n\nDynamic Route Segments can be used to programmatically generate route segments from dynamic data.](/docs/app/api-reference/file-conventions/dynamic-routes)\n\nWas this helpful?\n\nsupported.\n\nSend",
  "tags": [
    "nextjs",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:54:50.151247+00:00",
  "content_length": 8195,
  "content_hash": "d91d530a3ce2ef3a"
}