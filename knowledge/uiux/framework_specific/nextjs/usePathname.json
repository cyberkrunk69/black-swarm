{
  "id": "nextjs__docs_app_api-reference_functions_use-pathname",
  "source_id": "nextjs",
  "source_name": "Next.js Documentation",
  "category": "framework_specific",
  "url": "https://nextjs.org/docs/app/api-reference/functions/use-pathname",
  "title": "usePathname",
  "content": "Menu\nUsing App Router\nFeatures available in /app\nLatest Version\n16.1.6\nAPI Reference\nFunctions\nusePathname\nCopy page\nusePathname\nLast updated\nOctober 22, 2025\nusePathname\nis a\nClient Component\nhook that lets you read the current URL's\npathname\n.\nGood to know\n: When\ncacheComponents\nis enabled\nusePathname\nmay require a\nSuspense\nboundary around it if your route has a dynamic param. If you use\ngenerateStaticParams\nthe\nSuspense\nboundary is optional\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport\n{ usePathname }\nfrom\n'next/navigation'\nexport\ndefault\nfunction\nExampleClientComponent\n() {\nconst\npathname\n=\nusePathname\n()\nreturn\n<\np\n>Current pathname: {pathname}</\np\n>\n}\nusePathname\nintentionally requires using a\nClient Component\n. It's important to note Client Components are not a de-optimization. They are an integral part of the\nServer Components\narchitecture.\nFor example, a Client Component with\nusePathname\nwill be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.\nGood to know\n:\nReading the current URL from a\nServer Component\nis not supported. This design is intentional to support layout state being preserved across page navigations.\nIf your page is being statically pre-rendered and your app has\nrewrites\nin\nnext.config\nor a\nProxy\nfile, reading the pathname with\nusePathname()\ncan result in hydration mismatch errors\u2014because the initial value comes from the server and may not match the actual browser pathname after routing. See our\nexample\nfor a way to mitigate this issue.\nCompatibility with Pages Router\nIf you have components that use\nusePathname\nand they are imported into routes within the Pages Router, be aware that\nusePathname\nmay return\nnull\nif the router is not yet initialized. This can occur in cases such as\nfallback routes\nor during\nAutomatic Static Optimization\nin the Pages Router.\nTo enhance compatibility between routing systems, if your project contains both an\napp\nand a\npages\ndirectory, Next.js will automatically adjust the return type of\nusePathname\n.\nParameters\nconst\npathname\n=\nusePathname\n()\nusePathname\ndoes not take any parameters.\nReturns\nusePathname\nreturns a string of the current URL's pathname. For example:\nURL\nReturned value\n/\n'/'\n/dashboard\n'/dashboard'\n/dashboard?v=2\n'/dashboard'\n/blog/hello-world\n'/blog/hello-world'\nExamples\nDo something in response to a route change\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport\n{ useEffect }\nfrom\n'react'\nimport\n{ usePathname\n,\nuseSearchParams }\nfrom\n'next/navigation'\nfunction\nExampleClientComponent\n() {\nconst\npathname\n=\nusePathname\n()\nconst\nsearchParams\n=\nuseSearchParams\n()\nuseEffect\n(()\n=>\n{\n// Do something here...\n}\n,\n[pathname\n,\nsearchParams])\n}\nAvoid hydration mismatch with rewrites\nWhen a page is pre-rendered, the HTML is generated for the source pathname. If the page is then reached through a rewrite using\nnext.config\nor\nProxy\n, the browser URL may differ, and\nusePathname()\nwill read the rewritten pathname on the client.\nTo avoid hydration mismatches, design the UI so that only a small, isolated part depends on the client pathname. Render a stable fallback on the server and update that part after mount.\napp/example-client-component.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport\n{ useEffect\n,\nuseState }\nfrom\n'react'\nimport\n{ usePathname }\nfrom\n'next/navigation'\nexport\ndefault\nfunction\nPathnameBadge\n() {\nconst\npathname\n=\nusePathname\n()\nconst\n[\nclientPathname\n,\nsetClientPathname\n]\n=\nuseState\n(\n''\n)\nuseEffect\n(()\n=>\n{\nsetClientPathname\n(pathname)\n}\n,\n[pathname])\nreturn\n(\n<\np\n>\nCurrent pathname: <\nspan\n>{clientPathname}</\nspan\n>\n</\np\n>\n)\n}\nVersion\nChanges\nv13.0.0\nusePathname\nintroduced.\nWas this helpful?\nsupported.\nSend",
  "content_markdown": "Menu\n\nUsing App Router\n\nFeatures available in /app\n\nLatest Version\n\n16.1.6\n\n[API Reference](/docs/app/api-reference)[Functions](/docs/app/api-reference/functions)usePathname\n\nCopy page\n\n# usePathname\n\nLast updated October 22, 2025\n\n`usePathname` is a **Client Component** hook that lets you read the current URL's **pathname**.\n\n> **Good to know**: When [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) is enabled `usePathname` may require a `Suspense` boundary around it if your route has a dynamic param. If you use `generateStaticParams` the `Suspense` boundary is optional\n\napp/example-client-component.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\n \nimport { usePathname } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const pathname = usePathname()\n  return <p>Current pathname: {pathname}</p>\n}\n```\n\n`usePathname` intentionally requires using a [Client Component](/docs/app/getting-started/server-and-client-components). It's important to note Client Components are not a de-optimization. They are an integral part of the [Server Components](/docs/app/getting-started/server-and-client-components) architecture.\n\nFor example, a Client Component with `usePathname` will be rendered into HTML on the initial page load. When navigating to a new route, this component does not need to be re-fetched. Instead, the component is downloaded once (in the client JavaScript bundle), and re-renders based on the current state.\n\n> **Good to know**:\n>\n> - Reading the current URL from a [Server Component](/docs/app/getting-started/server-and-client-components) is not supported. This design is intentional to support layout state being preserved across page navigations.\n> - If your page is being statically pre-rendered and your app has [rewrites](/docs/app/api-reference/config/next-config-js/rewrites) in `next.config` or a [Proxy](/docs/app/api-reference/file-conventions/proxy) file, reading the pathname with `usePathname()` can result in hydration mismatch errors\u2014because the initial value comes from the server and may not match the actual browser pathname after routing. See our [example](#avoid-hydration-mismatch-with-rewrites) for a way to mitigate this issue.\n\nCompatibility with Pages Router\n\nIf you have components that use `usePathname` and they are imported into routes within the Pages Router, be aware that `usePathname` may return `null` if the router is not yet initialized. This can occur in cases such as [fallback routes](/docs/pages/api-reference/functions/get-static-paths#fallback-true) or during [Automatic Static Optimization](https://nextjs.org/docs/pages/building-your-application/rendering/static#automatic-static-optimization) in the Pages Router.\n\nTo enhance compatibility between routing systems, if your project contains both an `app` and a `pages` directory, Next.js will automatically adjust the return type of `usePathname`.\n\n## Parameters\n\n```\nconst pathname = usePathname()\n```\n\n`usePathname` does not take any parameters.\n\n## Returns\n\n`usePathname` returns a string of the current URL's pathname. For example:\n\n| URL | Returned value |\n| --- | --- |\n| `/` | `'/'` |\n| `/dashboard` | `'/dashboard'` |\n| `/dashboard?v=2` | `'/dashboard'` |\n| `/blog/hello-world` | `'/blog/hello-world'` |\n\n## Examples\n\n### Do something in response to a route change\n\napp/example-client-component.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\n \nimport { useEffect } from 'react'\nimport { usePathname, useSearchParams } from 'next/navigation'\n \nfunction ExampleClientComponent() {\n  const pathname = usePathname()\n  const searchParams = useSearchParams()\n  useEffect(() => {\n    // Do something here...\n  }, [pathname, searchParams])\n}\n```\n\n### Avoid hydration mismatch with rewrites\n\nWhen a page is pre-rendered, the HTML is generated for the source pathname. If the page is then reached through a rewrite using `next.config` or `Proxy`, the browser URL may differ, and `usePathname()` will read the rewritten pathname on the client.\n\nTo avoid hydration mismatches, design the UI so that only a small, isolated part depends on the client pathname. Render a stable fallback on the server and update that part after mount.\n\napp/example-client-component.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\n \nimport { useEffect, useState } from 'react'\nimport { usePathname } from 'next/navigation'\n \nexport default function PathnameBadge() {\n  const pathname = usePathname()\n  const [clientPathname, setClientPathname] = useState('')\n \n  useEffect(() => {\n    setClientPathname(pathname)\n  }, [pathname])\n \n  return (\n    <p>\n      Current pathname: <span>{clientPathname}</span>\n    </p>\n  )\n}\n```\n\n| Version | Changes |\n| --- | --- |\n| `v13.0.0` | `usePathname` introduced. |\n\nWas this helpful?\n\nsupported.\n\nSend",
  "tags": [
    "nextjs",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:55:15.909406+00:00",
  "content_length": 3915,
  "content_hash": "19272cdf8850b441"
}