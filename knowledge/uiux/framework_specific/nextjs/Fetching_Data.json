{
  "id": "nextjs__docs_app_building-your-application_data-fetching",
  "source_id": "nextjs",
  "source_name": "Next.js Documentation",
  "category": "framework_specific",
  "url": "https://nextjs.org/docs/app/building-your-application/data-fetching",
  "title": "Fetching Data",
  "content": "Menu\nUsing App Router\nFeatures available in /app\nLatest Version\n16.1.6\nApp Router\nGetting Started\nFetching Data\nCopy page\nFetching Data\nLast updated\nDecember 3, 2025\nThis page will walk you through how you can fetch data in\nServer and Client Components\n, and how to\nstream\ncomponents that depend on data.\nFetching data\nServer Components\nYou can fetch data in Server Components using any asynchronous I/O, such as:\nThe\nfetch\nAPI\nAn\nORM or database\nReading from the filesystem using Node.js APIs like\nfs\nWith the\nfetch\nAPI\nTo fetch data with the\nfetch\nAPI, turn your component into an asynchronous function, and await the\nfetch\ncall. For example:\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nasync\nfunction\nPage\n() {\nconst\ndata\n=\nawait\nfetch\n(\n'https://api.vercel.app/\nblog\n'\n)\nconst\nposts\n=\nawait\ndata\n.json\n()\nreturn\n(\n<\nul\n>\n{\nposts\n.map\n((post)\n=>\n(\n<\nli\nkey\n=\n{\npost\n.id}>{\npost\n.title}</\nli\n>\n))}\n</\nul\n>\n)\n}\nGood to know:\nfetch\nresponses are not cached by default. However, Next.js will\npre-render\nthe route and the output will be cached for improved performance. If you'd like to opt into\ndynamic rendering\n, use the\n{ cache: 'no-store' }\noption. See the\nfetch\nAPI Reference\n.\nDuring development, you can log\nfetch\ncalls for better visibility and debugging. See the\nlogging\nAPI reference\n.\nWith an ORM or database\nSince Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\n{ db\n,\nposts }\nfrom\n'@/lib/db'\nexport\ndefault\nasync\nfunction\nPage\n() {\nconst\nallPosts\n=\nawait\ndb\n.select\n()\n.from\n(posts)\nreturn\n(\n<\nul\n>\n{\nallPosts\n.map\n((post)\n=>\n(\n<\nli\nkey\n=\n{\npost\n.id}>{\npost\n.title}</\nli\n>\n))}\n</\nul\n>\n)\n}\nClient Components\nThere are two ways to fetch data in Client Components, using:\nReact's\nuse\nhook\nA community library like\nSWR\nor\nReact Query\nStreaming data with the\nuse\nhook\nYou can use React's\nuse\nhook\nto\nstream\ndata from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\nPosts\nfrom\n'@/app/ui/posts'\nimport\n{ Suspense }\nfrom\n'react'\nexport\ndefault\nfunction\nPage\n() {\n// Don't await the data fetching function\nconst\nposts\n=\ngetPosts\n()\nreturn\n(\n<\nSuspense\nfallback\n=\n{<\ndiv\n>Loading...</\ndiv\n>}>\n<\nPosts\nposts\n=\n{posts} />\n</\nSuspense\n>\n)\n}\nThen, in your Client Component, use the\nuse\nhook to read the promise:\napp/ui/posts.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport\n{ use }\nfrom\n'react'\nexport\ndefault\nfunction\nPosts\n({\nposts\n,\n}\n:\n{\nposts\n:\nPromise\n<{ id\n:\nstring\n; title\n:\nstring\n}[]>\n}) {\nconst\nallPosts\n=\nuse\n(posts)\nreturn\n(\n<\nul\n>\n{\nallPosts\n.map\n((post)\n=>\n(\n<\nli\nkey\n=\n{\npost\n.id}>{\npost\n.title}</\nli\n>\n))}\n</\nul\n>\n)\n}\nIn the example above, the\n<Posts>\ncomponent is wrapped in a\n<Suspense>\nboundary\n. This means the fallback will be shown while the promise is being resolved. Learn more about\nstreaming\n.\nCommunity libraries\nYou can use a community library like\nSWR\nor\nReact Query\nto fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\n'use client'\nimport\nuseSWR\nfrom\n'swr'\nconst\nfetcher\n=\n(url)\n=>\nfetch\n(url)\n.then\n((r)\n=>\nr\n.json\n())\nexport\ndefault\nfunction\nBlogPage\n() {\nconst\n{\ndata\n,\nerror\n,\nisLoading\n}\n=\nuseSWR\n(\n'https://api.vercel.app/\nblog\n'\n,\nfetcher\n)\nif\n(isLoading)\nreturn\n<\ndiv\n>Loading...</\ndiv\n>\nif\n(error)\nreturn\n<\ndiv\n>Error: {\nerror\n.message}</\ndiv\n>\nreturn\n(\n<\nul\n>\n{\ndata\n.map\n((post\n:\n{ id\n:\nstring\n; title\n:\nstring\n})\n=>\n(\n<\nli\nkey\n=\n{\npost\n.id}>{\npost\n.title}</\nli\n>\n))}\n</\nul\n>\n)\n}\nDeduplicate requests and cache data\nOne way to deduplicate\nfetch\nrequests is with\nrequest memoization\n. With this mechanism,\nfetch\ncalls using\nGET\nor\nHEAD\nwith the same URL and options in a single render pass are combined into one request. This happens automatically, and you can\nopt out\nby passing an Abort signal to\nfetch\n.\nRequest memoization is scoped to the lifetime of a request.\nYou can also deduplicate\nfetch\nrequests by using Next.js\u2019\nData Cache\n, for example by setting\ncache: 'force-cache'\nin your\nfetch\noptions.\nData Cache allows sharing data across the current render pass and incoming requests.\nIf you are\nnot\nusing\nfetch\n, and instead using an ORM or database directly, you can wrap your data access with the\nReact\ncache\nfunction.\napp/lib/data.ts\nTypeScript\nJavaScript\nTypeScript\nimport\n{ cache }\nfrom\n'react'\nimport\n{ db\n,\nposts\n,\neq }\nfrom\n'@/\nlib\n/db'\nexport\nconst\ngetPost\n=\ncache\n(\nasync\n(id\n:\nstring\n)\n=>\n{\nconst\npost\n=\nawait\ndb\n.\nquery\n.\nposts\n.findFirst\n({\nwhere\n:\neq\n(\nposts\n.id\n,\nparseInt\n(id))\n,\n})\n})\nStreaming\nWarning:\nThe content below assumes the\ncacheComponents\nconfig option\nis enabled in your application. The flag was introduced in Next.js 15 canary.\nWhen you fetch data in Server Components, the data is fetched and rendered on the server for each request. If you have any slow data requests, the whole route will be blocked from rendering until all the data is fetched.\nTo improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\nThere are two ways you can leverage streaming in your application:\nWrapping a page with a\nloading.js\nfile\nWrapping a component with\n<Suspense>\nWith\nloading.js\nYou can create a\nloading.js\nfile in the same folder as your page to stream the\nentire page\nwhile the data is being fetched. For example, to stream\napp/blog/page.js\n, add the file inside the\napp/blog\nfolder.\napp/blog/loading.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nfunction\nLoading\n() {\n// Define the Loading UI here\nreturn\n<\ndiv\n>Loading...</\ndiv\n>\n}\nOn navigation, the user will immediately see the layout and a\nloading state\nwhile the page is being rendered. The new content will then be automatically swapped in once rendering is complete.\nBehind-the-scenes,\nloading.js\nwill be nested inside\nlayout.js\n, and will automatically wrap the\npage.js\nfile and any children below in a\n<Suspense>\nboundary.\nThis approach works well for route segments (layouts and pages), but for more granular streaming, you can use\n<Suspense>\n.\nWith\n<Suspense>\n<Suspense>\nallows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the\n<Suspense>\nboundary, and stream in the list of blog posts inside the boundary.\napp/blog/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\n{ Suspense }\nfrom\n'react'\nimport\nBlogList\nfrom\n'@/components/BlogList'\nimport\nBlogListSkeleton\nfrom\n'@/components/BlogListSkeleton'\nexport\ndefault\nfunction\nBlogPage\n() {\nreturn\n(\n<\ndiv\n>\n{\n/* This content will be sent to the client immediately */\n}\n<\nheader\n>\n<\nh1\n>Welcome to the Blog</\nh1\n>\n<\np\n>Read the latest posts below.</\np\n>\n</\nheader\n>\n<\nmain\n>\n{\n/* If there's any dynamic content inside this boundary, it will be streamed in */\n}\n<\nSuspense\nfallback\n=\n{<\nBlogListSkeleton\n/>}>\n<\nBlogList\n/>\n</\nSuspense\n>\n</\nmain\n>\n</\ndiv\n>\n)\n}\nCreating meaningful loading states\nAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\nIn development, you can preview and inspect the loading state of your components using the\nReact Devtools\n.\nExamples\nSequential data fetching\nSequential data fetching happens when one request depends on data from another.\nFor example,\n<Playlists>\ncan only fetch data after\n<Artist>\ncompletes because it needs the\nartistID\n:\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nexport\ndefault\nasync\nfunction\nPage\n({\nparams\n,\n}\n:\n{\nparams\n:\nPromise\n<{ username\n:\nstring\n}>\n}) {\nconst\n{\nusername\n}\n=\nawait\nparams\n// Get\nartist\ninformation\nconst\nartist\n=\nawait\ngetArtist\n(username)\nreturn\n(\n<>\n<\nh1\n>{\nartist\n.name}</\nh1\n>\n{\n/* Show fallback UI while the Playlists component is loading */\n}\n<\nSuspense\nfallback\n=\n{<\ndiv\n>Loading...</\ndiv\n>}>\n{\n/* Pass the\nartist\nID to the Playlists component */\n}\n<\nPlaylists\nartist\nID\n=\n{\nartist\n.id} />\n</\nSuspense\n>\n</>\n)\n}\nasync\nfunction\nPlaylists\n({\nartist\nID }\n:\n{\nartist\nID\n:\nstring\n}) {\n// Use the\nartist\nID to fetch playlists\nconst\nplaylists\n=\nawait\ngetArtistPlaylists\n(\nartist\nID)\nreturn\n(\n<\nul\n>\n{\nplaylists\n.map\n((playlist)\n=>\n(\n<\nli\nkey\n=\n{\nplaylist\n.id}>{\nplaylist\n.name}</\nli\n>\n))}\n</\nul\n>\n)\n}\nIn this example,\n<Suspense>\nallows the playlists to stream in after the artist data loads. However, the page still waits for the artist data before displaying anything. To prevent this, you can wrap the entire page component in a\n<Suspense>\nboundary (for example, using a\nloading.js\nfile\n) to show a loading state immediately.\nEnsure your data source can resolve the first request quickly, as it blocks everything else. If you can't optimize the request further, consider\ncaching\nthe result if the data changes infrequently.\nParallel data fetching\nParallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.\nBy default,\nlayouts and pages\nare rendered in parallel. So each segment starts fetching data as soon as possible.\nHowever, within\nany\ncomponent, multiple\nasync\n/\nawait\nrequests can still be sequential if placed after the other. For example,\ngetAlbums\nwill be blocked until\ngetArtist\nis resolved:\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\n{ getArtist\n,\ngetAlbums }\nfrom\n'@/app/lib/data'\nexport\ndefault\nasync\nfunction\nPage\n({ params }) {\n// These requests will be sequential\nconst\n{\nusername\n}\n=\nawait\nparams\nconst\nartist\n=\nawait\ngetArtist\n(username)\nconst\nalbums\n=\nawait\ngetAlbums\n(username)\nreturn\n<\ndiv\n>{\nartist\n.name}</\ndiv\n>\n}\nStart multiple requests by calling\nfetch\n, then await them with\nPromise.all\n. Requests begin as soon as\nfetch\nis called.\napp/artist/[username]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\nAlbums\nfrom\n'./albums'\nasync\nfunction\ngetArtist\n(username\n:\nstring\n) {\nconst\nres\n=\nawait\nfetch\n(\n`https://api.example.com/\nartist\n/\n${\nusername\n}\n`\n)\nreturn\nres\n.json\n()\n}\nasync\nfunction\ngetAlbums\n(username\n:\nstring\n) {\nconst\nres\n=\nawait\nfetch\n(\n`https://api.example.com/\nartist\n/\n${\nusername\n}\n/albums`\n)\nreturn\nres\n.json\n()\n}\nexport\ndefault\nasync\nfunction\nPage\n({\nparams\n,\n}\n:\n{\nparams\n:\nPromise\n<{ username\n:\nstring\n}>\n}) {\nconst\n{\nusername\n}\n=\nawait\nparams\n// Initiate requests\nconst\nartist\nData\n=\ngetArtist\n(username)\nconst\nalbumsData\n=\ngetAlbums\n(username)\nconst\n[\nartist\n,\nalbums\n]\n=\nawait\nPromise\n.all\n([\nartist\nData\n,\nalbumsData])\nreturn\n(\n<>\n<\nh1\n>{\nartist\n.name}</\nh1\n>\n<\nAlbums\nlist\n=\n{albums} />\n</>\n)\n}\nGood to know:\nIf one request fails when using\nPromise.all\n, the entire operation will fail. To handle this, you can use the\nPromise.allSettled\nmethod instead.\nPreloading data\nYou can preload data by creating a utility function that you eagerly call above blocking requests.\n<Item>\nconditionally renders based on the\ncheckIsAvailable()\nfunction.\nYou can call\npreload()\nbefore\ncheckIsAvailable()\nto eagerly initiate\n<Item/>\ndata dependencies. By the time\n<Item/>\nis rendered, its data has already been fetched.\napp/item/[id]/page.tsx\nTypeScript\nJavaScript\nTypeScript\nimport\n{ getItem\n,\ncheckIsAvailable }\nfrom\n'@/lib/data'\nexport\ndefault\nasync\nfunction\nPage\n({\nparams\n,\n}\n:\n{\nparams\n:\nPromise\n<{ id\n:\nstring\n}>\n}) {\nconst\n{\nid\n}\n=\nawait\nparams\n// starting loading\nitem\ndata\npreload\n(id)\n// perform another asynchronous task\nconst\nisAvailable\n=\nawait\ncheckIsAvailable\n()\nreturn\nisAvailable\n?\n<\nItem\nid\n=\n{id} />\n:\nnull\n}\nconst\npreload\n=\n(id\n:\nstring\n)\n=>\n{\n// void evaluates the given expression and returns undefined\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\nvoid\ngetItem\n(id)\n}\nexport\nasync\nfunction\nItem\n({ id }\n:\n{ id\n:\nstring\n}) {\nconst\nresult\n=\nawait\ngetItem\n(id)\n// ...\n}\nAdditionally, you can use React's\ncache\nfunction\nand the\nserver-only\npackage\nto create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.\nutils/get-item.ts\nTypeScript\nJavaScript\nTypeScript\nimport\n{ cache }\nfrom\n'react'\nimport\n'server-only'\nimport\n{ getItem }\nfrom\n'@/lib/data'\nexport\nconst\npreload\n=\n(id\n:\nstring\n)\n=>\n{\nvoid\ngetItem\n(id)\n}\nexport\nconst\ngetItem\n=\ncache\n(\nasync\n(id\n:\nstring\n)\n=>\n{\n// ...\n})\nAPI Reference\nLearn more about the features mentioned in this page by reading the API Reference.\nData Security\nLearn the built-in data security features in Next.js and learn best practices for protecting your application's data.\nfetch\nAPI reference for the extended fetch function.\nloading.js\nAPI reference for the loading.js file.\nlogging\nConfigure how data fetches are logged to the console when running Next.js in development mode.\ntaint\nEnable tainting Objects and Values.\nWas this helpful?\nsupported.\nSend",
  "content_markdown": "Menu\n\nUsing App Router\n\nFeatures available in /app\n\nLatest Version\n\n16.1.6\n\n[App Router](/docs/app)[Getting Started](/docs/app/getting-started)Fetching Data\n\nCopy page\n\n# Fetching Data\n\nLast updated December 3, 2025\n\nThis page will walk you through how you can fetch data in [Server and Client Components](/docs/app/getting-started/server-and-client-components), and how to [stream](#streaming) components that depend on data.\n\n## Fetching data\n\n### Server Components\n\nYou can fetch data in Server Components using any asynchronous I/O, such as:\n\n1. The [`fetch` API](#with-the-fetch-api)\n2. An [ORM or database](#with-an-orm-or-database)\n3. Reading from the filesystem using Node.js APIs like `fs`\n\n#### With the `fetch` API\n\nTo fetch data with the `fetch` API, turn your component into an asynchronous function, and await the `fetch` call. For example:\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default async function Page() {\n  const data = await fetch('https://api.vercel.app/blog')\n  const posts = await data.json()\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n> **Good to know:**\n>\n> - `fetch` responses are not cached by default. However, Next.js will [pre-render](/docs/app/guides/caching#static-rendering) the route and the output will be cached for improved performance. If you'd like to opt into [dynamic rendering](/docs/app/guides/caching#dynamic-rendering), use the `{ cache: 'no-store' }` option. See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch).\n> - During development, you can log `fetch` calls for better visibility and debugging. See the [`logging` API reference](/docs/app/api-reference/config/next-config-js/logging).\n\n#### With an ORM or database\n\nSince Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { db, posts } from '@/lib/db'\n \nexport default async function Page() {\n  const allPosts = await db.select().from(posts)\n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n### Client Components\n\nThere are two ways to fetch data in Client Components, using:\n\n1. React's [`use` hook](https://react.dev/reference/react/use)\n2. A community library like [SWR](https://swr.vercel.app/) or [React Query](https://tanstack.com/query/latest)\n\n#### Streaming data with the `use` hook\n\nYou can use React's [`use` hook](https://react.dev/reference/react/use) to [stream](#streaming) data from the server to client. Start by fetching data in your Server component, and pass the promise to your Client Component as prop:\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport Posts from '@/app/ui/posts'\nimport { Suspense } from 'react'\n \nexport default function Page() {\n  // Don't await the data fetching function\n  const posts = getPosts()\n \n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <Posts posts={posts} />\n    </Suspense>\n  )\n}\n```\n\nThen, in your Client Component, use the `use` hook to read the promise:\n\napp/ui/posts.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\nimport { use } from 'react'\n \nexport default function Posts({\n  posts,\n}: {\n  posts: Promise<{ id: string; title: string }[]>\n}) {\n  const allPosts = use(posts)\n \n  return (\n    <ul>\n      {allPosts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nIn the example above, the `<Posts>` component is wrapped in a [`<Suspense>` boundary](https://react.dev/reference/react/Suspense). This means the fallback will be shown while the promise is being resolved. Learn more about [streaming](#streaming).\n\n#### Community libraries\n\nYou can use a community library like [SWR](https://swr.vercel.app/) or [React Query](https://tanstack.com/query/latest) to fetch data in Client Components. These libraries have their own semantics for caching, streaming, and other features. For example, with SWR:\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\n'use client'\nimport useSWR from 'swr'\n \nconst fetcher = (url) => fetch(url).then((r) => r.json())\n \nexport default function BlogPage() {\n  const { data, error, isLoading } = useSWR(\n    'https://api.vercel.app/blog',\n    fetcher\n  )\n \n  if (isLoading) return <div>Loading...</div>\n  if (error) return <div>Error: {error.message}</div>\n \n  return (\n    <ul>\n      {data.map((post: { id: string; title: string }) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\n## Deduplicate requests and cache data\n\nOne way to deduplicate `fetch` requests is with [request memoization](/docs/app/guides/caching#request-memoization). With this mechanism, `fetch` calls using `GET` or `HEAD` with the same URL and options in a single render pass are combined into one request. This happens automatically, and you can [opt out](/docs/app/guides/caching#opting-out) by passing an Abort signal to `fetch`.\n\nRequest memoization is scoped to the lifetime of a request.\n\nYou can also deduplicate `fetch` requests by using Next.js\u2019 [Data Cache](/docs/app/guides/caching#data-cache), for example by setting `cache: 'force-cache'` in your `fetch` options.\n\nData Cache allows sharing data across the current render pass and incoming requests.\n\nIf you are *not* using `fetch`, and instead using an ORM or database directly, you can wrap your data access with the [React `cache`](https://react.dev/reference/react/cache) function.\n\napp/lib/data.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { cache } from 'react'\nimport { db, posts, eq } from '@/lib/db'\n \nexport const getPost = cache(async (id: string) => {\n  const post = await db.query.posts.findFirst({\n    where: eq(posts.id, parseInt(id)),\n  })\n})\n```\n\n## Streaming\n\n> **Warning:** The content below assumes the [`cacheComponents` config option](/docs/app/api-reference/config/next-config-js/cacheComponents) is enabled in your application. The flag was introduced in Next.js 15 canary.\n\nWhen you fetch data in Server Components, the data is fetched and rendered on the server for each request. If you have any slow data requests, the whole route will be blocked from rendering until all the data is fetched.\n\nTo improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\n\n![How Server Rendering with Streaming Works](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&w=3840&q=75)![How Server Rendering with Streaming Works](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&w=3840&q=75)\n\nThere are two ways you can leverage streaming in your application:\n\n1. Wrapping a page with a [`loading.js` file](#with-loadingjs)\n2. Wrapping a component with [`<Suspense>`](#with-suspense)\n\n### With `loading.js`\n\nYou can create a `loading.js` file in the same folder as your page to stream the **entire page** while the data is being fetched. For example, to stream `app/blog/page.js`, add the file inside the `app/blog` folder.\n\n![Blog folder structure with loading.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Floading-file.png&w=3840&q=75)![Blog folder structure with loading.js file](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Floading-file.png&w=3840&q=75)\n\napp/blog/loading.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default function Loading() {\n  // Define the Loading UI here\n  return <div>Loading...</div>\n}\n```\n\nOn navigation, the user will immediately see the layout and a [loading state](#creating-meaningful-loading-states) while the page is being rendered. The new content will then be automatically swapped in once rendering is complete.\n\n![Loading UI](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Floading-ui.png&w=3840&q=75)![Loading UI](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Floading-ui.png&w=3840&q=75)\n\nBehind-the-scenes, `loading.js` will be nested inside `layout.js`, and will automatically wrap the `page.js` file and any children below in a `<Suspense>` boundary.\n\n![loading.js overview](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Floading-overview.png&w=3840&q=75)![loading.js overview](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Floading-overview.png&w=3840&q=75)\n\nThis approach works well for route segments (layouts and pages), but for more granular streaming, you can use `<Suspense>`.\n\n### With `<Suspense>`\n\n`<Suspense>` allows you to be more granular about what parts of the page to stream. For example, you can immediately show any page content that falls outside of the `<Suspense>` boundary, and stream in the list of blog posts inside the boundary.\n\napp/blog/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { Suspense } from 'react'\nimport BlogList from '@/components/BlogList'\nimport BlogListSkeleton from '@/components/BlogListSkeleton'\n \nexport default function BlogPage() {\n  return (\n    <div>\n      {/* This content will be sent to the client immediately */}\n      <header>\n        <h1>Welcome to the Blog</h1>\n        <p>Read the latest posts below.</p>\n      </header>\n      <main>\n        {/* If there's any dynamic content inside this boundary, it will be streamed in */}\n        <Suspense fallback={<BlogListSkeleton />}>\n          <BlogList />\n        </Suspense>\n      </main>\n    </div>\n  )\n}\n```\n\n### Creating meaningful loading states\n\nAn instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\n\nIn development, you can preview and inspect the loading state of your components using the [React Devtools](https://react.dev/learn/react-developer-tools).\n\n## Examples\n\n### Sequential data fetching\n\nSequential data fetching happens when one request depends on data from another.\n\nFor example, `<Playlists>` can only fetch data after `<Artist>` completes because it needs the `artistID`:\n\napp/artist/[username]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n  // Get artist information\n  const artist = await getArtist(username)\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      {/* Show fallback UI while the Playlists component is loading */}\n      <Suspense fallback={<div>Loading...</div>}>\n        {/* Pass the artist ID to the Playlists component */}\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  )\n}\n \nasync function Playlists({ artistID }: { artistID: string }) {\n  // Use the artist ID to fetch playlists\n  const playlists = await getArtistPlaylists(artistID)\n \n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nIn this example, `<Suspense>` allows the playlists to stream in after the artist data loads. However, the page still waits for the artist data before displaying anything. To prevent this, you can wrap the entire page component in a `<Suspense>` boundary (for example, using a [`loading.js` file](#with-loadingjs)) to show a loading state immediately.\n\nEnsure your data source can resolve the first request quickly, as it blocks everything else. If you can't optimize the request further, consider [caching](#deduplicate-requests-and-cache-data) the result if the data changes infrequently.\n\n### Parallel data fetching\n\nParallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.\n\nBy default, [layouts and pages](/docs/app/getting-started/layouts-and-pages) are rendered in parallel. So each segment starts fetching data as soon as possible.\n\nHowever, within *any* component, multiple `async`/`await` requests can still be sequential if placed after the other. For example, `getAlbums` will be blocked until `getArtist` is resolved:\n\napp/artist/[username]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { getArtist, getAlbums } from '@/app/lib/data'\n \nexport default async function Page({ params }) {\n  // These requests will be sequential\n  const { username } = await params\n  const artist = await getArtist(username)\n  const albums = await getAlbums(username)\n  return <div>{artist.name}</div>\n}\n```\n\nStart multiple requests by calling `fetch`, then await them with [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all). Requests begin as soon as `fetch` is called.\n\napp/artist/[username]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport Albums from './albums'\n \nasync function getArtist(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}`)\n  return res.json()\n}\n \nasync function getAlbums(username: string) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n  return res.json()\n}\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ username: string }>\n}) {\n  const { username } = await params\n \n  // Initiate requests\n  const artistData = getArtist(username)\n  const albumsData = getAlbums(username)\n \n  const [artist, albums] = await Promise.all([artistData, albumsData])\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums} />\n    </>\n  )\n}\n```\n\n> **Good to know:** If one request fails when using `Promise.all`, the entire operation will fail. To handle this, you can use the [`Promise.allSettled`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled) method instead.\n\n### Preloading data\n\nYou can preload data by creating a utility function that you eagerly call above blocking requests. `<Item>` conditionally renders based on the `checkIsAvailable()` function.\n\nYou can call `preload()` before `checkIsAvailable()` to eagerly initiate `<Item/>` data dependencies. By the time `<Item/>` is rendered, its data has already been fetched.\n\napp/item/[id]/page.tsx\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { getItem, checkIsAvailable } from '@/lib/data'\n \nexport default async function Page({\n  params,\n}: {\n  params: Promise<{ id: string }>\n}) {\n  const { id } = await params\n  // starting loading item data\n  preload(id)\n  // perform another asynchronous task\n  const isAvailable = await checkIsAvailable()\n \n  return isAvailable ? <Item id={id} /> : null\n}\n \nconst preload = (id: string) => {\n  // void evaluates the given expression and returns undefined\n  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n  void getItem(id)\n}\n \nexport async function Item({ id }: { id: string }) {\n  const result = await getItem(id)\n  // ...\n}\n```\n\nAdditionally, you can use React's [`cache` function](https://react.dev/reference/react/cache) and the [`server-only` package](https://www.npmjs.com/package/server-only) to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.\n\nutils/get-item.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport { cache } from 'react'\nimport 'server-only'\nimport { getItem } from '@/lib/data'\n \nexport const preload = (id: string) => {\n  void getItem(id)\n}\n \nexport const getItem = cache(async (id: string) => {\n  // ...\n})\n```\n\n## API Reference\n\nLearn more about the features mentioned in this page by reading the API Reference.\n\n[### Data Security\n\nLearn the built-in data security features in Next.js and learn best practices for protecting your application's data.](/docs/app/guides/data-security)[### fetch\n\nAPI reference for the extended fetch function.](/docs/app/api-reference/functions/fetch)[### loading.js\n\nAPI reference for the loading.js file.](/docs/app/api-reference/file-conventions/loading)[### logging\n\nConfigure how data fetches are logged to the console when running Next.js in development mode.](/docs/app/api-reference/config/next-config-js/logging)[### taint\n\nEnable tainting Objects and Values.](/docs/app/api-reference/config/next-config-js/taint)\n\nWas this helpful?\n\nsupported.\n\nSend",
  "tags": [
    "nextjs",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:54:54.195271+00:00",
  "content_length": 13267,
  "content_hash": "2ab4199dd9e2edb1"
}