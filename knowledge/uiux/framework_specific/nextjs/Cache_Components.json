{
  "id": "nextjs__docs_app_building-your-application_rendering",
  "source_id": "nextjs",
  "source_name": "Next.js Documentation",
  "category": "framework_specific",
  "url": "https://nextjs.org/docs/app/building-your-application/rendering",
  "title": "Cache Components",
  "content": "Menu\nUsing App Router\nFeatures available in /app\nLatest Version\n16.1.6\nApp Router\nGetting Started\nCache Components\nCopy page\nCache Components\nLast updated\nJanuary 26, 2026\nGood to know:\nCache Components is an opt-in feature. Enable it by setting the\ncacheComponents\nflag to\ntrue\nin your Next config file. See\nEnabling Cache Components\nfor more details.\nCache Components lets you mix static, cached, and dynamic content in a single route, giving you the speed of static sites with the flexibility of dynamic rendering.\nServer-rendered applications typically force a choice between static pages (fast but stale) and dynamic pages (fresh but slow). Moving this work to the client trades server load for larger bundles and slower initial rendering.\nCache Components eliminates these tradeoffs by prerendering routes into a\nstatic HTML shell\nthat's immediately sent to the browser, with dynamic content updating the UI as it becomes ready.\nHow rendering works with Cache Components\nAt build time, Next.js renders your route's component tree. As long as components don't access network resources, certain system APIs, or require an incoming request to render, their output is\nautomatically added to the static shell\n. Otherwise, you must choose how to handle them:\nDefer rendering to request time by wrapping components in React's\n<Suspense>\n,\nshowing fallback UI\nuntil the content is ready, or\nCache the result using the\nuse cache\ndirective to\ninclude it in the static shell\n(if no request data is needed)\nBecause this happens ahead of time, before a request arrives, we refer to it as prerendering. This generates a static shell consisting of HTML for initial page loads and a serialized\nRSC Payload\nfor client-side navigation, ensuring the browser receives fully rendered content instantly whether users navigate directly to the URL or transition from another page.\nNext.js requires you to explicitly handle components that can't complete during prerendering. If they aren't wrapped in\n<Suspense>\nor marked with\nuse cache\n, you'll see an\nUncached data was accessed outside of <Suspense>\nerror during development and build time.\nGood to know\n: Caching can be applied at the component or function level, while fallback UI can be defined around any subtree, which means you can compose static, cached, and dynamic content within a single route.\nThis rendering approach is called\nPartial Prerendering\n, and it's the default behavior with Cache Components. For the rest of this document, we simply refer to it as \"prerendering\" which can produce a partial or complete output.\n\ud83c\udfa5 Watch:\nWhy Partial Prerendering and how it works \u2192\nYouTube (10 minutes)\n.\nAutomatically prerendered content\nOperations like synchronous I/O, module imports, and pure computations can complete during prerendering. Components using only these operations have their rendered output included in the static HTML shell.\nBecause all operations in the\nPage\ncomponent below complete during rendering, its rendered output is automatically included in the static shell. When both the layout and page prerender successfully, the entire route is the static shell.\npage.tsx\nimport\nfs\nfrom\n'node:fs'\nexport\ndefault\nasync\nfunction\nPage\n() {\n// Synchronous file system read\nconst\ncontent\n=\nfs\n.readFileSync\n(\n'./config.json'\n,\n'utf-8'\n)\n// Module imports\nconst\nconstants\n=\nawait\nimport\n(\n'./constants.json'\n)\n// Pure computations\nconst\nprocessed\n=\nJSON\n.parse\n(content).\nitems\n.map\n((item)\n=>\nitem\n.value\n*\n2\n)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>{\nconstants\n.appName}</\nh1\n>\n<\nul\n>\n{\nprocessed\n.map\n((value\n,\ni)\n=>\n(\n<\nli\nkey\n=\n{i}>{value}</\nli\n>\n))}\n</\nul\n>\n</\ndiv\n>\n)\n}\nGood to know\n: You can verify that a route was fully prerendered by checking the build output summary. Alternatively, see what content was added to the static shell of any page by viewing the page source in your browser.\nDefer rendering to request time\nDuring prerendering, when Next.js encounters work it can't complete (like network requests, accessing request data, or async operations), it requires you to explicitly handle it. To defer rendering to request time, a parent component must provide fallback UI using a Suspense boundary. The fallback becomes part of the static shell while the actual content resolves at request time.\nPlace Suspense boundaries as close as possible to the components that need them. This maximizes the amount of content in the static shell, since everything outside the boundary can still prerender normally.\nGood to know\n: With Suspense boundaries, multiple dynamic sections can render in parallel rather than blocking each other, reducing total load time.\nDynamic content\nExternal systems provide content asynchronously, which often takes an unpredictable time to resolve and may even fail. This is why prerendering doesn't execute them automatically.\nIn general, when you need the latest data from the source on each request (like real-time feeds or personalized content), defer rendering by providing fallback UI with a Suspense boundary.\nFor example, the\nDynamicContent\ncomponent below uses multiple operations that are not automatically prerendered.\npage.tsx\nimport\n{ Suspense }\nfrom\n'react'\nimport\nfs\nfrom\n'node:fs/promises'\nasync\nfunction\nDynamicContent\n() {\n// Network request\nconst\ndata\n=\nawait\nfetch\n(\n'https://api.example.com/data'\n)\n// Database query\nconst\nusers\n=\nawait\ndb\n.query\n(\n'SELECT * FROM users'\n)\n// Async file system operation\nconst\nfile\n=\nawait\nfs\n.readFile\n(\n'..'\n,\n'utf-8'\n)\n// Simulating external system delay\nawait\nnew\nPromise\n((resolve)\n=>\nsetTimeout\n(resolve\n,\n100\n))\nreturn\n<\ndiv\n>Not in the static shell</\ndiv\n>\n}\nTo use\nDynamicContent\nwithin a page, wrap it in\n<Suspense>\nto define fallback UI:\npage.tsx\nexport\ndefault\nasync\nfunction\nPage\n(props) {\nreturn\n(\n<>\n<\nh1\n>Part of the static shell</\nh1\n>\n{\n/* <p>Loading..</p> is part of the static shell */\n}\n<\nSuspense\nfallback\n=\n{<\np\n>Loading..</\np\n>}>\n<\nDynamicContent\n/>\n<\ndiv\n>Sibling excluded from static shell</\ndiv\n>\n</\nSuspense\n>\n</>\n)\n}\nPrerendering stops at the\nfetch\nrequest. The request itself is not started, and any code after it is not executed.\nThe fallback (\n<p>Loading...</p>\n) is included in the static shell, while the component's content streams at request time.\nIn this example, since all operations (network request, database query, file read, and timeout) run sequentially within the same component, the content won't appear until they all complete.\nGood to know\n: For dynamic content that doesn't change frequently, you can use\nuse cache\nto include the dynamic data in the static shell instead of streaming it. See the\nduring prerendering\nsection for an example.\nRuntime data\nA specific type of dynamic data that requires request context, only available when a user makes a request.\ncookies()\n- User's cookie data\nheaders()\n- Request headers\nsearchParams\n- URL query parameters\nparams\n- Dynamic route parameters (unless at least one sample is provided via\ngenerateStaticParams\n). See\nDynamic Routes with Cache Components\nfor detailed patterns.\npage.tsx\nimport\n{ cookies\n,\nheaders }\nfrom\n'next/headers'\nimport\n{ Suspense }\nfrom\n'react'\nasync\nfunction\nRuntimeData\n({ searchParams }) {\n// Accessing request data\nconst\ncookieStore\n=\nawait\ncookies\n()\nconst\nheaderStore\n=\nawait\nheaders\n()\nconst\nsearch\n=\nawait\nsearchParams\nreturn\n<\ndiv\n>Not in the static shell</\ndiv\n>\n}\nTo use the\nRuntimeData\ncomponent, wrap it in a\n<Suspense>\nboundary:\npage.tsx\nexport\ndefault\nasync\nfunction\nPage\n(props) {\nreturn\n(\n<>\n<\nh1\n>Part of the static shell</\nh1\n>\n{\n/* <p>Loading..</p> is part of the static shell */\n}\n<\nSuspense\nfallback\n=\n{<\np\n>Loading..</\np\n>}>\n<\nRuntimeData\nsearchParams\n=\n{\nprops\n.searchParams} />\n<\ndiv\n>Sibling excluded from static shell</\ndiv\n>\n</\nSuspense\n>\n</>\n)\n}\nUse\nconnection()\nif you need to defer to request time without accessing any of the runtime APIs above.\nGood to know\n: Runtime data cannot be cached with\nuse cache\nbecause it requires request context. Components that access runtime APIs must always be wrapped in\n<Suspense>\n. However, you can extract values from runtime data and pass them as arguments to cached functions. See the\nwith runtime data\nsection for an example.\nOne approach for reading runtime data like cookies without blocking the static shell is to pass a promise to a client context provider. See\nSharing data with context and React.cache\nfor an example.\nGood to know:\nReact.cache\noperates in an isolated scope inside\nuse cache\nboundaries. See\nReact.cache isolation\nfor more information.\nNon-deterministic operations\nOperations like\nMath.random()\n,\nDate.now()\n, or\ncrypto.randomUUID()\nproduce different values each time they execute. To ensure these run at request time (generating unique values per request), Cache Components requires you to explicitly signal this intent by calling these operations after dynamic or runtime data access.\nimport\n{ connection }\nfrom\n'next/server'\nimport\n{ Suspense }\nfrom\n'react'\nasync\nfunction\nUniqueContent\n() {\n// Explicitly defer to request time\nawait\nconnection\n()\n// Non-deterministic operations\nconst\nrandom\n=\nMath\n.random\n()\nconst\nnow\n=\nDate\n.now\n()\nconst\ndate\n=\nnew\nDate\n()\nconst\nuuid\n=\ncrypto\n.randomUUID\n()\nconst\nbytes\n=\ncrypto\n.getRandomValues\n(\nnew\nUint8Array\n(\n16\n))\nreturn\n(\n<\ndiv\n>\n<\np\n>{random}</\np\n>\n<\np\n>{now}</\np\n>\n<\np\n>{\ndate\n.getTime\n()}</\np\n>\n<\np\n>{uuid}</\np\n>\n<\np\n>{bytes}</\np\n>\n</\ndiv\n>\n)\n}\nBecause the\nUniqueContent\ncomponent defers to request time, to use it within a route, it must be wrapped in\n<Suspense>\n:\npage.tsx\nexport\ndefault\nasync\nfunction\nPage\n() {\nreturn\n(\n// <p>Loading..</p> is part of the static shell\n<\nSuspense\nfallback\n=\n{<\np\n>Loading..</\np\n>}>\n<\nUniqueContent\n/>\n</\nSuspense\n>\n)\n}\nEvery incoming request would see different random numbers, date, etc.\nGood to know\n: You can cache non-deterministic operations with\nuse cache\n. See the\nwith non-deterministic operations\nsection for examples.\nUsing\nuse cache\nThe\nuse cache\ndirective caches the return value of async functions and components. You can apply it at the function, component, or file level.\nArguments and any closed-over values from parent scopes automatically become part of the\ncache key\n, which means different inputs produce separate cache entries. This enables personalized or parameterized cached content.\nWhen\ndynamic content\ndoesn't need to be fetched fresh from the source on every request, caching it lets you include the content in the static shell during prerendering, or reuse the result at runtime across multiple requests.\nCached content can be revalidated in two ways: automatically based on the cache lifetime, or on-demand using tags with\nrevalidateTag\nor\nupdateTag\n.\nGood to know\n: See\nserialization requirements and constraints\nfor details on what can be cached and how arguments work.\nDuring prerendering\nWhile\ndynamic content\nis fetched from external sources, it's often unlikely to change between accesses. Product catalog data updates with inventory changes, blog post content rarely changes after publishing, and analytics reports for past dates remain static.\nIf this data doesn't depend on\nruntime data\n, you can use the\nuse cache\ndirective to include it in the static HTML shell. Use\ncacheLife\nto define how long to use the cached data.\nWhen revalidation occurs, the static shell is updated with fresh content. See\nTagging and revalidating\nfor details on on-demand revalidation.\napp/page.tsx\nimport\n{ cacheLife }\nfrom\n'next/cache'\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\ncacheLife\n(\n'hours'\n)\nconst\nusers\n=\nawait\ndb\n.query\n(\n'SELECT * FROM users'\n)\nreturn\n(\n<\nul\n>\n{\nusers\n.map\n((user)\n=>\n(\n<\nli\nkey\n=\n{\nuser\n.id}>{\nuser\n.name}</\nli\n>\n))}\n</\nul\n>\n)\n}\nThe\ncacheLife\nfunction accepts a cache profile name (like\n'hours'\n,\n'days'\n, or\n'weeks'\n) or a custom configuration object to control cache behavior:\napp/page.tsx\nimport\n{ cacheLife }\nfrom\n'next/cache'\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\ncacheLife\n({\nstale\n:\n3600\n,\n// 1 hour until considered stale\nrevalidate\n:\n7200\n,\n// 2 hours until revalidated\nexpire\n:\n86400\n,\n// 1 day until expired\n})\nconst\nusers\n=\nawait\ndb\n.query\n(\n'SELECT * FROM users'\n)\nreturn\n(\n<\nul\n>\n{\nusers\n.map\n((user)\n=>\n(\n<\nli\nkey\n=\n{\nuser\n.id}>{\nuser\n.name}</\nli\n>\n))}\n</\nul\n>\n)\n}\nSee the\ncacheLife\nAPI reference\nfor available profiles and custom configuration options.\nWith runtime data\nRuntime data and\nuse cache\ncannot be used in the same scope. However, you can extract values from runtime APIs and pass them as arguments to cached functions.\napp/profile/page.tsx\nimport\n{ cookies }\nfrom\n'next/headers'\nimport\n{ Suspense }\nfrom\n'react'\nexport\ndefault\nfunction\nPage\n() {\n// Page itself creates the dynamic boundary\nreturn\n(\n<\nSuspense\nfallback\n=\n{<\ndiv\n>Loading...</\ndiv\n>}>\n<\nProfileContent\n/>\n</\nSuspense\n>\n)\n}\n// Component (not cached) reads runtime data\nasync\nfunction\nProfileContent\n() {\nconst\nsession\n=\n(\nawait\ncookies\n())\n.get\n(\n'session'\n)?.value\nreturn\n<\nCachedContent\nsessionId\n=\n{session} />\n}\n// Cached component/function receives data as props\nasync\nfunction\nCachedContent\n({ sessionId }\n:\n{ sessionId\n:\nstring\n}) {\n'use cache'\n// sessionId becomes part of cache key\nconst\ndata\n=\nawait\nfetchUserData\n(sessionId)\nreturn\n<\ndiv\n>{data}</\ndiv\n>\n}\nAt request time,\nCachedContent\nexecutes if no matching cache entry is found, and stores the result for future requests.\nWith non-deterministic operations\nWithin a\nuse cache\nscope, non-deterministic operations execute during prerendering. This is useful when you want the same rendered output served to all users:\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\n// Execute once, then cached for all requests\nconst\nrandom\n=\nMath\n.random\n()\nconst\nrandom2\n=\nMath\n.random\n()\nconst\nnow\n=\nDate\n.now\n()\nconst\ndate\n=\nnew\nDate\n()\nconst\nuuid\n=\ncrypto\n.randomUUID\n()\nconst\nbytes\n=\ncrypto\n.getRandomValues\n(\nnew\nUint8Array\n(\n16\n))\nreturn\n(\n<\ndiv\n>\n<\np\n>\n{random} and {random2}\n</\np\n>\n<\np\n>{now}</\np\n>\n<\np\n>{\ndate\n.getTime\n()}</\np\n>\n<\np\n>{uuid}</\np\n>\n<\np\n>{bytes}</\np\n>\n</\ndiv\n>\n)\n}\nAll requests will be served a route containing the same random numbers, timestamp, and UUID until the cache is revalidated.\nTagging and revalidating\nTag cached data with\ncacheTag\nand revalidate it after mutations using\nupdateTag\nin Server Actions for immediate updates, or\nrevalidateTag\nwhen delays in updates are acceptable.\nWith\nupdateTag\nUse\nupdateTag\nwhen you need to expire and immediately refresh cached data within the same request:\napp/actions.ts\nimport\n{ cacheTag\n,\nupdateTag }\nfrom\n'next/cache'\nexport\nasync\nfunction\ngetCart\n() {\n'use cache'\ncacheTag\n(\n'cart'\n)\n// fetch data\n}\nexport\nasync\nfunction\nupdateCart\n(itemId\n:\nstring\n) {\n'use server'\n// write data using the itemId\n// update the user cart\nupdateTag\n(\n'cart'\n)\n}\nWith\nrevalidateTag\nUse\nrevalidateTag\nwhen you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.\napp/actions.ts\nimport\n{ cacheTag\n,\nrevalidateTag }\nfrom\n'next/cache'\nexport\nasync\nfunction\ngetPosts\n() {\n'use cache'\ncacheTag\n(\n'posts'\n)\n// fetch data\n}\nexport\nasync\nfunction\ncreatePost\n(post\n:\nFormData\n) {\n'use server'\n// write data using the FormData\nrevalidateTag\n(\n'posts'\n,\n'max'\n)\n}\nFor more detailed explanation and usage examples, see the\nuse cache\nAPI reference\n.\nWhat should I cache?\nWhat you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use\nuse cache\nwith\ncacheLife\nto describe that behavior.\nFor content management systems with update mechanisms, consider using tags with longer cache durations and rely on\nrevalidateTag\nto mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\nPutting it all together\nHere's a complete example showing static content, cached dynamic content, and streaming dynamic content working together on a single page:\napp/blog/page.tsx\nimport\n{ Suspense }\nfrom\n'react'\nimport\n{ cookies }\nfrom\n'next/headers'\nimport\n{ cacheLife }\nfrom\n'next/cache'\nimport\nLink\nfrom\n'next/link'\nexport\ndefault\nfunction\nBlogPage\n() {\nreturn\n(\n<>\n{\n/* Static content - prerendered automatically */\n}\n<\nheader\n>\n<\nh1\n>Our Blog</\nh1\n>\n<\nnav\n>\n<\nLink\nhref\n=\n\"/\"\n>Home</\nLink\n> | <\nLink\nhref\n=\n\"/about\"\n>About</\nLink\n>\n</\nnav\n>\n</\nheader\n>\n{\n/* Cached dynamic content - included in the static shell */\n}\n<\nBlogPosts\n/>\n{\n/* Runtime dynamic content - streams at request time */\n}\n<\nSuspense\nfallback\n=\n{<\np\n>Loading your preferences...</\np\n>}>\n<\nUserPreferences\n/>\n</\nSuspense\n>\n</>\n)\n}\n// Everyone sees the same\nblog\nposts (revalidated every hour)\nasync\nfunction\nBlogPosts\n() {\n'use cache'\ncacheLife\n(\n'hours'\n)\nconst\nres\n=\nawait\nfetch\n(\n'https://api.vercel.app/\nblog\n'\n)\nconst\nposts\n=\nawait\nres\n.json\n()\nreturn\n(\n<\nsection\n>\n<\nh2\n>Latest Posts</\nh2\n>\n<\nul\n>\n{\nposts\n.slice\n(\n0\n,\n5\n)\n.map\n((post\n:\nany\n)\n=>\n(\n<\nli\nkey\n=\n{\npost\n.id}>\n<\nh3\n>{\npost\n.title}</\nh3\n>\n<\np\n>\nBy {\npost\n.author} on {\npost\n.date}\n</\np\n>\n</\nli\n>\n))}\n</\nul\n>\n</\nsection\n>\n)\n}\n// Personalized per user based on their cookie\nasync\nfunction\nUserPreferences\n() {\nconst\ntheme\n=\n(\nawait\ncookies\n())\n.get\n(\n'theme'\n)?.value\n||\n'light'\nconst\nfavoriteCategory\n=\n(\nawait\ncookies\n())\n.get\n(\n'category'\n)?.value\nreturn\n(\n<\naside\n>\n<\np\n>Your theme: {theme}</\np\n>\n{favoriteCategory\n&&\n<\np\n>Favorite category: {favoriteCategory}</\np\n>}\n</\naside\n>\n)\n}\nDuring prerendering the header (static) and the blog posts fetched from the API (cached with\nuse cache\n), both become part of the static shell along with the fallback UI for user preferences.\nWhen a user visits the page, they instantly see this prerendered shell with the header and blog posts. Only the personalized preferences need to stream in at request time since they depend on the user's cookies. This ensures fast initial page loads while still providing personalized content.\nMetadata and Viewport\ngenerateMetadata\nand\ngenerateViewport\nare part of rendering your page or layout. During prerendering, their access to runtime data or uncached dynamic data is tracked separately from the rest of the page.\nIf a page or layout is prerenderable but only metadata or viewport accesses uncached dynamic data or runtime data, Next.js requires an explicit choice: cache the data if possible, or signal that deferred rendering is intentional. See\nMetadata with Cache Components\nand\nViewport with Cache Components\nfor how to handle this.\nEnabling Cache Components\nYou can enable Cache Components (which includes PPR) by adding the\ncacheComponents\noption to your Next config file:\nnext.config.ts\nTypeScript\nJavaScript\nTypeScript\nimport\ntype\n{ NextConfig }\nfrom\n'next'\nconst\nnextConfig\n:\nNextConfig\n=\n{\ncacheComponents\n:\ntrue\n,\n}\nexport\ndefault\nnextConfig\nGood to know:\nWhen Cache Components is enabled,\nGET\nRoute Handlers follow the same prerendering model as pages. See\nRoute Handlers with Cache Components\nfor details.\nNavigation uses Activity\nWhen the\ncacheComponents\nflag is enabled, Next.js uses React's\n<Activity>\ncomponent to preserve component state during client-side navigation.\nRather than unmounting the previous route when you navigate away, Next.js sets the Activity mode to\n\"hidden\"\n. This means:\nComponent state is preserved when navigating between routes\nWhen you navigate back, the previous route reappears with its state intact\nEffects are cleaned up when a route is hidden, and recreated when it becomes visible again\nThis behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes.\nGood to know\n: Next.js uses heuristics to keep a few recently visited routes\n\"hidden\"\n, while older routes are removed from the DOM to prevent excessive growth.\nMigrating route segment configs\nWhen Cache Components is enabled, several route segment config options are no longer needed or supported:\ndynamic = \"force-dynamic\"\nNot needed.\nAll pages are dynamic by default.\napp/page.tsx\n// Before - No longer needed\nexport\nconst\ndynamic\n=\n'force-dynamic'\nexport\ndefault\nfunction\nPage\n() {\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\napp/page.tsx\n// After - Just remove it\nexport\ndefault\nfunction\nPage\n() {\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\ndynamic = \"force-static\"\nStart by removing it. When unhandled dynamic or runtime data access is detected during development and build time, Next.js raises an error. Otherwise, the\nprerendering\nstep automatically extracts the static HTML shell.\nFor dynamic data access, add\nuse cache\nas close to the data access as possible with a long\ncacheLife\nlike\n'max'\nto maintain cached behavior. If needed, add it at the top of the page or layout.\nFor runtime data access (\ncookies()\n,\nheaders()\n, etc.), errors will direct you to\nwrap it with\nSuspense\n. Since you started by using\nforce-static\n, you must remove the runtime data access to prevent any request time work.\napp/page.tsx\n// Before\nexport\nconst\ndynamic\n=\n'force-static'\nexport\ndefault\nasync\nfunction\nPage\n() {\nconst\ndata\n=\nawait\nfetch\n(\n'https://api.example.com/data'\n)\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\napp/page.tsx\nimport\n{ cacheLife }\nfrom\n'next/cache'\n// After - Use 'use cache' instead\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\ncacheLife\n(\n'max'\n)\nconst\ndata\n=\nawait\nfetch\n(\n'https://api.example.com/data'\n)\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\nrevalidate\nReplace with\ncacheLife\n.\nUse the\ncacheLife\nfunction to define cache duration instead of the route segment config.\n// Before\nexport\nconst\nrevalidate\n=\n3600\n// 1 hour\nexport\ndefault\nasync\nfunction\nPage\n() {\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\napp/page.tsx\n// After - Use cacheLife\nimport\n{ cacheLife }\nfrom\n'next/cache'\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\ncacheLife\n(\n'hours'\n)\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\nfetchCache\nNot needed.\nWith\nuse cache\n, all data fetching within a cached scope is automatically cached, making\nfetchCache\nunnecessary.\napp/page.tsx\n// Before\nexport\nconst\nfetchCache\n=\n'force-cache'\napp/page.tsx\n// After - Use 'use cache' to control caching behavior\nexport\ndefault\nasync\nfunction\nPage\n() {\n'use cache'\n// All fetches here are cached\nreturn\n<\ndiv\n>...</\ndiv\n>\n}\nruntime = 'edge'\nNot supported.\nCache Components requires Node.js runtime and will throw errors with\nEdge Runtime\n.\nNext Steps\nLearn more about the config option for Cache Components.\ncacheComponents\nLearn how to enable the cacheComponents flag in Next.js.\nuse cache\nLearn how to use the \"use cache\" directive to cache data in your Next.js application.\ncacheLife\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.\ncacheTag\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.\nrevalidateTag\nAPI Reference for the revalidateTag function.\nupdateTag\nAPI Reference for the updateTag function.\nWas this helpful?\nsupported.\nSend",
  "content_markdown": "Menu\n\nUsing App Router\n\nFeatures available in /app\n\nLatest Version\n\n16.1.6\n\n[App Router](/docs/app)[Getting Started](/docs/app/getting-started)Cache Components\n\nCopy page\n\n# Cache Components\n\nLast updated January 26, 2026\n\n> **Good to know:** Cache Components is an opt-in feature. Enable it by setting the `cacheComponents` flag to `true` in your Next config file. See [Enabling Cache Components](#enabling-cache-components) for more details.\n\nCache Components lets you mix static, cached, and dynamic content in a single route, giving you the speed of static sites with the flexibility of dynamic rendering.\n\nServer-rendered applications typically force a choice between static pages (fast but stale) and dynamic pages (fresh but slow). Moving this work to the client trades server load for larger bundles and slower initial rendering.\n\nCache Components eliminates these tradeoffs by prerendering routes into a **static HTML shell** that's immediately sent to the browser, with dynamic content updating the UI as it becomes ready.\n\n![Partially re-rendered Product Page showing static nav and product information, and dynamic cart and recommended products](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Flearn%2Flight%2Fthinking-in-ppr.png&w=3840&q=75)![Partially re-rendered Product Page showing static nav and product information, and dynamic cart and recommended products](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Flearn%2Fdark%2Fthinking-in-ppr.png&w=3840&q=75)\n\n## How rendering works with Cache Components\n\nAt build time, Next.js renders your route's component tree. As long as components don't access network resources, certain system APIs, or require an incoming request to render, their output is **automatically added to the static shell**. Otherwise, you must choose how to handle them:\n\n- Defer rendering to request time by wrapping components in React's [`<Suspense>`](https://react.dev/reference/react/Suspense), [showing fallback UI](#defer-rendering-to-request-time) until the content is ready, or\n- Cache the result using the [`use cache`](/docs/app/api-reference/directives/use-cache) directive to [include it in the static shell](#using-use-cache) (if no request data is needed)\n\nBecause this happens ahead of time, before a request arrives, we refer to it as prerendering. This generates a static shell consisting of HTML for initial page loads and a serialized [RSC Payload](/docs/app/getting-started/server-and-client-components#on-the-server) for client-side navigation, ensuring the browser receives fully rendered content instantly whether users navigate directly to the URL or transition from another page.\n\nNext.js requires you to explicitly handle components that can't complete during prerendering. If they aren't wrapped in `<Suspense>` or marked with `use cache`, you'll see an [`Uncached data was accessed outside of <Suspense>`](https://nextjs.org/docs/messages/blocking-route) error during development and build time.\n\n> **Good to know**: Caching can be applied at the component or function level, while fallback UI can be defined around any subtree, which means you can compose static, cached, and dynamic content within a single route.\n\n![Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&w=3840&q=75)![Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.](/_next/image?url=https%3A%2F%2Fh8DxKfmAPhn8O0p3.public.blob.vercel-storage.com%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&w=3840&q=75)\n\nThis rendering approach is called **Partial Prerendering**, and it's the default behavior with Cache Components. For the rest of this document, we simply refer to it as \"prerendering\" which can produce a partial or complete output.\n\n> **\ud83c\udfa5 Watch:** Why Partial Prerendering and how it works \u2192 [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).\n\n## Automatically prerendered content\n\nOperations like synchronous I/O, module imports, and pure computations can complete during prerendering. Components using only these operations have their rendered output included in the static HTML shell.\n\nBecause all operations in the `Page` component below complete during rendering, its rendered output is automatically included in the static shell. When both the layout and page prerender successfully, the entire route is the static shell.\n\npage.tsx\n\n```\nimport fs from 'node:fs'\n \nexport default async function Page() {\n  // Synchronous file system read\n  const content = fs.readFileSync('./config.json', 'utf-8')\n \n  // Module imports\n  const constants = await import('./constants.json')\n \n  // Pure computations\n  const processed = JSON.parse(content).items.map((item) => item.value * 2)\n \n  return (\n    <div>\n      <h1>{constants.appName}</h1>\n      <ul>\n        {processed.map((value, i) => (\n          <li key={i}>{value}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n```\n\n> **Good to know**: You can verify that a route was fully prerendered by checking the build output summary. Alternatively, see what content was added to the static shell of any page by viewing the page source in your browser.\n\n## Defer rendering to request time\n\nDuring prerendering, when Next.js encounters work it can't complete (like network requests, accessing request data, or async operations), it requires you to explicitly handle it. To defer rendering to request time, a parent component must provide fallback UI using a Suspense boundary. The fallback becomes part of the static shell while the actual content resolves at request time.\n\nPlace Suspense boundaries as close as possible to the components that need them. This maximizes the amount of content in the static shell, since everything outside the boundary can still prerender normally.\n\n> **Good to know**: With Suspense boundaries, multiple dynamic sections can render in parallel rather than blocking each other, reducing total load time.\n\n### Dynamic content\n\nExternal systems provide content asynchronously, which often takes an unpredictable time to resolve and may even fail. This is why prerendering doesn't execute them automatically.\n\nIn general, when you need the latest data from the source on each request (like real-time feeds or personalized content), defer rendering by providing fallback UI with a Suspense boundary.\n\nFor example, the `DynamicContent` component below uses multiple operations that are not automatically prerendered.\n\npage.tsx\n\n```\nimport { Suspense } from 'react'\nimport fs from 'node:fs/promises'\n \nasync function DynamicContent() {\n  // Network request\n  const data = await fetch('https://api.example.com/data')\n \n  // Database query\n  const users = await db.query('SELECT * FROM users')\n \n  // Async file system operation\n  const file = await fs.readFile('..', 'utf-8')\n \n  // Simulating external system delay\n  await new Promise((resolve) => setTimeout(resolve, 100))\n \n  return <div>Not in the static shell</div>\n}\n```\n\nTo use `DynamicContent` within a page, wrap it in `<Suspense>` to define fallback UI:\n\npage.tsx\n\n```\nexport default async function Page(props) {\n  return (\n    <>\n      <h1>Part of the static shell</h1>\n      {/* <p>Loading..</p> is part of the static shell */}\n      <Suspense fallback={<p>Loading..</p>}>\n        <DynamicContent />\n        <div>Sibling excluded from static shell</div>\n      </Suspense>\n    </>\n  )\n}\n```\n\nPrerendering stops at the `fetch` request. The request itself is not started, and any code after it is not executed.\n\nThe fallback (`<p>Loading...</p>`) is included in the static shell, while the component's content streams at request time.\n\nIn this example, since all operations (network request, database query, file read, and timeout) run sequentially within the same component, the content won't appear until they all complete.\n\n> **Good to know**: For dynamic content that doesn't change frequently, you can use `use cache` to include the dynamic data in the static shell instead of streaming it. See the [during prerendering](#during-prerendering) section for an example.\n\n### Runtime data\n\nA specific type of dynamic data that requires request context, only available when a user makes a request.\n\n- [`cookies()`](/docs/app/api-reference/functions/cookies) - User's cookie data\n- [`headers()`](/docs/app/api-reference/functions/headers) - Request headers\n- [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) - URL query parameters\n- [`params`](/docs/app/api-reference/file-conventions/page#params-optional) - Dynamic route parameters (unless at least one sample is provided via [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params)). See [Dynamic Routes with Cache Components](/docs/app/api-reference/file-conventions/dynamic-routes#with-cache-components) for detailed patterns.\n\npage.tsx\n\n```\nimport { cookies, headers } from 'next/headers'\nimport { Suspense } from 'react'\n \nasync function RuntimeData({ searchParams }) {\n  // Accessing request data\n  const cookieStore = await cookies()\n  const headerStore = await headers()\n  const search = await searchParams\n \n  return <div>Not in the static shell</div>\n}\n```\n\nTo use the `RuntimeData` component, wrap it in a `<Suspense>` boundary:\n\npage.tsx\n\n```\nexport default async function Page(props) {\n  return (\n    <>\n      <h1>Part of the static shell</h1>\n      {/* <p>Loading..</p> is part of the static shell */}\n      <Suspense fallback={<p>Loading..</p>}>\n        <RuntimeData searchParams={props.searchParams} />\n        <div>Sibling excluded from static shell</div>\n      </Suspense>\n    </>\n  )\n}\n```\n\nUse [`connection()`](/docs/app/api-reference/functions/connection) if you need to defer to request time without accessing any of the runtime APIs above.\n\n> **Good to know**: Runtime data cannot be cached with `use cache` because it requires request context. Components that access runtime APIs must always be wrapped in `<Suspense>`. However, you can extract values from runtime data and pass them as arguments to cached functions. See the [with runtime data](#with-runtime-data) section for an example.\n\nOne approach for reading runtime data like cookies without blocking the static shell is to pass a promise to a client context provider. See [Sharing data with context and React.cache](/docs/app/getting-started/server-and-client-components#sharing-data-with-context-and-reactcache) for an example.\n\n> **Good to know:** `React.cache` operates in an isolated scope inside `use cache` boundaries. See [React.cache isolation](/docs/app/api-reference/directives/use-cache#reactcache-isolation) for more information.\n\n### Non-deterministic operations\n\nOperations like `Math.random()`, `Date.now()`, or `crypto.randomUUID()` produce different values each time they execute. To ensure these run at request time (generating unique values per request), Cache Components requires you to explicitly signal this intent by calling these operations after dynamic or runtime data access.\n\n```\nimport { connection } from 'next/server'\nimport { Suspense } from 'react'\n \nasync function UniqueContent() {\n  // Explicitly defer to request time\n  await connection()\n \n  // Non-deterministic operations\n  const random = Math.random()\n  const now = Date.now()\n  const date = new Date()\n  const uuid = crypto.randomUUID()\n  const bytes = crypto.getRandomValues(new Uint8Array(16))\n \n  return (\n    <div>\n      <p>{random}</p>\n      <p>{now}</p>\n      <p>{date.getTime()}</p>\n      <p>{uuid}</p>\n      <p>{bytes}</p>\n    </div>\n  )\n}\n```\n\nBecause the `UniqueContent` component defers to request time, to use it within a route, it must be wrapped in `<Suspense>`:\n\npage.tsx\n\n```\nexport default async function Page() {\n  return (\n    // <p>Loading..</p> is part of the static shell\n    <Suspense fallback={<p>Loading..</p>}>\n      <UniqueContent />\n    </Suspense>\n  )\n}\n```\n\nEvery incoming request would see different random numbers, date, etc.\n\n> **Good to know**: You can cache non-deterministic operations with `use cache`. See the [with non-deterministic operations](#with-non-deterministic-operations) section for examples.\n\n## Using `use cache`\n\nThe [`use cache`](/docs/app/api-reference/directives/use-cache) directive caches the return value of async functions and components. You can apply it at the function, component, or file level.\n\nArguments and any closed-over values from parent scopes automatically become part of the [cache key](/docs/app/api-reference/directives/use-cache#cache-keys), which means different inputs produce separate cache entries. This enables personalized or parameterized cached content.\n\nWhen [dynamic content](#dynamic-content) doesn't need to be fetched fresh from the source on every request, caching it lets you include the content in the static shell during prerendering, or reuse the result at runtime across multiple requests.\n\nCached content can be revalidated in two ways: automatically based on the cache lifetime, or on-demand using tags with [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) or [`updateTag`](/docs/app/api-reference/functions/updateTag).\n\n> **Good to know**: See [serialization requirements and constraints](/docs/app/api-reference/directives/use-cache#constraints) for details on what can be cached and how arguments work.\n\n### During prerendering\n\nWhile [dynamic content](#dynamic-content) is fetched from external sources, it's often unlikely to change between accesses. Product catalog data updates with inventory changes, blog post content rarely changes after publishing, and analytics reports for past dates remain static.\n\nIf this data doesn't depend on [runtime data](#runtime-data), you can use the `use cache` directive to include it in the static HTML shell. Use [`cacheLife`](/docs/app/api-reference/functions/cacheLife) to define how long to use the cached data.\n\nWhen revalidation occurs, the static shell is updated with fresh content. See [Tagging and revalidating](#tagging-and-revalidating) for details on on-demand revalidation.\n\napp/page.tsx\n\n```\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  'use cache'\n  cacheLife('hours')\n \n  const users = await db.query('SELECT * FROM users')\n \n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nThe `cacheLife` function accepts a cache profile name (like `'hours'`, `'days'`, or `'weeks'`) or a custom configuration object to control cache behavior:\n\napp/page.tsx\n\n```\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  'use cache'\n  cacheLife({\n    stale: 3600, // 1 hour until considered stale\n    revalidate: 7200, // 2 hours until revalidated\n    expire: 86400, // 1 day until expired\n  })\n \n  const users = await db.query('SELECT * FROM users')\n \n  return (\n    <ul>\n      {users.map((user) => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nSee the [`cacheLife` API reference](/docs/app/api-reference/functions/cacheLife) for available profiles and custom configuration options.\n\n### With runtime data\n\nRuntime data and [`use cache`](/docs/app/api-reference/directives/use-cache) cannot be used in the same scope. However, you can extract values from runtime APIs and pass them as arguments to cached functions.\n\napp/profile/page.tsx\n\n```\nimport { cookies } from 'next/headers'\nimport { Suspense } from 'react'\n \nexport default function Page() {\n  // Page itself creates the dynamic boundary\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      <ProfileContent />\n    </Suspense>\n  )\n}\n \n// Component (not cached) reads runtime data\nasync function ProfileContent() {\n  const session = (await cookies()).get('session')?.value\n \n  return <CachedContent sessionId={session} />\n}\n \n// Cached component/function receives data as props\nasync function CachedContent({ sessionId }: { sessionId: string }) {\n  'use cache'\n  // sessionId becomes part of cache key\n  const data = await fetchUserData(sessionId)\n  return <div>{data}</div>\n}\n```\n\nAt request time, `CachedContent` executes if no matching cache entry is found, and stores the result for future requests.\n\n### With non-deterministic operations\n\nWithin a `use cache` scope, non-deterministic operations execute during prerendering. This is useful when you want the same rendered output served to all users:\n\n```\nexport default async function Page() {\n  'use cache'\n \n  // Execute once, then cached for all requests\n  const random = Math.random()\n  const random2 = Math.random()\n  const now = Date.now()\n  const date = new Date()\n  const uuid = crypto.randomUUID()\n  const bytes = crypto.getRandomValues(new Uint8Array(16))\n \n  return (\n    <div>\n      <p>\n        {random} and {random2}\n      </p>\n      <p>{now}</p>\n      <p>{date.getTime()}</p>\n      <p>{uuid}</p>\n      <p>{bytes}</p>\n    </div>\n  )\n}\n```\n\nAll requests will be served a route containing the same random numbers, timestamp, and UUID until the cache is revalidated.\n\n### Tagging and revalidating\n\nTag cached data with [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and revalidate it after mutations using [`updateTag`](/docs/app/api-reference/functions/updateTag) in Server Actions for immediate updates, or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) when delays in updates are acceptable.\n\n#### With `updateTag`\n\nUse `updateTag` when you need to expire and immediately refresh cached data within the same request:\n\napp/actions.ts\n\n```\nimport { cacheTag, updateTag } from 'next/cache'\n \nexport async function getCart() {\n  'use cache'\n  cacheTag('cart')\n  // fetch data\n}\n \nexport async function updateCart(itemId: string) {\n  'use server'\n  // write data using the itemId\n  // update the user cart\n  updateTag('cart')\n}\n```\n\n#### With `revalidateTag`\n\nUse `revalidateTag` when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.\n\napp/actions.ts\n\n```\nimport { cacheTag, revalidateTag } from 'next/cache'\n \nexport async function getPosts() {\n  'use cache'\n  cacheTag('posts')\n  // fetch data\n}\n \nexport async function createPost(post: FormData) {\n  'use server'\n  // write data using the FormData\n  revalidateTag('posts', 'max')\n}\n```\n\nFor more detailed explanation and usage examples, see the [`use cache` API reference](/docs/app/api-reference/directives/use-cache).\n\n### What should I cache?\n\nWhat you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use `use cache` with `cacheLife` to describe that behavior.\n\nFor content management systems with update mechanisms, consider using tags with longer cache durations and rely on `revalidateTag` to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\n\n## Putting it all together\n\nHere's a complete example showing static content, cached dynamic content, and streaming dynamic content working together on a single page:\n\napp/blog/page.tsx\n\n```\nimport { Suspense } from 'react'\nimport { cookies } from 'next/headers'\nimport { cacheLife } from 'next/cache'\nimport Link from 'next/link'\n \nexport default function BlogPage() {\n  return (\n    <>\n      {/* Static content - prerendered automatically */}\n      <header>\n        <h1>Our Blog</h1>\n        <nav>\n          <Link href=\"/\">Home</Link> | <Link href=\"/about\">About</Link>\n        </nav>\n      </header>\n \n      {/* Cached dynamic content - included in the static shell */}\n      <BlogPosts />\n \n      {/* Runtime dynamic content - streams at request time */}\n      <Suspense fallback={<p>Loading your preferences...</p>}>\n        <UserPreferences />\n      </Suspense>\n    </>\n  )\n}\n \n// Everyone sees the same blog posts (revalidated every hour)\nasync function BlogPosts() {\n  'use cache'\n  cacheLife('hours')\n \n  const res = await fetch('https://api.vercel.app/blog')\n  const posts = await res.json()\n \n  return (\n    <section>\n      <h2>Latest Posts</h2>\n      <ul>\n        {posts.slice(0, 5).map((post: any) => (\n          <li key={post.id}>\n            <h3>{post.title}</h3>\n            <p>\n              By {post.author} on {post.date}\n            </p>\n          </li>\n        ))}\n      </ul>\n    </section>\n  )\n}\n \n// Personalized per user based on their cookie\nasync function UserPreferences() {\n  const theme = (await cookies()).get('theme')?.value || 'light'\n  const favoriteCategory = (await cookies()).get('category')?.value\n \n  return (\n    <aside>\n      <p>Your theme: {theme}</p>\n      {favoriteCategory && <p>Favorite category: {favoriteCategory}</p>}\n    </aside>\n  )\n}\n```\n\nDuring prerendering the header (static) and the blog posts fetched from the API (cached with `use cache`), both become part of the static shell along with the fallback UI for user preferences.\n\nWhen a user visits the page, they instantly see this prerendered shell with the header and blog posts. Only the personalized preferences need to stream in at request time since they depend on the user's cookies. This ensures fast initial page loads while still providing personalized content.\n\n## Metadata and Viewport\n\n`generateMetadata` and `generateViewport` are part of rendering your page or layout. During prerendering, their access to runtime data or uncached dynamic data is tracked separately from the rest of the page.\n\nIf a page or layout is prerenderable but only metadata or viewport accesses uncached dynamic data or runtime data, Next.js requires an explicit choice: cache the data if possible, or signal that deferred rendering is intentional. See [Metadata with Cache Components](/docs/app/api-reference/functions/generate-metadata#with-cache-components) and [Viewport with Cache Components](/docs/app/api-reference/functions/generate-viewport#with-cache-components) for how to handle this.\n\n## Enabling Cache Components\n\nYou can enable Cache Components (which includes PPR) by adding the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) option to your Next config file:\n\nnext.config.ts\n\nTypeScript\n\nJavaScriptTypeScript\n\n```\nimport type { NextConfig } from 'next'\n \nconst nextConfig: NextConfig = {\n  cacheComponents: true,\n}\n \nexport default nextConfig\n```\n\n> **Good to know:** When Cache Components is enabled, `GET` Route Handlers follow the same prerendering model as pages. See [Route Handlers with Cache Components](/docs/app/getting-started/route-handlers#with-cache-components) for details.\n\n## Navigation uses Activity\n\nWhen the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) flag is enabled, Next.js uses React's [`<Activity>`](https://react.dev/reference/react/Activity) component to preserve component state during client-side navigation.\n\nRather than unmounting the previous route when you navigate away, Next.js sets the Activity mode to [`\"hidden\"`](https://react.dev/reference/react/Activity#activity). This means:\n\n- Component state is preserved when navigating between routes\n- When you navigate back, the previous route reappears with its state intact\n- Effects are cleaned up when a route is hidden, and recreated when it becomes visible again\n\nThis behavior improves the navigation experience by maintaining UI state (form inputs, or expanded sections) when users navigate back and forth between routes.\n\n> **Good to know**: Next.js uses heuristics to keep a few recently visited routes `\"hidden\"`, while older routes are removed from the DOM to prevent excessive growth.\n\n## Migrating route segment configs\n\nWhen Cache Components is enabled, several route segment config options are no longer needed or supported:\n\n### `dynamic = \"force-dynamic\"`\n\n**Not needed.** All pages are dynamic by default.\n\napp/page.tsx\n\n```\n// Before - No longer needed\nexport const dynamic = 'force-dynamic'\n \nexport default function Page() {\n  return <div>...</div>\n}\n```\n\napp/page.tsx\n\n```\n// After - Just remove it\nexport default function Page() {\n  return <div>...</div>\n}\n```\n\n### `dynamic = \"force-static\"`\n\nStart by removing it. When unhandled dynamic or runtime data access is detected during development and build time, Next.js raises an error. Otherwise, the [prerendering](#automatically-prerendered-content) step automatically extracts the static HTML shell.\n\nFor dynamic data access, add [`use cache`](#using-use-cache) as close to the data access as possible with a long [`cacheLife`](/docs/app/api-reference/functions/cacheLife) like `'max'` to maintain cached behavior. If needed, add it at the top of the page or layout.\n\nFor runtime data access (`cookies()`, `headers()`, etc.), errors will direct you to [wrap it with `Suspense`](#runtime-data). Since you started by using `force-static`, you must remove the runtime data access to prevent any request time work.\n\napp/page.tsx\n\n```\n// Before\nexport const dynamic = 'force-static'\n \nexport default async function Page() {\n  const data = await fetch('https://api.example.com/data')\n  return <div>...</div>\n}\n```\n\napp/page.tsx\n\n```\nimport { cacheLife } from 'next/cache'\n \n// After - Use 'use cache' instead\nexport default async function Page() {\n  'use cache'\n  cacheLife('max')\n  const data = await fetch('https://api.example.com/data')\n  return <div>...</div>\n}\n```\n\n### `revalidate`\n\n**Replace with `cacheLife`.** Use the `cacheLife` function to define cache duration instead of the route segment config.\n\n```\n// Before\nexport const revalidate = 3600 // 1 hour\n \nexport default async function Page() {\n  return <div>...</div>\n}\n```\n\napp/page.tsx\n\n```\n// After - Use cacheLife\nimport { cacheLife } from 'next/cache'\n \nexport default async function Page() {\n  'use cache'\n  cacheLife('hours')\n  return <div>...</div>\n}\n```\n\n### `fetchCache`\n\n**Not needed.** With `use cache`, all data fetching within a cached scope is automatically cached, making `fetchCache` unnecessary.\n\napp/page.tsx\n\n```\n// Before\nexport const fetchCache = 'force-cache'\n```\n\napp/page.tsx\n\n```\n// After - Use 'use cache' to control caching behavior\nexport default async function Page() {\n  'use cache'\n  // All fetches here are cached\n  return <div>...</div>\n}\n```\n\n### `runtime = 'edge'`\n\n**Not supported.** Cache Components requires Node.js runtime and will throw errors with [Edge Runtime](/docs/app/api-reference/edge).\n\n## Next Steps\n\nLearn more about the config option for Cache Components.\n\n[### cacheComponents\n\nLearn how to enable the cacheComponents flag in Next.js.](/docs/app/api-reference/config/next-config-js/cacheComponents)[### use cache\n\nLearn how to use the \"use cache\" directive to cache data in your Next.js application.](/docs/app/api-reference/directives/use-cache)[### cacheLife\n\nLearn how to use the cacheLife function to set the cache expiration time for a cached function or component.](/docs/app/api-reference/functions/cacheLife)[### cacheTag\n\nLearn how to use the cacheTag function to manage cache invalidation in your Next.js application.](/docs/app/api-reference/functions/cacheTag)[### revalidateTag\n\nAPI Reference for the revalidateTag function.](/docs/app/api-reference/functions/revalidateTag)[### updateTag\n\nAPI Reference for the updateTag function.](/docs/app/api-reference/functions/updateTag)\n\nWas this helpful?\n\nsupported.\n\nSend",
  "tags": [
    "nextjs",
    "react",
    "ssr",
    "framework"
  ],
  "extracted_at": "2026-02-03T12:54:52.183537+00:00",
  "content_length": 22933,
  "content_hash": "9b3fdc464fc6a095"
}