{
  "id": "vue-patterns__guide_components_slots_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/components/slots.html",
  "title": "Slots\u200b",
  "content": "Slots\n\u200b\nThis page assumes you've already read the\nComponents Basics\n. Read that first if you are new to components.\nWatch a free video lesson on Vue School\nSlot Content and Outlet\n\u200b\nWe have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\nFor example, we may have a\n<FancyButton>\ncomponent that supports usage like this:\ntemplate\n<\nFancyButton\n>\nClick me!\n<!-- slot content -->\n</\nFancyButton\n>\nThe template of\n<FancyButton>\nlooks like this:\ntemplate\n<\nbutton\nclass\n=\n\"fancy-btn\"\n>\n<\nslot\n></\nslot\n>\n<!-- slot outlet -->\n</\nbutton\n>\nThe\n<slot>\nelement is a\nslot outlet\nthat indicates where the parent-provided\nslot content\nshould be rendered.\nAnd the final rendered DOM:\nhtml\n<\nbutton\nclass\n=\n\"fancy-btn\"\n>Click me!</\nbutton\n>\nTry it in the Playground\nTry it in the Playground\nWith slots, the\n<FancyButton>\nis responsible for rendering the outer\n<button>\n(and its fancy styling), while the inner content is provided by the parent component.\nAnother way to understand slots is by comparing them to JavaScript functions:\njs\n// parent component passing slot content\nFancyButton\n(\n'Click me!'\n)\n// FancyButton renders slot content in its own template\nfunction\nFancyButton\n(\nslotContent\n) {\nreturn\n`<button class=\"fancy-btn\">\n${\nslotContent\n}\n</button>`\n}\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\ntemplate\n<\nFancyButton\n>\n<\nspan\nstyle\n=\n\"color:red\"\n>Click me!</\nspan\n>\n<\nAwesomeIcon\nname\n=\n\"plus\"\n/>\n</\nFancyButton\n>\nTry it in the Playground\nTry it in the Playground\nBy using slots, our\n<FancyButton>\nis more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\nVue components' slot mechanism is inspired by the\nnative Web Component\n<slot>\nelement\n, but with additional capabilities that we will see later.\nRender Scope\n\u200b\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\ntemplate\n<\nspan\n>{{ message }}</\nspan\n>\n<\nFancyButton\n>{{ message }}</\nFancyButton\n>\nHere both\n{{ message }}\ninterpolations will render the same content.\nSlot content does\nnot\nhave access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\nExpressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.\nFallback Content\n\u200b\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a\n<SubmitButton>\ncomponent:\ntemplate\n<\nbutton\ntype\n=\n\"submit\"\n>\n<\nslot\n></\nslot\n>\n</\nbutton\n>\nWe might want the text \"Submit\" to be rendered inside the\n<button>\nif the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the\n<slot>\ntags:\ntemplate\n<\nbutton\ntype\n=\n\"submit\"\n>\n<\nslot\n>\nSubmit\n<!-- fallback content -->\n</\nslot\n>\n</\nbutton\n>\nNow when we use\n<SubmitButton>\nin a parent component, providing no content for the slot:\ntemplate\n<\nSubmitButton\n/>\nThis will render the fallback content, \"Submit\":\nhtml\n<\nbutton\ntype\n=\n\"submit\"\n>Submit</\nbutton\n>\nBut if we provide content:\ntemplate\n<\nSubmitButton\n>Save</\nSubmitButton\n>\nThen the provided content will be rendered instead:\nhtml\n<\nbutton\ntype\n=\n\"submit\"\n>Save</\nbutton\n>\nTry it in the Playground\nTry it in the Playground\nNamed Slots\n\u200b\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a\n<BaseLayout>\ncomponent with the following template:\ntemplate\n<\ndiv\nclass\n=\n\"container\"\n>\n<\nheader\n>\n<!-- We want header content here -->\n</\nheader\n>\n<\nmain\n>\n<!-- We want main content here -->\n</\nmain\n>\n<\nfooter\n>\n<!-- We want footer content here -->\n</\nfooter\n>\n</\ndiv\n>\nFor these cases, the\n<slot>\nelement has a special attribute,\nname\n, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\ntemplate\n<\ndiv\nclass\n=\n\"container\"\n>\n<\nheader\n>\n<\nslot\nname\n=\n\"header\"\n></\nslot\n>\n</\nheader\n>\n<\nmain\n>\n<\nslot\n></\nslot\n>\n</\nmain\n>\n<\nfooter\n>\n<\nslot\nname\n=\n\"footer\"\n></\nslot\n>\n</\nfooter\n>\n</\ndiv\n>\nA\n<slot>\noutlet without\nname\nimplicitly has the name \"default\".\nIn a parent component using\n<BaseLayout>\n, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where\nnamed slots\ncome in.\nTo pass a named slot, we need to use a\n<template>\nelement with the\nv-slot\ndirective, and then pass the name of the slot as an argument to\nv-slot\n:\ntemplate\n<\nBaseLayout\n>\n<\ntemplate\nv-slot:header\n>\n<!-- content for the header slot -->\n</\ntemplate\n>\n</\nBaseLayout\n>\nv-slot\nhas a dedicated shorthand\n#\n, so\n<template v-slot:header>\ncan be shortened to just\n<template #header>\n. Think of it as \"render this template fragment in the child component's 'header' slot\".\nHere's the code passing content for all three slots to\n<BaseLayout>\nusing the shorthand syntax:\ntemplate\n<\nBaseLayout\n>\n<\ntemplate\n#\nheader\n>\n<\nh1\n>Here might be a page title</\nh1\n>\n</\ntemplate\n>\n<\ntemplate\n#\ndefault\n>\n<\np\n>A paragraph for the main content.</\np\n>\n<\np\n>And another one.</\np\n>\n</\ntemplate\n>\n<\ntemplate\n#\nfooter\n>\n<\np\n>Here's some contact info</\np\n>\n</\ntemplate\n>\n</\nBaseLayout\n>\nWhen a component accepts both a default slot and named slots, all top-level non-\n<template>\nnodes are implicitly treated as content for the default slot. So the above can also be written as:\ntemplate\n<\nBaseLayout\n>\n<\ntemplate\n#\nheader\n>\n<\nh1\n>Here might be a page title</\nh1\n>\n</\ntemplate\n>\n<!-- implicit default slot -->\n<\np\n>A paragraph for the main content.</\np\n>\n<\np\n>And another one.</\np\n>\n<\ntemplate\n#\nfooter\n>\n<\np\n>Here's some contact info</\np\n>\n</\ntemplate\n>\n</\nBaseLayout\n>\nNow everything inside the\n<template>\nelements will be passed to the corresponding slots. The final rendered HTML will be:\nhtml\n<\ndiv\nclass\n=\n\"container\"\n>\n<\nheader\n>\n<\nh1\n>Here might be a page title</\nh1\n>\n</\nheader\n>\n<\nmain\n>\n<\np\n>A paragraph for the main content.</\np\n>\n<\np\n>And another one.</\np\n>\n</\nmain\n>\n<\nfooter\n>\n<\np\n>Here's some contact info</\np\n>\n</\nfooter\n>\n</\ndiv\n>\nTry it in the Playground\nTry it in the Playground\nAgain, it may help you understand named slots better using the JavaScript function analogy:\njs\n// passing multiple slot fragments with different names\nBaseLayout\n({\nheader:\n`...`\n,\ndefault:\n`...`\n,\nfooter:\n`...`\n})\n// <BaseLayout> renders them in different places\nfunction\nBaseLayout\n(\nslots\n) {\nreturn\n`<div class=\"container\">\n<header>${\nslots\n.\nheader\n}</header>\n<main>${\nslots\n.\ndefault\n}</main>\n<footer>${\nslots\n.\nfooter\n}</footer>\n</div>`\n}\nConditional Slots\n\u200b\nSometimes you want to render something based on whether or not content has been passed to a slot.\nYou can use the\n$slots\nproperty in combination with a\nv-if\nto achieve this.\nIn the example below we define a Card component with three conditional slots:\nheader\n,\nfooter\nand the\ndefault\none. When content for the header / footer / default is present, we want to wrap it to provide additional styling:\ntemplate\n<\ntemplate\n>\n<\ndiv\nclass\n=\n\"card\"\n>\n<\ndiv\nv-if\n=\n\"\n$slots.header\n\"\nclass\n=\n\"card-header\"\n>\n<\nslot\nname\n=\n\"header\"\n/>\n</\ndiv\n>\n<\ndiv\nv-if\n=\n\"\n$slots.default\n\"\nclass\n=\n\"card-content\"\n>\n<\nslot\n/>\n</\ndiv\n>\n<\ndiv\nv-if\n=\n\"\n$slots.footer\n\"\nclass\n=\n\"card-footer\"\n>\n<\nslot\nname\n=\n\"footer\"\n/>\n</\ndiv\n>\n</\ndiv\n>\n</\ntemplate\n>\nTry it in the Playground\nDynamic Slot Names\n\u200b\nDynamic directive arguments\nalso work on\nv-slot\n, allowing the definition of dynamic slot names:\ntemplate\n<\nbase-layout\n>\n<\ntemplate\nv-slot:\n[\ndynamicSlotName\n]>\n...\n</\ntemplate\n>\n<!-- with shorthand -->\n<\ntemplate\n#[\ndynamicSlotName\n]>\n...\n</\ntemplate\n>\n</\nbase-layout\n>\nDo note the expression is subject to the\nsyntax constraints\nof dynamic directive arguments.\nScoped Slots\n\u200b\nAs discussed in\nRender Scope\n, slot content does not have access to state in the child component.\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\ntemplate\n<!-- <MyComponent> template -->\n<\ndiv\n>\n<\nslot\n:\ntext\n=\n\"\ngreetingMessage\n\"\n:\ncount\n=\n\"\n1\n\"\n></\nslot\n>\n</\ndiv\n>\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using\nv-slot\ndirectly on the child component tag:\ntemplate\n<\nMyComponent\nv-slot\n=\n\"\nslotProps\n\"\n>\n{{ slotProps.text }} {{ slotProps.count }}\n</\nMyComponent\n>\nTry it in the Playground\nTry it in the Playground\nThe props passed to the slot by the child are available as the value of the corresponding\nv-slot\ndirective, which can be accessed by expressions inside the slot.\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\njs\nMyComponent\n({\n// passing the default slot, but as a function\ndefault\n: (\nslotProps\n)\n=>\n{\nreturn\n`${\nslotProps\n.\ntext\n} ${\nslotProps\n.\ncount\n}`\n}\n})\nfunction\nMyComponent\n(\nslots\n) {\nconst\ngreetingMessage\n=\n'hello'\nreturn\n`<div>${\n// call the slot function with props!\nslots\n.\ndefault\n({ text:\ngreetingMessage\n, count:\n1\n})\n}</div>`\n}\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual\nrender functions\n.\nNotice how\nv-slot=\"slotProps\"\nmatches the slot function signature. Just like with function arguments, we can use destructuring in\nv-slot\n:\ntemplate\n<\nMyComponent\nv-slot\n=\n\"\n{ text, count }\n\"\n>\n{{ text }} {{ count }}\n</\nMyComponent\n>\nNamed Scoped Slots\n\u200b\nNamed scoped slots work similarly - slot props are accessible as the value of the\nv-slot\ndirective:\nv-slot:name=\"slotProps\"\n. When using the shorthand, it looks like this:\ntemplate\n<\nMyComponent\n>\n<\ntemplate\n#\nheader\n=\n\"\nheaderProps\n\"\n>\n{{ headerProps }}\n</\ntemplate\n>\n<\ntemplate\n#\ndefault\n=\n\"\ndefaultProps\n\"\n>\n{{ defaultProps }}\n</\ntemplate\n>\n<\ntemplate\n#\nfooter\n=\n\"\nfooterProps\n\"\n>\n{{ footerProps }}\n</\ntemplate\n>\n</\nMyComponent\n>\nPassing props to a named slot:\ntemplate\n<\nslot\nname\n=\n\"header\"\nmessage\n=\n\"hello\"\n></\nslot\n>\nNote the\nname\nof a slot won't be included in the props because it is reserved - so the resulting\nheaderProps\nwould be\n{ message: 'hello' }\n.\nIf you are mixing named slots with the default scoped slot, you need to use an explicit\n<template>\ntag for the default slot. Attempting to place the\nv-slot\ndirective directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\ntemplate\n<!-- <MyComponent> template -->\n<\ndiv\n>\n<\nslot\n:\nmessage\n=\n\"\nhello\n\"\n></\nslot\n>\n<\nslot\nname\n=\n\"footer\"\n/>\n</\ndiv\n>\ntemplate\n<!-- This template won't compile -->\n<\nMyComponent\nv-slot\n=\n\"\n{ message }\n\"\n>\n<\np\n>{{ message }}</\np\n>\n<\ntemplate\n#\nfooter\n>\n<!-- message belongs to the default slot, and is not available here -->\n<\np\n>{{ message }}</\np\n>\n</\ntemplate\n>\n</\nMyComponent\n>\nUsing an explicit\n<template>\ntag for the default slot helps to make it clear that the\nmessage\nprop is not available inside the other slot:\ntemplate\n<\nMyComponent\n>\n<!-- Use explicit default slot -->\n<\ntemplate\n#\ndefault\n=\n\"\n{ message }\n\"\n>\n<\np\n>{{ message }}</\np\n>\n</\ntemplate\n>\n<\ntemplate\n#\nfooter\n>\n<\np\n>Here's some contact info</\np\n>\n</\ntemplate\n>\n</\nMyComponent\n>\nFancy List Example\n\u200b\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a\n<FancyList>\ncomponent that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\ntemplate\n<\nFancyList\n:\napi-url\n=\n\"\nurl\n\"\n:\nper-page\n=\n\"\n10\n\"\n>\n<\ntemplate\n#\nitem\n=\n\"\n{ body, username, likes }\n\"\n>\n<\ndiv\nclass\n=\n\"item\"\n>\n<\np\n>{{ body }}</\np\n>\n<\np\n>by {{ username }} | {{ likes }} likes</\np\n>\n</\ndiv\n>\n</\ntemplate\n>\n</\nFancyList\n>\nInside\n<FancyList>\n, we can render the same\n<slot>\nmultiple times with different item data (notice we are using\nv-bind\nto pass an object as slot props):\ntemplate\n<\nul\n>\n<\nli\nv-for\n=\n\"\nitem\nin\nitems\n\"\n>\n<\nslot\nname\n=\n\"item\"\nv-bind\n=\n\"\nitem\n\"\n></\nslot\n>\n</\nli\n>\n</\nul\n>\nTry it in the Playground\nTry it in the Playground\nRenderless Components\n\u200b\nThe\n<FancyList>\nuse case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a\nRenderless Component\n.\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\ntemplate\n<\nMouseTracker\nv-slot\n=\n\"\n{ x, y }\n\"\n>\nMouse is at: {{ x }}, {{ y }}\n</\nMouseTracker\n>\nTry it in the Playground\nTry it in the Playground\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a\nComposable\n.\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic\nand\ncompose visual output, like in the\n<FancyList>\nexample.\nEdit this page on GitHub",
  "content_markdown": "# Slots [\u200b](#slots)\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-3-component-slots?friend=vuejs \"Free Vue.js Slots Lesson\")\n\n## Slot Content and Outlet [\u200b](#slot-content-and-outlet)\n\nWe have learned that components can accept props, which can be JavaScript values of any type. But how about template content? In some cases, we may want to pass a template fragment to a child component, and let the child component render the fragment within its own template.\n\nFor example, we may have a `<FancyButton>` component that supports usage like this:\n\ntemplate\n\n```\n<FancyButton>\n  Click me! <!-- slot content -->\n</FancyButton>\n```\n\nThe template of `<FancyButton>` looks like this:\n\ntemplate\n\n```\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot outlet -->\n</button>\n```\n\nThe `<slot>` element is a **slot outlet** that indicates where the parent-provided **slot content** should be rendered.\n\n![slot diagram](/assets/slots.CKcE8XYd.png)\n\nAnd the final rendered DOM:\n\nhtml\n\n```\n<button class=\"fancy-btn\">Click me!</button>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNpdUdlqAyEU/ZVbQ0kLMdNsXabTQFvoV8yLcRkkjopLSQj596oTwqRvnuM9y9UT+rR2/hs5qlHjqZM2gOch2m2rZW+NC/BDND1+xRCMBuFMD9N5NeKyeNrqphrUSZdA4L1VJPCEAJrRdCEAvpWke+g5NHcYg1cmADU6cB0A4zzThmYckqimupqiGfpXILe/zdwNhaki3n+0SOR5vAu6ReU++efUajtqYGJQ/FIg5w8Wt9FlOx+OKh/nV1c4ZVNqlHE1TIQQ7xnvCN13zkTNalBSc+Jw5wiTac2H1WLDeDeDyXrJVm9LWG7uE3hev3AhHge1cYwnO200L4QljEnd1bCxB1g82UNhe+I6qQs5kuGcE30NrxeaRudzOWtkemeXuHP5tLIKOv8BN+mw3w==)\n\n[Try it in the Playground](https://play.vuejs.org/#eNpdUdtOwzAM/RUThAbSurIbl1ImARJf0ZesSapoqROlKdo07d9x0jF1SHmIT+xzcY7sw7nZTy9Zwcqu9tqFTYW6ddYH+OZYHz77ECyC8raFySwfYXFsUiFAhXKfBoRUvDcBjhGtLbGgxNAVcLziOlVIp8wvelQE2TrDg6QKoBx1JwDgy+h6B62E8ibLoDM2kAAGoocsiz1VKMfmCCrzCymbsn/GY95rze1grja8694rpmJ/tg1YsfRO/FE134wc2D4YeTYQ9QeKa+mUrgsHE6+zC+vfjoz1Bdwqpd5iveX1rvG2R1GA0Si5zxrPhaaY98v5WshmCrerhVi+LmCxvqPiafUslXoYpq0XkuiQ1p4Ax4XQ2BSwdnuYP7p9QlvuG40JHI1lUaenv3o5w3Xvu2jOWU179oQNn5aisNMvLBvDOg==)\n\nWith slots, the `<FancyButton>` is responsible for rendering the outer `<button>` (and its fancy styling), while the inner content is provided by the parent component.\n\nAnother way to understand slots is by comparing them to JavaScript functions:\n\njs\n\n```\n// parent component passing slot content\nFancyButton('Click me!')\n\n// FancyButton renders slot content in its own template\nfunction FancyButton(slotContent) {\n  return `<button class=\"fancy-btn\">\n      ${slotContent}\n    </button>`\n}\n```\n\nSlot content is not just limited to text. It can be any valid template content. For example, we can pass in multiple elements, or even other components:\n\ntemplate\n\n```\n<FancyButton>\n  <span style=\"color:red\">Click me!</span>\n  <AwesomeIcon name=\"plus\" />\n</FancyButton>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1UmtOwkAQvspQYtCEgrx81EqCJibeoX+W7bRZaHc3+1AI4QyewH8ewvN4Aa/gbgtNIfFf5+vMfI/ZXbCQcvBmMYiCWFPFpAGNxsp5wlkphTLwQjjdPlljBIdMiRJ6g2EL88O9pnnxjlqU+EpbzS3s0BwPaypH4gqDpSyIQVcBxK3VFQDwXDC6hhJdlZi4zf3fRKwl4aDNtsDHJKCiECqiW8KTYH5c1gEnwnUdJ9rCh/XeM6Z42AgN+sFZAj6+Ux/LOjFaEK2diMz3h0vjNfj/zokuhPFU3lTdfcpShVOZcJ+DZgHs/HxtCrpZlj34eknoOlfC8jSCgnEkKswVSRlyczkZzVLM+9CdjtPJ/RjGswtX3ExvMcuu6mmhUnTruOBYAZKkKeN5BDO5gdG13FRoSVTOeAW2xkLPY3UEdweYWqW9OCkYN6gctq9uXllx2Z09CJ9dJwzBascI7nBYihWDldUGMqEgdTVIq6TQqCEMfUpNSD+fX7/fH+3b7P8AdGP6wA==)\n\n[Try it in the Playground](https://play.vuejs.org/#eNptUltu2zAQvMpGQZEWsOzGiftQ1QBpgQK9g35oaikwkUiCj9aGkTPkBPnLIXKeXCBXyJKKBdoIoA/tYGd3doa74tqY+b+ARVXUjltp/FWj5GC09fCHKb79FbzXCoTVA5zNFxkWaWdT8/V/dHrAvzxrzrC3ZoBG4SYRWhQs9B52EeWapihU3lWwyxfPDgbfNYq+ejEppcLjYHrmkSqAOqMmAOB3L/ktDEhV4+v8gMR/l1M7wxQ4v+3xZ1Nw3Wtb8S1TTXG1H3cCJIO69oxc5mLUcrSrXkxSi1lxZGT0//CS9Wg875lzJELE/nLto4bko69dr31cFc8auw+3JHvSEfQ7nwbsHY9HwakQ4kes14zfdlYH1VbQS4XMlp1lraRMPl6cr1rsZnB6uWwvvi9hufpAxZfLryjEp5GtbYs0TlGICTCsbaXqKliZDZx/NpuEDsx2UiUwo5VxT6Dkv73BPFgXxRktlUdL2Jh6OoW8O3pX0buTsoTgaCNQcDjoGwk3wXkQ2tJLGzSYYI126KAso0uTSc8Pjy9P93k2d6+NyRKa)\n\nBy using slots, our `<FancyButton>` is more flexible and reusable. We can now use it in different places with different inner content, but all with the same fancy styling.\n\nVue components' slot mechanism is inspired by the [native Web Component `<slot>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot), but with additional capabilities that we will see later.\n\n## Render Scope [\u200b](#render-scope)\n\nSlot content has access to the data scope of the parent component, because it is defined in the parent. For example:\n\ntemplate\n\n```\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\nHere both `{{ message }}` interpolations will render the same content.\n\nSlot content does **not** have access to the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with JavaScript's lexical scoping. In other words:\n\n> Expressions in the parent template only have access to the parent scope; expressions in the child template only have access to the child scope.\n\n## Fallback Content [\u200b](#fallback-content)\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a `<SubmitButton>` component:\n\ntemplate\n\n```\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\nWe might want the text \"Submit\" to be rendered inside the `<button>` if the parent didn't provide any slot content. To make \"Submit\" the fallback content, we can place it in between the `<slot>` tags:\n\ntemplate\n\n```\n<button type=\"submit\">\n  <slot>\n    Submit <!-- fallback content -->\n  </slot>\n</button>\n```\n\nNow when we use `<SubmitButton>` in a parent component, providing no content for the slot:\n\ntemplate\n\n```\n<SubmitButton />\n```\n\nThis will render the fallback content, \"Submit\":\n\nhtml\n\n```\n<button type=\"submit\">Submit</button>\n```\n\nBut if we provide content:\n\ntemplate\n\n```\n<SubmitButton>Save</SubmitButton>\n```\n\nThen the provided content will be rendered instead:\n\nhtml\n\n```\n<button type=\"submit\">Save</button>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1kMsKwjAQRX9lzMaNbfcSC/oL3WbT1ikU8yKZFEX8d5MGgi2YVeZxZ86dN7taWy8B2ZlxP7rZEnikYFuhZ2WNI+jCoGa6BSKjYXJGwbFufpNJfhSaN1kflTEgVFb2hDEC4IeqguARpl7KoR8fQPgkqKpc3Wxo1lxRWWeW+Y4wBk9x9V9d2/UL8g1XbOJN4WAntodOnrecQ2agl8WLYH7tFyw5olj10iR3EJ+gPCxDFluj0YS6EAqKR8mi9M3Td1ifLxWShcU=)\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1UEEOwiAQ/MrKxYu1d4Mm+gWvXChuk0YKpCyNxvh3lxIb28SEA8zuDDPzEucQ9mNCcRAymqELdFKu64MfCK6p6Tu6JCLvoB18D9t9/Qtm4lY5AOXwMVFu2OpkCV4ZNZ51HDqKhwLAQjIjb+X4yHr+mh+EfbCakF8AclNVkCJCq61ttLkD4YOgqsp0YbGesJkVBj92NwSTIrH3v7zTVY8oF8F4SdazD7ET69S5rqXPpnigZ8CjEnHaVyInIp5G63O6XIGiIlZMzrGMd8RVfR0q4lIKKV+L+srW+wNTTZq3)\n\n## Named Slots [\u200b](#named-slots)\n\nThere are times when it's useful to have multiple slot outlets in a single component. For example, in a `<BaseLayout>` component with the following template:\n\ntemplate\n\n```\n<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>\n```\n\nFor these cases, the `<slot>` element has a special attribute, `name`, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:\n\ntemplate\n\n```\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\nA `<slot>` outlet without `name` implicitly has the name \"default\".\n\nIn a parent component using `<BaseLayout>`, we need a way to pass multiple slot content fragments, each targeting a different slot outlet. This is where **named slots** come in.\n\nTo pass a named slot, we need to use a `<template>` element with the `v-slot` directive, and then pass the name of the slot as an argument to `v-slot`:\n\ntemplate\n\n```\n<BaseLayout>\n  <template v-slot:header>\n    <!-- content for the header slot -->\n  </template>\n</BaseLayout>\n```\n\n`v-slot` has a dedicated shorthand `#`, so `<template v-slot:header>` can be shortened to just `<template #header>`. Think of it as \"render this template fragment in the child component's 'header' slot\".\n\n![named slots diagram](/assets/named-slots.CCIb9Mo_.png)\n\nHere's the code passing content for all three slots to `<BaseLayout>` using the shorthand syntax:\n\ntemplate\n\n```\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\nWhen a component accepts both a default slot and named slots, all top-level non-`<template>` nodes are implicitly treated as content for the default slot. So the above can also be written as:\n\ntemplate\n\n```\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <!-- implicit default slot -->\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</BaseLayout>\n```\n\nNow everything inside the `<template>` elements will be passed to the corresponding slots. The final rendered HTML will be:\n\nhtml\n\n```\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9UsFuwjAM/RWrHLgMOi5o6jIkdtphn9BLSF0aKU2ixEVjiH+fm8JoQdvRfu/5xS8+ZVvvl4cOsyITUQXtCSJS5zel1a13geBdRvyUR9cR1MG1MF/mt1YvnZdW5IOWVVwQtt5IQq4AxI2cau5ccZg1KCsMlz4jzWrzgQGh1fuGYIcgwcs9AmkyKHKGLyPykcfD1Apr2ZmrHUN+s+U5Qe6D9A3ULgA1bCK1BeUsoaWlyPuVb3xbgbSOaQGcxRH8v3XtHI0X8mmfeYToWkxmUhFoW7s/JvblJLERmj1l0+T7T5tqK30AZWSMb2WW3LTFUGZXp/u8o3EEVrbI9AFjLn8mt38fN9GIPrSp/p4/Yoj7OMZ+A/boN9KInPeZZpAOLNLRDAsPZDgN4p0L/NQFOV/Ayn9x6EZXMFNKvQ4E5YwLBczW6/WlU3NIi6i/sYDn5Qu2qX1OF51MsvMPkrIEHg==)\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9UkFuwjAQ/MoqHLiUpFxQlaZI9NRDn5CLSTbEkmNb9oKgiL934wRwQK3ky87O7njGPicba9PDHpM8KXzlpKV1qWVnjSP4FB6/xcnsCRpnOpin2R3qh+alBig1HgO9xkbsFcG5RyvDOzRq8vkAQLSury+l5lNkN1EuCDurBCFXAMWdH2pGrn2YtShqdCPOnXa5/kKH0MldS7BFEGDFDoEkKSwybo8rskjjaevo4L7Wrje8x4mdE7aFxjiglkWE1GxQE9tLi8xO+LoGoQ3THLD/qP2/dGMMxYZs8DP34E2HQUxUBFI35o+NfTlJLOomL8n04frXns7W8gCVEt5/lElQkxpdmVyVHvP2yhBo0SHThx5z+TEZvl1uMlP0oU3nH/kRo3iMI9Ybes960UyRsZ9pBuGDeTqpwfBAvn7NrXF81QUZm8PSHjl0JWuYVVX1PhAqo4zLYbZarUak4ZAWXv5gDq/pG3YBHn50EEkuv5irGBk=)\n\nAgain, it may help you understand named slots better using the JavaScript function analogy:\n\njs\n\n```\n// passing multiple slot fragments with different names\nBaseLayout({\n  header: `...`,\n  default: `...`,\n  footer: `...`\n})\n\n// <BaseLayout> renders them in different places\nfunction BaseLayout(slots) {\n  return `<div class=\"container\">\n      <header>${slots.header}</header>\n      <main>${slots.default}</main>\n      <footer>${slots.footer}</footer>\n    </div>`\n}\n```\n\n## Conditional Slots [\u200b](#conditional-slots)\n\nSometimes you want to render something based on whether or not content has been passed to a slot.\n\nYou can use the [$slots](/api/component-instance#slots) property in combination with a [v-if](/guide/essentials/conditional#v-if) to achieve this.\n\nIn the example below we define a Card component with three conditional slots: `header`, `footer` and the `default` one. When content for the header / footer / default is present, we want to wrap it to provide additional styling:\n\ntemplate\n\n```\n<template>\n  <div class=\"card\">\n    <div v-if=\"$slots.header\" class=\"card-header\">\n      <slot name=\"header\" />\n    </div>\n    \n    <div v-if=\"$slots.default\" class=\"card-content\">\n      <slot />\n    </div>\n    \n    <div v-if=\"$slots.footer\" class=\"card-footer\">\n      <slot name=\"footer\" />\n    </div>\n  </div>\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqVVMtu2zAQ/BWCLZBLIjVoTq4aoA1yaA9t0eaoCy2tJcYUSZCUKyPwv2dJioplOw4C+EDuzM4+ONYT/aZ1tumBLmhhK8O1IxZcr29LyTutjCN3zNRkZVRHLrLcXzz9opRFHvnIxIuDTgvmAG+EFJ4WTnhOCPnQAqvBjHFE2uvbh5Zbgj/XAolwkWN4TM33VI/UalixXvjyo5yeqVVKOpCuyP0ob6utlHL7vUE3U4twkWP4hJq/jiPP4vSSOouNrHiTPVolcclPnl3SSnWaCzC/teNK2pIuSEA8xoRQ/3+GmDM9XKZ41UK1PhF/tIOPlfSPAQtmAyWdMMdMAy7C9/9+wYDnCexU3QtknwH/glWi9z1G2vde1tj2Hi90+yNYhcvmwd4PuHabhvKNeuYu8EuK1rk7M/pLu5+zm5BXyh1uMdnOu3S+95pvSCWYtV9xQcgqaXogj2yu+AqBj1YoZ7NosJLOEq5S9OXtPZtI1gFSppx8engUHs+vVhq9eVhq9ORRrXdpRyseSqfo6SmmnONK6XTw9yis24q448wXSG+0VAb3sSDXeiBoDV6TpWDV+ktENatrdMGCfAoBfL1JYNzzpINJjVFoJ9yKUKho19ul6OFQ6UYPx1rjIpPYeXIc/vXCgjetawzbni0dPnhhJ3T3DMVSruI=)\n\n## Dynamic Slot Names [\u200b](#dynamic-slot-names)\n\n[Dynamic directive arguments](/guide/essentials/template-syntax#dynamic-arguments) also work on `v-slot`, allowing the definition of dynamic slot names:\n\ntemplate\n\n```\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- with shorthand -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\nDo note the expression is subject to the [syntax constraints](/guide/essentials/template-syntax#dynamic-argument-syntax-constraints) of dynamic directive arguments.\n\n## Scoped Slots [\u200b](#scoped-slots)\n\nAs discussed in [Render Scope](#render-scope), slot content does not have access to state in the child component.\n\nHowever, there are cases where it could be useful if a slot's content can make use of data from both the parent scope and the child scope. To achieve that, we need a way for the child to pass data to a slot when rendering it.\n\nIn fact, we can do exactly that - we can pass attributes to a slot outlet just like passing props to a component:\n\ntemplate\n\n```\n<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\nReceiving the slot props is a bit different when using a single default slot vs. using named slots. We are going to show how to receive props using a single default slot first, by using `v-slot` directly on the child component tag:\n\ntemplate\n\n```\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n```\n\n![scoped slots diagram](/assets/scoped-slots.B67tIPc5.svg)\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9kMEKgzAMhl8l9OJlU3aVOhg7C3uAXsRlTtC2tFE2pO++dA5xMnZqk+b/8/2dxMnadBxQ5EL62rWWwCMN9qh021vjCMrn2fBNoya4OdNDkmarXhQnSstsVrOOC8LedhVhrEiuHca97wwVSsTj4oz1SvAUgKJpgqWZEj4IQoCvZm0Gtgghzss1BDvIbFkqdmID+CNdbbQnaBwitbop0fuqQSgguWPXmX+JePe1HT/QMtJBHnE51MZOCcjfzPx04JxsydPzp2Szxxo7vABY1I/p)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkNFqxCAQRX9l8CUttAl9DbZQ+rzQD/AlJLNpwKjoJGwJ/nvHpAnusrAg6FzHO567iE/nynlCUQsZWj84+lBmGJ31BKffL8sng4bg7O0IRVllWnpWKAOgDF7WBx2em0kTLElt975QbwLkhkmIyvCS1TGXC8LR6YYwVSTzH8yvQVt6VyJt3966oAR38XhaFjjEkvBCECNcia2d2CLyOACZQ7CDrI6h4kXcAF7lcg+za6h5et4JPdLkzV4B9B6RBtOfMISmxxqKH9TarrGtATxMgf/bDfM/qExEUCdEDuLGXAmoV06+euNs2JK7tyCrzSNHjX9aurQf)\n\nThe props passed to the slot by the child are available as the value of the corresponding `v-slot` directive, which can be accessed by expressions inside the slot.\n\nYou can think of a scoped slot as a function being passed into the child component. The child component then calls it, passing props as arguments:\n\njs\n\n```\nMyComponent({\n  // passing the default slot, but as a function\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = 'hello'\n  return `<div>${\n    // call the slot function with props!\n    slots.default({ text: greetingMessage, count: 1 })\n  }</div>`\n}\n```\n\nIn fact, this is very close to how scoped slots are compiled, and how you would use scoped slots in manual [render functions](/guide/extras/render-function).\n\nNotice how `v-slot=\"slotProps\"` matches the slot function signature. Just like with function arguments, we can use destructuring in `v-slot`:\n\ntemplate\n\n```\n<MyComponent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n</MyComponent>\n```\n\n### Named Scoped Slots [\u200b](#named-scoped-slots)\n\nNamed scoped slots work similarly - slot props are accessible as the value of the `v-slot` directive: `v-slot:name=\"slotProps\"`. When using the shorthand, it looks like this:\n\ntemplate\n\n```\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ footerProps }}\n  </template>\n</MyComponent>\n```\n\nPassing props to a named slot:\n\ntemplate\n\n```\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\nNote the `name` of a slot won't be included in the props because it is reserved - so the resulting `headerProps` would be `{ message: 'hello' }`.\n\nIf you are mixing named slots with the default scoped slot, you need to use an explicit `<template>` tag for the default slot. Attempting to place the `v-slot` directive directly on the component will result in a compilation error. This is to avoid any ambiguity about the scope of the props of the default slot. For example:\n\ntemplate\n\n```\n<!-- <MyComponent> template -->\n<div>\n  <slot :message=\"hello\"></slot>\n  <slot name=\"footer\" />\n</div>\n```\n\ntemplate\n\n```\n<!-- This template won't compile -->\n<MyComponent v-slot=\"{ message }\">\n  <p>{{ message }}</p>\n  <template #footer>\n    <!-- message belongs to the default slot, and is not available here -->\n    <p>{{ message }}</p>\n  </template>\n</MyComponent>\n```\n\nUsing an explicit `<template>` tag for the default slot helps to make it clear that the `message` prop is not available inside the other slot:\n\ntemplate\n\n```\n<MyComponent>\n  <!-- Use explicit default slot -->\n  <template #default=\"{ message }\">\n    <p>{{ message }}</p>\n  </template>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</MyComponent>\n```\n\n### Fancy List Example [\u200b](#fancy-list-example)\n\nYou may be wondering what would be a good use case for scoped slots. Here's an example: imagine a `<FancyList>` component that renders a list of items - it may encapsulate the logic for loading remote data, using the data to display a list, or even advanced features like pagination or infinite scrolling. However, we want it to be flexible with how each item looks and leave the styling of each item to the parent component consuming it. So the desired usage may look like this:\n\ntemplate\n\n```\n<FancyList :api-url=\"url\" :per-page=\"10\">\n  <template #item=\"{ body, username, likes }\">\n    <div class=\"item\">\n      <p>{{ body }}</p>\n      <p>by {{ username }} | {{ likes }} likes</p>\n    </div>\n  </template>\n</FancyList>\n```\n\nInside `<FancyList>`, we can render the same `<slot>` multiple times with different item data (notice we are using `v-bind` to pass an object as slot props):\n\ntemplate\n\n```\n<ul>\n  <li v-for=\"item in items\">\n    <slot name=\"item\" v-bind=\"item\"></slot>\n  </li>\n</ul>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFU2Fv0zAQ/StHJtROapNuZTBCNwnQQKBpTGxCQss+uMml8+bYlu2UlZL/zjlp0lQa40sU3/nd3Xv3vA7eax0uSwziYGZTw7UDi67Up4nkhVbGwScm09U5tw5yowoYhFEX8cBBImdRgyQMHRwWWjCHdAKYbdFM83FpxEkS0DcJINZoxpotkCIHkySo7xOixcMep19KrmGustUISotGsgJHIPgDWqg6DKEyvoRUMGsJ4HG9HGX16bqpAlU1izy5baqDFegYweYroMttMwLAHx/Y9Kyan36RWUTN2+mjXfpbrei8k6SjdSuBYFOlMaNI6AeAtcflSrqx5b8xhkl4jMU7H0yVUCaGvVeH8+PjKYWqWnpf5DQYBTtb+fc612Awh2qzzGaBiUyVpBVpo7SFE8gw5xIv/Wl4M9gsbjCCQbuywe3+FuXl9iiqO7xpElEEhUofKFQo2mTGiFiOLr3jcpFImuiaF6hKNxzuw8lpw7kuEy6ZKJGK3TR6NluLYXBVqwRXQjkLn0ueIc3TLonyZ0sm4acqKVovKIbDCVQjGsb1qvyg2telU4Yzz6eHv6ARBWdwjVqUNCbbFjqgQn6aW1J8RKfJhDg+5/lStG4QHJZjnpO5XjT0BMqFu+uZ81yxjEQJw7A1kOA76FyZjaWBy0akvu8tCQKeQ+d7wsy5zLpz1FlzU3kW1QP+x40ApWgWAySEJTv6/NitNMkllcTakwCaZZ5ADEf6cROas/RhYVQps5igEpkZLwzRROmG04OjDBcj7+Js+vYQDo9e0uH1qzeY5/s1vtaaqG969+vTTrsmBTMLLv12nuy7l+d5W673SBzxkzlfhPdWSXokdZMkSFWhuUDzTTtOnk6CuG2fBEwI9etrHXOmRLJUE0/vMH14In5vH30sCS4Nkr+WmARdztHQ6Jr02dUFPtJ/lyxUVgq6/UzyO1olSj9jc+0DcaWxe/fqab/UT51Uu7Znjw6lbUn5QWtR6vtJQM//4zPUt+NOw+lGzCqo/gLm1QS8)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNVNtq20AQ/ZWpQnECujhO0qaqY+hD25fQl4RCifKwllbKktXushcT1/W/d1bSSnYJNCCEZmbPmcuZ1S76olS6cTTKo6UpNVN2VQjWKqktfCOi3N4yY6HWsoVZmo0eD5kVAqAQ9KU7XNGaOG5h572lRAZBhTV574CJzJv7QuCzzMaMaFjaKk4sRQtgOeUmiiVO85siwncRQa6oThRpKHrO50XUnUdEwMMJw08M7mAtq20MzlAtSEtj4OyZGkweMIiq2AZKToxBgMcdxDCqVrueBfb7ZaaOQiOspZYgbL0FPBySIQD+eMeQc99/HJIsM0weqs+O258mjfZREE1jt5yCKaWiFXpSX0A/5loKmxj2m+YwT69p+7kXg0udw8nlYn19fYGufvSeZBXF0ZGmR2vwmrJKS4WiPswGWWYxzIIgs8fYH6mIJadnQXdNrdMiWAB+yJ7gsXdgLfjqcK10wtJqgmYZ+spnpGgl6up5oaa2fGKi6U8Yau9ZS6Wzpwi7WU1p7BMzaZcLbuBh0q2XM4fZXTc+uOPSGvjuWEWxlaAexr9uiIBf0qG3Uy6HxXwo9B+mn47CvbNSM+LHccDxAyvmjMA9Vdxh1WQiO0eywBVGEaN3Pj972wVxPKwOZ7BJWI2b+K5rOOVUNPbpYJNvJalwZmmahm3j7AhdSz3sPzDRS3R4SQwOCXxP4yVBzJqJarSzcY8H5mXWFfif1QVwPGjGcQWTLp7YrcLxCfyDdAuMW0cq30AOV+plcK1J+dxoXJkqR6igRCeNxjbxp3N6cX5V0Sb2K19dfFrA4uo9Gh8uP9K6Puvw3eyx9SH3IT/qPCZpiW6Y8Gq9mvekrutAN96o/V99ALPj)\n\n### Renderless Components [\u200b](#renderless-components)\n\nThe `<FancyList>` use case we discussed above encapsulates both reusable logic (data fetching, pagination etc.) and visual output, while delegating part of the visual output to the consumer component via scoped slots.\n\nIf we push this concept a bit further, we can come up with components that only encapsulate logic and do not render anything by themselves - visual output is fully delegated to the consumer component with scoped slots. We call this type of component a **Renderless Component**.\n\nAn example renderless component could be one that encapsulates the logic of tracking the current mouse position:\n\ntemplate\n\n```\n<MouseTracker v-slot=\"{ x, y }\">\n  Mouse is at: {{ x }}, {{ y }}\n</MouseTracker>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUcFqhDAQ/ZUhF12w2rO4Cz301t5aaCEX0dki1SQko6uI/96J7i4qLPQQmHmZ9+Y9ZhQvxsRdiyIVmStsZQgcUmtOUlWN0ZbgXbcOP2xe/KKFs9UNBHGyBj09kCpLFj4zuSFsTJ0T+o6yjUb35GpNRylG6CMYYJKCpwAkzWNQOcgphZG/YZoiX/DQNAttFjMrS+6LRCT2rh6HGsHiOQKtmKIIS19+qmZpYLrmXIKxM1Vo5Yj9HD0vfD7ckGGF3LDWlOyHP/idYPQCfdzldTtjscl/8MuDww78lsqHVHdTYXjwCpdKlfoS52X52qGit8oRKrRhwHYdNrrDILouPbCNVZCtgJ1n/6Xx8JYAmT8epD3fr5cC0oGLQYpkd4zpD27R0vA=)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqVUU1rwzAM/SvCl7SQJTuHdLDDbttthw18MbW6hjW2seU0oeS/T0lounQfUDBGepaenvxO4tG5rIkoClGGra8cPUhT1c56ghcbA756tf1EDztva0iy/Ds4NCbSAEiD7diicafigeA0oFvLPAYNhWICYEE5IL00fMp8Hs0JYe0OinDIqFyIaO7CwdJGihO0KXTcLriK59NYBlUARTyMn6Hv0yHgIp7ARAvl3FXm8yCRiuu1Fv/x23JakVqtz3t5pOjNOQNoC7hPz0nHyRSzEr7Ghxppb/XlZ6JjRlzhTAlA+ypkLWwAM6c+8G2BdzP+/pPbRkOoL/KOldH2mCmtnxr247kKhAb9KuHKgLVtMEkn2knG+sIVzV9sfmy8hfB/swHKwV0oWja4lQKKjoNOivzKrf4L/JPqaQ==)\n\nWhile an interesting pattern, most of what can be achieved with Renderless Components can be achieved in a more efficient fashion with Composition API, without incurring the overhead of extra component nesting. Later, we will see how we can implement the same mouse tracking functionality as a [Composable](/guide/reusability/composables).\n\nThat said, scoped slots are still useful in cases where we need to both encapsulate logic **and** compose visual output, like in the `<FancyList>` example.\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/components/slots.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:08.057014+00:00",
  "content_length": 14160,
  "content_hash": "8f5fc48d2d59e92c"
}