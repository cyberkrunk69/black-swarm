{
  "id": "vue-patterns__guide_essentials_class-and-style_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/class-and-style.html",
  "title": "Class and Style Bindings\u200b",
  "content": "Class and Style Bindings\n\u200b\nA common need for data binding is manipulating an element's class list and inline styles. Since\nclass\nand\nstyle\nare both attributes, we can use\nv-bind\nto assign them a string value dynamically, much like with other attributes. However, trying to generate those values using string concatenation can be annoying and error-prone. For this reason, Vue provides special enhancements when\nv-bind\nis used with\nclass\nand\nstyle\n. In addition to strings, the expressions can also evaluate to objects or arrays.\nBinding HTML Classes\n\u200b\nWatch a free video lesson on Vue School\nWatch a free video lesson on Vue School\nBinding to Objects\n\u200b\nWe can pass an object to\n:class\n(short for\nv-bind:class\n) to dynamically toggle classes:\ntemplate\n<\ndiv\n:\nclass\n=\n\"\n{ active: isActive }\n\"\n></\ndiv\n>\nThe above syntax means the presence of the\nactive\nclass will be determined by the\ntruthiness\nof the data property\nisActive\n.\nYou can have multiple classes toggled by having more fields in the object. In addition, the\n:class\ndirective can also co-exist with the plain\nclass\nattribute. So given the following state:\njs\nconst\nisActive\n=\nref\n(\ntrue\n)\nconst\nhasError\n=\nref\n(\nfalse\n)\njs\ndata\n() {\nreturn\n{\nisActive:\ntrue\n,\nhasError:\nfalse\n}\n}\nAnd the following template:\ntemplate\n<\ndiv\nclass\n=\n\"static\"\n:\nclass\n=\n\"\n{ active: isActive,\n'text-danger'\n: hasError }\n\"\n></\ndiv\n>\nIt will render:\ntemplate\n<\ndiv\nclass\n=\n\"static active\"\n></\ndiv\n>\nWhen\nisActive\nor\nhasError\nchanges, the class list will be updated accordingly. For example, if\nhasError\nbecomes\ntrue\n, the class list will become\n\"static active text-danger\"\n.\nThe bound object doesn't have to be inline:\njs\nconst\nclassObject\n=\nreactive\n({\nactive:\ntrue\n,\n'text-danger'\n:\nfalse\n})\njs\ndata\n() {\nreturn\n{\nclassObject: {\nactive:\ntrue\n,\n'text-danger'\n:\nfalse\n}\n}\n}\ntemplate\n<\ndiv\n:\nclass\n=\n\"\nclassObject\n\"\n></\ndiv\n>\nThis will render:\ntemplate\n<\ndiv\nclass\n=\n\"active\"\n></\ndiv\n>\nWe can also bind to a\ncomputed property\nthat returns an object. This is a common and powerful pattern:\njs\nconst\nisActive\n=\nref\n(\ntrue\n)\nconst\nerror\n=\nref\n(\nnull\n)\nconst\nclassObject\n=\ncomputed\n(()\n=>\n({\nactive: isActive.value\n&&\n!\nerror.value,\n'text-danger'\n: error.value\n&&\nerror.value.type\n===\n'fatal'\n}))\njs\ndata\n() {\nreturn\n{\nisActive:\ntrue\n,\nerror:\nnull\n}\n},\ncomputed\n: {\nclassObject\n() {\nreturn\n{\nactive:\nthis\n.isActive\n&&\n!\nthis\n.error,\n'text-danger'\n:\nthis\n.error\n&&\nthis\n.error.type\n===\n'fatal'\n}\n}\n}\ntemplate\n<\ndiv\n:\nclass\n=\n\"\nclassObject\n\"\n></\ndiv\n>\nBinding to Arrays\n\u200b\nWe can bind\n:class\nto an array to apply a list of classes:\njs\nconst\nactiveClass\n=\nref\n(\n'active'\n)\nconst\nerrorClass\n=\nref\n(\n'text-danger'\n)\njs\ndata\n() {\nreturn\n{\nactiveClass:\n'active'\n,\nerrorClass:\n'text-danger'\n}\n}\ntemplate\n<\ndiv\n:\nclass\n=\n\"\n[activeClass, errorClass]\n\"\n></\ndiv\n>\nWhich will render:\ntemplate\n<\ndiv\nclass\n=\n\"active text-danger\"\n></\ndiv\n>\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\ntemplate\n<\ndiv\n:\nclass\n=\n\"\n[isActive\n?\nactiveClass\n:\n''\n, errorClass]\n\"\n></\ndiv\n>\nThis will always apply\nerrorClass\n, but\nactiveClass\nwill only be applied when\nisActive\nis truthy.\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside the array syntax:\ntemplate\n<\ndiv\n:\nclass\n=\n\"\n[{ [activeClass]: isActive }, errorClass]\n\"\n></\ndiv\n>\nWith Components\n\u200b\nThis section assumes knowledge of\nComponents\n. Feel free to skip it and come back later.\nWhen you use the\nclass\nattribute on a component with a single root element, those classes will be added to the component's root element and merged with any existing class already on it.\nFor example, if we have a component named\nMyComponent\nwith the following template:\ntemplate\n<!-- child component template -->\n<\np\nclass\n=\n\"foo bar\"\n>Hi!</\np\n>\nThen add some classes when using it:\ntemplate\n<!-- when using the component -->\n<\nMyComponent\nclass\n=\n\"baz boo\"\n/>\nThe rendered HTML will be:\ntemplate\n<\np\nclass\n=\n\"foo bar baz boo\"\n>Hi!</\np\n>\nThe same is true for class bindings:\ntemplate\n<\nMyComponent\n:\nclass\n=\n\"\n{ active: isActive }\n\"\n/>\nWhen\nisActive\nis truthy, the rendered HTML will be:\ntemplate\n<\np\nclass\n=\n\"foo bar active\"\n>Hi!</\np\n>\nIf your component has multiple root elements, you would need to define which element will receive this class. You can do this using the\n$attrs\ncomponent property:\ntemplate\n<!-- MyComponent template using $attrs -->\n<\np\n:\nclass\n=\n\"\n$attrs.class\n\"\n>Hi!</\np\n>\n<\nspan\n>This is a child component</\nspan\n>\ntemplate\n<\nMyComponent\nclass\n=\n\"baz\"\n/>\nWill render:\nhtml\n<\np\nclass\n=\n\"baz\"\n>Hi!</\np\n>\n<\nspan\n>This is a child component</\nspan\n>\nYou can learn more about component attribute inheritance in\nFallthrough Attributes\nsection.\nBinding Inline Styles\n\u200b\nBinding to Objects\n\u200b\n:style\nsupports binding to JavaScript object values - it corresponds to an\nHTML element's\nstyle\nproperty\n:\njs\nconst\nactiveColor\n=\nref\n(\n'red'\n)\nconst\nfontSize\n=\nref\n(\n30\n)\njs\ndata\n() {\nreturn\n{\nactiveColor:\n'red'\n,\nfontSize:\n30\n}\n}\ntemplate\n<\ndiv\n:\nstyle\n=\n\"\n{ color: activeColor, fontSize: fontSize\n+\n'px'\n}\n\"\n></\ndiv\n>\nAlthough camelCase keys are recommended,\n:style\nalso supports kebab-cased CSS property keys (corresponds to how they are used in actual CSS) - for example:\ntemplate\n<\ndiv\n:\nstyle\n=\n\"\n{\n'font-size'\n: fontSize\n+\n'px'\n}\n\"\n></\ndiv\n>\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\njs\nconst\nstyleObject\n=\nreactive\n({\ncolor:\n'red'\n,\nfontSize:\n'30px'\n})\njs\ndata\n() {\nreturn\n{\nstyleObject: {\ncolor:\n'red'\n,\nfontSize:\n'13px'\n}\n}\n}\ntemplate\n<\ndiv\n:\nstyle\n=\n\"\nstyleObject\n\"\n></\ndiv\n>\nAgain, object style binding is often used in conjunction with computed properties that return objects.\n:style\ndirectives can also coexist with regular style attributes, just like\n:class\n.\nTemplate:\ntemplate\n<\nh1\nstyle\n=\n\"color: red\"\n:\nstyle\n=\n\"'font-size: 1em'\"\n>hello</\nh1\n>\nIt will render:\ntemplate\n<\nh1\nstyle\n=\n\"color: red; font-size: 1em;\"\n>hello</\nh1\n>\nBinding to Arrays\n\u200b\nWe can bind\n:style\nto an array of multiple style objects. These objects will be merged and applied to the same element:\ntemplate\n<\ndiv\n:\nstyle\n=\n\"\n[baseStyles, overridingStyles]\n\"\n></\ndiv\n>\nAuto-prefixing\n\u200b\nWhen you use a CSS property that requires a\nvendor prefix\nin\n:style\n, Vue will automatically add the appropriate prefix. Vue does this by checking at runtime to see which style properties are supported in the current browser. If the browser doesn't support a particular property then various prefixed variants will be tested to try to find one that is supported.\nMultiple Values\n\u200b\nYou can provide an array of multiple (prefixed) values to a style property, for example:\ntemplate\n<\ndiv\n:\nstyle\n=\n\"\n{ display: [\n'-webkit-box'\n,\n'-ms-flexbox'\n,\n'flex'\n] }\n\"\n></\ndiv\n>\nThis will only render the last value in the array which the browser supports. In this example, it will render\ndisplay: flex\nfor browsers that support the unprefixed version of flexbox.\nEdit this page on GitHub",
  "content_markdown": "# Class and Style Bindings [\u200b](#class-and-style-bindings)\n\nA common need for data binding is manipulating an element's class list and inline styles. Since `class` and `style` are both attributes, we can use `v-bind` to assign them a string value dynamically, much like with other attributes. However, trying to generate those values using string concatenation can be annoying and error-prone. For this reason, Vue provides special enhancements when `v-bind` is used with `class` and `style`. In addition to strings, the expressions can also evaluate to objects or arrays.\n\n## Binding HTML Classes [\u200b](#binding-html-classes)\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/dynamic-css-classes-with-vue-3?friend=vuejs \"Free Vue.js Dynamic CSS Classes Lesson\")\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-fundamentals-capi-dynamic-css-classes-with-vue?friend=vuejs \"Free Vue.js Dynamic CSS Classes Lesson\")\n\n### Binding to Objects [\u200b](#binding-to-objects)\n\nWe can pass an object to `:class` (short for `v-bind:class`) to dynamically toggle classes:\n\ntemplate\n\n```\n<div :class=\"{ active: isActive }\"></div>\n```\n\nThe above syntax means the presence of the `active` class will be determined by the [truthiness](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) of the data property `isActive`.\n\nYou can have multiple classes toggled by having more fields in the object. In addition, the `:class` directive can also co-exist with the plain `class` attribute. So given the following state:\n\njs\n\n```\nconst isActive = ref(true)\nconst hasError = ref(false)\n```\n\njs\n\n```\ndata() {\n  return {\n    isActive: true,\n    hasError: false\n  }\n}\n```\n\nAnd the following template:\n\ntemplate\n\n```\n<div\n  class=\"static\"\n  :class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n\nIt will render:\n\ntemplate\n\n```\n<div class=\"static active\"></div>\n```\n\nWhen `isActive` or `hasError` changes, the class list will be updated accordingly. For example, if `hasError` becomes `true`, the class list will become `\"static active text-danger\"`.\n\nThe bound object doesn't have to be inline:\n\njs\n\n```\nconst classObject = reactive({\n  active: true,\n  'text-danger': false\n})\n```\n\njs\n\n```\ndata() {\n  return {\n    classObject: {\n      active: true,\n      'text-danger': false\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<div :class=\"classObject\"></div>\n```\n\nThis will render:\n\ntemplate\n\n```\n<div class=\"active\"></div>\n```\n\nWe can also bind to a [computed property](/guide/essentials/computed) that returns an object. This is a common and powerful pattern:\n\njs\n\n```\nconst isActive = ref(true)\nconst error = ref(null)\n\nconst classObject = computed(() => ({\n  active: isActive.value && !error.value,\n  'text-danger': error.value && error.value.type === 'fatal'\n}))\n```\n\njs\n\n```\ndata() {\n  return {\n    isActive: true,\n    error: null\n  }\n},\ncomputed: {\n  classObject() {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<div :class=\"classObject\"></div>\n```\n\n### Binding to Arrays [\u200b](#binding-to-arrays)\n\nWe can bind `:class` to an array to apply a list of classes:\n\njs\n\n```\nconst activeClass = ref('active')\nconst errorClass = ref('text-danger')\n```\n\njs\n\n```\ndata() {\n  return {\n    activeClass: 'active',\n    errorClass: 'text-danger'\n  }\n}\n```\n\ntemplate\n\n```\n<div :class=\"[activeClass, errorClass]\"></div>\n```\n\nWhich will render:\n\ntemplate\n\n```\n<div class=\"active text-danger\"></div>\n```\n\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\n\ntemplate\n\n```\n<div :class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\nThis will always apply `errorClass`, but `activeClass` will only be applied when `isActive` is truthy.\n\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside the array syntax:\n\ntemplate\n\n```\n<div :class=\"[{ [activeClass]: isActive }, errorClass]\"></div>\n```\n\n### With Components [\u200b](#with-components)\n\n> This section assumes knowledge of [Components](/guide/essentials/component-basics). Feel free to skip it and come back later.\n\nWhen you use the `class` attribute on a component with a single root element, those classes will be added to the component's root element and merged with any existing class already on it.\n\nFor example, if we have a component named `MyComponent` with the following template:\n\ntemplate\n\n```\n<!-- child component template -->\n<p class=\"foo bar\">Hi!</p>\n```\n\nThen add some classes when using it:\n\ntemplate\n\n```\n<!-- when using the component -->\n<MyComponent class=\"baz boo\" />\n```\n\nThe rendered HTML will be:\n\ntemplate\n\n```\n<p class=\"foo bar baz boo\">Hi!</p>\n```\n\nThe same is true for class bindings:\n\ntemplate\n\n```\n<MyComponent :class=\"{ active: isActive }\" />\n```\n\nWhen `isActive` is truthy, the rendered HTML will be:\n\ntemplate\n\n```\n<p class=\"foo bar active\">Hi!</p>\n```\n\nIf your component has multiple root elements, you would need to define which element will receive this class. You can do this using the `$attrs` component property:\n\ntemplate\n\n```\n<!-- MyComponent template using $attrs -->\n<p :class=\"$attrs.class\">Hi!</p>\n<span>This is a child component</span>\n```\n\ntemplate\n\n```\n<MyComponent class=\"baz\" />\n```\n\nWill render:\n\nhtml\n\n```\n<p class=\"baz\">Hi!</p>\n<span>This is a child component</span>\n```\n\nYou can learn more about component attribute inheritance in [Fallthrough Attributes](/guide/components/attrs) section.\n\n## Binding Inline Styles [\u200b](#binding-inline-styles)\n\n### Binding to Objects [\u200b](#binding-to-objects-1)\n\n`:style` supports binding to JavaScript object values - it corresponds to an [HTML element's `style` property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style):\n\njs\n\n```\nconst activeColor = ref('red')\nconst fontSize = ref(30)\n```\n\njs\n\n```\ndata() {\n  return {\n    activeColor: 'red',\n    fontSize: 30\n  }\n}\n```\n\ntemplate\n\n```\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n```\n\nAlthough camelCase keys are recommended, `:style` also supports kebab-cased CSS property keys (corresponds to how they are used in actual CSS) - for example:\n\ntemplate\n\n```\n<div :style=\"{ 'font-size': fontSize + 'px' }\"></div>\n```\n\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\n\njs\n\n```\nconst styleObject = reactive({\n  color: 'red',\n  fontSize: '30px'\n})\n```\n\njs\n\n```\ndata() {\n  return {\n    styleObject: {\n      color: 'red',\n      fontSize: '13px'\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<div :style=\"styleObject\"></div>\n```\n\nAgain, object style binding is often used in conjunction with computed properties that return objects.\n\n`:style` directives can also coexist with regular style attributes, just like `:class`.\n\nTemplate:\n\ntemplate\n\n```\n<h1 style=\"color: red\" :style=\"'font-size: 1em'\">hello</h1>\n```\n\nIt will render:\n\ntemplate\n\n```\n<h1 style=\"color: red; font-size: 1em;\">hello</h1>\n```\n\n### Binding to Arrays [\u200b](#binding-to-arrays-1)\n\nWe can bind `:style` to an array of multiple style objects. These objects will be merged and applied to the same element:\n\ntemplate\n\n```\n<div :style=\"[baseStyles, overridingStyles]\"></div>\n```\n\n### Auto-prefixing [\u200b](#auto-prefixing)\n\nWhen you use a CSS property that requires a [vendor prefix](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix) in `:style`, Vue will automatically add the appropriate prefix. Vue does this by checking at runtime to see which style properties are supported in the current browser. If the browser doesn't support a particular property then various prefixed variants will be tested to try to find one that is supported.\n\n### Multiple Values [\u200b](#multiple-values)\n\nYou can provide an array of multiple (prefixed) values to a style property, for example:\n\ntemplate\n\n```\n<div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\nThis will only render the last value in the array which the browser supports. In this example, it will render `display: flex` for browsers that support the unprefixed version of flexbox.\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/class-and-style.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:54.169170+00:00",
  "content_length": 6989,
  "content_hash": "f918d6127666cab7"
}