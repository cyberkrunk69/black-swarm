{
  "id": "vue-patterns__guide_components_registration_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/components/registration.html",
  "title": "Component Registration\u200b",
  "content": "Component Registration\n\u200b\nThis page assumes you've already read the\nComponents Basics\n. Read that first if you are new to components.\nWatch a free video lesson on Vue School\nA Vue component needs to be \"registered\" so that Vue knows where to locate its implementation when it is encountered in a template. There are two ways to register components: global and local.\nGlobal Registration\n\u200b\nWe can make components available globally in the current\nVue application\nusing the\n.component()\nmethod:\njs\nimport\n{ createApp }\nfrom\n'vue'\nconst\napp\n=\ncreateApp\n({})\napp.\ncomponent\n(\n// the registered name\n'MyComponent'\n,\n// the implementation\n{\n/* ... */\n}\n)\nIf using SFCs, you will be registering the imported\n.vue\nfiles:\njs\nimport\nMyComponent\nfrom\n'./App.vue'\napp.\ncomponent\n(\n'MyComponent'\n, MyComponent)\nThe\n.component()\nmethod can be chained:\njs\napp\n.\ncomponent\n(\n'ComponentA'\n, ComponentA)\n.\ncomponent\n(\n'ComponentB'\n, ComponentB)\n.\ncomponent\n(\n'ComponentC'\n, ComponentC)\nGlobally registered components can be used in the template of any component within this application:\ntemplate\n<!-- this will work in any component inside the app -->\n<\nComponentA\n/>\n<\nComponentB\n/>\n<\nComponentC\n/>\nThis even applies to all subcomponents, meaning all three of these components will also be available\ninside each other\n.\nLocal Registration\n\u200b\nWhile convenient, global registration has a few drawbacks:\nGlobal registration prevents build systems from removing unused components (a.k.a \"tree-shaking\"). If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.\nGlobal registration makes dependency relationships less explicit in large applications. It makes it difficult to locate a child component's implementation from a parent component using it. This can affect long-term maintainability similar to using too many global variables.\nLocal registration scopes the availability of the registered components to the current component only. It makes the dependency relationship more explicit, and is more tree-shaking friendly.\nWhen using SFC with\n<script setup>\n, imported components can be locally used without registration:\nvue\n<\nscript\nsetup\n>\nimport\nComponentA\nfrom\n'./ComponentA.vue'\n</\nscript\n>\n<\ntemplate\n>\n<\nComponentA\n/>\n</\ntemplate\n>\nIn non-\n<script setup>\n, you will need to use the\ncomponents\noption:\njs\nimport\nComponentA\nfrom\n'./ComponentA.js'\nexport\ndefault\n{\ncomponents: {\nComponentA\n},\nsetup\n() {\n// ...\n}\n}\nLocal registration is done using the\ncomponents\noption:\nvue\n<\nscript\n>\nimport\nComponentA\nfrom\n'./ComponentA.vue'\nexport\ndefault\n{\ncomponents: {\nComponentA\n}\n}\n</\nscript\n>\n<\ntemplate\n>\n<\nComponentA\n/>\n</\ntemplate\n>\nFor each property in the\ncomponents\nobject, the key will be the registered name of the component, while the value will contain the implementation of the component. The above example is using the ES2015 property shorthand and is equivalent to:\njs\nexport\ndefault\n{\ncomponents: {\nComponentA: ComponentA\n}\n// ...\n}\nNote that\nlocally registered components are\nnot\nalso available in descendant components\n. In this case,\nComponentA\nwill be made available to the current component only, not any of its child or descendant components.\nComponent Name Casing\n\u200b\nThroughout the guide, we are using PascalCase names when registering components. This is because:\nPascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.\n<PascalCase />\nmakes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).\nThis is the recommended style when working with SFC or string templates. However, as discussed in\nin-DOM Template Parsing Caveats\n, PascalCase tags are not usable in in-DOM templates.\nLuckily, Vue supports resolving kebab-case tags to components registered using PascalCase. This means a component registered as\nMyComponent\ncan be referenced inside a Vue template (or inside an HTML element rendered by Vue) via both\n<MyComponent>\nand\n<my-component>\n. This allows us to use the same JavaScript component registration code regardless of template source.\nEdit this page on GitHub",
  "content_markdown": "# Component Registration [\u200b](#component-registration)\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-3-global-vs-local-vue-components?friend=vuejs \"Free Vue.js Component Registration Lesson\")\n\nA Vue component needs to be \"registered\" so that Vue knows where to locate its implementation when it is encountered in a template. There are two ways to register components: global and local.\n\n## Global Registration [\u200b](#global-registration)\n\nWe can make components available globally in the current [Vue application](/guide/essentials/application) using the `.component()` method:\n\njs\n\n```\nimport { createApp } from 'vue'\n\nconst app = createApp({})\n\napp.component(\n  // the registered name\n  'MyComponent',\n  // the implementation\n  {\n    /* ... */\n  }\n)\n```\n\nIf using SFCs, you will be registering the imported `.vue` files:\n\njs\n\n```\nimport MyComponent from './App.vue'\n\napp.component('MyComponent', MyComponent)\n```\n\nThe `.component()` method can be chained:\n\njs\n\n```\napp\n  .component('ComponentA', ComponentA)\n  .component('ComponentB', ComponentB)\n  .component('ComponentC', ComponentC)\n```\n\nGlobally registered components can be used in the template of any component within this application:\n\ntemplate\n\n```\n<!-- this will work in any component inside the app -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\nThis even applies to all subcomponents, meaning all three of these components will also be available *inside each other*.\n\n## Local Registration [\u200b](#local-registration)\n\nWhile convenient, global registration has a few drawbacks:\n\n1. Global registration prevents build systems from removing unused components (a.k.a \"tree-shaking\"). If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.\n2. Global registration makes dependency relationships less explicit in large applications. It makes it difficult to locate a child component's implementation from a parent component using it. This can affect long-term maintainability similar to using too many global variables.\n\nLocal registration scopes the availability of the registered components to the current component only. It makes the dependency relationship more explicit, and is more tree-shaking friendly.\n\nWhen using SFC with `<script setup>`, imported components can be locally used without registration:\n\nvue\n\n```\n<script setup>\nimport ComponentA from './ComponentA.vue'\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\nIn non-`<script setup>`, you will need to use the `components` option:\n\njs\n\n```\nimport ComponentA from './ComponentA.js'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n```\n\nLocal registration is done using the `components` option:\n\nvue\n\n```\n<script>\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  }\n}\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\nFor each property in the `components` object, the key will be the registered name of the component, while the value will contain the implementation of the component. The above example is using the ES2015 property shorthand and is equivalent to:\n\njs\n\n```\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n}\n```\n\nNote that **locally registered components are *not* also available in descendant components**. In this case, `ComponentA` will be made available to the current component only, not any of its child or descendant components.\n\n## Component Name Casing [\u200b](#component-name-casing)\n\nThroughout the guide, we are using PascalCase names when registering components. This is because:\n\n1. PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.\n2. `<PascalCase />` makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).\n\nThis is the recommended style when working with SFC or string templates. However, as discussed in [in-DOM Template Parsing Caveats](/guide/essentials/component-basics#in-dom-template-parsing-caveats), PascalCase tags are not usable in in-DOM templates.\n\nLuckily, Vue supports resolving kebab-case tags to components registered using PascalCase. This means a component registered as `MyComponent` can be referenced inside a Vue template (or inside an HTML element rendered by Vue) via both `<MyComponent>` and `<my-component>`. This allows us to use the same JavaScript component registration code regardless of template source.\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/components/registration.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:02.653393+00:00",
  "content_length": 4265,
  "content_hash": "4322f30c122326c8"
}