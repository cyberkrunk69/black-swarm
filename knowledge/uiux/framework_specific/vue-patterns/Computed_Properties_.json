{
  "id": "vue-patterns__guide_essentials_computed_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/computed.html",
  "title": "Computed Properties\u200b",
  "content": "Computed Properties\n\u200b\nWatch a free video lesson on Vue School\nWatch a free video lesson on Vue School\nBasic Example\n\u200b\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\nauthor: {\nname:\n'John Doe'\n,\nbooks: [\n'Vue 2 - Advanced Guide'\n,\n'Vue 3 - Basic Guide'\n,\n'Vue 4 - The Mystery'\n]\n}\n}\n}\n}\njs\nconst\nauthor\n=\nreactive\n({\nname:\n'John Doe'\n,\nbooks: [\n'Vue 2 - Advanced Guide'\n,\n'Vue 3 - Basic Guide'\n,\n'Vue 4 - The Mystery'\n]\n})\nAnd we want to display different messages depending on if\nauthor\nalready has some books or not:\ntemplate\n<\np\n>Has published books:</\np\n>\n<\nspan\n>{{ author.books.length > 0 ? 'Yes' : 'No' }}</\nspan\n>\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on\nauthor.books\n. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\nThat's why for complex logic that includes reactive data, it is recommended to use a\ncomputed property\n. Here's the same example, refactored:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\nauthor: {\nname:\n'John Doe'\n,\nbooks: [\n'Vue 2 - Advanced Guide'\n,\n'Vue 3 - Basic Guide'\n,\n'Vue 4 - The Mystery'\n]\n}\n}\n},\ncomputed: {\n// a computed getter\npublishedBooksMessage\n() {\n// `this` points to the component instance\nreturn\nthis\n.author.books.\nlength\n>\n0\n?\n'Yes'\n:\n'No'\n}\n}\n}\ntemplate\n<\np\n>Has published books:</\np\n>\n<\nspan\n>{{ publishedBooksMessage }}</\nspan\n>\nTry it in the Playground\nHere we have declared a computed property\npublishedBooksMessage\n.\nTry to change the value of the\nbooks\narray in the application\ndata\nand you will see how\npublishedBooksMessage\nis changing accordingly.\nYou can data-bind to computed properties in templates just like a normal property. Vue is aware that\nthis.publishedBooksMessage\ndepends on\nthis.author.books\n, so it will update any bindings that depend on\nthis.publishedBooksMessage\nwhen\nthis.author.books\nchanges.\nSee also:\nTyping Computed Properties\nvue\n<\nscript\nsetup\n>\nimport\n{ reactive, computed }\nfrom\n'vue'\nconst\nauthor\n=\nreactive\n({\nname:\n'John Doe'\n,\nbooks: [\n'Vue 2 - Advanced Guide'\n,\n'Vue 3 - Basic Guide'\n,\n'Vue 4 - The Mystery'\n]\n})\n// a computed ref\nconst\npublishedBooksMessage\n=\ncomputed\n(()\n=>\n{\nreturn\nauthor.books.\nlength\n>\n0\n?\n'Yes'\n:\n'No'\n})\n</\nscript\n>\n<\ntemplate\n>\n<\np\n>Has published books:</\np\n>\n<\nspan\n>{{ publishedBooksMessage }}</\nspan\n>\n</\ntemplate\n>\nTry it in the Playground\nHere we have declared a computed property\npublishedBooksMessage\n. The\ncomputed()\nfunction expects to be passed a\ngetter function\n, and the returned value is a\ncomputed ref\n. Similar to normal refs, you can access the computed result as\npublishedBooksMessage.value\n. Computed refs are also auto-unwrapped in templates so you can reference them without\n.value\nin template expressions.\nA computed property automatically tracks its reactive dependencies. Vue is aware that the computation of\npublishedBooksMessage\ndepends on\nauthor.books\n, so it will update any bindings that depend on\npublishedBooksMessage\nwhen\nauthor.books\nchanges.\nSee also:\nTyping Computed\nComputed Caching vs. Methods\n\u200b\nYou may have noticed we can achieve the same result by invoking a method in the expression:\ntemplate\n<\np\n>{{ calculateBooksMessage() }}</\np\n>\njs\n// in component\nmethods\n: {\ncalculateBooksMessage\n() {\nreturn\nthis\n.author.books.\nlength\n>\n0\n?\n'Yes'\n:\n'No'\n}\n}\njs\n// in component\nfunction\ncalculateBooksMessage\n() {\nreturn\nauthor.books.\nlength\n>\n0\n?\n'Yes'\n:\n'No'\n}\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that\ncomputed properties are cached based on their reactive dependencies.\nA computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as\nauthor.books\nhas not changed, multiple access to\npublishedBooksMessage\nwill immediately return the previously computed result without having to run the getter function again.\nThis also means the following computed property will never update, because\nDate.now()\nis not a reactive dependency:\njs\ncomputed\n: {\nnow\n() {\nreturn\nDate.\nnow\n()\n}\n}\njs\nconst\nnow\n=\ncomputed\n(()\n=>\nDate.\nnow\n())\nIn comparison, a method invocation will\nalways\nrun the function whenever a re-render happens.\nWhy do we need caching? Imagine we have an expensive computed property\nlist\n, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on\nlist\n. Without caching, we would be executing\nlist\n\u2019s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\nWritable Computed\n\u200b\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\nfirstName:\n'John'\n,\nlastName:\n'Doe'\n}\n},\ncomputed: {\nfullName: {\n// getter\nget\n() {\nreturn\nthis\n.firstName\n+\n' '\n+\nthis\n.lastName\n},\n// setter\nset\n(\nnewValue\n) {\n// Note: we are using destructuring assignment syntax here.\n[\nthis\n.firstName,\nthis\n.lastName]\n=\nnewValue.\nsplit\n(\n' '\n)\n}\n}\n}\n}\nNow when you run\nthis.fullName = 'John Doe'\n, the setter will be invoked and\nthis.firstName\nand\nthis.lastName\nwill be updated accordingly.\nvue\n<\nscript\nsetup\n>\nimport\n{ ref, computed }\nfrom\n'vue'\nconst\nfirstName\n=\nref\n(\n'John'\n)\nconst\nlastName\n=\nref\n(\n'Doe'\n)\nconst\nfullName\n=\ncomputed\n({\n// getter\nget\n() {\nreturn\nfirstName.value\n+\n' '\n+\nlastName.value\n},\n// setter\nset\n(\nnewValue\n) {\n// Note: we are using destructuring assignment syntax here.\n[firstName.value, lastName.value]\n=\nnewValue.\nsplit\n(\n' '\n)\n}\n})\n</\nscript\n>\nNow when you run\nfullName.value = 'John Doe'\n, the setter will be invoked and\nfirstName\nand\nlastName\nwill be updated accordingly.\nGetting the Previous Value\n\u200b\nOnly supported in 3.4+\nIn case you need it, you can get the previous value returned by the computed property accessing the second argument of the getter:\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\ncount:\n2\n}\n},\ncomputed: {\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nalwaysSmall\n(\n_\n,\nprevious\n) {\nif\n(\nthis\n.count\n<=\n3\n) {\nreturn\nthis\n.count\n}\nreturn\nprevious\n}\n}\n}\nvue\n<\nscript\nsetup\n>\nimport\n{ ref, computed }\nfrom\n'vue'\nconst\ncount\n=\nref\n(\n2\n)\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst\nalwaysSmall\n=\ncomputed\n((\nprevious\n)\n=>\n{\nif\n(count.value\n<=\n3\n) {\nreturn\ncount.value\n}\nreturn\nprevious\n})\n</\nscript\n>\nIn case you're using a writable computed:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\ncount:\n2\n}\n},\ncomputed: {\nalwaysSmall: {\nget\n(\n_\n,\nprevious\n) {\nif\n(\nthis\n.count\n<=\n3\n) {\nreturn\nthis\n.count\n}\nreturn\nprevious;\n},\nset\n(\nnewValue\n) {\nthis\n.count\n=\nnewValue\n*\n2\n}\n}\n}\n}\nvue\n<\nscript\nsetup\n>\nimport\n{ ref, computed }\nfrom\n'vue'\nconst\ncount\n=\nref\n(\n2\n)\nconst\nalwaysSmall\n=\ncomputed\n({\nget\n(\nprevious\n) {\nif\n(count.value\n<=\n3\n) {\nreturn\ncount.value\n}\nreturn\nprevious\n},\nset\n(\nnewValue\n) {\ncount.value\n=\nnewValue\n*\n2\n}\n})\n</\nscript\n>\nBest Practices\n\u200b\nGetters should be side-effect free\n\u200b\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example,\ndon't mutate other state, make async requests, or mutate the DOM inside a computed getter!\nThink of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with\nwatchers\n.\nAvoid mutating computed value\n\u200b\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.\nEdit this page on GitHub",
  "content_markdown": "# Computed Properties [\u200b](#computed-properties)\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/computed-properties-in-vue-3?friend=vuejs \"Free Vue.js Computed Properties Lesson\")\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-fundamentals-capi-computed-properties-in-vue-with-the-composition-api?friend=vuejs \"Free Vue.js Computed Properties Lesson\")\n\n## Basic Example [\u200b](#basic-example)\n\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  }\n}\n```\n\njs\n\n```\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n```\n\nAnd we want to display different messages depending on if `author` already has some books or not:\n\ntemplate\n\n```\n<p>Has published books:</p>\n<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>\n```\n\nAt this point, the template is getting a bit cluttered. We have to look at it for a second before realizing that it performs a calculation depending on `author.books`. More importantly, we probably don't want to repeat ourselves if we need to include this calculation in the template more than once.\n\nThat's why for complex logic that includes reactive data, it is recommended to use a **computed property**. Here's the same example, refactored:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      author: {\n        name: 'John Doe',\n        books: [\n          'Vue 2 - Advanced Guide',\n          'Vue 3 - Basic Guide',\n          'Vue 4 - The Mystery'\n        ]\n      }\n    }\n  },\n  computed: {\n    // a computed getter\n    publishedBooksMessage() {\n      // `this` points to the component instance\n      return this.author.books.length > 0 ? 'Yes' : 'No'\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<p>Has published books:</p>\n<span>{{ publishedBooksMessage }}</span>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkN1KxDAQhV/l0JsqaFfUq1IquwiKsF6JINaLbDNui20S8rO4lL676c82eCFCIDOZMzkzXxetlUoOjqI0ykypa2XzQtC3ktqC0ydzjUVXCIAzy87OpxjQZJ0WpwxgzlZSp+EBEKylFPGTrATuJcUXobST8sukeA8vQPzqCNe4xJofmCiJ48HV/FfbLLrxog0zdfmn4tYrXirC9mgs6WMcBB+nsJ+C8erHH0rZKmeJL0sot2tqUxHfDONuyRi2p4BggWCr2iQTgGTcLGlI7G2FHFe4Q/xGJoYn8SznQSbTQviTrRboPrHUqoZZ8hmQqfyRmTDFTC1bqalsFBN5183o/3NG33uvoWUwXYyi/gdTEpwK)\n\nHere we have declared a computed property `publishedBooksMessage`.\n\nTry to change the value of the `books` array in the application `data` and you will see how `publishedBooksMessage` is changing accordingly.\n\nYou can data-bind to computed properties in templates just like a normal property. Vue is aware that `this.publishedBooksMessage` depends on `this.author.books`, so it will update any bindings that depend on `this.publishedBooksMessage` when `this.author.books` changes.\n\nSee also: [Typing Computed Properties](/guide/typescript/options-api#typing-computed-properties)\n\nvue\n\n```\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst author = reactive({\n  name: 'John Doe',\n  books: [\n    'Vue 2 - Advanced Guide',\n    'Vue 3 - Basic Guide',\n    'Vue 4 - The Mystery'\n  ]\n})\n\n// a computed ref\nconst publishedBooksMessage = computed(() => {\n  return author.books.length > 0 ? 'Yes' : 'No'\n})\n</script>\n\n<template>\n  <p>Has published books:</p>\n  <span>{{ publishedBooksMessage }}</span>\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp1kE9Lw0AQxb/KI5dtoTainkoaaREUoZ5EEONhm0ybYLO77J9CCfnuzta0vdjbzr6Zeb95XbIwZroPlMySzJW2MR6OfDB5oZrWaOvRwZIsfbOnCUrdmuCpQo+N1S0ET4pCFarUynnI4GttMT9PjLpCAUq2NIN41bXCkyYxiZ9rrX/cDF/xDYiPQLjDDRbVXqqSHZ5DUw2tg3zP8lK6pvxHe2DtvSasDs6TPTAT8F2ofhzh0hTygm5pc+I1Yb1rXE3VMsKsyDm5JcY/9Y5GY8xzHI+wnIpVw4nTI/10R2rra+S4xSPEJzkBvvNNs310ztK/RDlLLjy1Zic9cQVkJn+R7gIwxJGlMXiWnZEq77orhH3Pq2NH9DjvTfpfSBSbmA==)\n\nHere we have declared a computed property `publishedBooksMessage`. The `computed()` function expects to be passed a [getter function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description), and the returned value is a **computed ref**. Similar to normal refs, you can access the computed result as `publishedBooksMessage.value`. Computed refs are also auto-unwrapped in templates so you can reference them without `.value` in template expressions.\n\nA computed property automatically tracks its reactive dependencies. Vue is aware that the computation of `publishedBooksMessage` depends on `author.books`, so it will update any bindings that depend on `publishedBooksMessage` when `author.books` changes.\n\nSee also: [Typing Computed](/guide/typescript/composition-api#typing-computed)\n\n## Computed Caching vs. Methods [\u200b](#computed-caching-vs-methods)\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\ntemplate\n\n```\n<p>{{ calculateBooksMessage() }}</p>\n```\n\njs\n\n```\n// in component\nmethods: {\n  calculateBooksMessage() {\n    return this.author.books.length > 0 ? 'Yes' : 'No'\n  }\n}\n```\n\njs\n\n```\n// in component\nfunction calculateBooksMessage() {\n  return author.books.length > 0 ? 'Yes' : 'No'\n}\n```\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that **computed properties are cached based on their reactive dependencies.** A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as `author.books` has not changed, multiple access to `publishedBooksMessage` will immediately return the previously computed result without having to run the getter function again.\n\nThis also means the following computed property will never update, because `Date.now()` is not a reactive dependency:\n\njs\n\n```\ncomputed: {\n  now() {\n    return Date.now()\n  }\n}\n```\n\njs\n\n```\nconst now = computed(() => Date.now())\n```\n\nIn comparison, a method invocation will **always** run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property `list`, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on `list`. Without caching, we would be executing `list`\u2019s getter many more times than necessary! In cases where you do not want caching, use a method call instead.\n\n## Writable Computed [\u200b](#writable-computed)\n\nComputed properties are by default getter-only. If you attempt to assign a new value to a computed property, you will receive a runtime warning. In the rare cases where you need a \"writable\" computed property, you can create one by providing both a getter and a setter:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  },\n  computed: {\n    fullName: {\n      // getter\n      get() {\n        return this.firstName + ' ' + this.lastName\n      },\n      // setter\n      set(newValue) {\n        // Note: we are using destructuring assignment syntax here.\n        [this.firstName, this.lastName] = newValue.split(' ')\n      }\n    }\n  }\n}\n```\n\nNow when you run `this.fullName = 'John Doe'`, the setter will be invoked and `this.firstName` and `this.lastName` will be updated accordingly.\n\nvue\n\n```\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('John')\nconst lastName = ref('Doe')\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + ' ' + lastName.value\n  },\n  // setter\n  set(newValue) {\n    // Note: we are using destructuring assignment syntax here.\n    [firstName.value, lastName.value] = newValue.split(' ')\n  }\n})\n</script>\n```\n\nNow when you run `fullName.value = 'John Doe'`, the setter will be invoked and `firstName` and `lastName` will be updated accordingly.\n\n## Getting the Previous Value [\u200b](#previous)\n\n- Only supported in 3.4+\n\nIn case you need it, you can get the previous value returned by the computed property accessing the second argument of the getter:\n\nIn case you need it, you can get the previous value returned by the computed property accessing the first argument of the getter:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    // This computed will return the value of count when it's less or equal to 3.\n    // When count is >=4, the last value that fulfilled our condition will be returned\n    // instead until count is less or equal to 3\n    alwaysSmall(_, previous) {\n      if (this.count <= 3) {\n        return this.count\n      }\n\n      return previous\n    }\n  }\n}\n```\n\nvue\n\n```\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\n// This computed will return the value of count when it's less or equal to 3.\n// When count is >=4, the last value that fulfilled our condition will be returned\n// instead until count is less or equal to 3\nconst alwaysSmall = computed((previous) => {\n  if (count.value <= 3) {\n    return count.value\n  }\n\n  return previous\n})\n</script>\n```\n\nIn case you're using a writable computed:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      count: 2\n    }\n  },\n  computed: {\n    alwaysSmall: {\n      get(_, previous) {\n        if (this.count <= 3) {\n          return this.count\n        }\n\n        return previous;\n      },\n      set(newValue) {\n        this.count = newValue * 2\n      }\n    }\n  }\n}\n```\n\nvue\n\n```\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst count = ref(2)\n\nconst alwaysSmall = computed({\n  get(previous) {\n    if (count.value <= 3) {\n      return count.value\n    }\n\n    return previous\n  },\n  set(newValue) {\n    count.value = newValue * 2\n  }\n})\n</script>\n```\n\n## Best Practices [\u200b](#best-practices)\n\n### Getters should be side-effect free [\u200b](#getters-should-be-side-effect-free)\n\nIt is important to remember that computed getter functions should only perform pure computation and be free of side effects. For example, **don't mutate other state, make async requests, or mutate the DOM inside a computed getter!** Think of a computed property as declaratively describing how to derive a value based on other values - its only responsibility should be computing and returning that value. Later in the guide we will discuss how we can perform side effects in reaction to state changes with [watchers](/guide/essentials/watchers).\n\n### Avoid mutating computed value [\u200b](#avoid-mutating-computed-value)\n\nThe returned value from a computed property is derived state. Think of it as a temporary snapshot - every time the source state changes, a new snapshot is created. It does not make sense to mutate a snapshot, so a computed return value should be treated as read-only and never be mutated - instead, update the source state it depends on to trigger new computations.\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/computed.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:52.303152+00:00",
  "content_length": 8824,
  "content_hash": "799cd376aa4a4e71"
}