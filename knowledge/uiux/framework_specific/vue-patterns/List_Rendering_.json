{
  "id": "vue-patterns__guide_essentials_list_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/list.html",
  "title": "List Rendering\u200b",
  "content": "List Rendering\n\u200b\nWatch a free video lesson on Vue School\nWatch a free video lesson on Vue School\nv-for\n\u200b\nWe can use the\nv-for\ndirective to render a list of items based on an array. The\nv-for\ndirective requires a special syntax in the form of\nitem in items\n, where\nitems\nis the source data array and\nitem\nis an\nalias\nfor the array element being iterated on:\njs\nconst\nitems\n=\nref\n([{ message:\n'Foo'\n}, { message:\n'Bar'\n}])\njs\ndata\n() {\nreturn\n{\nitems: [{ message:\n'Foo'\n}, { message:\n'Bar'\n}]\n}\n}\ntemplate\n<\nli\nv-for\n=\n\"\nitem\nin\nitems\n\"\n>\n{{ item.message }}\n</\nli\n>\nInside the\nv-for\nscope, template expressions have access to all parent scope properties. In addition,\nv-for\nalso supports an optional second alias for the index of the current item:\njs\nconst\nparentMessage\n=\nref\n(\n'Parent'\n)\nconst\nitems\n=\nref\n([{ message:\n'Foo'\n}, { message:\n'Bar'\n}])\njs\ndata\n() {\nreturn\n{\nparentMessage:\n'Parent'\n,\nitems: [{ message:\n'Foo'\n}, { message:\n'Bar'\n}]\n}\n}\ntemplate\n<\nli\nv-for\n=\n\"\n(item, index)\nin\nitems\n\"\n>\n{{ parentMessage }} - {{ index }} - {{ item.message }}\n</\nli\n>\nParent - 0 - Foo\nParent - 1 - Bar\nTry it in the Playground\nTry it in the Playground\nThe variable scoping of\nv-for\nis similar to the following JavaScript:\njs\nconst\nparentMessage\n=\n'Parent'\nconst\nitems\n=\n[\n/* ... */\n]\nitems.\nforEach\n((\nitem\n,\nindex\n)\n=>\n{\n// has access to outer scope `parentMessage`\n// but `item` and `index` are only available in here\nconsole.\nlog\n(parentMessage, item.message, index)\n})\nNotice how the\nv-for\nvalue matches the function signature of the\nforEach\ncallback. In fact, you can use destructuring on the\nv-for\nitem alias similar to destructuring function arguments:\ntemplate\n<\nli\nv-for\n=\n\"\n{ message }\nin\nitems\n\"\n>\n{{ message }}\n</\nli\n>\n<!-- with index alias -->\n<\nli\nv-for\n=\n\"\n({ message }, index)\nin\nitems\n\"\n>\n{{ message }} {{ index }}\n</\nli\n>\nFor nested\nv-for\n, scoping also works similar to nested functions. Each\nv-for\nscope has access to parent scopes:\ntemplate\n<\nli\nv-for\n=\n\"\nitem\nin\nitems\n\"\n>\n<\nspan\nv-for\n=\n\"\nchildItem\nin\nitem.children\n\"\n>\n{{ item.message }} {{ childItem }}\n</\nspan\n>\n</\nli\n>\nYou can also use\nof\nas the delimiter instead of\nin\n, so that it is closer to JavaScript's syntax for iterators:\ntemplate\n<\ndiv\nv-for\n=\n\"\nitem\nof\nitems\n\"\n></\ndiv\n>\nv-for\nwith an Object\n\u200b\nYou can also use\nv-for\nto iterate through the properties of an object. The iteration order will be based on the result of calling\nObject.values()\non the object:\njs\nconst\nmyObject\n=\nreactive\n({\ntitle:\n'How to do lists in Vue'\n,\nauthor:\n'Jane Doe'\n,\npublishedAt:\n'2016-04-10'\n})\njs\ndata\n() {\nreturn\n{\nmyObject: {\ntitle:\n'How to do lists in Vue'\n,\nauthor:\n'Jane Doe'\n,\npublishedAt:\n'2016-04-10'\n}\n}\n}\ntemplate\n<\nul\n>\n<\nli\nv-for\n=\n\"\nvalue\nin\nmyObject\n\"\n>\n{{ value }}\n</\nli\n>\n</\nul\n>\nYou can also provide a second alias for the property's name (a.k.a. key):\ntemplate\n<\nli\nv-for\n=\n\"\n(value, key)\nin\nmyObject\n\"\n>\n{{ key }}: {{ value }}\n</\nli\n>\nAnd another for the index:\ntemplate\n<\nli\nv-for\n=\n\"\n(value, key, index)\nin\nmyObject\n\"\n>\n{{ index }}. {{ key }}: {{ value }}\n</\nli\n>\nTry it in the Playground\nTry it in the Playground\nv-for\nwith a Range\n\u200b\nv-for\ncan also take an integer. In this case it will repeat the template that many times, based on a range of\n1...n\n.\ntemplate\n<\nspan\nv-for\n=\n\"\nn\nin\n10\n\"\n>{{ n }}</\nspan\n>\nNote here\nn\nstarts with an initial value of\n1\ninstead of\n0\n.\nv-for\non\n<template>\n\u200b\nSimilar to template\nv-if\n, you can also use a\n<template>\ntag with\nv-for\nto render a block of multiple elements. For example:\ntemplate\n<\nul\n>\n<\ntemplate\nv-for\n=\n\"\nitem\nin\nitems\n\"\n>\n<\nli\n>{{ item.msg }}</\nli\n>\n<\nli\nclass\n=\n\"divider\"\nrole\n=\n\"presentation\"\n></\nli\n>\n</\ntemplate\n>\n</\nul\n>\nv-for\nwith\nv-if\n\u200b\nWhen they exist on the same node,\nv-if\nhas a higher priority than\nv-for\n. That means the\nv-if\ncondition will not have access to variables from the scope of the\nv-for\n:\ntemplate\n<!--\nThis will throw an error because property \"todo\"\nis not defined on instance.\n-->\n<\nli\nv-for\n=\n\"\ntodo\nin\ntodos\n\"\nv-if\n=\n\"\n!\ntodo.isComplete\n\"\n>\n{{ todo.name }}\n</\nli\n>\nThis can be fixed by moving\nv-for\nto a wrapping\n<template>\ntag (which is also more explicit):\ntemplate\n<\ntemplate\nv-for\n=\n\"\ntodo\nin\ntodos\n\"\n>\n<\nli\nv-if\n=\n\"\n!\ntodo.isComplete\n\"\n>\n{{ todo.name }}\n</\nli\n>\n</\ntemplate\n>\nNote\nIt's\nnot\nrecommended to use\nv-if\nand\nv-for\non the same element due to implicit precedence.\nThere are two common cases where this can be tempting:\nTo filter items in a list (e.g.\nv-for=\"user in users\" v-if=\"user.isActive\"\n). In these cases, replace\nusers\nwith a new computed property that returns your filtered list (e.g.\nactiveUsers\n).\nTo avoid rendering a list if it should be hidden (e.g.\nv-for=\"user in users\" v-if=\"shouldShowUsers\"\n). In these cases, move the\nv-if\nto a container element (e.g.\nul\n,\nol\n).\nMaintaining State with\nkey\n\u200b\nWhen Vue is updating a list of elements rendered with\nv-for\n, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\nThis default mode is efficient, but\nonly suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)\n.\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique\nkey\nattribute for each item:\ntemplate\n<\ndiv\nv-for\n=\n\"\nitem\nin\nitems\n\"\n:\nkey\n=\n\"\nitem.id\n\"\n>\n<!-- content -->\n</\ndiv\n>\nWhen using\n<template v-for>\n, the\nkey\nshould be placed on the\n<template>\ncontainer:\ntemplate\n<\ntemplate\nv-for\n=\n\"\ntodo\nin\ntodos\n\"\n:\nkey\n=\n\"\ntodo.name\n\"\n>\n<\nli\n>{{ todo.name }}</\nli\n>\n</\ntemplate\n>\nNote\nkey\nhere is a special attribute being bound with\nv-bind\n. It should not be confused with the property key variable when\nusing\nv-for\nwith an object\n.\nIt is recommended to provide a\nkey\nattribute with\nv-for\nwhenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\nThe\nkey\nbinding expects primitive values - i.e. strings and numbers. Do not use objects as\nv-for\nkeys. For detailed usage of the\nkey\nattribute, please see the\nkey\nAPI documentation\n.\nv-for\nwith a Component\n\u200b\nThis section assumes knowledge of\nComponents\n. Feel free to skip it and come back later.\nYou can directly use\nv-for\non a component, like any normal element (don't forget to provide a\nkey\n):\ntemplate\n<\nMyComponent\nv-for\n=\n\"\nitem\nin\nitems\n\"\n:\nkey\n=\n\"\nitem.id\n\"\n/>\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\ntemplate\n<\nMyComponent\nv-for\n=\n\"\n(item, index)\nin\nitems\n\"\n:\nitem\n=\n\"\nitem\n\"\n:\nindex\n=\n\"\nindex\n\"\n:\nkey\n=\n\"\nitem.id\n\"\n/>\nThe reason for not automatically injecting\nitem\ninto the component is because that makes the component tightly coupled to how\nv-for\nworks. Being explicit about where its data comes from makes the component reusable in other situations.\nCheck out\nthis example of a simple todo list\nto see how to render a list of components using\nv-for\n, passing different data to each instance.\nCheck out\nthis example of a simple todo list\nto see how to render a list of components using\nv-for\n, passing different data to each instance.\nArray Change Detection\n\u200b\nMutation Methods\n\u200b\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\nReplacing an Array\n\u200b\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g.\nfilter()\n,\nconcat()\nand\nslice()\n, which do not mutate the original array but\nalways return a new array\n. When working with non-mutating methods, we should replace the old array with the new one:\njs\n// `items` is a ref with array value\nitems.value\n=\nitems.value.\nfilter\n((\nitem\n)\n=>\nitem.message.\nmatch\n(\n/\nFoo\n/\n))\njs\nthis\n.items\n=\nthis\n.items.\nfilter\n((\nitem\n)\n=>\nitem.message.\nmatch\n(\n/\nFoo\n/\n))\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\nDisplaying Filtered/Sorted Results\n\u200b\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\nFor example:\njs\nconst\nnumbers\n=\nref\n([\n1\n,\n2\n,\n3\n,\n4\n,\n5\n])\nconst\nevenNumbers\n=\ncomputed\n(()\n=>\n{\nreturn\nnumbers.value.\nfilter\n((\nn\n)\n=>\nn\n%\n2\n===\n0\n)\n})\njs\ndata\n() {\nreturn\n{\nnumbers: [\n1\n,\n2\n,\n3\n,\n4\n,\n5\n]\n}\n},\ncomputed\n: {\nevenNumbers\n() {\nreturn\nthis\n.numbers.\nfilter\n(\nn\n=>\nn\n%\n2\n===\n0\n)\n}\n}\ntemplate\n<\nli\nv-for\n=\n\"\nn\nin\nevenNumbers\n\"\n>{{ n }}</\nli\n>\nIn situations where computed properties are not feasible (e.g. inside nested\nv-for\nloops), you can use a method:\njs\nconst\nsets\n=\nref\n([\n[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n],\n[\n6\n,\n7\n,\n8\n,\n9\n,\n10\n]\n])\nfunction\neven\n(\nnumbers\n) {\nreturn\nnumbers.\nfilter\n((\nnumber\n)\n=>\nnumber\n%\n2\n===\n0\n)\n}\njs\ndata\n() {\nreturn\n{\nsets: [[\n1\n,\n2\n,\n3\n,\n4\n,\n5\n], [\n6\n,\n7\n,\n8\n,\n9\n,\n10\n]]\n}\n},\nmethods\n: {\neven\n(numbers) {\nreturn\nnumbers.\nfilter\n(\nnumber\n=>\nnumber\n%\n2\n===\n0\n)\n}\n}\ntemplate\n<\nul\nv-for\n=\n\"\nnumbers\nin\nsets\n\"\n>\n<\nli\nv-for\n=\n\"\nn\nin\neven\n(numbers)\n\"\n>{{ n }}</\nli\n>\n</\nul\n>\nBe careful with\nreverse()\nand\nsort()\nin a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:\ndiff\n- return numbers.reverse()\n+ return [...numbers].reverse()\nEdit this page on GitHub",
  "content_markdown": "# List Rendering [\u200b](#list-rendering)\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/list-rendering-in-vue-3?friend=vuejs \"Free Vue.js List Rendering Lesson\")\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-fundamentals-capi-list-rendering-in-vue?friend=vuejs \"Free Vue.js List Rendering Lesson\")\n\n## `v-for` [\u200b](#v-for)\n\nWe can use the `v-for` directive to render a list of items based on an array. The `v-for` directive requires a special syntax in the form of `item in items`, where `items` is the source data array and `item` is an **alias** for the array element being iterated on:\n\njs\n\n```\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\n```\n\njs\n\n```\ndata() {\n  return {\n    items: [{ message: 'Foo' }, { message: 'Bar' }]\n  }\n}\n```\n\ntemplate\n\n```\n<li v-for=\"item in items\">\n  {{ item.message }}\n</li>\n```\n\nInside the `v-for` scope, template expressions have access to all parent scope properties. In addition, `v-for` also supports an optional second alias for the index of the current item:\n\njs\n\n```\nconst parentMessage = ref('Parent')\nconst items = ref([{ message: 'Foo' }, { message: 'Bar' }])\n```\n\njs\n\n```\ndata() {\n  return {\n    parentMessage: 'Parent',\n    items: [{ message: 'Foo' }, { message: 'Bar' }]\n  }\n}\n```\n\ntemplate\n\n```\n<li v-for=\"(item, index) in items\">\n  {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n- Parent - 0 - Foo\n- Parent - 1 - Bar\n\n[Try it in the Playground](https://play.vuejs.org/#eNpdTsuqwjAQ/ZVDNlFQu5d64bpwJ7g3LopOJdAmIRlFCPl3p60PcDWcM+eV1X8Iq/uN1FrV6RxtYCTiW/gzzvbBR0ZGpBYFbfQ9tEi1ccadvUuM0ERyvKeUmithMyhn+jCSev4WWaY+vZ7HjH5Sr6F33muUhTR8uW0ThTuJua6mPbJEgGSErmEaENedxX3Z+rgxajbEL2DdhR5zOVOdUSIEDOf8M7IULCHsaPgiMa1eK4QcS6rOSkhdfapVeQLQEWnH)\n\n[Try it in the Playground](https://play.vuejs.org/#eNpVTssKwjAQ/JUllyr0cS9V0IM3wbvxEOxWAm0a0m0phPy7m1aqhpDsDLMz48XJ2nwaUZSiGp5OWzpKg7PtHUGNjRpbAi8NQK1I7fbrLMkhjc5EJAn4WOXQ0BWHQb2whOS24CSN6qjXhN1Qwt1Dt2kufZ9ASOGXOyvH3GMNCdGdH75VsZVjwGa2VYQRUdVqmLKmdwcpdjEnBW1qnPf8wZIrBQujoff/RSEEyIDZZeGLeCn/dGJyCSlazSZVsUWL8AYme21i)\n\nThe variable scoping of `v-for` is similar to the following JavaScript:\n\njs\n\n```\nconst parentMessage = 'Parent'\nconst items = [\n  /* ... */\n]\n\nitems.forEach((item, index) => {\n  // has access to outer scope `parentMessage`\n  // but `item` and `index` are only available in here\n  console.log(parentMessage, item.message, index)\n})\n```\n\nNotice how the `v-for` value matches the function signature of the `forEach` callback. In fact, you can use destructuring on the `v-for` item alias similar to destructuring function arguments:\n\ntemplate\n\n```\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- with index alias -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\nFor nested `v-for`, scoping also works similar to nested functions. Each `v-for` scope has access to parent scopes:\n\ntemplate\n\n```\n<li v-for=\"item in items\">\n  <span v-for=\"childItem in item.children\">\n    {{ item.message }} {{ childItem }}\n  </span>\n</li>\n```\n\nYou can also use `of` as the delimiter instead of `in`, so that it is closer to JavaScript's syntax for iterators:\n\ntemplate\n\n```\n<div v-for=\"item of items\"></div>\n```\n\n## `v-for` with an Object [\u200b](#v-for-with-an-object)\n\nYou can also use `v-for` to iterate through the properties of an object. The iteration order will be based on the result of calling `Object.values()` on the object:\n\njs\n\n```\nconst myObject = reactive({\n  title: 'How to do lists in Vue',\n  author: 'Jane Doe',\n  publishedAt: '2016-04-10'\n})\n```\n\njs\n\n```\ndata() {\n  return {\n    myObject: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<ul>\n  <li v-for=\"value in myObject\">\n    {{ value }}\n  </li>\n</ul>\n```\n\nYou can also provide a second alias for the property's name (a.k.a. key):\n\ntemplate\n\n```\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n```\n\nAnd another for the index:\n\ntemplate\n\n```\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNo9jjFvgzAQhf/KE0sSCQKpqg7IqRSpQ9WlWycvBC6KW2NbcKaNEP+9B7Tx4nt33917Y3IKYT9ESspE9XVnAqMnjuFZO9MG3zFGdFTVbAbChEvnW2yE32inXe1dz2hv7+dPqhnHO7kdtQPYsKUSm1f/DfZoPKzpuYdx+JAL6cxUka++E+itcoQX/9cO8SzslZoTy+yhODxlxWN2KMR22mmn8jWrpBTB1AZbMc2KVbTyQ56yBkN28d1RJ9uhspFSfNEtFf+GfnZzjP/oOll2NQPjuM4xTftZyIaU5VwuN0SsqMqtWZxUvliq/J4jmX4BTCp08A==)\n\n[Try it in the Playground](https://play.vuejs.org/#eNo9T8FqwzAM/RWRS1pImnSMHYI3KOwwdtltJ1/cRqXe3Ng4ctYS8u+TbVJjLD3rPelpLg7O7aaARVeI8eS1ozc54M1ZT9DjWQVDMMsBoFekNtucS/JIwQ8RSQI+1/vX8QdP1K2E+EmaDHZQftg/IAu9BaNHGkEP8B2wrFYxgAp0sZ6pn2pAeLepmEuSXDiy7oL9gduXT+3+pW6f631bZoqkJY/kkB6+onnswoDw6owijIhEMByjUBgNU322/lUWm0mZgBX84r1ifz3ettHmupYskjbanedch2XZRcAKTnnvGVIPBpkqGqPTJNGkkaJ5+CiWf4KkfBs=)\n\n## `v-for` with a Range [\u200b](#v-for-with-a-range)\n\n`v-for` can also take an integer. In this case it will repeat the template that many times, based on a range of `1...n`.\n\ntemplate\n\n```\n<span v-for=\"n in 10\">{{ n }}</span>\n```\n\nNote here `n` starts with an initial value of `1` instead of `0`.\n\n## `v-for` on `<template>` [\u200b](#v-for-on-template)\n\nSimilar to template `v-if`, you can also use a `<template>` tag with `v-for` to render a block of multiple elements. For example:\n\ntemplate\n\n```\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n## `v-for` with `v-if` [\u200b](#v-for-with-v-if)\n\nWhen they exist on the same node, `v-if` has a higher priority than `v-for`. That means the `v-if` condition will not have access to variables from the scope of the `v-for`:\n\ntemplate\n\n```\n<!--\nThis will throw an error because property \"todo\"\nis not defined on instance.\n-->\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo.name }}\n</li>\n```\n\nThis can be fixed by moving `v-for` to a wrapping `<template>` tag (which is also more explicit):\n\ntemplate\n\n```\n<template v-for=\"todo in todos\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n\nNote\n\nIt's **not** recommended to use `v-if` and `v-for` on the same element due to implicit precedence.\n\nThere are two common cases where this can be tempting:\n\n- To filter items in a list (e.g. `v-for=\"user in users\" v-if=\"user.isActive\"`). In these cases, replace `users` with a new computed property that returns your filtered list (e.g. `activeUsers`).\n- To avoid rendering a list if it should be hidden (e.g. `v-for=\"user in users\" v-if=\"shouldShowUsers\"`). In these cases, move the `v-if` to a container element (e.g. `ul`, `ol`).\n\n## Maintaining State with `key` [\u200b](#maintaining-state-with-key)\n\nWhen Vue is updating a list of elements rendered with `v-for`, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.\n\nThis default mode is efficient, but **only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)**.\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique `key` attribute for each item:\n\ntemplate\n\n```\n<div v-for=\"item in items\" :key=\"item.id\">\n  <!-- content -->\n</div>\n```\n\nWhen using `<template v-for>`, the `key` should be placed on the `<template>` container:\n\ntemplate\n\n```\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li>{{ todo.name }}</li>\n</template>\n```\n\nNote\n\n`key` here is a special attribute being bound with `v-bind`. It should not be confused with the property key variable when [using `v-for` with an object](#v-for-with-an-object).\n\nIt is recommended to provide a `key` attribute with `v-for` whenever possible, unless the iterated DOM content is simple (i.e. contains no components or stateful DOM elements), or you are intentionally relying on the default behavior for performance gains.\n\nThe `key` binding expects primitive values - i.e. strings and numbers. Do not use objects as `v-for` keys. For detailed usage of the `key` attribute, please see the [`key` API documentation](/api/built-in-special-attributes#key).\n\n## `v-for` with a Component [\u200b](#v-for-with-a-component)\n\n> This section assumes knowledge of [Components](/guide/essentials/component-basics). Feel free to skip it and come back later.\n\nYou can directly use `v-for` on a component, like any normal element (don't forget to provide a `key`):\n\ntemplate\n\n```\n<MyComponent v-for=\"item in items\" :key=\"item.id\" />\n```\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\ntemplate\n\n```\n<MyComponent\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n/>\n```\n\nThe reason for not automatically injecting `item` into the component is because that makes the component tightly coupled to how `v-for` works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nCheck out [this example of a simple todo list](https://play.vuejs.org/#eNp1U8Fu2zAM/RXCGGAHTWx02ylwgxZYB+ywYRhyq3dwLGYRYkuCJTsZjPz7KMmK3ay9JBQfH/meKA/Rk1Jp32G0jnJdtVwZ0Gg6tSkEb5RsDQzQ4h4usG9lAzGVxldoK5n8ZrAZsTQLCduRygAKUUmhDQg8WWyLZwMPtmESx4sAGkL0mH6xrMH+AHC2hvuljw03Na4h/iLBHBAY1wfUbsTFVcwoH28o2/KIIDuaQ0TTlvrwNu/TDe+7PDlKXZ6EZxTiN4kuRI3W0dk4u4yUf7bZfScqw6WAkrEf3m+y8AOcw7Qv6w5T1elDMhs7Nbq7e61gdmme60SQAvgfIhExiSSJeeb3SBukAy1D1aVBezL5XrYN9Csp1rrbNdykqsUehXkookl0EVGxlZHX5Q5rIBLhNHFlbRD6xBiUzlOeuZJQz4XqjI+BxjSSYe2pQWwRBZizV01DmsRWeJA1Qzv0Of2TwldE5hZRlVd+FkbuOmOksJLybIwtkmfWqg+7qz47asXpSiaN3lxikSVwwfC8oD+/sEnV+oh/qcxmU85mebepgLjDBD622Mg+oDrVquYVJm7IEu4XoXKTZ1dho3gnmdJhedEymn9ab3ysDPdc4M9WKp28xE5JbB+rzz/Trm3eK3LAu8/E7p2PNzYM/i3ChR7W7L7hsSIvR7L2Aal1EhqTp80vF95sw3WcG7r8A0XaeME=) to see how to render a list of components using `v-for`, passing different data to each instance.\n\nCheck out [this example of a simple todo list](https://play.vuejs.org/#eNqNVE2PmzAQ/SsjVIlEm4C27Qmx0a7UVuqhPVS5lT04eFKsgG2BSVJF+e8d2xhIu10tihR75s2bNx9wiZ60To49RlmUd2UrtNkUUjRatQa2iquvBhvYt6qBOEmDwQbEhQQoJJ4dlOOe9bWBi7WWiuIlStNlcJlYrivr5MywxdIDAVo0fSvDDUDiyeK3eDYZxLGLsI8hI7H9DHeYQuwjeAb3I9gFCFMjUXxSYCoELroKO6fZP17Mf6jev0i1ZQcE1RtHaFrWVW/l+/Ai3zd1clQ1O8k5Uzg+j1HUZePaSFwfvdGhfNIGTaW47bV3Mc6/+zZOfaaslegS18ZE9121mIm0Ep17ynN3N5M8CB4g44AC4Lq8yTFDwAPNcK63kPTL03HR6EKboWtm0N5MvldtA8e1klnX7xphEt3ikTbpoYimsoqIwJY0r9kOa6Ag8lPeta2PvE+cA3M7k6cOEvBC6n7UfVw3imPtQ8eiouAW/IY0mElsiZWqOdqkn5NfCXxB5G6SJRvj05By1xujpJWUp8PZevLUluqP/ajPploLasmk0Re3sJ4VCMnxvKQ//0JMqrID/iaYtSaCz+xudsHjLpPzscVGHYO3SzpdixIXLskK7pcBucnTUdgg3kkmcxhetIrmH4ebr8m/n4jC6FZp+z7HTlLsVx1p4M7odcXPr6+Lnb8YOne5+C2F6/D6DH2Hx5JqOlCJ7yz7IlBTbZsf7vjXVBzjvLDrH5T0lgo=) to see how to render a list of components using `v-for`, passing different data to each instance.\n\n## Array Change Detection [\u200b](#array-change-detection)\n\n### Mutation Methods [\u200b](#mutation-methods)\n\nVue is able to detect when a reactive array's mutation methods are called and trigger necessary updates. These mutation methods are:\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\n### Replacing an Array [\u200b](#replacing-an-array)\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. `filter()`, `concat()` and `slice()`, which do not mutate the original array but **always return a new array**. When working with non-mutating methods, we should replace the old array with the new one:\n\njs\n\n```\n// `items` is a ref with array value\nitems.value = items.value.filter((item) => item.message.match(/Foo/))\n```\n\njs\n\n```\nthis.items = this.items.filter((item) => item.message.match(/Foo/))\n```\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\n## Displaying Filtered/Sorted Results [\u200b](#displaying-filtered-sorted-results)\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nFor example:\n\njs\n\n```\nconst numbers = ref([1, 2, 3, 4, 5])\n\nconst evenNumbers = computed(() => {\n  return numbers.value.filter((n) => n % 2 === 0)\n})\n```\n\njs\n\n```\ndata() {\n  return {\n    numbers: [1, 2, 3, 4, 5]\n  }\n},\ncomputed: {\n  evenNumbers() {\n    return this.numbers.filter(n => n % 2 === 0)\n  }\n}\n```\n\ntemplate\n\n```\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\nIn situations where computed properties are not feasible (e.g. inside nested `v-for` loops), you can use a method:\n\njs\n\n```\nconst sets = ref([\n  [1, 2, 3, 4, 5],\n  [6, 7, 8, 9, 10]\n])\n\nfunction even(numbers) {\n  return numbers.filter((number) => number % 2 === 0)\n}\n```\n\njs\n\n```\ndata() {\n  return {\n    sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n  }\n},\nmethods: {\n  even(numbers) {\n    return numbers.filter(number => number % 2 === 0)\n  }\n}\n```\n\ntemplate\n\n```\n<ul v-for=\"numbers in sets\">\n  <li v-for=\"n in even(numbers)\">{{ n }}</li>\n</ul>\n```\n\nBe careful with `reverse()` and `sort()` in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:\n\ndiff\n\n```\n- return numbers.reverse()\n+ return [...numbers].reverse()\n```\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/list.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:57.689091+00:00",
  "content_length": 10018,
  "content_hash": "d9cf32c9602138ef"
}