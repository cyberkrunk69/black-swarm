{
  "id": "vue-patterns__guide_components_events_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/components/events.html",
  "title": "Component Events\u200b",
  "content": "Component Events\n\u200b\nThis page assumes you've already read the\nComponents Basics\n. Read that first if you are new to components.\nWatch a free video lesson on Vue School\nEmitting and Listening to Events\n\u200b\nA component can emit custom events directly in template expressions (e.g. in a\nv-on\nhandler) using the built-in\n$emit\nmethod:\ntemplate\n<!-- MyComponent -->\n<\nbutton\n@\nclick\n=\n\"\n$emit\n(\n'someEvent'\n)\n\"\n>Click Me</\nbutton\n>\nThe\n$emit()\nmethod is also available on the component instance as\nthis.$emit()\n:\njs\nexport\ndefault\n{\nmethods: {\nsubmit\n() {\nthis\n.\n$emit\n(\n'someEvent'\n)\n}\n}\n}\nThe parent can then listen to it using\nv-on\n:\ntemplate\n<\nMyComponent\n@\nsome-event\n=\n\"\ncallback\n\"\n/>\nThe\n.once\nmodifier is also supported on component event listeners:\ntemplate\n<\nMyComponent\n@\nsome-event\n.\nonce\n=\n\"\ncallback\n\"\n/>\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with\nprops casing\n, we recommend using kebab-cased event listeners in templates.\nTIP\nUnlike native DOM events, component emitted events do\nnot\nbubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a\nglobal state management solution\n.\nEvent Arguments\n\u200b\nIt's sometimes useful to emit a specific value with an event. For example, we may want the\n<BlogPost>\ncomponent to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to\n$emit\nto provide this value:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\n$emit\n(\n'increaseBy'\n,\n1\n)\n\"\n>\nIncrease by 1\n</\nbutton\n>\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\ntemplate\n<\nMyButton\n@\nincrease-by\n=\n\"\n(\nn\n)\n=>\ncount\n+=\nn\n\"\n/>\nOr, if the event handler is a method:\ntemplate\n<\nMyButton\n@\nincrease-by\n=\n\"\nincreaseCount\n\"\n/>\nThen the value will be passed as the first parameter of that method:\njs\nmethods\n: {\nincreaseCount\n(n) {\nthis\n.count\n+=\nn\n}\n}\njs\nfunction\nincreaseCount\n(\nn\n) {\ncount.value\n+=\nn\n}\nTIP\nAll extra arguments passed to\n$emit()\nafter the event name will be forwarded to the listener. For example, with\n$emit('foo', 1, 2, 3)\nthe listener function will receive three arguments.\nDeclaring Emitted Events\n\u200b\nA component can explicitly declare the events it will emit using the\ndefineEmits()\nmacro\nemits\noption\n:\nvue\n<\nscript\nsetup\n>\ndefineEmits\n([\n'inFocus'\n,\n'submit'\n])\n</\nscript\n>\nThe\n$emit\nmethod that we used in the\n<template>\nisn't accessible within the\n<script setup>\nsection of a component, but\ndefineEmits()\nreturns an equivalent function that we can use instead:\nvue\n<\nscript\nsetup\n>\nconst\nemit\n=\ndefineEmits\n([\n'inFocus'\n,\n'submit'\n])\nfunction\nbuttonClick\n() {\nemit\n(\n'submit'\n)\n}\n</\nscript\n>\nThe\ndefineEmits()\nmacro\ncannot\nbe used inside a function, it must be placed directly within\n<script setup>\n, as in the example above.\nIf you're using an explicit\nsetup\nfunction instead of\n<script setup>\n, events should be declared using the\nemits\noption, and the\nemit\nfunction is exposed on the\nsetup()\ncontext:\njs\nexport\ndefault\n{\nemits: [\n'inFocus'\n,\n'submit'\n],\nsetup\n(\nprops\n,\nctx\n) {\nctx.\nemit\n(\n'submit'\n)\n}\n}\nAs with other properties of the\nsetup()\ncontext,\nemit\ncan safely be destructured:\njs\nexport\ndefault\n{\nemits: [\n'inFocus'\n,\n'submit'\n],\nsetup\n(\nprops\n, {\nemit\n}) {\nemit\n(\n'submit'\n)\n}\n}\njs\nexport\ndefault\n{\nemits: [\n'inFocus'\n,\n'submit'\n]\n}\nThe\nemits\noption and\ndefineEmits()\nmacro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\nvue\n<\nscript\nsetup\nlang\n=\n\"ts\"\n>\nconst\nemit\n=\ndefineEmits\n({\nsubmit\n(\npayload\n:\n{\nemail\n:\nstring\n,\npassword\n:\nstring\n}) {\n// return `true` or `false` to indicate\n// validation pass / fail\n}\n})\n</\nscript\n>\nIf you are using TypeScript with\n<script setup>\n, it's also possible to declare emitted events using pure type annotations:\nvue\n<\nscript\nsetup\nlang\n=\n\"ts\"\n>\nconst\nemit\n=\ndefineEmits\n<{\n(\ne\n:\n'change'\n,\nid\n:\nnumber\n)\n:\nvoid\n(\ne\n:\n'update'\n,\nvalue\n:\nstring\n)\n:\nvoid\n}>()\n</\nscript\n>\nMore details:\nTyping Component Emits\njs\nexport\ndefault\n{\nemits: {\nsubmit\n(\npayload\n:\n{\nemail\n:\nstring\n,\npassword\n:\nstring\n}) {\n// return `true` or `false` to indicate\n// validation pass / fail\n}\n}\n}\nSee also:\nTyping Component Emits\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from\nfallthrough attributes\n, avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\nTIP\nIf a native event (e.g.,\nclick\n) is defined in the\nemits\noption, the listener will now only listen to component-emitted\nclick\nevents and no longer respond to native\nclick\nevents.\nEvents Validation\n\u200b\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\nTo add validation, the event is assigned a function that receives the arguments passed to the\nthis.$emit\nemit\ncall and returns a boolean to indicate whether the event is valid or not.\nvue\n<\nscript\nsetup\n>\nconst\nemit\n=\ndefineEmits\n({\n// No validation\nclick:\nnull\n,\n// Validate submit event\nsubmit\n: ({\nemail\n,\npassword\n})\n=>\n{\nif\n(email\n&&\npassword) {\nreturn\ntrue\n}\nelse\n{\nconsole.\nwarn\n(\n'Invalid submit event payload!'\n)\nreturn\nfalse\n}\n}\n})\nfunction\nsubmitForm\n(\nemail\n,\npassword\n) {\nemit\n(\n'submit'\n, { email, password })\n}\n</\nscript\n>\njs\nexport\ndefault\n{\nemits: {\n// No validation\nclick:\nnull\n,\n// Validate submit event\nsubmit\n: ({\nemail\n,\npassword\n})\n=>\n{\nif\n(email\n&&\npassword) {\nreturn\ntrue\n}\nelse\n{\nconsole.\nwarn\n(\n'Invalid submit event payload!'\n)\nreturn\nfalse\n}\n}\n},\nmethods: {\nsubmitForm\n(\nemail\n,\npassword\n) {\nthis\n.\n$emit\n(\n'submit'\n, { email, password })\n}\n}\n}\nEdit this page on GitHub",
  "content_markdown": "# Component Events [\u200b](#component-events)\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/defining-custom-events-emits?friend=vuejs \"Free Vue.js Lesson on Defining Custom Events\")\n\n## Emitting and Listening to Events [\u200b](#emitting-and-listening-to-events)\n\nA component can emit custom events directly in template expressions (e.g. in a `v-on` handler) using the built-in `$emit` method:\n\ntemplate\n\n```\n<!-- MyComponent -->\n<button @click=\"$emit('someEvent')\">Click Me</button>\n```\n\nThe `$emit()` method is also available on the component instance as `this.$emit()`:\n\njs\n\n```\nexport default {\n  methods: {\n    submit() {\n      this.$emit('someEvent')\n    }\n  }\n}\n```\n\nThe parent can then listen to it using `v-on`:\n\ntemplate\n\n```\n<MyComponent @some-event=\"callback\" />\n```\n\nThe `.once` modifier is also supported on component event listeners:\n\ntemplate\n\n```\n<MyComponent @some-event.once=\"callback\" />\n```\n\nLike components and props, event names provide an automatic case transformation. Notice we emitted a camelCase event, but can listen for it using a kebab-cased listener in the parent. As with [props casing](/guide/components/props#prop-name-casing), we recommend using kebab-cased event listeners in templates.\n\nTIP\n\nUnlike native DOM events, component emitted events do **not** bubble. You can only listen to the events emitted by a direct child component. If there is a need to communicate between sibling or deeply nested components, use an external event bus or a [global state management solution](/guide/scaling-up/state-management).\n\n## Event Arguments [\u200b](#event-arguments)\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the `<BlogPost>` component to be in charge of how much to enlarge the text by. In those cases, we can pass extra arguments to `$emit` to provide this value:\n\ntemplate\n\n```\n<button @click=\"$emit('increaseBy', 1)\">\n  Increase by 1\n</button>\n```\n\nThen, when we listen to the event in the parent, we can use an inline arrow function as the listener, which allows us to access the event argument:\n\ntemplate\n\n```\n<MyButton @increase-by=\"(n) => count += n\" />\n```\n\nOr, if the event handler is a method:\n\ntemplate\n\n```\n<MyButton @increase-by=\"increaseCount\" />\n```\n\nThen the value will be passed as the first parameter of that method:\n\njs\n\n```\nmethods: {\n  increaseCount(n) {\n    this.count += n\n  }\n}\n```\n\njs\n\n```\nfunction increaseCount(n) {\n  count.value += n\n}\n```\n\nTIP\n\nAll extra arguments passed to `$emit()` after the event name will be forwarded to the listener. For example, with `$emit('foo', 1, 2, 3)` the listener function will receive three arguments.\n\n## Declaring Emitted Events [\u200b](#declaring-emitted-events)\n\nA component can explicitly declare the events it will emit using the [`defineEmits()`](/api/sfc-script-setup#defineprops-defineemits) macro[`emits`](/api/options-state#emits) option:\n\nvue\n\n```\n<script setup>\ndefineEmits(['inFocus', 'submit'])\n</script>\n```\n\nThe `$emit` method that we used in the `<template>` isn't accessible within the `<script setup>` section of a component, but `defineEmits()` returns an equivalent function that we can use instead:\n\nvue\n\n```\n<script setup>\nconst emit = defineEmits(['inFocus', 'submit'])\n\nfunction buttonClick() {\n  emit('submit')\n}\n</script>\n```\n\nThe `defineEmits()` macro **cannot** be used inside a function, it must be placed directly within `<script setup>`, as in the example above.\n\nIf you're using an explicit `setup` function instead of `<script setup>`, events should be declared using the [`emits`](/api/options-state#emits) option, and the `emit` function is exposed on the `setup()` context:\n\njs\n\n```\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, ctx) {\n    ctx.emit('submit')\n  }\n}\n```\n\nAs with other properties of the `setup()` context, `emit` can safely be destructured:\n\njs\n\n```\nexport default {\n  emits: ['inFocus', 'submit'],\n  setup(props, { emit }) {\n    emit('submit')\n  }\n}\n```\n\njs\n\n```\nexport default {\n  emits: ['inFocus', 'submit']\n}\n```\n\nThe `emits` option and `defineEmits()` macro also support an object syntax. If using TypeScript you can type arguments, which allows us to perform runtime validation of the payload of the emitted events:\n\nvue\n\n```\n<script setup lang=\"ts\">\nconst emit = defineEmits({\n  submit(payload: { email: string, password: string }) {\n    // return `true` or `false` to indicate\n    // validation pass / fail\n  }\n})\n</script>\n```\n\nIf you are using TypeScript with `<script setup>`, it's also possible to declare emitted events using pure type annotations:\n\nvue\n\n```\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  (e: 'change', id: number): void\n  (e: 'update', value: string): void\n}>()\n</script>\n```\n\nMore details: [Typing Component Emits](/guide/typescript/composition-api#typing-component-emits)\n\njs\n\n```\nexport default {\n  emits: {\n    submit(payload: { email: string, password: string }) {\n      // return `true` or `false` to indicate\n      // validation pass / fail\n    }\n  }\n}\n```\n\nSee also: [Typing Component Emits](/guide/typescript/options-api#typing-component-emits)\n\nAlthough optional, it is recommended to define all emitted events in order to better document how a component should work. It also allows Vue to exclude known listeners from [fallthrough attributes](/guide/components/attrs#v-on-listener-inheritance), avoiding edge cases caused by DOM events manually dispatched by 3rd party code.\n\nTIP\n\nIf a native event (e.g., `click`) is defined in the `emits` option, the listener will now only listen to component-emitted `click` events and no longer respond to native `click` events.\n\n## Events Validation [\u200b](#events-validation)\n\nSimilar to prop type validation, an emitted event can be validated if it is defined with the object syntax instead of the array syntax.\n\nTo add validation, the event is assigned a function that receives the arguments passed to the `this.$emit``emit` call and returns a boolean to indicate whether the event is valid or not.\n\nvue\n\n```\n<script setup>\nconst emit = defineEmits({\n  // No validation\n  click: null,\n\n  // Validate submit event\n  submit: ({ email, password }) => {\n    if (email && password) {\n      return true\n    } else {\n      console.warn('Invalid submit event payload!')\n      return false\n    }\n  }\n})\n\nfunction submitForm(email, password) {\n  emit('submit', { email, password })\n}\n</script>\n```\n\njs\n\n```\nexport default {\n  emits: {\n    // No validation\n    click: null,\n\n    // Validate submit event\n    submit: ({ email, password }) => {\n      if (email && password) {\n        return true\n      } else {\n        console.warn('Invalid submit event payload!')\n        return false\n      }\n    }\n  },\n  methods: {\n    submitForm(email, password) {\n      this.$emit('submit', { email, password })\n    }\n  }\n}\n```\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/components/events.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:06.215773+00:00",
  "content_length": 5996,
  "content_hash": "461594e6024a67b6"
}