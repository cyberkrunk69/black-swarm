{
  "id": "vue-patterns__guide_built-ins_transition_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/built-ins/transition.html",
  "title": "Transition\u200b",
  "content": "Transition\n\u200b\nVue offers two built-in components that can help work with transitions and animations in response to changing state:\n<Transition>\nfor applying animations when an element or component is entering and leaving the DOM. This is covered on this page.\n<TransitionGroup>\nfor applying animations when an element or component is inserted into, removed from, or moved within a\nv-for\nlist. This is covered in\nthe next chapter\n.\nAside from these two components, we can also apply animations in Vue using other techniques such as toggling CSS classes or state-driven animations via style bindings. These additional techniques are covered in the\nAnimation Techniques\nchapter.\nThe\n<Transition>\nComponent\n\u200b\n<Transition>\nis a built-in component: this means it is available in any component's template without having to register it. It can be used to apply enter and leave animations on elements or components passed to it via its default slot. The enter or leave can be triggered by one of the following:\nConditional rendering via\nv-if\nConditional display via\nv-show\nDynamic components toggling via the\n<component>\nspecial element\nChanging the special\nkey\nattribute\nThis is an example of the most basic usage:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\nshow\n=\n!\nshow\n\"\n>Toggle</\nbutton\n>\n<\nTransition\n>\n<\np\nv-if\n=\n\"\nshow\n\"\n>hello</\np\n>\n</\nTransition\n>\ncss\n/* we will explain what these classes do next! */\n.v-enter-active\n,\n.v-leave-active\n{\ntransition\n: opacity\n0.5\ns\nease\n;\n}\n.v-enter-from\n,\n.v-leave-to\n{\nopacity\n:\n0\n;\n}\nToggle Fade\nhello\nTry it in the Playground\nTry it in the Playground\nTIP\n<Transition>\nonly supports a single element or component as its slot content. If the content is a component, the component must also have only one single root element.\nWhen an element in a\n<Transition>\ncomponent is inserted or removed, this is what happens:\nVue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, a number of\nCSS transition classes\nwill be added / removed at appropriate timings.\nIf there are listeners for\nJavaScript hooks\n, these hooks will be called at appropriate timings.\nIf no CSS transitions / animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed on the browser's next animation frame.\nCSS-Based Transitions\n\u200b\nTransition Classes\n\u200b\nThere are six classes applied for enter / leave transitions.\nv-enter-from\n: Starting state for enter. Added before the element is inserted, removed one frame after the element is inserted.\nv-enter-active\n: Active state for enter. Applied during the entire entering phase. Added before the element is inserted, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.\nv-enter-to\n: Ending state for enter. Added one frame after the element is inserted (at the same time\nv-enter-from\nis removed), removed when the transition/animation finishes.\nv-leave-from\n: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.\nv-leave-active\n: Active state for leave. Applied during the entire leaving phase. Added immediately when a leaving transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.\nv-leave-to\n: Ending state for leave. Added one frame after a leaving transition is triggered (at the same time\nv-leave-from\nis removed), removed when the transition/animation finishes.\nv-enter-active\nand\nv-leave-active\ngive us the ability to specify different easing curves for enter / leave transitions, which we'll see an example of in the following sections.\nNamed Transitions\n\u200b\nA transition can be named via the\nname\nprop:\ntemplate\n<\nTransition\nname\n=\n\"fade\"\n>\n...\n</\nTransition\n>\nFor a named transition, its transition classes will be prefixed with its name instead of\nv\n. For example, the applied class for the above transition will be\nfade-enter-active\ninstead of\nv-enter-active\n. The CSS for the fade transition should look like this:\ncss\n.fade-enter-active\n,\n.fade-leave-active\n{\ntransition\n: opacity\n0.5\ns\nease\n;\n}\n.fade-enter-from\n,\n.fade-leave-to\n{\nopacity\n:\n0\n;\n}\nCSS Transitions\n\u200b\n<Transition>\nis most commonly used in combination with\nnative CSS transitions\n, as seen in the basic example above. The\ntransition\nCSS property is a shorthand that allows us to specify multiple aspects of a transition, including properties that should be animated, duration of the transition, and\neasing curves\n.\nHere is a more advanced example that transitions multiple properties, with different durations and easing curves for enter and leave:\ntemplate\n<\nTransition\nname\n=\n\"slide-fade\"\n>\n<\np\nv-if\n=\n\"\nshow\n\"\n>hello</\np\n>\n</\nTransition\n>\ncss\n/*\nEnter and leave animations can use different\ndurations and timing functions.\n*/\n.slide-fade-enter-active\n{\ntransition\n:\nall\n0.3\ns\nease-out\n;\n}\n.slide-fade-leave-active\n{\ntransition\n:\nall\n0.8\ns\ncubic-bezier\n(\n1\n,\n0.5\n,\n0.8\n,\n1\n);\n}\n.slide-fade-enter-from\n,\n.slide-fade-leave-to\n{\ntransform\n:\ntranslateX\n(\n20\npx\n);\nopacity\n:\n0\n;\n}\nToggle Slide + Fade\nhello\nTry it in the Playground\nTry it in the Playground\nCSS Animations\n\u200b\nNative CSS animations\nare applied in the same way as CSS transitions, with the difference being that\n*-enter-from\nis not removed immediately after the element is inserted, but on an\nanimationend\nevent.\nFor most CSS animations, we can simply declare them under the\n*-enter-active\nand\n*-leave-active\nclasses. Here's an example:\ntemplate\n<\nTransition\nname\n=\n\"bounce\"\n>\n<\np\nv-if\n=\n\"\nshow\n\"\nstyle\n=\n\"text-align: center;\"\n>\nHello here is some bouncy text!\n</\np\n>\n</\nTransition\n>\ncss\n.bounce-enter-active\n{\nanimation\n: bounce-in\n0.5\ns\n;\n}\n.bounce-leave-active\n{\nanimation\n: bounce-in\n0.5\ns\nreverse\n;\n}\n@keyframes\nbounce-in\n{\n0%\n{\ntransform\n:\nscale\n(\n0\n);\n}\n50%\n{\ntransform\n:\nscale\n(\n1.25\n);\n}\n100%\n{\ntransform\n:\nscale\n(\n1\n);\n}\n}\nToggle\nHello here is some bouncy text!\nTry it in the Playground\nTry it in the Playground\nCustom Transition Classes\n\u200b\nYou can also specify custom transition classes by passing the following props to\n<Transition>\n:\nenter-from-class\nenter-active-class\nenter-to-class\nleave-from-class\nleave-active-class\nleave-to-class\nThese will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as\nAnimate.css\n:\ntemplate\n<!-- assuming Animate.css is included on the page -->\n<\nTransition\nname\n=\n\"custom-classes\"\nenter-active-class\n=\n\"animate__animated animate__tada\"\nleave-active-class\n=\n\"animate__animated animate__bounceOutRight\"\n>\n<\np\nv-if\n=\n\"\nshow\n\"\n>hello</\np\n>\n</\nTransition\n>\nTry it in the Playground\nTry it in the Playground\nUsing Transitions and Animations Together\n\u200b\nVue needs to attach event listeners in order to know when a transition has ended. It can either be\ntransitionend\nor\nanimationend\n, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about by passing the\ntype\nprop, with a value of either\nanimation\nor\ntransition\n:\ntemplate\n<\nTransition\ntype\n=\n\"animation\"\n>...</\nTransition\n>\nNested Transitions and Explicit Transition Durations\n\u200b\nAlthough the transition classes are only applied to the direct child element in\n<Transition>\n, we can transition nested elements using nested CSS selectors:\ntemplate\n<\nTransition\nname\n=\n\"nested\"\n>\n<\ndiv\nv-if\n=\n\"\nshow\n\"\nclass\n=\n\"outer\"\n>\n<\ndiv\nclass\n=\n\"inner\"\n>\nHello\n</\ndiv\n>\n</\ndiv\n>\n</\nTransition\n>\ncss\n/* rules that target nested elements */\n.nested-enter-active\n.inner\n,\n.nested-leave-active\n.inner\n{\ntransition\n:\nall\n0.3\ns\nease-in-out\n;\n}\n.nested-enter-from\n.inner\n,\n.nested-leave-to\n.inner\n{\ntransform\n:\ntranslateX\n(\n30\npx\n);\nopacity\n:\n0\n;\n}\n/* ... other necessary CSS omitted */\nWe can even add a transition delay to the nested element on enter, which creates a staggered enter animation sequence:\ncss\n/* delay enter of nested element for staggered effect */\n.nested-enter-active\n.inner\n{\ntransition-delay\n:\n0.25\ns\n;\n}\nHowever, this creates a small issue. By default, the\n<Transition>\ncomponent attempts to automatically figure out when the transition has finished by listening to the\nfirst\ntransitionend\nor\nanimationend\nevent on the root transition element. With a nested transition, the desired behavior should be waiting until the transitions of all inner elements have finished.\nIn such cases you can specify an explicit transition duration (in milliseconds) using the\nduration\nprop on the\n<Transition>\ncomponent. The total duration should match the delay plus transition duration of the inner element:\ntemplate\n<\nTransition\n:\nduration\n=\n\"\n550\n\"\n>...</\nTransition\n>\nToggle\nHello\nTry it in the Playground\nIf necessary, you can also specify separate values for enter and leave durations using an object:\ntemplate\n<\nTransition\n:\nduration\n=\n\"\n{ enter:\n500\n, leave:\n800\n}\n\"\n>...</\nTransition\n>\nPerformance Considerations\n\u200b\nYou may notice that the animations shown above are mostly using properties like\ntransform\nand\nopacity\n. These properties are efficient to animate because:\nThey do not affect the document layout during the animation, so they do not trigger expensive CSS layout calculation on every animation frame.\nMost modern browsers can leverage GPU hardware acceleration when animating\ntransform\n.\nIn comparison, properties like\nheight\nor\nmargin\nwill trigger CSS layout, so they are much more expensive to animate, and should be used with caution.\nJavaScript Hooks\n\u200b\nYou can hook into the transition process with JavaScript by listening to events on the\n<Transition>\ncomponent:\ntemplate\n<\nTransition\n@\nbefore-enter\n=\n\"\nonBeforeEnter\n\"\n@\nenter\n=\n\"\nonEnter\n\"\n@\nafter-enter\n=\n\"\nonAfterEnter\n\"\n@\nenter-cancelled\n=\n\"\nonEnterCancelled\n\"\n@\nbefore-leave\n=\n\"\nonBeforeLeave\n\"\n@\nleave\n=\n\"\nonLeave\n\"\n@\nafter-leave\n=\n\"\nonAfterLeave\n\"\n@\nleave-cancelled\n=\n\"\nonLeaveCancelled\n\"\n>\n<!-- ... -->\n</\nTransition\n>\njs\n// called before the element is inserted into the DOM.\n// use this to set the \"enter-from\" state of the element\nfunction\nonBeforeEnter\n(\nel\n) {}\n// called one frame after the element is inserted.\n// use this to start the entering animation.\nfunction\nonEnter\n(\nel\n,\ndone\n) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone\n()\n}\n// called when the enter transition has finished.\nfunction\nonAfterEnter\n(\nel\n) {}\n// called when the enter transition is cancelled before completion.\nfunction\nonEnterCancelled\n(\nel\n) {}\n// called before the leave hook.\n// Most of the time, you should just use the leave hook\nfunction\nonBeforeLeave\n(\nel\n) {}\n// called when the leave transition starts.\n// use this to start the leaving animation.\nfunction\nonLeave\n(\nel\n,\ndone\n) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone\n()\n}\n// called when the leave transition has finished and the\n// element has been removed from the DOM.\nfunction\nonAfterLeave\n(\nel\n) {}\n// only available with v-show transitions\nfunction\nonLeaveCancelled\n(\nel\n) {}\njs\nexport\ndefault\n{\n// ...\nmethods: {\n// called before the element is inserted into the DOM.\n// use this to set the \"enter-from\" state of the element\nonBeforeEnter\n(\nel\n) {},\n// called one frame after the element is inserted.\n// use this to start the animation.\nonEnter\n(\nel\n,\ndone\n) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone\n()\n},\n// called when the enter transition has finished.\nonAfterEnter\n(\nel\n) {},\n// called when the enter transition is cancelled before completion.\nonEnterCancelled\n(\nel\n) {},\n// called before the leave hook.\n// Most of the time, you should just use the leave hook.\nonBeforeLeave\n(\nel\n) {},\n// called when the leave transition starts.\n// use this to start the leaving animation.\nonLeave\n(\nel\n,\ndone\n) {\n// call the done callback to indicate transition end\n// optional if used in combination with CSS\ndone\n()\n},\n// called when the leave transition has finished and the\n// element has been removed from the DOM.\nonAfterLeave\n(\nel\n) {},\n// only available with v-show transitions\nonLeaveCancelled\n(\nel\n) {}\n}\n}\nThese hooks can be used in combination with CSS transitions / animations or on their own.\nWhen using JavaScript-only transitions, it is usually a good idea to add the\n:css=\"false\"\nprop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition:\ntemplate\n<\nTransition\n...\n:\ncss\n=\n\"\nfalse\n\"\n>\n...\n</\nTransition\n>\nWith\n:css=\"false\"\n, we are also fully responsible for controlling when the transition ends. In this case, the\ndone\ncallbacks are required for the\n@enter\nand\n@leave\nhooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\nHere's a demo using the\nGSAP library\nto perform the animations. You can, of course, use any other animation library you want, for example\nAnime.js\nor\nMotion One\n:\nToggle\nTry it in the Playground\nTry it in the Playground\nReusable Transitions\n\u200b\nTransitions can be reused through Vue's component system. To create a reusable transition, we can create a component that wraps the\n<Transition>\ncomponent and passes down the slot content:\nMyTransition.vue\nvue\n<\nscript\n>\n// JavaScript hooks logic...\n</\nscript\n>\n<\ntemplate\n>\n<!-- wrap the built-in Transition component -->\n<\nTransition\nname\n=\n\"my-transition\"\n@enter\n=\n\"onEnter\"\n@leave\n=\n\"onLeave\"\n>\n<\nslot\n></\nslot\n>\n<!-- pass down slot content -->\n</\nTransition\n>\n</\ntemplate\n>\n<\nstyle\n>\n/*\nNecessary CSS...\nNote: avoid using <style scoped> here since it\ndoes not apply to slot content.\n*/\n</\nstyle\n>\nNow\nMyTransition\ncan be imported and used just like the built-in version:\ntemplate\n<\nMyTransition\n>\n<\ndiv\nv-if\n=\n\"\nshow\n\"\n>Hello</\ndiv\n>\n</\nMyTransition\n>\nTransition on Appear\n\u200b\nIf you also want to apply a transition on the initial render of a node, you can add the\nappear\nprop:\ntemplate\n<\nTransition\nappear\n>\n...\n</\nTransition\n>\nTransition Between Elements\n\u200b\nIn addition to toggling an element with\nv-if\n/\nv-show\n, we can also transition between two elements using\nv-if\n/\nv-else\n/\nv-else-if\n, as long as we make sure that there is only one element being shown at any given moment:\ntemplate\n<\nTransition\n>\n<\nbutton\nv-if\n=\n\"\ndocState\n===\n'saved'\"\n>Edit</\nbutton\n>\n<\nbutton\nv-else-if\n=\n\"\ndocState\n===\n'edited'\"\n>Save</\nbutton\n>\n<\nbutton\nv-else-if\n=\n\"\ndocState\n===\n'editing'\"\n>Cancel</\nbutton\n>\n</\nTransition\n>\nClick to cycle through states:\nEdit\nTry it in the Playground\nTransition Modes\n\u200b\nIn the previous example, the entering and leaving elements are animated at the same time, and we had to make them\nposition: absolute\nto avoid the layout issue when both elements are present in the DOM.\nHowever, in some cases this isn't an option, or simply isn't the desired behavior. We may want the leaving element to be animated out first, and for the entering element to only be inserted\nafter\nthe leaving animation has finished. Orchestrating such animations manually would be very complicated - luckily, we can enable this behavior by passing\n<Transition>\na\nmode\nprop:\ntemplate\n<\nTransition\nmode\n=\n\"out-in\"\n>\n...\n</\nTransition\n>\nHere's the previous demo with\nmode=\"out-in\"\n:\nClick to cycle through states:\nEdit\n<Transition>\nalso supports\nmode=\"in-out\"\n, although it's much less frequently used.\nTransition Between Components\n\u200b\n<Transition>\ncan also be used around\ndynamic components\n:\ntemplate\n<\nTransition\nname\n=\n\"fade\"\nmode\n=\n\"out-in\"\n>\n<\ncomponent\n:\nis\n=\n\"\nactiveComponent\n\"\n></\ncomponent\n>\n</\nTransition\n>\nA\nB\nComponent A\nTry it in the Playground\nTry it in the Playground\nDynamic Transitions\n\u200b\n<Transition>\nprops like\nname\ncan also be dynamic! It allows us to dynamically apply different transitions based on state change:\ntemplate\n<\nTransition\n:\nname\n=\n\"\ntransitionName\n\"\n>\n<!-- ... -->\n</\nTransition\n>\nThis can be useful when you've defined CSS transitions / animations using Vue's transition class conventions and want to switch between them.\nYou can also apply different behavior in JavaScript transition hooks based on the current state of your component. Finally, the ultimate way of creating dynamic transitions is through\nreusable transition components\nthat accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.\nTransitions with the Key Attribute\n\u200b\nSometimes you need to force the re-render of a DOM element in order for a transition to occur.\nTake this counter component for example:\nvue\n<\nscript\nsetup\n>\nimport\n{ ref }\nfrom\n'vue'\n;\nconst\ncount\n=\nref\n(\n0\n);\nsetInterval\n(()\n=>\ncount.value\n++\n,\n1000\n);\n</\nscript\n>\n<\ntemplate\n>\n<\nTransition\n>\n<\nspan\n:key\n=\n\"count\"\n>{{ count }}</\nspan\n>\n</\nTransition\n>\n</\ntemplate\n>\nvue\n<\nscript\n>\nexport\ndefault\n{\ndata\n() {\nreturn\n{\ncount:\n1\n,\ninterval:\nnull\n}\n},\nmounted\n() {\nthis\n.interval\n=\nsetInterval\n(()\n=>\n{\nthis\n.count\n++\n;\n},\n1000\n)\n},\nbeforeDestroy\n() {\nclearInterval\n(\nthis\n.interval)\n}\n}\n</\nscript\n>\n<\ntemplate\n>\n<\nTransition\n>\n<\nspan\n:key\n=\n\"count\"\n>{{ count }}</\nspan\n>\n</\nTransition\n>\n</\ntemplate\n>\nIf we had excluded the\nkey\nattribute, only the text node would be updated and thus no transition would occur. However, with the\nkey\nattribute in place, Vue knows to create a new\nspan\nelement whenever\ncount\nchanges and thus the\nTransition\ncomponent has 2 different elements to transition between.\nTry it in the Playground\nTry it in the Playground\nRelated\n<Transition>\nAPI reference\nEdit this page on GitHub",
  "content_markdown": "# Transition [\u200b](#transition)\n\nVue offers two built-in components that can help work with transitions and animations in response to changing state:\n\n- `<Transition>` for applying animations when an element or component is entering and leaving the DOM. This is covered on this page.\n- `<TransitionGroup>` for applying animations when an element or component is inserted into, removed from, or moved within a `v-for` list. This is covered in [the next chapter](/guide/built-ins/transition-group).\n\nAside from these two components, we can also apply animations in Vue using other techniques such as toggling CSS classes or state-driven animations via style bindings. These additional techniques are covered in the [Animation Techniques](/guide/extras/animation) chapter.\n\n## The `<Transition>` Component [\u200b](#the-transition-component)\n\n`<Transition>` is a built-in component: this means it is available in any component's template without having to register it. It can be used to apply enter and leave animations on elements or components passed to it via its default slot. The enter or leave can be triggered by one of the following:\n\n- Conditional rendering via `v-if`\n- Conditional display via `v-show`\n- Dynamic components toggling via the `<component>` special element\n- Changing the special `key` attribute\n\nThis is an example of the most basic usage:\n\ntemplate\n\n```\n<button @click=\"show = !show\">Toggle</button>\n<Transition>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\ncss\n\n```\n/* we will explain what these classes do next! */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\nToggle Fade\n\nhello\n\n[Try it in the Playground](https://play.vuejs.org/#eNpVkEFuwyAQRa8yZZNWqu1sunFJ1N4hSzYUjRNUDAjGVJHluxcCipIV/OG/pxEr+/a+TwuykfGogvYEEWnxR2H17F0gWCHgBBtMwc2wy9WdsMIqZ2OuXtwfHErhlcKCb8LyoVoynwPh7I0kzAmA/yxEzsKXMlr9HgRr9Es5BTue3PlskA+1VpFTkDZq0i3niYfU6anRmbqgMY4PZeH8OjwBfHhYIMdIV1OuferQEoZOKtIJ328TgzJhm8BabHR3jeC8VJqusO8/IqCM+CnsVqR3V/mfRxO5amnkCPuK5B+6rcG2fydshks=)\n\n[Try it in the Playground](https://play.vuejs.org/#eNpVkMFuAiEQhl9lyqlNuouXXrZo2nfwuBeKs0qKQGBAjfHdZZfVrAmB+f/M/2WGK/v1vs0JWcdEVEF72vQWz94Fgh0OMhmCa28BdpLk+0etAQJSCvahAOLBnTqgkLA6t/EpVzmCP7lFEB69kYRFAYi/ROQs/Cij1f+6ZyMG1vA2vj3bbN1+b1Dw2lYj2yBt1KRnXRwPudHDnC6pAxrjBPe1n78EBF8MUGSkixnLNjdoCUMjFemMn5NjUGacnboqPVkdOC+Vpgus2q8IKCN+T+suWENwxyWJXKXMyQ5WNVJ+aBqD3e6VSYoi)\n\nTIP\n\n`<Transition>` only supports a single element or component as its slot content. If the content is a component, the component must also have only one single root element.\n\nWhen an element in a `<Transition>` component is inserted or removed, this is what happens:\n\n1. Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, a number of [CSS transition classes](#transition-classes) will be added / removed at appropriate timings.\n2. If there are listeners for [JavaScript hooks](#javascript-hooks), these hooks will be called at appropriate timings.\n3. If no CSS transitions / animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed on the browser's next animation frame.\n\n## CSS-Based Transitions [\u200b](#css-based-transitions)\n\n### Transition Classes [\u200b](#transition-classes)\n\nThere are six classes applied for enter / leave transitions.\n\n![Transition Diagram](/assets/transition-classes.DYG5-69l.png)\n\n1. `v-enter-from`: Starting state for enter. Added before the element is inserted, removed one frame after the element is inserted.\n2. `v-enter-active`: Active state for enter. Applied during the entire entering phase. Added before the element is inserted, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.\n3. `v-enter-to`: Ending state for enter. Added one frame after the element is inserted (at the same time `v-enter-from` is removed), removed when the transition/animation finishes.\n4. `v-leave-from`: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.\n5. `v-leave-active`: Active state for leave. Applied during the entire leaving phase. Added immediately when a leaving transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.\n6. `v-leave-to`: Ending state for leave. Added one frame after a leaving transition is triggered (at the same time `v-leave-from` is removed), removed when the transition/animation finishes.\n\n`v-enter-active` and `v-leave-active` give us the ability to specify different easing curves for enter / leave transitions, which we'll see an example of in the following sections.\n\n### Named Transitions [\u200b](#named-transitions)\n\nA transition can be named via the `name` prop:\n\ntemplate\n\n```\n<Transition name=\"fade\">\n  ...\n</Transition>\n```\n\nFor a named transition, its transition classes will be prefixed with its name instead of `v`. For example, the applied class for the above transition will be `fade-enter-active` instead of `v-enter-active`. The CSS for the fade transition should look like this:\n\ncss\n\n```\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n```\n\n### CSS Transitions [\u200b](#css-transitions)\n\n`<Transition>` is most commonly used in combination with [native CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions), as seen in the basic example above. The `transition` CSS property is a shorthand that allows us to specify multiple aspects of a transition, including properties that should be animated, duration of the transition, and [easing curves](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function).\n\nHere is a more advanced example that transitions multiple properties, with different durations and easing curves for enter and leave:\n\ntemplate\n\n```\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\ncss\n\n```\n/*\n  Enter and leave animations can use different\n  durations and timing functions.\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n\nToggle Slide + Fade\n\nhello\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkc9uwjAMxl/F6wXQKIVNk1AX0HbZC4zDDr2E4EK0NIkStxtDvPviFQ0OSFzyx/m+n+34kL16P+lazMpMRBW0J4hIrV9WVjfeBYIDBKzhCHVwDQySdFDZyipnY5Lu3BcsWDCk0OKosqLoKcmfLoSNN5KQbyTWLZGz8KKMVp+LKju573ivsuXKbbcG4d3oDcI9vMkNiqL3JD+AWAVpoyadGFY2yATW5nVSJj9rkspDl+v6hE/hHRrjRMEdpdfiDEkBUVxWaEWkveHj5AzO0RKGXCrSHcKBIfSPKEEaA9PJYwSUEXPX0nNlj8y6RBiUHd5AzCOodq1VvsYfjWE4G6fgEy/zMcxG17B9ZTyX8bV85C5y1S40ZX/kdj+GD1P/zVQA56XStC9h2idJI/z7huz4CxoVvE4=)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqFkc1uwjAMgF/F6wk0SmHTJNQFtF32AuOwQy+hdSFamkSJ08EQ776EbMAkJKTIf7I/O/Y+ezVm3HvMyoy52gpDi0rh1mhL0GDLvSTYVwqg4cQHw2QDWCRv1Z8H4Db6qwSyHlPkEFUQ4bHixA0OYWckJ4wesZUn0gpeainqz3mVRQzM4S7qKlss9XotEd6laBDu4Y03yIpUE+oB2NJy5QSJwFC8w0iIuXkbMkN9moUZ6HPR/uJDeINSalaYxCjOkBBgxeWEijnayWiOz+AcFaHNeU2ix7QCOiFK4FLCZPzoALnDXHt6Pq7hP0Ii7/EGYuag9itR5yv8FmgH01EIPkUxG8F0eA2bJmut7kbX+pG+6NVq28WTBTN+92PwMDHbSAXQhteCdiVMUpNwwuMassMP8kfAJQ==)\n\n### CSS Animations [\u200b](#css-animations)\n\n[Native CSS animations](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations) are applied in the same way as CSS transitions, with the difference being that `*-enter-from` is not removed immediately after the element is inserted, but on an `animationend` event.\n\nFor most CSS animations, we can simply declare them under the `*-enter-active` and `*-leave-active` classes. Here's an example:\n\ntemplate\n\n```\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    Hello here is some bouncy text!\n  </p>\n</Transition>\n```\n\ncss\n\n```\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n\nToggle\n\nHello here is some bouncy text!\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNksGOgjAQhl9lJNmoBwRNvCAa97YP4JFLbQZsLG3TDqzG+O47BaOezCYkpfB9/0wHbsm3c4u+w6RIyiC9cgQBqXO7yqjWWU9wA4813KH2toUpo9PKVEZaExg92V/YRmBGvsN5ZcpsTGGfN4St04Iw7qg8dkTWwF5qJc/bKnnYk7hWye5gm0ZjmY0YKwDlwQsTFCnWjGiRpaPtjETG43smHPSpqh9pVQKBrjpyrfCNMilZV8Aqd5cNEF4oFVo1pgCJhtBvnjEAP6i1hRN6BBUg2BZhKHUdvMmjWhYHE9dXY/ygzN4PasqhB75djM2mQ7FUSFI9wi0GCJ6uiHYxVsFUGcgX67CpzP0lahQ9/k/kj9CjDzgG7M94rT1PLLxhQ0D+Na4AFI9QW98WEKTQOMvnLAOwDrD+wC0Xq/Ubusw/sU+QL/45hskk9z8Bddbn)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUs2OwiAQfpWxySZ66I8mXioa97YP4LEXrNNKpEBg2tUY330pqOvJmBBgyPczP1yTb2OyocekTJirrTC0qRSejbYEB2x4LwmulQI4cOLTWbwDWKTeqkcE4I76twSyPcaX23j4zS+WP3V9QNgZyQnHiNi+J9IKtrUU9WldJaMMrGEynlWy2em2lcjyCPMUALazXDlBwtMU79CT9rpXNXp4tGYGhlQ0d7UqAUcXOeI6bluhUtKmhEVhzisgPFPKpWhVCTUqQrt6ygD8oJQajmgRhAOnO4RgdQm8yd0tNzGv/D8x/8Dy10IVCzn4axaTTYNZymsSA8YuciU6PrLL6IKpUFBkS7cKXXwQJfIBPyP6IQ1oHUaB7QkvjfUdcy+wIFB8PeZIYwmNtl0JruYSp8XMk+/TXL7BzbPF8gU6L95hn8D4OUJnktsfM1vavg==)\n\n### Custom Transition Classes [\u200b](#custom-transition-classes)\n\nYou can also specify custom transition classes by passing the following props to `<Transition>`:\n\n- `enter-from-class`\n- `enter-active-class`\n- `enter-to-class`\n- `leave-from-class`\n- `leave-active-class`\n- `leave-to-class`\n\nThese will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as [Animate.css](https://daneden.github.io/animate.css/):\n\ntemplate\n\n```\n<!-- assuming Animate.css is included on the page -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUctuwjAQ/BXXF9oDsZB6ogbRL6hUcbSEjLMhpn7JXtNWiH/vhqS0R3zxPmbWM+szf02pOVXgSy6LyTYhK4A1rVWwPsWM7MwydOzCuhw9mxF0poIKJoZC0D5+stUAeMRc4UkFKcYpxKcEwSenEYYM5b4ixsA2xlnzsVJ8Yj8Mt+LrbTwcHEgxwojCmNxmHYpFG2kaoxO0B2KaWjD6uXG6FCiKj00ICHmuDdoTjD2CavJBCna7KWjZrYK61b9cB5pI93P3sQYDbxXf7aHHccpVMolO7DS33WSQjPXgXJRi2Cl1xZ8nKkjxf0dBFvx2Q7iZtq94j5jKUgjThmNpjIu17ZzO0JjohT7qL+HsvohJWWNKEc/NolncKt6Goar4y/V7rg/wyw9zrLOy)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNUcFuwjAM/RUvp+1Ao0k7sYDYF0yaOFZCJjU0LE2ixGFMiH9f2gDbcVKU2M9+tl98Fm8hNMdMYi5U0tEEXraOTsFHho52mC3DuXUAHTI+PlUbIBLn6G4eQOr91xw4ZqrIZXzKVY6S97rFYRqCRabRY7XNzN7BSlujPxetGMvAAh7GtxXLtd/vLSlZ0woFQK0jumTY+FJt7ORwoMLUObEfZtpiSpRaUYPkmOIMNZsj1VhJRWeGMsFmczU6uCOMHd64lrCQ/s/d+uw0vWf+MPuea5Vp5DJ0gOPM7K4Ci7CerPVKhipJ/moqgJJ//8ipxN92NFdmmLbSip45pLmUunOH1Gjrc7ezGKnRfpB4wJO0ZpvkdbJGpyRfmufm+Y4Mxo1oK16n9UwNxOUHwaK3iQ==)\n\n### Using Transitions and Animations Together [\u200b](#using-transitions-and-animations-together)\n\nVue needs to attach event listeners in order to know when a transition has ended. It can either be `transitionend` or `animationend`, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.\n\nHowever, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about by passing the `type` prop, with a value of either `animation` or `transition`:\n\ntemplate\n\n```\n<Transition type=\"animation\">...</Transition>\n```\n\n### Nested Transitions and Explicit Transition Durations [\u200b](#nested-transitions-and-explicit-transition-durations)\n\nAlthough the transition classes are only applied to the direct child element in `<Transition>`, we can transition nested elements using nested CSS selectors:\n\ntemplate\n\n```\n<Transition name=\"nested\">\n  <div v-if=\"show\" class=\"outer\">\n    <div class=\"inner\">\n      Hello\n    </div>\n  </div>\n</Transition>\n```\n\ncss\n\n```\n/* rules that target nested elements */\n.nested-enter-active .inner,\n.nested-leave-active .inner {\n  transition: all 0.3s ease-in-out;\n}\n\n.nested-enter-from .inner,\n.nested-leave-to .inner {\n  transform: translateX(30px);\n  opacity: 0;\n}\n\n/* ... other necessary CSS omitted */\n```\n\nWe can even add a transition delay to the nested element on enter, which creates a staggered enter animation sequence:\n\ncss\n\n```\n/* delay enter of nested element for staggered effect */\n.nested-enter-active .inner {\n  transition-delay: 0.25s;\n}\n```\n\nHowever, this creates a small issue. By default, the `<Transition>` component attempts to automatically figure out when the transition has finished by listening to the **first** `transitionend` or `animationend` event on the root transition element. With a nested transition, the desired behavior should be waiting until the transitions of all inner elements have finished.\n\nIn such cases you can specify an explicit transition duration (in milliseconds) using the `duration` prop on the `<Transition>` component. The total duration should match the delay plus transition duration of the inner element:\n\ntemplate\n\n```\n<Transition :duration=\"550\">...</Transition>\n```\n\nToggle\n\nHello\n\n[Try it in the Playground](https://play.vuejs.org/#eNqVVd9v0zAQ/leO8LAfrE3HNKSFbgKmSYMHQNAHkPLiOtfEm2NHttN2mvq/c7bTNi1jgFop9t13d9995ziPyfumGc5bTLJkbLkRjQOLrm2uciXqRhsHj2BwBiuYGV3DAUEPcpUrrpUlaKUXcOkBh860eJSrcRqzUDxtHNaNZA5pBzCets5pBe+4FPz+Mk+66Bf+mSdXE12WEsdphMWQiWHKCicoLCtaw/yKIs/PR3kCitVIG4XWYUEJfATFFGIO84GYdRUIyCWzlra6dWg2wA66dgqlts7c+d8tSqk34JTQ6xqb9TjdUiTDOO21TFvrHqRfDkPpExiGKvBITjdl/L40ulVFBi8R8a3P17CiEKrM4GzULIOlFmpQoSgrl8HpKFpX3kFZu2y0BNhJxznvwaJCA1TEYcC4E3MkKp1VIptjZ43E3KajDJiUMBqeWUBmcUBUqJGYOT2GAiV7gJAA9Iy4GyoBKLH2z+N0W3q/CMC2yCCkyajM63Mbc+9z9mfvZD+b071MM23qLC69+j8PvX5HQUDdMC6cL7BOTtQXCJwpas/qHhWIBdYtWGgtDWNttWTmThu701pf1W6+v1Hd8Xbz+k+VQxmv8i7Fv1HZn+g/iv2nRkjzbd6npf/Rkz49DifQ3dLZBBYOJzC4rqgCwsUbmLYlCAUVU4XsCd1NrCeRHcYXb1IJC/RX2hEYCwJTvHYVMZoavbBI09FmU+LiFSzIh0AIXy1mqZiFKaKCmVhiEVJ7GftHZTganUZ56EYLL3FykjhL195MlMM7qxXdmEGDPOG6boRE86UJVPMki+p4H01WLz4Fm78hSdBo5xXy+yfsd3bpbXny1SA1M8c82fgcMyW66L75/hmXtN44a120ktDPOL+h1bL1HCPsA42DaPdwge3HcO/TOCb2ZumQJtA15Yl65Crg84S+BdfPtL6lezY8C3GkZ7L6Bc1zNR0=)\n\nIf necessary, you can also specify separate values for enter and leave durations using an object:\n\ntemplate\n\n```\n<Transition :duration=\"{ enter: 500, leave: 800 }\">...</Transition>\n```\n\n### Performance Considerations [\u200b](#performance-considerations)\n\nYou may notice that the animations shown above are mostly using properties like `transform` and `opacity`. These properties are efficient to animate because:\n\n1. They do not affect the document layout during the animation, so they do not trigger expensive CSS layout calculation on every animation frame.\n2. Most modern browsers can leverage GPU hardware acceleration when animating `transform`.\n\nIn comparison, properties like `height` or `margin` will trigger CSS layout, so they are much more expensive to animate, and should be used with caution.\n\n## JavaScript Hooks [\u200b](#javascript-hooks)\n\nYou can hook into the transition process with JavaScript by listening to events on the `<Transition>` component:\n\ntemplate\n\n```\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\n```\n\njs\n\n```\n// called before the element is inserted into the DOM.\n// use this to set the \"enter-from\" state of the element\nfunction onBeforeEnter(el) {}\n\n// called one frame after the element is inserted.\n// use this to start the entering animation.\nfunction onEnter(el, done) {\n  // call the done callback to indicate transition end\n  // optional if used in combination with CSS\n  done()\n}\n\n// called when the enter transition has finished.\nfunction onAfterEnter(el) {}\n\n// called when the enter transition is cancelled before completion.\nfunction onEnterCancelled(el) {}\n\n// called before the leave hook.\n// Most of the time, you should just use the leave hook\nfunction onBeforeLeave(el) {}\n\n// called when the leave transition starts.\n// use this to start the leaving animation.\nfunction onLeave(el, done) {\n  // call the done callback to indicate transition end\n  // optional if used in combination with CSS\n  done()\n}\n\n// called when the leave transition has finished and the\n// element has been removed from the DOM.\nfunction onAfterLeave(el) {}\n\n// only available with v-show transitions\nfunction onLeaveCancelled(el) {}\n```\n\njs\n\n```\nexport default {\n  // ...\n  methods: {\n    // called before the element is inserted into the DOM.\n    // use this to set the \"enter-from\" state of the element\n    onBeforeEnter(el) {},\n\n    // called one frame after the element is inserted.\n    // use this to start the animation.\n    onEnter(el, done) {\n      // call the done callback to indicate transition end\n      // optional if used in combination with CSS\n      done()\n    },\n\n    // called when the enter transition has finished.\n    onAfterEnter(el) {},\n\n    // called when the enter transition is cancelled before completion.\n    onEnterCancelled(el) {},\n\n    // called before the leave hook.\n    // Most of the time, you should just use the leave hook.\n    onBeforeLeave(el) {},\n\n    // called when the leave transition starts.\n    // use this to start the leaving animation.\n    onLeave(el, done) {\n      // call the done callback to indicate transition end\n      // optional if used in combination with CSS\n      done()\n    },\n\n    // called when the leave transition has finished and the\n    // element has been removed from the DOM.\n    onAfterLeave(el) {},\n\n    // only available with v-show transitions\n    onLeaveCancelled(el) {}\n  }\n}\n```\n\nThese hooks can be used in combination with CSS transitions / animations or on their own.\n\nWhen using JavaScript-only transitions, it is usually a good idea to add the `:css=\"false\"` prop. This explicitly tells Vue to skip auto CSS transition detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition:\n\ntemplate\n\n```\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n```\n\nWith `:css=\"false\"`, we are also fully responsible for controlling when the transition ends. In this case, the `done` callbacks are required for the `@enter` and `@leave` hooks. Otherwise, the hooks will be called synchronously and the transition will finish immediately.\n\nHere's a demo using the [GSAP library](https://gsap.com/) to perform the animations. You can, of course, use any other animation library you want, for example [Anime.js](https://animejs.com/) or [Motion One](https://motion.dev/):\n\nToggle\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNVMtu2zAQ/JUti8I2YD3i1GigKmnaorcCveTQArpQFCWzlkiCpBwHhv+9Sz1qKYckJ3FnlzvD2YVO5KvW4aHlJCGpZUZoB5a7Vt9lUjRaGQcnMLyEM5RGNbDA0sX/VGWpHnB/xEQmmZIWe+zUI9z6m0tnWr7ymbKVzAklQclvvFSG/5COmyWvV3DKJHTdQiRHZN0jAJbRmv9OIA432/UE+jODlKZMuKcErnx8RrazP8woR7I1FEryKaVTU8aiNdRfwWZTQtQwi1HAGF/YB4BTyxNY8JpaJ1go5K/WLTfhdg1Xq8V4SX5Xja65w0ovaCJ8Jvsnpwc+l525F2XH4ac3Cj8mcB3HbxE9qnvFMRzJ0K3APuhIjPefmTTyvWBAGvWbiDuIgeNYRh3HCCDNW+fQmHtWC7a/zciwaO/8NyN3D6qqap5GfVnXAC89GCqt8Bp77vu827+A+53AJrOFzMhQdMnO8dqPpMO74Yx4wqxFtKS1HbBOMdIX4gAMffVp71+Qq2NG4BCIcngBKk8jLOvfGF30IpBGEwcwtO6p9sdwbNXPIadsXxnVyiKB9x83+c3N9WePN9RUQgZO6QQ2sT524KMo3M5Pf4h3XFQ7NwFyZQpuAkML0doEtvEHhPvRDPRkTfq/QNDgRvy1SuIvpFOSDQmbkWTckf7hHsjIzjltkyhqpd5XIVNN5HNfGlW09eAcMp3J+R+pEn7L)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqNVFFvmzAQ/is3pimNlABNF61iaddt2tukvfRhk/xiwIAXsJF9pKmq/PedDTSwh7ZSFLjvzvd9/nz4KfjatuGhE0ES7GxmZIu3TMmm1QahtLyFwugGFu51wRQAU+Lok7koeFcjPDk058gvlv07gBHYGTVGALbSDwmg6USPnNzjtHL/jcBK5zZxxQwZavVNFNqIHwqF8RUAWs2jn4IffCfqQz+mik5lKLWi3GT1hagHRU58aAUSshpV2YzX4ncCcbjZDp099GcG6ZZnEh8TuPR8S0/oTJhQjmQryLUSU0rUU8a8M9wtoWZTQtIwi0nAGJ/ZB0BwKxJYiJpblFko1a8OLzbhdgWXy8WzP99109YCqdIJmgifyfYuzmUzfFF2HH56o/BjAldx/BbRo7pXHKMjGbrl1IcciWn9fyaNfC8YsIueR5wCFFTGUVAEsEs7pOmDu6yW2f6GBW5o4QbeuScLbu91WdZiF/VlvgEtujdcWek09tx3qZ+/tXAzQU1mA8mCoeicneO1OxKP9yM+4ElmLaEFr+2AecVEn8sDZOSrSzv/1qk+sgAOa1kMOyDlu4jK+j1GZ70E7KKJAxRafKzdazi26s8h5dm+NLpTeQLvP27S6+urz/7T5aaUao26TWATt0cPPsgcK3f6Q1wJWVY4AVJtcmHWhueyo89+G38guD+agT5YBf39s25oIv5arehu8krYkLAs8BeG86DfuANYUCG2NomiTrX7Msx0E7ncl0bnXT04566M4PQPykWaWw==)\n\n## Reusable Transitions [\u200b](#reusable-transitions)\n\nTransitions can be reused through Vue's component system. To create a reusable transition, we can create a component that wraps the `<Transition>` component and passes down the slot content:\n\nMyTransition.vue\n\nvue\n\n```\n<script>\n// JavaScript hooks logic...\n</script>\n\n<template>\n  <!-- wrap the built-in Transition component -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- pass down slot content -->\n  </Transition>\n</template>\n\n<style>\n/*\n  Necessary CSS...\n  Note: avoid using <style scoped> here since it\n  does not apply to slot content.\n*/\n</style>\n```\n\nNow `MyTransition` can be imported and used just like the built-in version:\n\ntemplate\n\n```\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\n```\n\n## Transition on Appear [\u200b](#transition-on-appear)\n\nIf you also want to apply a transition on the initial render of a node, you can add the `appear` prop:\n\ntemplate\n\n```\n<Transition appear>\n  ...\n</Transition>\n```\n\n## Transition Between Elements [\u200b](#transition-between-elements)\n\nIn addition to toggling an element with `v-if` / `v-show`, we can also transition between two elements using `v-if` / `v-else` / `v-else-if`, as long as we make sure that there is only one element being shown at any given moment:\n\ntemplate\n\n```\n<Transition>\n  <button v-if=\"docState === 'saved'\">Edit</button>\n  <button v-else-if=\"docState === 'edited'\">Save</button>\n  <button v-else-if=\"docState === 'editing'\">Cancel</button>\n</Transition>\n```\n\nClick to cycle through states:\n\nEdit\n\n[Try it in the Playground](https://play.vuejs.org/#eNqdk8tu2zAQRX9loI0SoLLcFN2ostEi6BekmwLa0NTYJkKRBDkSYhj+9wxJO3ZegBGu+Lhz7syQ3Bd/nJtNIxZN0QbplSMISKNbdkYNznqCPXhcwwHW3g5QsrTsTGekNYGgt/KBBCEsouimDGLCvrztTFtnGGN4QTg4zbK4ojY4YSDQTuOiKwbhN8pUXm221MDd3D11xfJeK/kIZEHupEagrbfjZssxzAgNs5nALIC2VxNILUJg1IpMxWmRUAY9U6IZ2/3zwgRFyhowYoieQaseq9ElDaTRrkYiVkyVWrPiXNdiAcequuIkPo3fMub5Sg4l9oqSevmXZ22dwR8YoQ74kdsL4Go7ZTbR74HT/KJfJlxleGrG8l4YifqNYVuf251vqOYr4llbXz4C06b75+ns1a3BPsb0KrBy14Aymnerlbby8Vc8cTajG35uzFITpu0t5ufzHQdeH6LBsezEO0eJVbB6pBiVVLPTU6jQEPpKyMj8dnmgkQs+HmQcvVTIQK1hPrv7GQAFt9eO9Bk6fZ8Ub52Qiri8eUo+4dbWD02exh79v/nBP+H2PStnwz/jelJ1geKvk/peHJ4BoRZYow==)\n\n## Transition Modes [\u200b](#transition-modes)\n\nIn the previous example, the entering and leaving elements are animated at the same time, and we had to make them `position: absolute` to avoid the layout issue when both elements are present in the DOM.\n\nHowever, in some cases this isn't an option, or simply isn't the desired behavior. We may want the leaving element to be animated out first, and for the entering element to only be inserted **after** the leaving animation has finished. Orchestrating such animations manually would be very complicated - luckily, we can enable this behavior by passing `<Transition>` a `mode` prop:\n\ntemplate\n\n```\n<Transition mode=\"out-in\">\n  ...\n</Transition>\n```\n\nHere's the previous demo with `mode=\"out-in\"`:\n\nClick to cycle through states:\n\nEdit\n\n`<Transition>` also supports `mode=\"in-out\"`, although it's much less frequently used.\n\n## Transition Between Components [\u200b](#transition-between-components)\n\n`<Transition>` can also be used around [dynamic components](/guide/essentials/component-basics#dynamic-components):\n\ntemplate\n\n```\n<Transition name=\"fade\" mode=\"out-in\">\n  <component :is=\"activeComponent\"></component>\n</Transition>\n```\n\nA  B \n\nComponent A\n\n[Try it in the Playground](https://play.vuejs.org/#eNqtksFugzAMhl/F4tJNKtDLLoxWKnuDacdcUnC3SCGJiMmEqr77EkgLbXfYYZyI8/v77dinZG9M5npMiqS0dScMgUXqzY4p0RrdEZzAfnEp9fc7HuEMx063sPIZq6viTbdmHy+yfDwF5K2guhFUUcBUnkNvcelBGrjTooHaC7VCRXBAoT6hQTRyAH2w2DlsmKq1sgS8JuEwUCfxdgF7Gqt5ZqrMp+58X/5A2BrJCcOJSskPKP0v+K8UyvQENBjcsqTjjdAsAZe2ukHpI3dm/q5wXPZBPFqxZAf7gCrzGfufDlVwqB4cPjqurCChFSjeBvGRN+iTA9afdE+pUD43FjG/bSHsb667Mr9qJot89vCBMl8+oiotDTL8ZsE39UnYpRN0fQlK5A5jEE6BSVdiAdrwWtAAm+zFAnKLr0ydA3pJDDt0x/PrMrJifgGbKdFPfCwpWU+TuWz5omzfVCNcfJJ5geL8pqtFn5E07u7fSHFOj6TzDyUDNEM=)\n\n[Try it in the Playground](https://play.vuejs.org/#eNqtks9ugzAMxl/F4tJNamGXXVhWqewVduSSgStFCkkUDFpV9d0XJyn9t8MOkxBg5/Pvi+Mci51z5TxhURdi7LxytG2NGpz1BB92cDvYezvAqqxixNLVjaC5ETRZ0Br8jpIe93LSBMfWAHRBYQ0aGms4Jvw6Q05rFvSS5NNzEgN4pMmbcwQgO1Izsj5CalhFRLDj1RN/wis8olpaCQHh4LQk5IiEll+owy+XCGXcREAHh+9t4WWvbFvAvBlsjzpk7gx5TeqJtdG4LbawY5KoLtR/NGjYoHkw+PTSjIqUNWDkwOK97DHUMjVEdqKNMqE272E5dajV+JvpVlSLJllUF4+QENX1ERox0kHzb8m+m1CEfpOgYYgpqVHOmJNpgLQQa7BOdooO8FK+joByxLc4tlsiX6s7HtnEyvU1vKTCMO+4pWKdBnO+0FfbDk31as5HsvR+Hl9auuozk+J1/hspz+mRdPoBYtonzg==)\n\n## Dynamic Transitions [\u200b](#dynamic-transitions)\n\n`<Transition>` props like `name` can also be dynamic! It allows us to dynamically apply different transitions based on state change:\n\ntemplate\n\n```\n<Transition :name=\"transitionName\">\n  <!-- ... -->\n</Transition>\n```\n\nThis can be useful when you've defined CSS transitions / animations using Vue's transition class conventions and want to switch between them.\n\nYou can also apply different behavior in JavaScript transition hooks based on the current state of your component. Finally, the ultimate way of creating dynamic transitions is through [reusable transition components](#reusable-transitions) that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.\n\n## Transitions with the Key Attribute [\u200b](#transitions-with-the-key-attribute)\n\nSometimes you need to force the re-render of a DOM element in order for a transition to occur.\n\nTake this counter component for example:\n\nvue\n\n```\n<script setup>\nimport { ref } from 'vue';\nconst count = ref(0);\n\nsetInterval(() => count.value++, 1000);\n</script>\n\n<template>\n  <Transition>\n    <span :key=\"count\">{{ count }}</span>\n  </Transition>\n</template>\n```\n\nvue\n\n```\n<script>\nexport default {\n  data() {\n    return {\n      count: 1,\n      interval: null \n    }\n  },\n  mounted() {\n    this.interval = setInterval(() => {\n      this.count++;\n    }, 1000)\n  },\n  beforeDestroy() {\n    clearInterval(this.interval)\n  }\n}\n</script>\n\n<template>\n  <Transition>\n    <span :key=\"count\">{{ count }}</span>\n  </Transition>\n</template>\n```\n\nIf we had excluded the `key` attribute, only the text node would be updated and thus no transition would occur. However, with the `key` attribute in place, Vue knows to create a new `span` element whenever `count` changes and thus the `Transition` component has 2 different elements to transition between.\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9UsFu2zAM/RVCl6Zo4nhYd/GcAtvQQ3fYhq1HXTSFydTKkiDJbjLD/z5KMrKgLXoTHx/5+CiO7JNz1dAja1gbpFcuQsDYuxtuVOesjzCCxx1MsPO2gwuiXnzkhhtpTYggbW8ibBJlUV/mBJXfmYh+EHqxuITNDYzcQGFWBPZ4dUXEaQnv6jrXtOuiTJoUROycFhEpAmi3agCpRQgbzp68cA49ZyV174UJKiprckxIcMJA84hHImc9oo7jPOQ0kQ4RSvH6WXW7JiV6teszfQpDPGqEIK3DLSGpQbazsyaugvqLDVx77JIhbqp5wsxwtrRvPFI7NWDhEGtYYVrQSsgELzOiUQw4I2Vh8TRgA9YJqeIR6upDABQh9TpTAPE7WN3HlxLp084Foi3N54YN1KWEVpOMkkO2ZJHsmp3aVw/BGjqMXJE22jml0X93STRw1pReKSe0tk9fMxZ9nzwVXP5B+fgK/hAOCePsh8dAt4KcnXJR+D3S16X07a9veKD3KdnZba+J/UbyJ+Zl0IyF9rk3Wxr7jJenvcvnrcz+PtweItKuZ1Np0MScMp8zOvkvb1j/P+776jrX0UbZ9A+fYSTP)\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9U8tu2zAQ/JUFTwkSyw6aXlQ7QB85pIe2aHPUhZHWDhOKJMiVYtfwv3dJSpbbBgEMWJydndkdUXvx0bmi71CUYhlqrxzdVAa3znqCBtey0wT7ygA0kuTZeX4G8EidN+MJoLadoRKuLkdAGULfS12C6bSGDB/i3yFx2tiAzaRIjyoUYxesICDdDaczZq1uJrNETY4XFx8G5Uu4WiwW55PBA66txy8YyNvdZFNrlP4o/Jdpbq4M/5bzYxZ8IGydloR8Alg2qmcVGcKqEi9eOoe+EqnExXsvTVCkrBkQxoKTBspn3HFDmprp+32ODA4H9mLCKDD/R2E5Zz9+Ws5PpuBjoJ1GCLV12DASJdKGa2toFtRvLOHaY8vx8DrFMGdiOJvlS48sp3rMHGb1M4xRzGQdYU6REY6rxwHJGdJxwBKsk7WiHSyK9wFQhqh14gDyIVjd0f8Wa2/bUwOyWXwQLGGRWzicuChvKC4F8bpmrTbFU7CGL2zqiJm2Tmn03100DZUox5ddCam1ffmaMPJd3Cnj9SPWz6/gT2EbsUr88Bj4VmAljjWSfoP88mL59tc33PLzsdjaptPMfqP4E1MYPGOmfepMw2Of8NK0d238+JTZ3IfbLSFnPSwVB53udyX4q/38xurTuO+K6/Fqi8MffqhR/A==)\n\n---\n\n**Related**\n\n- [`<Transition>` API reference](/api/built-in-components#transition)\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/built-ins/transition.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:11.452961+00:00",
  "content_length": 17891,
  "content_hash": "e889d79450cedce3"
}