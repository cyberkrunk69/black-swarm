{
  "id": "vue-patterns__guide_components_props_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/components/props.html",
  "title": "Props\u200b",
  "content": "Props\n\u200b\nThis page assumes you've already read the\nComponents Basics\n. Read that first if you are new to components.\nWatch a free video lesson on Vue School\nProps Declaration\n\u200b\nVue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in\nits dedicated section\n).\nIn SFCs using\n<script setup>\n, props can be declared using the\ndefineProps()\nmacro:\nvue\n<\nscript\nsetup\n>\nconst\nprops\n=\ndefineProps\n([\n'foo'\n])\nconsole.\nlog\n(props.foo)\n</\nscript\n>\nIn non-\n<script setup>\ncomponents, props are declared using the\nprops\noption:\njs\nexport\ndefault\n{\nprops: [\n'foo'\n],\nsetup\n(\nprops\n) {\n// setup() receives props as the first argument.\nconsole.\nlog\n(props.foo)\n}\n}\nNotice the argument passed to\ndefineProps()\nis the same as the value provided to the\nprops\noptions: the same props options API is shared between the two declaration styles.\nProps are declared using the\nprops\noption:\njs\nexport\ndefault\n{\nprops: [\n'foo'\n],\ncreated\n() {\n// props are exposed on `this`\nconsole.\nlog\n(\nthis\n.foo)\n}\n}\nIn addition to declaring props using an array of strings, we can also use the object syntax:\njs\nexport\ndefault\n{\nprops: {\ntitle: String,\nlikes: Number\n}\n}\njs\n// in <script setup>\ndefineProps\n({\ntitle: String,\nlikes: Number\n})\njs\n// in non-<script setup>\nexport\ndefault\n{\nprops: {\ntitle: String,\nlikes: Number\n}\n}\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about\nprop validation\nfurther down this page.\nSee also:\nTyping Component Props\nIf you are using TypeScript with\n<script setup>\n, it's also possible to declare props using pure type annotations:\nvue\n<\nscript\nsetup\nlang\n=\n\"ts\"\n>\ndefineProps\n<{\ntitle\n?:\nstring\nlikes\n?:\nnumber\n}>()\n</\nscript\n>\nMore details:\nTyping Component Props\nReactive Props Destructure\n\u200b\nVue's reactivity system tracks state usage based on property access. E.g. when you access\nprops.foo\nin a computed getter or a watcher, the\nfoo\nprop gets tracked as a dependency.\nSo, given the following code:\njs\nconst\n{\nfoo\n}\n=\ndefineProps\n([\n'foo'\n])\nwatchEffect\n(()\n=>\n{\n// runs only once before 3.5\n// re-runs when the \"foo\" prop changes in 3.5+\nconsole.\nlog\n(foo)\n})\nIn version 3.4 and below,\nfoo\nis an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends\nprops.\nwhen code in the same\n<script setup>\nblock accesses variables destructured from\ndefineProps\n. Therefore the code above becomes equivalent to the following:\njs\nconst\nprops\n=\ndefineProps\n([\n'foo'\n])\nwatchEffect\n(()\n=>\n{\n// `foo` transformed to `props.foo` by the compiler\nconsole.\nlog\n(props.foo)\n})\nIn addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:\nts\nconst\n{\nfoo\n=\n'hello'\n}\n=\ndefineProps\n<{\nfoo\n?:\nstring\n}>()\nIf you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props.\nPassing Destructured Props into Functions\n\u200b\nWhen we pass a destructured prop into a function, e.g.:\njs\nconst\n{\nfoo\n}\n=\ndefineProps\n([\n'foo'\n])\nwatch\n(foo,\n/* ... */\n)\nThis will not work as expected because it is equivalent to\nwatch(props.foo, ...)\n- we are passing a value instead of a reactive data source to\nwatch\n. In fact, Vue's compiler will catch such cases and throw a warning.\nSimilar to how we can watch a normal prop with\nwatch(() => props.foo, ...)\n, we can watch a destructured prop also by wrapping it in a getter:\njs\nwatch\n(()\n=>\nfoo,\n/* ... */\n)\nIn addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity:\njs\nuseComposable\n(()\n=>\nfoo)\nThe external function can call the getter (or normalize it with\ntoValue\n) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\nProp Passing Details\n\u200b\nProp Name Casing\n\u200b\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\njs\ndefineProps\n({\ngreetingMessage: String\n})\njs\nexport\ndefault\n{\nprops: {\ngreetingMessage: String\n}\n}\ntemplate\n<\nspan\n>{{ greetingMessage }}</\nspan\n>\nTechnically, you can also use camelCase when passing props to a child component (except in\nin-DOM templates\n). However, the convention is using kebab-case in all cases to align with HTML attributes:\ntemplate\n<\nMyComponent\ngreeting-message\n=\n\"hello\"\n/>\nWe use\nPascalCase for component tags\nwhen possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\nStatic vs. Dynamic Props\n\u200b\nSo far, you've seen props passed as static values, like in:\ntemplate\n<\nBlogPost\ntitle\n=\n\"My journey with Vue\"\n/>\nYou've also seen props assigned dynamically with\nv-bind\nor its\n:\nshortcut, such as in:\ntemplate\n<!-- Dynamically assign the value of a variable -->\n<\nBlogPost\n:\ntitle\n=\n\"\npost.title\n\"\n/>\n<!-- Dynamically assign the value of a complex expression -->\n<\nBlogPost\n:\ntitle\n=\n\"\npost.title\n+\n' by '\n+\npost.author.name\n\"\n/>\nPassing Different Value Types\n\u200b\nIn the two examples above, we happen to pass string values, but\nany\ntype of value can be passed to a prop.\nNumber\n\u200b\ntemplate\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<\nBlogPost\n:\nlikes\n=\n\"\n42\n\"\n/>\n<!-- Dynamically assign to the value of a variable. -->\n<\nBlogPost\n:\nlikes\n=\n\"\npost.likes\n\"\n/>\nBoolean\n\u200b\ntemplate\n<!-- Including the prop with no value will imply `true`. -->\n<\nBlogPost\nis-published\n/>\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<\nBlogPost\n:\nis-published\n=\n\"\nfalse\n\"\n/>\n<!-- Dynamically assign to the value of a variable. -->\n<\nBlogPost\n:\nis-published\n=\n\"\npost.isPublished\n\"\n/>\nArray\n\u200b\ntemplate\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<\nBlogPost\n:\ncomment-ids\n=\n\"\n[\n234\n,\n266\n,\n273\n]\n\"\n/>\n<!-- Dynamically assign to the value of a variable. -->\n<\nBlogPost\n:\ncomment-ids\n=\n\"\npost.commentIds\n\"\n/>\nObject\n\u200b\ntemplate\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<\nBlogPost\n:\nauthor\n=\n\"\n{\nname:\n'Veronica'\n,\ncompany:\n'Veridian Dynamics'\n}\n\"\n/>\n<!-- Dynamically assign to the value of a variable. -->\n<\nBlogPost\n:\nauthor\n=\n\"\npost.author\n\"\n/>\nBinding Multiple Properties Using an Object\n\u200b\nIf you want to pass all the properties of an object as props, you can use\nv-bind\nwithout an argument\n(\nv-bind\ninstead of\n:prop-name\n). For example, given a\npost\nobject:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\npost: {\nid:\n1\n,\ntitle:\n'My Journey with Vue'\n}\n}\n}\n}\njs\nconst\npost\n=\n{\nid:\n1\n,\ntitle:\n'My Journey with Vue'\n}\nThe following template:\ntemplate\n<\nBlogPost\nv-bind\n=\n\"\npost\n\"\n/>\nWill be equivalent to:\ntemplate\n<\nBlogPost\n:\nid\n=\n\"\npost.id\n\"\n:\ntitle\n=\n\"\npost.title\n\"\n/>\nOne-Way Data Flow\n\u200b\nAll props form a\none-way-down binding\nbetween the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should\nnot\nattempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\njs\nconst\nprops\n=\ndefineProps\n([\n'foo'\n])\n// \u274c warning, props are readonly!\nprops.foo\n=\n'bar'\njs\nexport\ndefault\n{\nprops: [\n'foo'\n],\ncreated\n() {\n// \u274c warning, props are readonly!\nthis\n.foo\n=\n'bar'\n}\n}\nThere are usually two cases where it's tempting to mutate a prop:\nThe prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.\nIn this case, it's best to define a local data property that uses the prop as its initial value:\njs\nconst\nprops\n=\ndefineProps\n([\n'initialCounter'\n])\n// counter only uses props.initialCounter as the initial value;\n// it is disconnected from future prop updates.\nconst\ncounter\n=\nref\n(props.initialCounter)\njs\nexport\ndefault\n{\nprops: [\n'initialCounter'\n],\ndata\n() {\nreturn\n{\n// counter only uses this.initialCounter as the initial value;\n// it is disconnected from future prop updates.\ncounter:\nthis\n.initialCounter\n}\n}\n}\nThe prop is passed in as a raw value that needs to be transformed.\nIn this case, it's best to define a computed property using the prop's value:\njs\nconst\nprops\n=\ndefineProps\n([\n'size'\n])\n// computed property that auto-updates when the prop changes\nconst\nnormalizedSize\n=\ncomputed\n(()\n=>\nprops.size.\ntrim\n().\ntoLowerCase\n())\njs\nexport\ndefault\n{\nprops: [\n'size'\n],\ncomputed: {\n// computed property that auto-updates when the prop changes\nnormalizedSize\n() {\nreturn\nthis\n.size.\ntrim\n().\ntoLowerCase\n()\n}\n}\n}\nMutating Object / Array Props\n\u200b\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it\nwill\nbe able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should\nemit an event\nto let the parent perform the mutation.\nProp Validation\n\u200b\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\nTo specify prop validations, you can provide an object with validation requirements to the\ndefineProps()\nmacro\nprops\noption\n, instead of an array of strings. For example:\njs\ndefineProps\n({\n// Basic type check\n//  (`null` and `undefined` values will allow any type)\npropA: Number,\n// Multiple possible types\npropB: [String, Number],\n// Required string\npropC: {\ntype: String,\nrequired:\ntrue\n},\n// Required but nullable string\npropD: {\ntype: [String,\nnull\n],\nrequired:\ntrue\n},\n// Number with a default value\npropE: {\ntype: Number,\ndefault:\n100\n},\n// Object with a default value\npropF: {\ntype: Object,\n// Object or array defaults must be returned from\n// a factory function. The function receives the raw\n// props received by the component as the argument.\ndefault\n(\nrawProps\n) {\nreturn\n{ message:\n'hello'\n}\n}\n},\n// Custom validator function\n// full props passed as 2nd argument in 3.4+\npropG: {\nvalidator\n(\nvalue\n,\nprops\n) {\n// The value must match one of these strings\nreturn\n[\n'success'\n,\n'warning'\n,\n'danger'\n].\nincludes\n(value)\n}\n},\n// Function with a default value\npropH: {\ntype: Function,\n// Unlike object or array default, this is not a factory\n// function - this is a function to serve as a default value\ndefault\n() {\nreturn\n'Default function'\n}\n}\n})\nTIP\nCode inside the\ndefineProps()\nargument\ncannot access other variables declared in\n<script setup>\n, because the entire expression is moved to an outer function scope when compiled.\njs\nexport\ndefault\n{\nprops: {\n// Basic type check\n//  (`null` and `undefined` values will allow any type)\npropA: Number,\n// Multiple possible types\npropB: [String, Number],\n// Required string\npropC: {\ntype: String,\nrequired:\ntrue\n},\n// Required but nullable string\npropD: {\ntype: [String,\nnull\n],\nrequired:\ntrue\n},\n// Number with a default value\npropE: {\ntype: Number,\ndefault:\n100\n},\n// Object with a default value\npropF: {\ntype: Object,\n// Object or array defaults must be returned from\n// a factory function. The function receives the raw\n// props received by the component as the argument.\ndefault\n(\nrawProps\n) {\nreturn\n{ message:\n'hello'\n}\n}\n},\n// Custom validator function\n// full props passed as 2nd argument in 3.4+\npropG: {\nvalidator\n(\nvalue\n,\nprops\n) {\n// The value must match one of these strings\nreturn\n[\n'success'\n,\n'warning'\n,\n'danger'\n].\nincludes\n(value)\n}\n},\n// Function with a default value\npropH: {\ntype: Function,\n// Unlike object or array default, this is not a factory\n// function - this is a function to serve as a default value\ndefault\n() {\nreturn\n'Default function'\n}\n}\n}\n}\nAdditional details:\nAll props are optional by default, unless\nrequired: true\nis specified.\nAn absent optional prop other than\nBoolean\nwill have\nundefined\nvalue.\nThe\nBoolean\nabsent props will be cast to\nfalse\n. You can change this by setting a\ndefault\nfor it \u2014 i.e.:\ndefault: undefined\nto behave as a non-Boolean prop.\nIf a\ndefault\nvalue is specified, it will be used if the resolved prop value is\nundefined\n- this includes both when the prop is absent, or an explicit\nundefined\nvalue is passed.\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\nIf using\nType-based props declarations\n, Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example,\ndefineProps<{ msg: string }>\nwill be compiled into\n{ msg: { type: String, required: true }}\n.\nNote\nNote that props are validated\nbefore\na component instance is created, so instance properties (e.g.\ndata\n,\ncomputed\n, etc.) will not be available inside\ndefault\nor\nvalidator\nfunctions.\nRuntime Type Checks\n\u200b\nThe\ntype\ncan be one of the following native constructors:\nString\nNumber\nBoolean\nArray\nObject\nDate\nFunction\nSymbol\nError\nIn addition,\ntype\ncan also be a custom class or constructor function and the assertion will be made with an\ninstanceof\ncheck. For example, given the following class:\njs\nclass\nPerson\n{\nconstructor\n(\nfirstName\n,\nlastName\n) {\nthis\n.firstName\n=\nfirstName\nthis\n.lastName\n=\nlastName\n}\n}\nYou could use it as a prop's type:\njs\ndefineProps\n({\nauthor: Person\n})\njs\nexport\ndefault\n{\nprops: {\nauthor: Person\n}\n}\nVue will use\ninstanceof Person\nto validate whether the value of the\nauthor\nprop is indeed an instance of the\nPerson\nclass.\nNullable Type\n\u200b\nIf the type is required but nullable, you can use the array syntax that includes\nnull\n:\njs\ndefineProps\n({\nid: {\ntype: [String,\nnull\n],\nrequired:\ntrue\n}\n})\njs\nexport\ndefault\n{\nprops: {\nid: {\ntype: [String,\nnull\n],\nrequired:\ntrue\n}\n}\n}\nNote that if\ntype\nis just\nnull\nwithout using the array syntax, it will allow any type.\nBoolean Casting\n\u200b\nProps with\nBoolean\ntype have special casting rules to mimic the behavior of native boolean attributes. Given a\n<MyComponent>\nwith the following declaration:\njs\ndefineProps\n({\ndisabled: Boolean\n})\njs\nexport\ndefault\n{\nprops: {\ndisabled: Boolean\n}\n}\nThe component can be used like this:\ntemplate\n<!-- equivalent of passing :disabled=\"true\" -->\n<\nMyComponent\ndisabled\n/>\n<!-- equivalent of passing :disabled=\"false\" -->\n<\nMyComponent\n/>\nWhen a prop is declared to allow multiple types, the casting rules for\nBoolean\nwill also be applied. However, there is an edge when both\nString\nand\nBoolean\nare allowed - the Boolean casting rule only applies if Boolean appears before String:\njs\n// disabled will be casted to true\ndefineProps\n({\ndisabled: [Boolean, Number]\n})\n// disabled will be casted to true\ndefineProps\n({\ndisabled: [Boolean, String]\n})\n// disabled will be casted to true\ndefineProps\n({\ndisabled: [Number, Boolean]\n})\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps\n({\ndisabled: [String, Boolean]\n})\njs\n// disabled will be casted to true\nexport\ndefault\n{\nprops: {\ndisabled: [Boolean, Number]\n}\n}\n// disabled will be casted to true\nexport\ndefault\n{\nprops: {\ndisabled: [Boolean, String]\n}\n}\n// disabled will be casted to true\nexport\ndefault\n{\nprops: {\ndisabled: [Number, Boolean]\n}\n}\n// disabled will be parsed as an empty string (disabled=\"\")\nexport\ndefault\n{\nprops: {\ndisabled: [String, Boolean]\n}\n}\nEdit this page on GitHub",
  "content_markdown": "# Props [\u200b](#props)\n\n> This page assumes you've already read the [Components Basics](/guide/essentials/component-basics). Read that first if you are new to components.\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-3-reusable-components-with-props?friend=vuejs \"Free Vue.js Props Lesson\")\n\n## Props Declaration [\u200b](#props-declaration)\n\nVue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in [its dedicated section](/guide/components/attrs)).\n\nIn SFCs using `<script setup>`, props can be declared using the `defineProps()` macro:\n\nvue\n\n```\n<script setup>\nconst props = defineProps(['foo'])\n\nconsole.log(props.foo)\n</script>\n```\n\nIn non-`<script setup>` components, props are declared using the [`props`](/api/options-state#props) option:\n\njs\n\n```\nexport default {\n  props: ['foo'],\n  setup(props) {\n    // setup() receives props as the first argument.\n    console.log(props.foo)\n  }\n}\n```\n\nNotice the argument passed to `defineProps()` is the same as the value provided to the `props` options: the same props options API is shared between the two declaration styles.\n\nProps are declared using the [`props`](/api/options-state#props) option:\n\njs\n\n```\nexport default {\n  props: ['foo'],\n  created() {\n    // props are exposed on `this`\n    console.log(this.foo)\n  }\n}\n```\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\njs\n\n```\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\njs\n\n```\n// in <script setup>\ndefineProps({\n  title: String,\n  likes: Number\n})\n```\n\njs\n\n```\n// in non-<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n}\n```\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about [prop validation](#prop-validation) further down this page.\n\nSee also: [Typing Component Props](/guide/typescript/options-api#typing-component-props)\n\nIf you are using TypeScript with `<script setup>`, it's also possible to declare props using pure type annotations:\n\nvue\n\n```\n<script setup lang=\"ts\">\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n</script>\n```\n\nMore details: [Typing Component Props](/guide/typescript/composition-api#typing-component-props)\n\n## Reactive Props Destructure [\u200b](#reactive-props-destructure)\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access `props.foo` in a computed getter or a watcher, the `foo` prop gets tracked as a dependency.\n\nSo, given the following code:\n\njs\n\n```\nconst { foo } = defineProps(['foo'])\n\nwatchEffect(() => {\n  // runs only once before 3.5\n  // re-runs when the \"foo\" prop changes in 3.5+\n  console.log(foo)\n})\n```\n\nIn version 3.4 and below, `foo` is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends `props.` when code in the same `<script setup>` block accesses variables destructured from `defineProps`. Therefore the code above becomes equivalent to the following:\n\njs\n\n```\nconst props = defineProps(['foo'])\n\nwatchEffect(() => {\n  // `foo` transformed to `props.foo` by the compiler\n  console.log(props.foo)\n})\n```\n\nIn addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration:\n\nts\n\n```\nconst { foo = 'hello' } = defineProps<{ foo?: string }>()\n```\n\nIf you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props.\n\n### Passing Destructured Props into Functions [\u200b](#passing-destructured-props-into-functions)\n\nWhen we pass a destructured prop into a function, e.g.:\n\njs\n\n```\nconst { foo } = defineProps(['foo'])\n\nwatch(foo, /* ... */)\n```\n\nThis will not work as expected because it is equivalent to `watch(props.foo, ...)` - we are passing a value instead of a reactive data source to `watch`. In fact, Vue's compiler will catch such cases and throw a warning.\n\nSimilar to how we can watch a normal prop with `watch(() => props.foo, ...)`, we can watch a destructured prop also by wrapping it in a getter:\n\njs\n\n```\nwatch(() => foo, /* ... */)\n```\n\nIn addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity:\n\njs\n\n```\nuseComposable(() => foo)\n```\n\nThe external function can call the getter (or normalize it with [toValue](/api/reactivity-utilities#tovalue)) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\n## Prop Passing Details [\u200b](#prop-passing-details)\n\n### Prop Name Casing [\u200b](#prop-name-casing)\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\njs\n\n```\ndefineProps({\n  greetingMessage: String\n})\n```\n\njs\n\n```\nexport default {\n  props: {\n    greetingMessage: String\n  }\n}\n```\n\ntemplate\n\n```\n<span>{{ greetingMessage }}</span>\n```\n\nTechnically, you can also use camelCase when passing props to a child component (except in [in-DOM templates](/guide/essentials/component-basics#in-dom-template-parsing-caveats)). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\ntemplate\n\n```\n<MyComponent greeting-message=\"hello\" />\n```\n\nWe use [PascalCase for component tags](/guide/components/registration#component-name-casing) when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\n### Static vs. Dynamic Props [\u200b](#static-vs-dynamic-props)\n\nSo far, you've seen props passed as static values, like in:\n\ntemplate\n\n```\n<BlogPost title=\"My journey with Vue\" />\n```\n\nYou've also seen props assigned dynamically with `v-bind` or its `:` shortcut, such as in:\n\ntemplate\n\n```\n<!-- Dynamically assign the value of a variable -->\n<BlogPost :title=\"post.title\" />\n\n<!-- Dynamically assign the value of a complex expression -->\n<BlogPost :title=\"post.title + ' by ' + post.author.name\" />\n```\n\n### Passing Different Value Types [\u200b](#passing-different-value-types)\n\nIn the two examples above, we happen to pass string values, but *any* type of value can be passed to a prop.\n\n#### Number [\u200b](#number)\n\ntemplate\n\n```\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<BlogPost :likes=\"42\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :likes=\"post.likes\" />\n```\n\n#### Boolean [\u200b](#boolean)\n\ntemplate\n\n```\n<!-- Including the prop with no value will imply `true`. -->\n<BlogPost is-published />\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<BlogPost :is-published=\"false\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :is-published=\"post.isPublished\" />\n```\n\n#### Array [\u200b](#array)\n\ntemplate\n\n```\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :comment-ids=\"post.commentIds\" />\n```\n\n#### Object [\u200b](#object)\n\ntemplate\n\n```\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<BlogPost\n  :author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n />\n\n<!-- Dynamically assign to the value of a variable. -->\n<BlogPost :author=\"post.author\" />\n```\n\n### Binding Multiple Properties Using an Object [\u200b](#binding-multiple-properties-using-an-object)\n\nIf you want to pass all the properties of an object as props, you can use [`v-bind` without an argument](/guide/essentials/template-syntax#dynamically-binding-multiple-attributes) (`v-bind` instead of `:prop-name`). For example, given a `post` object:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      post: {\n        id: 1,\n        title: 'My Journey with Vue'\n      }\n    }\n  }\n}\n```\n\njs\n\n```\nconst post = {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\nThe following template:\n\ntemplate\n\n```\n<BlogPost v-bind=\"post\" />\n```\n\nWill be equivalent to:\n\ntemplate\n\n```\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\n```\n\n## One-Way Data Flow [\u200b](#one-way-data-flow)\n\nAll props form a **one-way-down binding** between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should **not** attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\njs\n\n```\nconst props = defineProps(['foo'])\n\n// \u274c warning, props are readonly!\nprops.foo = 'bar'\n```\n\njs\n\n```\nexport default {\n  props: ['foo'],\n  created() {\n    // \u274c warning, props are readonly!\n    this.foo = 'bar'\n  }\n}\n```\n\nThere are usually two cases where it's tempting to mutate a prop:\n\n1. **The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.** In this case, it's best to define a local data property that uses the prop as its initial value:\n\n   js\n\n   ```\n   const props = defineProps(['initialCounter'])\n\n   // counter only uses props.initialCounter as the initial value;\n   // it is disconnected from future prop updates.\n   const counter = ref(props.initialCounter)\n   ```\n\n   js\n\n   ```\n   export default {\n     props: ['initialCounter'],\n     data() {\n       return {\n         // counter only uses this.initialCounter as the initial value;\n         // it is disconnected from future prop updates.\n         counter: this.initialCounter\n       }\n     }\n   }\n   ```\n2. **The prop is passed in as a raw value that needs to be transformed.** In this case, it's best to define a computed property using the prop's value:\n\n   js\n\n   ```\n   const props = defineProps(['size'])\n\n   // computed property that auto-updates when the prop changes\n   const normalizedSize = computed(() => props.size.trim().toLowerCase())\n   ```\n\n   js\n\n   ```\n   export default {\n     props: ['size'],\n     computed: {\n       // computed property that auto-updates when the prop changes\n       normalizedSize() {\n         return this.size.trim().toLowerCase()\n       }\n     }\n   }\n   ```\n\n### Mutating Object / Array Props [\u200b](#mutating-object-array-props)\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it **will** be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should [emit an event](/guide/components/events) to let the parent perform the mutation.\n\n## Prop Validation [\u200b](#prop-validation)\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the `defineProps()` macro`props` option, instead of an array of strings. For example:\n\njs\n\n```\ndefineProps({\n  // Basic type check\n  //  (`null` and `undefined` values will allow any type)\n  propA: Number,\n  // Multiple possible types\n  propB: [String, Number],\n  // Required string\n  propC: {\n    type: String,\n    required: true\n  },\n  // Required but nullable string\n  propD: {\n    type: [String, null],\n    required: true\n  },\n  // Number with a default value\n  propE: {\n    type: Number,\n    default: 100\n  },\n  // Object with a default value\n  propF: {\n    type: Object,\n    // Object or array defaults must be returned from\n    // a factory function. The function receives the raw\n    // props received by the component as the argument.\n    default(rawProps) {\n      return { message: 'hello' }\n    }\n  },\n  // Custom validator function\n  // full props passed as 2nd argument in 3.4+\n  propG: {\n    validator(value, props) {\n      // The value must match one of these strings\n      return ['success', 'warning', 'danger'].includes(value)\n    }\n  },\n  // Function with a default value\n  propH: {\n    type: Function,\n    // Unlike object or array default, this is not a factory\n    // function - this is a function to serve as a default value\n    default() {\n      return 'Default function'\n    }\n  }\n})\n```\n\nTIP\n\nCode inside the `defineProps()` argument **cannot access other variables declared in `<script setup>`**, because the entire expression is moved to an outer function scope when compiled.\n\njs\n\n```\nexport default {\n  props: {\n    // Basic type check\n    //  (`null` and `undefined` values will allow any type)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Required but nullable string\n    propD: {\n      type: [String, null],\n      required: true\n    },\n    // Number with a default value\n    propE: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propF: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function. The function receives the raw\n      // props received by the component as the argument.\n      default(rawProps) {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    // full props passed as 2nd argument in 3.4+\n    propG: {\n      validator(value, props) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].includes(value)\n      }\n    },\n    // Function with a default value\n    propH: {\n      type: Function,\n      // Unlike object or array default, this is not a factory\n      // function - this is a function to serve as a default value\n      default() {\n        return 'Default function'\n      }\n    }\n  }\n}\n```\n\nAdditional details:\n\n- All props are optional by default, unless `required: true` is specified.\n- An absent optional prop other than `Boolean` will have `undefined` value.\n- The `Boolean` absent props will be cast to `false`. You can change this by setting a `default` for it \u2014 i.e.: `default: undefined` to behave as a non-Boolean prop.\n- If a `default` value is specified, it will be used if the resolved prop value is `undefined` - this includes both when the prop is absent, or an explicit `undefined` value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nIf using [Type-based props declarations](/api/sfc-script-setup#type-only-props-emit-declarations) , Vue will try its best to compile the type annotations into equivalent runtime prop declarations. For example, `defineProps<{ msg: string }>` will be compiled into `{ msg: { type: String, required: true }}`.\n\nNote\n\nNote that props are validated **before** a component instance is created, so instance properties (e.g. `data`, `computed`, etc.) will not be available inside `default` or `validator` functions.\n\n### Runtime Type Checks [\u200b](#runtime-type-checks)\n\nThe `type` can be one of the following native constructors:\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Object`\n- `Date`\n- `Function`\n- `Symbol`\n- `Error`\n\nIn addition, `type` can also be a custom class or constructor function and the assertion will be made with an `instanceof` check. For example, given the following class:\n\njs\n\n```\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName\n    this.lastName = lastName\n  }\n}\n```\n\nYou could use it as a prop's type:\n\njs\n\n```\ndefineProps({\n  author: Person\n})\n```\n\njs\n\n```\nexport default {\n  props: {\n    author: Person\n  }\n}\n```\n\nVue will use `instanceof Person` to validate whether the value of the `author` prop is indeed an instance of the `Person` class.\n\n### Nullable Type [\u200b](#nullable-type)\n\nIf the type is required but nullable, you can use the array syntax that includes `null`:\n\njs\n\n```\ndefineProps({\n  id: {\n    type: [String, null],\n    required: true\n  }\n})\n```\n\njs\n\n```\nexport default {\n  props: {\n    id: {\n      type: [String, null],\n      required: true\n    }\n  }\n}\n```\n\nNote that if `type` is just `null` without using the array syntax, it will allow any type.\n\n## Boolean Casting [\u200b](#boolean-casting)\n\nProps with `Boolean` type have special casting rules to mimic the behavior of native boolean attributes. Given a `<MyComponent>` with the following declaration:\n\njs\n\n```\ndefineProps({\n  disabled: Boolean\n})\n```\n\njs\n\n```\nexport default {\n  props: {\n    disabled: Boolean\n  }\n}\n```\n\nThe component can be used like this:\n\ntemplate\n\n```\n<!-- equivalent of passing :disabled=\"true\" -->\n<MyComponent disabled />\n\n<!-- equivalent of passing :disabled=\"false\" -->\n<MyComponent />\n```\n\nWhen a prop is declared to allow multiple types, the casting rules for `Boolean` will also be applied. However, there is an edge when both `String` and `Boolean` are allowed - the Boolean casting rule only applies if Boolean appears before String:\n\njs\n\n```\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, Number]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Boolean, String]\n})\n\n// disabled will be casted to true\ndefineProps({\n  disabled: [Number, Boolean]\n})\n\n// disabled will be parsed as an empty string (disabled=\"\")\ndefineProps({\n  disabled: [String, Boolean]\n})\n```\n\njs\n\n```\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, Number]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Boolean, String]\n  }\n}\n\n// disabled will be casted to true\nexport default {\n  props: {\n    disabled: [Number, Boolean]\n  }\n}\n\n// disabled will be parsed as an empty string (disabled=\"\")\nexport default {\n  props: {\n    disabled: [String, Boolean]\n  }\n}\n```\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/components/props.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:56:04.632183+00:00",
  "content_length": 16778,
  "content_hash": "f4826411cae9dd0e"
}