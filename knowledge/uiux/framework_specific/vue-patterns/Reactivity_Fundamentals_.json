{
  "id": "vue-patterns__guide_essentials_reactivity-fundamentals_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
  "title": "Reactivity Fundamentals\u200b",
  "content": "Reactivity Fundamentals\n\u200b\nAPI Preference\nThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is\nOptions API\nComposition API\n. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.\nDeclaring Reactive State\n\u200b\nWith the Options API, we use the\ndata\noption to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance (\nthis\nin methods and lifecycle hooks):\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\ncount:\n1\n}\n},\n// `mounted` is a lifecycle hook which we will explain later\nmounted\n() {\n// `this` refers to the component instance.\nconsole.\nlog\n(\nthis\n.count)\n// => 1\n// data can be mutated as well\nthis\n.count\n=\n2\n}\n}\nTry it in the Playground\nThese instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the\ndata\nfunction. Where necessary, use\nnull\n,\nundefined\nor some other placeholder value for properties where the desired value isn't yet available.\nIt is possible to add a new property directly to\nthis\nwithout including it in\ndata\n. However, properties added this way will not be able to trigger reactive updates.\nVue uses a\n$\nprefix when exposing its own built-in APIs via the component instance. It also reserves the prefix\n_\nfor internal properties. You should avoid using names for top-level\ndata\nproperties that start with either of these characters.\nReactive Proxy vs. Original\n\u200b\nIn Vue 3, data is made reactive by leveraging\nJavaScript Proxies\n. Users coming from Vue 2 should be aware of the following edge case:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\nsomeObject: {}\n}\n},\nmounted\n() {\nconst\nnewObject\n=\n{}\nthis\n.someObject\n=\nnewObject\nconsole.\nlog\n(newObject\n===\nthis\n.someObject)\n// false\n}\n}\nWhen you access\nthis.someObject\nafter assigning it, the value is a reactive proxy of the original\nnewObject\n.\nUnlike in Vue 2, the original\nnewObject\nis left intact and will not be made reactive: make sure to always access reactive state as a property of\nthis\n.\nDeclaring Reactive State\n\u200b\nref()\n\u200b\nIn Composition API, the recommended way to declare reactive state is using the\nref()\nfunction:\njs\nimport\n{ ref }\nfrom\n'vue'\nconst\ncount\n=\nref\n(\n0\n)\nref()\ntakes the argument and returns it wrapped within a ref object with a\n.value\nproperty:\njs\nconst\ncount\n=\nref\n(\n0\n)\nconsole.\nlog\n(count)\n// { value: 0 }\nconsole.\nlog\n(count.value)\n// 0\ncount.value\n++\nconsole.\nlog\n(count.value)\n// 1\nSee also:\nTyping Refs\nTo access refs in a component's template, declare and return them from a component's\nsetup()\nfunction:\njs\nimport\n{ ref }\nfrom\n'vue'\nexport\ndefault\n{\n// `setup` is a special hook dedicated for the Composition API.\nsetup\n() {\nconst\ncount\n=\nref\n(\n0\n)\n// expose the ref to the template\nreturn\n{\ncount\n}\n}\n}\ntemplate\n<\ndiv\n>{{ count }}</\ndiv\n>\nNotice that we did\nnot\nneed to append\n.value\nwhen using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few\ncaveats\n).\nYou can also mutate a ref directly in event handlers:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\ncount\n++\n\"\n>\n{{ count }}\n</\nbutton\n>\nFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:\njs\nimport\n{ ref }\nfrom\n'vue'\nexport\ndefault\n{\nsetup\n() {\nconst\ncount\n=\nref\n(\n0\n)\nfunction\nincrement\n() {\n// .value is needed in JavaScript\ncount.value\n++\n}\n// don't forget to expose the function as well.\nreturn\n{\ncount,\nincrement\n}\n}\n}\nExposed methods can then be used as event handlers:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\nincrement\n\"\n>\n{{ count }}\n</\nbutton\n>\nHere's the example live on\nCodepen\n, without using any build tools.\n<script setup>\n\u200b\nManually exposing state and methods via\nsetup()\ncan be verbose. Luckily, it can be avoided when using\nSingle-File Components (SFCs)\n. We can simplify the usage with\n<script setup>\n:\nvue\n<\nscript\nsetup\n>\nimport\n{ ref }\nfrom\n'vue'\nconst\ncount\n=\nref\n(\n0\n)\nfunction\nincrement\n() {\ncount.value\n++\n}\n</\nscript\n>\n<\ntemplate\n>\n<\nbutton\n@click\n=\n\"increment\"\n>\n{{ count }}\n</\nbutton\n>\n</\ntemplate\n>\nTry it in the Playground\nTop-level imports, variables and functions declared in\n<script setup>\nare automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.\nTIP\nFor the rest of the guide, we will be primarily using SFC +\n<script setup>\nsyntax for the Composition API code examples, as that is the most common usage for Vue developers.\nIf you are not using SFC, you can still use Composition API with the\nsetup()\noption.\nWhy Refs?\n\u200b\nYou might be wondering why we need refs with the\n.value\ninstead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.\nWhen you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue\ntracks\nevery ref that was used during the render. Later on, when a ref is mutated, it will\ntrigger\na re-render for components that are tracking it.\nIn standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.\nThe\n.value\nproperty gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:\njs\n// pseudo code, not actual implementation\nconst\nmyRef\n=\n{\n_value:\n0\n,\nget\nvalue\n() {\ntrack\n()\nreturn\nthis\n._value\n},\nset\nvalue\n(\nnewValue\n) {\nthis\n._value\n=\nnewValue\ntrigger\n()\n}\n}\nAnother nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.\nThe reactivity system is discussed in more details in the\nReactivity in Depth\nsection.\nDeclaring Methods\n\u200b\nWatch a free video lesson on Vue School\nTo add methods to a component instance we use the\nmethods\noption. This should be an object containing the desired methods:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\ncount:\n0\n}\n},\nmethods: {\nincrement\n() {\nthis\n.count\n++\n}\n},\nmounted\n() {\n// methods can be called in lifecycle hooks, or other methods!\nthis\n.\nincrement\n()\n}\n}\nVue automatically binds the\nthis\nvalue for\nmethods\nso that it always refers to the component instance. This ensures that a method retains the correct\nthis\nvalue if it's used as an event listener or callback. You should avoid using arrow functions when defining\nmethods\n, as that prevents Vue from binding the appropriate\nthis\nvalue:\njs\nexport\ndefault\n{\nmethods: {\nincrement\n: ()\n=>\n{\n// BAD: no `this` access here!\n}\n}\n}\nJust like all other properties of the component instance, the\nmethods\nare accessible from within the component's template. Inside a template they are most commonly used as event listeners:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\nincrement\n\"\n>{{ count }}</\nbutton\n>\nTry it in the Playground\nIn the example above, the method\nincrement\nwill be called when the\n<button>\nis clicked.\nDeep Reactivity\n\u200b\nIn Vue, state is deeply reactive by default. This means you can expect changes to be detected even when you mutate nested objects or arrays:\njs\nexport\ndefault\n{\ndata\n() {\nreturn\n{\nobj: {\nnested: { count:\n0\n},\narr: [\n'foo'\n,\n'bar'\n]\n}\n}\n},\nmethods: {\nmutateDeeply\n() {\n// these will work as expected.\nthis\n.obj.nested.count\n++\nthis\n.obj.arr.\npush\n(\n'baz'\n)\n}\n}\n}\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like\nMap\n.\nA ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:\njs\nimport\n{ ref }\nfrom\n'vue'\nconst\nobj\n=\nref\n({\nnested: { count:\n0\n},\narr: [\n'foo'\n,\n'bar'\n]\n})\nfunction\nmutateDeeply\n() {\n// these will work as expected.\nobj.value.nested.count\n++\nobj.value.arr.\npush\n(\n'baz'\n)\n}\nNon-primitive values are turned into reactive proxies via\nreactive()\n, which is discussed below.\nIt is also possible to opt-out of deep reactivity with\nshallow refs\n. For shallow refs, only\n.value\naccess is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\nFurther reading:\nReduce Reactivity Overhead for Large Immutable Structures\nIntegration with External State Systems\nDOM Update Timing\n\u200b\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\nTo wait for the DOM update to complete after a state change, you can use the\nnextTick()\nglobal API:\njs\nimport\n{ nextTick }\nfrom\n'vue'\nasync\nfunction\nincrement\n() {\ncount.value\n++\nawait\nnextTick\n()\n// Now the DOM is updated\n}\njs\nimport\n{ nextTick }\nfrom\n'vue'\nexport\ndefault\n{\nmethods: {\nasync\nincrement\n() {\nthis\n.count\n++\nawait\nnextTick\n()\n// Now the DOM is updated\n}\n}\n}\nreactive()\n\u200b\nThere is another way to declare reactive state, with the\nreactive()\nAPI. Unlike a ref which wraps the inner value in a special object,\nreactive()\nmakes an object itself reactive:\njs\nimport\n{ reactive }\nfrom\n'vue'\nconst\nstate\n=\nreactive\n({ count:\n0\n})\nSee also:\nTyping Reactive\nUsage in template:\ntemplate\n<\nbutton\n@\nclick\n=\n\"\nstate.count\n++\n\"\n>\n{{ state.count }}\n</\nbutton\n>\nReactive objects are\nJavaScript Proxies\nand behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.\nreactive()\nconverts the object deeply: nested objects are also wrapped with\nreactive()\nwhen accessed. It is also called by\nref()\ninternally when the ref value is an object. Similar to shallow refs, there is also the\nshallowReactive()\nAPI for opting-out of deep reactivity.\nReactive Proxy vs. Original\n\u200b\nIt is important to note that the returned value from\nreactive()\nis a\nProxy\nof the original object, which is not equal to the original object:\njs\nconst\nraw\n=\n{}\nconst\nproxy\n=\nreactive\n(raw)\n// proxy is NOT equal to the original.\nconsole.\nlog\n(proxy\n===\nraw)\n// false\nOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to\nexclusively use the proxied versions of your state\n.\nTo ensure consistent access to the proxy, calling\nreactive()\non the same object always returns the same proxy, and calling\nreactive()\non an existing proxy also returns that same proxy:\njs\n// calling reactive() on the same object returns the same proxy\nconsole.\nlog\n(\nreactive\n(raw)\n===\nproxy)\n// true\n// calling reactive() on a proxy returns itself\nconsole.\nlog\n(\nreactive\n(proxy)\n===\nproxy)\n// true\nThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:\njs\nconst\nproxy\n=\nreactive\n({})\nconst\nraw\n=\n{}\nproxy.nested\n=\nraw\nconsole.\nlog\n(proxy.nested\n===\nraw)\n// false\nLimitations of\nreactive()\n\u200b\nThe\nreactive()\nAPI has a few limitations:\nLimited value types:\nit only works for object types (objects, arrays, and\ncollection types\nsuch as\nMap\nand\nSet\n). It cannot hold\nprimitive types\nsuch as\nstring\n,\nnumber\nor\nboolean\n.\nCannot replace entire object:\nsince Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:\njs\nlet\nstate\n=\nreactive\n({ count:\n0\n})\n// the above reference ({ count: 0 }) is no longer being tracked\n// (reactivity connection is lost!)\nstate\n=\nreactive\n({ count:\n1\n})\nNot destructure-friendly:\nwhen we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:\njs\nconst\nstate\n=\nreactive\n({ count:\n0\n})\n// count is disconnected from state.count when destructured.\nlet\n{ count }\n=\nstate\n// does not affect original state\ncount\n++\n// the function receives a plain number and\n// won't be able to track changes to state.count\n// we have to pass the entire object in to retain reactivity\ncallSomeFunction\n(state.count)\nDue to these limitations, we recommend using\nref()\nas the primary API for declaring reactive state.\nAdditional Ref Unwrapping Details\n\u200b\nAs Reactive Object Property\n\u200b\nA ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property:\njs\nconst\ncount\n=\nref\n(\n0\n)\nconst\nstate\n=\nreactive\n({\ncount\n})\nconsole.\nlog\n(state.count)\n// 0\nstate.count\n=\n1\nconsole.\nlog\n(count.value)\n// 1\nIf a new ref is assigned to a property linked to an existing ref, it will replace the old ref:\njs\nconst\notherCount\n=\nref\n(\n2\n)\nstate.count\n=\notherCount\nconsole.\nlog\n(state.count)\n// 2\n// original ref is now disconnected from state.count\nconsole.\nlog\n(count.value)\n// 1\nRef unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a\nshallow reactive object\n.\nCaveat in Arrays and Collections\n\u200b\nUnlike reactive objects, there is\nno\nunwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like\nMap\n:\njs\nconst\nbooks\n=\nreactive\n([\nref\n(\n'Vue 3 Guide'\n)])\n// need .value here\nconsole.\nlog\n(books[\n0\n].value)\nconst\nmap\n=\nreactive\n(\nnew\nMap\n([[\n'count'\n,\nref\n(\n0\n)]]))\n// need .value here\nconsole.\nlog\n(map.\nget\n(\n'count'\n).value)\nCaveat when Unwrapping in Templates\n\u200b\nRef unwrapping in templates only applies if the ref is a top-level property in the template render context.\nIn the example below,\ncount\nand\nobject\nare top-level properties, but\nobject.id\nis not:\njs\nconst\ncount\n=\nref\n(\n0\n)\nconst\nobject\n=\n{ id:\nref\n(\n1\n) }\nTherefore, this expression works as expected:\ntemplate\n{{ count + 1 }}\n...while this one does\nNOT\n:\ntemplate\n{{ object.id + 1 }}\nThe rendered result will be\n[object Object]1\nbecause\nobject.id\nis not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure\nid\ninto a top-level property:\njs\nconst\n{\nid\n}\n=\nobject\ntemplate\n{{ id + 1 }}\nNow the render result will be\n2\n.\nAnother thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a\n{{ }}\ntag), so the following will render\n1\n:\ntemplate\n{{ object.id }}\nThis is just a convenience feature of text interpolation and is equivalent to\n{{ object.id.value }}\n.\nStateful Methods\n\u200b\nIn some cases, we may need to dynamically create a method function, for example creating a debounced event handler:\njs\nimport\n{ debounce }\nfrom\n'lodash-es'\nexport\ndefault\n{\nmethods: {\n// Debouncing with Lodash\nclick:\ndebounce\n(\nfunction\n() {\n// ... respond to click ...\n},\n500\n)\n}\n}\nHowever, this approach is problematic for components that are reused because a debounced function is\nstateful\n: it maintains some internal state on the elapsed time. If multiple component instances share the same debounced function, they will interfere with one another.\nTo keep each component instance's debounced function independent of the others, we can create the debounced version in the\ncreated\nlifecycle hook:\njs\nexport\ndefault\n{\ncreated\n() {\n// each instance now has its own copy of debounced handler\nthis\n.debouncedClick\n=\n_.\ndebounce\n(\nthis\n.click,\n500\n)\n},\nunmounted\n() {\n// also a good idea to cancel the timer\n// when the component is removed\nthis\n.debouncedClick.\ncancel\n()\n},\nmethods: {\nclick\n() {\n// ... respond to click ...\n}\n}\n}\nEdit this page on GitHub",
  "content_markdown": "# Reactivity Fundamentals [\u200b](#reactivity-fundamentals)\n\nAPI Preference\n\nThis page and many other chapters later in the guide contain different content for the Options API and the Composition API. Your current preference is Options APIComposition API. You can toggle between the API styles using the \"API Preference\" switches at the top of the left sidebar.\n\n## Declaring Reactive State [\u200b](#declaring-reactive-state)\n\nWith the Options API, we use the `data` option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance (`this` in methods and lifecycle hooks):\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      count: 1\n    }\n  },\n\n  // `mounted` is a lifecycle hook which we will explain later\n  mounted() {\n    // `this` refers to the component instance.\n    console.log(this.count) // => 1\n\n    // data can be mutated as well\n    this.count = 2\n  }\n}\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNpFUNFqhDAQ/JXBpzsoHu2j3B2U/oYPpnGtoetGkrW2iP/eRFsPApthd2Zndilex7H8mqioimu0wY16r4W+Rx8ULXVmYsVSC9AaNafz/gcC6RTkHwHWT6IVnne85rI+1ZLr5YJmyG1qG7gIA3Yd2R/LhN77T8y9sz1mwuyYkXazcQI2SiHz/7iP3VlQexeb5KKjEKEe2lPyMIxeSBROohqxVO4E6yV6ppL9xykTy83tOQvd7tnzoZtDwhrBO2GYNFloYWLyxrzPPOi44WWLWUt618txvASUhhRCKSHgbZt2scKy7HfCujGOqWL9BVfOgyI=)\n\nThese instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the `data` function. Where necessary, use `null`, `undefined` or some other placeholder value for properties where the desired value isn't yet available.\n\nIt is possible to add a new property directly to `this` without including it in `data`. However, properties added this way will not be able to trigger reactive updates.\n\nVue uses a `$` prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix `_` for internal properties. You should avoid using names for top-level `data` properties that start with either of these characters.\n\n### Reactive Proxy vs. Original [\u200b](#reactive-proxy-vs-original)\n\nIn Vue 3, data is made reactive by leveraging [JavaScript Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). Users coming from Vue 2 should be aware of the following edge case:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      someObject: {}\n    }\n  },\n  mounted() {\n    const newObject = {}\n    this.someObject = newObject\n\n    console.log(newObject === this.someObject) // false\n  }\n}\n```\n\nWhen you access `this.someObject` after assigning it, the value is a reactive proxy of the original `newObject`. **Unlike in Vue 2, the original `newObject` is left intact and will not be made reactive: make sure to always access reactive state as a property of `this`.**\n\n## Declaring Reactive State [\u200b](#declaring-reactive-state-1)\n\n### `ref()` [\u200b](#ref)\n\nIn Composition API, the recommended way to declare reactive state is using the [`ref()`](/api/reactivity-core#ref) function:\n\njs\n\n```\nimport { ref } from 'vue'\n\nconst count = ref(0)\n```\n\n`ref()` takes the argument and returns it wrapped within a ref object with a `.value` property:\n\njs\n\n```\nconst count = ref(0)\n\nconsole.log(count) // { value: 0 }\nconsole.log(count.value) // 0\n\ncount.value++\nconsole.log(count.value) // 1\n```\n\n> See also: [Typing Refs](/guide/typescript/composition-api#typing-ref)\n\nTo access refs in a component's template, declare and return them from a component's `setup()` function:\n\njs\n\n```\nimport { ref } from 'vue'\n\nexport default {\n  // `setup` is a special hook dedicated for the Composition API.\n  setup() {\n    const count = ref(0)\n\n    // expose the ref to the template\n    return {\n      count\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<div>{{ count }}</div>\n```\n\nNotice that we did **not** need to append `.value` when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few [caveats](#caveat-when-unwrapping-in-templates)).\n\nYou can also mutate a ref directly in event handlers:\n\ntemplate\n\n```\n<button @click=\"count++\">\n  {{ count }}\n</button>\n```\n\nFor more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state:\n\njs\n\n```\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n\n    function increment() {\n      // .value is needed in JavaScript\n      count.value++\n    }\n\n    // don't forget to expose the function as well.\n    return {\n      count,\n      increment\n    }\n  }\n}\n```\n\nExposed methods can then be used as event handlers:\n\ntemplate\n\n```\n<button @click=\"increment\">\n  {{ count }}\n</button>\n```\n\nHere's the example live on [Codepen](https://codepen.io/vuejs-examples/pen/WNYbaqo), without using any build tools.\n\n### `<script setup>` [\u200b](#script-setup)\n\nManually exposing state and methods via `setup()` can be verbose. Luckily, it can be avoided when using [Single-File Components (SFCs)](/guide/scaling-up/sfc). We can simplify the usage with `<script setup>`:\n\nvue\n\n```\n<script setup>\nimport { ref } from 'vue'\n\nconst count = ref(0)\n\nfunction increment() {\n  count.value++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">\n    {{ count }}\n  </button>\n</template>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNo9jUEKgzAQRa8yZKMiaNcllvYe2dgwQqiZhDhxE3L3jrW4/DPvv1/UK8Zhz6juSm82uciwIef4MOR8DImhQMIFKiwpeGgEbQwZsoE2BhsyMUwH0d66475ksuwCgSOb0CNx20ExBCc77POase8NVUN6PBdlSwKjj+vMKAlAvzOzWJ52dfYzGXXpjPoBAKX856uopDGeFfnq8XKp+gWq4FAi)\n\nTop-level imports, variables and functions declared in `<script setup>` are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it.\n\nTIP\n\nFor the rest of the guide, we will be primarily using SFC + `<script setup>` syntax for the Composition API code examples, as that is the most common usage for Vue developers.\n\nIf you are not using SFC, you can still use Composition API with the [`setup()`](/api/composition-api-setup) option.\n\n### Why Refs? [\u200b](#why-refs)\n\nYou might be wondering why we need refs with the `.value` instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works.\n\nWhen you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue **tracks** every ref that was used during the render. Later on, when a ref is mutated, it will **trigger** a re-render for components that are tracking it.\n\nIn standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods.\n\nThe `.value` property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this:\n\njs\n\n```\n// pseudo code, not actual implementation\nconst myRef = {\n  _value: 0,\n  get value() {\n    track()\n    return this._value\n  },\n  set value(newValue) {\n    this._value = newValue\n    trigger()\n  }\n}\n```\n\nAnother nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code.\n\nThe reactivity system is discussed in more details in the [Reactivity in Depth](/guide/extras/reactivity-in-depth) section.\n\n## Declaring Methods [\u200b](#declaring-methods)\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/methods-in-vue-3?friend=vuejs \"Free Vue.js Methods Lesson\")\n\nTo add methods to a component instance we use the `methods` option. This should be an object containing the desired methods:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  },\n  mounted() {\n    // methods can be called in lifecycle hooks, or other methods!\n    this.increment()\n  }\n}\n```\n\nVue automatically binds the `this` value for `methods` so that it always refers to the component instance. This ensures that a method retains the correct `this` value if it's used as an event listener or callback. You should avoid using arrow functions when defining `methods`, as that prevents Vue from binding the appropriate `this` value:\n\njs\n\n```\nexport default {\n  methods: {\n    increment: () => {\n      // BAD: no `this` access here!\n    }\n  }\n}\n```\n\nJust like all other properties of the component instance, the `methods` are accessible from within the component's template. Inside a template they are most commonly used as event listeners:\n\ntemplate\n\n```\n<button @click=\"increment\">{{ count }}</button>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNplj9EKwyAMRX8l+LSx0e65uLL9hy+dZlTWqtg4BuK/z1baDgZicsPJgUR2d656B2QN45P02lErDH6c9QQKn10YCKIwAKqj7nAsPYBHCt6sCUDaYKiBS8lpLuk8/yNSb9XUrKg20uOIhnYXAPV6qhbF6fRvmOeodn6hfzwLKkx+vN5OyIFwdENHmBMAfwQia+AmBy1fV8E2gWBtjOUASInXBcxLvN4MLH0BCe1i4Q==)\n\nIn the example above, the method `increment` will be called when the `<button>` is clicked.\n\n### Deep Reactivity [\u200b](#deep-reactivity)\n\nIn Vue, state is deeply reactive by default. This means you can expect changes to be detected even when you mutate nested objects or arrays:\n\njs\n\n```\nexport default {\n  data() {\n    return {\n      obj: {\n        nested: { count: 0 },\n        arr: ['foo', 'bar']\n      }\n    }\n  },\n  methods: {\n    mutateDeeply() {\n      // these will work as expected.\n      this.obj.nested.count++\n      this.obj.arr.push('baz')\n    }\n  }\n}\n```\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like `Map`.\n\nA ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays:\n\njs\n\n```\nimport { ref } from 'vue'\n\nconst obj = ref({\n  nested: { count: 0 },\n  arr: ['foo', 'bar']\n})\n\nfunction mutateDeeply() {\n  // these will work as expected.\n  obj.value.nested.count++\n  obj.value.arr.push('baz')\n}\n```\n\nNon-primitive values are turned into reactive proxies via [`reactive()`](#reactive), which is discussed below.\n\nIt is also possible to opt-out of deep reactivity with [shallow refs](/api/reactivity-advanced#shallowref). For shallow refs, only `.value` access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nFurther reading:\n\n- [Reduce Reactivity Overhead for Large Immutable Structures](/guide/best-practices/performance#reduce-reactivity-overhead-for-large-immutable-structures)\n- [Integration with External State Systems](/guide/extras/reactivity-in-depth#integration-with-external-state-systems)\n\n### DOM Update Timing [\u200b](#dom-update-timing)\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the [nextTick()](/api/general#nexttick) global API:\n\njs\n\n```\nimport { nextTick } from 'vue'\n\nasync function increment() {\n  count.value++\n  await nextTick()\n  // Now the DOM is updated\n}\n```\n\njs\n\n```\nimport { nextTick } from 'vue'\n\nexport default {\n  methods: {\n    async increment() {\n      this.count++\n      await nextTick()\n      // Now the DOM is updated\n    }\n  }\n}\n```\n\n## `reactive()` [\u200b](#reactive)\n\nThere is another way to declare reactive state, with the `reactive()` API. Unlike a ref which wraps the inner value in a special object, `reactive()` makes an object itself reactive:\n\njs\n\n```\nimport { reactive } from 'vue'\n\nconst state = reactive({ count: 0 })\n```\n\n> See also: [Typing Reactive](/guide/typescript/composition-api#typing-reactive)\n\nUsage in template:\n\ntemplate\n\n```\n<button @click=\"state.count++\">\n  {{ state.count }}\n</button>\n```\n\nReactive objects are [JavaScript Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering.\n\n`reactive()` converts the object deeply: nested objects are also wrapped with `reactive()` when accessed. It is also called by `ref()` internally when the ref value is an object. Similar to shallow refs, there is also the [`shallowReactive()`](/api/reactivity-advanced#shallowreactive) API for opting-out of deep reactivity.\n\n### Reactive Proxy vs. Original [\u200b](#reactive-proxy-vs-original-1)\n\nIt is important to note that the returned value from `reactive()` is a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) of the original object, which is not equal to the original object:\n\njs\n\n```\nconst raw = {}\nconst proxy = reactive(raw)\n\n// proxy is NOT equal to the original.\nconsole.log(proxy === raw) // false\n```\n\nOnly the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to **exclusively use the proxied versions of your state**.\n\nTo ensure consistent access to the proxy, calling `reactive()` on the same object always returns the same proxy, and calling `reactive()` on an existing proxy also returns that same proxy:\n\njs\n\n```\n// calling reactive() on the same object returns the same proxy\nconsole.log(reactive(raw) === proxy) // true\n\n// calling reactive() on a proxy returns itself\nconsole.log(reactive(proxy) === proxy) // true\n```\n\nThis rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:\n\njs\n\n```\nconst proxy = reactive({})\n\nconst raw = {}\nproxy.nested = raw\n\nconsole.log(proxy.nested === raw) // false\n```\n\n### Limitations of `reactive()` [\u200b](#limitations-of-reactive)\n\nThe `reactive()` API has a few limitations:\n\n1. **Limited value types:** it only works for object types (objects, arrays, and [collection types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections) such as `Map` and `Set`). It cannot hold [primitive types](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) such as `string`, `number` or `boolean`.\n2. **Cannot replace entire object:** since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost:\n\n   js\n\n   ```\n   let state = reactive({ count: 0 })\n\n   // the above reference ({ count: 0 }) is no longer being tracked\n   // (reactivity connection is lost!)\n   state = reactive({ count: 1 })\n   ```\n3. **Not destructure-friendly:** when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection:\n\n   js\n\n   ```\n   const state = reactive({ count: 0 })\n\n   // count is disconnected from state.count when destructured.\n   let { count } = state\n   // does not affect original state\n   count++\n\n   // the function receives a plain number and\n   // won't be able to track changes to state.count\n   // we have to pass the entire object in to retain reactivity\n   callSomeFunction(state.count)\n   ```\n\nDue to these limitations, we recommend using `ref()` as the primary API for declaring reactive state.\n\n## Additional Ref Unwrapping Details [\u200b](#additional-ref-unwrapping-details)\n\n### As Reactive Object Property [\u200b](#ref-unwrapping-as-reactive-object-property)\n\nA ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property:\n\njs\n\n```\nconst count = ref(0)\nconst state = reactive({\n  count\n})\n\nconsole.log(state.count) // 0\n\nstate.count = 1\nconsole.log(count.value) // 1\n```\n\nIf a new ref is assigned to a property linked to an existing ref, it will replace the old ref:\n\njs\n\n```\nconst otherCount = ref(2)\n\nstate.count = otherCount\nconsole.log(state.count) // 2\n// original ref is now disconnected from state.count\nconsole.log(count.value) // 1\n```\n\nRef unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a [shallow reactive object](/api/reactivity-advanced#shallowreactive).\n\n### Caveat in Arrays and Collections [\u200b](#caveat-in-arrays-and-collections)\n\nUnlike reactive objects, there is **no** unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like `Map`:\n\njs\n\n```\nconst books = reactive([ref('Vue 3 Guide')])\n// need .value here\nconsole.log(books[0].value)\n\nconst map = reactive(new Map([['count', ref(0)]]))\n// need .value here\nconsole.log(map.get('count').value)\n```\n\n### Caveat when Unwrapping in Templates [\u200b](#caveat-when-unwrapping-in-templates)\n\nRef unwrapping in templates only applies if the ref is a top-level property in the template render context.\n\nIn the example below, `count` and `object` are top-level properties, but `object.id` is not:\n\njs\n\n```\nconst count = ref(0)\nconst object = { id: ref(1) }\n```\n\nTherefore, this expression works as expected:\n\ntemplate\n\n```\n{{ count + 1 }}\n```\n\n...while this one does **NOT**:\n\ntemplate\n\n```\n{{ object.id + 1 }}\n```\n\nThe rendered result will be `[object Object]1` because `object.id` is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure `id` into a top-level property:\n\njs\n\n```\nconst { id } = object\n```\n\ntemplate\n\n```\n{{ id + 1 }}\n```\n\nNow the render result will be `2`.\n\nAnother thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a `{{ }}` tag), so the following will render `1`:\n\ntemplate\n\n```\n{{ object.id }}\n```\n\nThis is just a convenience feature of text interpolation and is equivalent to `{{ object.id.value }}`.\n\n### Stateful Methods [\u200b](#stateful-methods)\n\nIn some cases, we may need to dynamically create a method function, for example creating a debounced event handler:\n\njs\n\n```\nimport { debounce } from 'lodash-es'\n\nexport default {\n  methods: {\n    // Debouncing with Lodash\n    click: debounce(function () {\n      // ... respond to click ...\n    }, 500)\n  }\n}\n```\n\nHowever, this approach is problematic for components that are reused because a debounced function is **stateful**: it maintains some internal state on the elapsed time. If multiple component instances share the same debounced function, they will interfere with one another.\n\nTo keep each component instance's debounced function independent of the others, we can create the debounced version in the `created` lifecycle hook:\n\njs\n\n```\nexport default {\n  created() {\n    // each instance now has its own copy of debounced handler\n    this.debouncedClick = _.debounce(this.click, 500)\n  },\n  unmounted() {\n    // also a good idea to cancel the timer\n    // when the component is removed\n    this.debouncedClick.cancel()\n  },\n  methods: {\n    click() {\n      // ... respond to click ...\n    }\n  }\n}\n```\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/reactivity-fundamentals.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:50.633246+00:00",
  "content_length": 16412,
  "content_hash": "fdd81eb0b6b1214c"
}