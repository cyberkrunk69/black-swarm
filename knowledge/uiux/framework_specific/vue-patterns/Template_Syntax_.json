{
  "id": "vue-patterns__guide_essentials_template-syntax_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/template-syntax.html",
  "title": "Template Syntax\u200b",
  "content": "Template Syntax\n\u200b\nWatch an interactive video lesson on Scrimba\nVue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\nUnder the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also\ndirectly write render functions\ninstead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.\nText Interpolation\n\u200b\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\ntemplate\n<\nspan\n>Message: {{ msg }}</\nspan\n>\nThe mustache tag will be replaced with the value of the\nmsg\nproperty\nfrom the corresponding component instance\n. It will also be updated whenever the\nmsg\nproperty changes.\nRaw HTML\n\u200b\nThe double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the\nv-html\ndirective\n:\ntemplate\n<\np\n>Using text interpolation: {{ rawHtml }}</\np\n>\n<\np\n>Using v-html directive: <\nspan\nv-html\n=\n\"\nrawHtml\n\"\n></\nspan\n></\np\n>\nUsing text interpolation: <span style=\"color: red\">This should be red.</span>\nUsing v-html directive:\nThis should be red.\nHere we're encountering something new. The\nv-html\nattribute you're seeing is called a\ndirective\n. Directives are prefixed with\nv-\nto indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the\nrawHtml\nproperty on the current active instance.\"\nThe contents of the\nspan\nwill be replaced with the value of the\nrawHtml\nproperty, interpreted as plain HTML - data bindings are ignored. Note that you cannot use\nv-html\nto compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\nSecurity Warning\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to\nXSS vulnerabilities\n. Only use\nv-html\non trusted content and\nnever\non user-provided content.\nAttribute Bindings\n\u200b\nMustaches cannot be used inside HTML attributes. Instead, use a\nv-bind\ndirective\n:\ntemplate\n<\ndiv\nv-bind\n:\nid\n=\n\"\ndynamicId\n\"\n></\ndiv\n>\nThe\nv-bind\ndirective instructs Vue to keep the element's\nid\nattribute in sync with the component's\ndynamicId\nproperty. If the bound value is\nnull\nor\nundefined\n, then the attribute will be removed from the rendered element.\nShorthand\n\u200b\nBecause\nv-bind\nis so commonly used, it has a dedicated shorthand syntax:\ntemplate\n<\ndiv\n:\nid\n=\n\"\ndynamicId\n\"\n></\ndiv\n>\nAttributes that start with\n:\nmay look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.\nFor the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.\nSame-name Shorthand\n\u200b\nOnly supported in 3.4+\nIf the attribute has the same name as the variable name of the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:\ntemplate\n<!-- same as :id=\"id\" -->\n<\ndiv\n:\nid\n></\ndiv\n>\n<!-- this also works -->\n<\ndiv\nv-bind:id\n></\ndiv\n>\nThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.\nBoolean Attributes\n\u200b\nBoolean attributes\nare attributes that can indicate true / false values by their presence on an element. For example,\ndisabled\nis one of the most commonly used boolean attributes.\nv-bind\nworks a bit differently in this case:\ntemplate\n<\nbutton\n:\ndisabled\n=\n\"\nisButtonDisabled\n\"\n>Button</\nbutton\n>\nThe\ndisabled\nattribute will be included if\nisButtonDisabled\nhas a\ntruthy value\n. It will also be included if the value is an empty string, maintaining consistency with\n<button disabled=\"\">\n. For other\nfalsy values\nthe attribute will be omitted.\nDynamically Binding Multiple Attributes\n\u200b\nIf you have a JavaScript object representing multiple attributes that looks like this:\njs\nconst\nobjectOfAttrs\n=\n{\nid:\n'container'\n,\nclass:\n'wrapper'\n,\nstyle:\n'background-color:green'\n}\njs\ndata\n() {\nreturn\n{\nobjectOfAttrs: {\nid:\n'container'\n,\nclass:\n'wrapper'\n}\n}\n}\nYou can bind them to a single element by using\nv-bind\nwithout an argument:\ntemplate\n<\ndiv\nv-bind\n=\n\"\nobjectOfAttrs\n\"\n></\ndiv\n>\nUsing JavaScript Expressions\n\u200b\nSo far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:\ntemplate\n{{ number + 1 }}\n{{ ok ? 'YES' : 'NO' }}\n{{ message.split('').reverse().join('') }}\n<\ndiv\n:\nid\n=\n\"`list-${\nid\n}`\"\n></\ndiv\n>\nThese expressions will be evaluated as JavaScript in the data scope of the current component instance.\nIn Vue templates, JavaScript expressions can be used in the following positions:\nInside text interpolations (mustaches)\nIn the attribute value of any Vue directives (special attributes that start with\nv-\n)\nExpressions Only\n\u200b\nEach binding can only contain\none single expression\n. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after\nreturn\n.\nTherefore, the following will\nNOT\nwork:\ntemplate\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\nCalling Functions\n\u200b\nIt is possible to call a component-exposed method inside a binding expression:\ntemplate\n<\ntime\n:\ntitle\n=\n\"\ntoTitleDate\n(date)\n\"\n:\ndatetime\n=\n\"\ndate\n\"\n>\n{{ formatDate(date) }}\n</\ntime\n>\nTIP\nFunctions called inside binding expressions will be called every time the component updates, so they should\nnot\nhave any side effects, such as changing data or triggering asynchronous operations.\nRestricted Globals Access\n\u200b\nTemplate expressions are sandboxed and only have access to a\nrestricted list of globals\n. The list exposes commonly used built-in globals such as\nMath\nand\nDate\n.\nGlobals not explicitly included in the list, for example user-attached properties on\nwindow\n, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to\napp.config.globalProperties\n.\nDirectives\n\u200b\nDirectives are special attributes with the\nv-\nprefix. Vue provides a number of\nbuilt-in directives\n, including\nv-html\nand\nv-bind\nwhich we have introduced above.\nDirective attribute values are expected to be single JavaScript expressions (with the exception of\nv-for\n,\nv-on\nand\nv-slot\n, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take\nv-if\nas an example:\ntemplate\n<\np\nv-if\n=\n\"\nseen\n\"\n>Now you see me</\np\n>\nHere, the\nv-if\ndirective would remove or insert the\n<p>\nelement based on the truthiness of the value of the expression\nseen\n.\nArguments\n\u200b\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the\nv-bind\ndirective is used to reactively update an HTML attribute:\ntemplate\n<\na\nv-bind\n:\nhref\n=\n\"\nurl\n\"\n> ... </\na\n>\n<!-- shorthand -->\n<\na\n:\nhref\n=\n\"\nurl\n\"\n> ... </\na\n>\nHere,\nhref\nis the argument, which tells the\nv-bind\ndirective to bind the element's\nhref\nattribute to the value of the expression\nurl\n. In the shorthand, everything before the argument (i.e.,\nv-bind:\n) is condensed into a single character,\n:\n.\nAnother example is the\nv-on\ndirective, which listens to DOM events:\ntemplate\n<\na\nv-on\n:\nclick\n=\n\"\ndoSomething\n\"\n> ... </\na\n>\n<!-- shorthand -->\n<\na\n@\nclick\n=\n\"\ndoSomething\n\"\n> ... </\na\n>\nHere, the argument is the event name to listen to:\nclick\n.\nv-on\nhas a corresponding shorthand, namely the\n@\ncharacter. We will talk about event handling in more detail too.\nDynamic Arguments\n\u200b\nIt is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\ntemplate\n<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<\na\nv-bind:\n[\nattributeName\n]=\n\"url\"\n> ... </\na\n>\n<!-- shorthand -->\n<\na\n:[\nattributeName\n]=\n\"url\"\n> ... </\na\n>\nHere,\nattributeName\nwill be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property,\nattributeName\n, whose value is\n\"href\"\n, then this binding will be equivalent to\nv-bind:href\n.\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\ntemplate\n<\na\nv-on:\n[\neventName\n]=\n\"doSomething\"\n> ... </\na\n>\n<!-- shorthand -->\n<\na\n@[\neventName\n]=\n\"doSomething\"\n> ... </\na\n>\nIn this example, when\neventName\n's value is\n\"focus\"\n,\nv-on:[eventName]\nwill be equivalent to\nv-on:focus\n.\nDynamic Argument Value Constraints\n\u200b\nDynamic arguments are expected to evaluate to a string, with the exception of\nnull\n. The special value\nnull\ncan be used to explicitly remove the binding. Any other non-string value will trigger a warning.\nDynamic Argument Syntax Constraints\n\u200b\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\ntemplate\n<!-- This will trigger a compiler warning. -->\n<\na\n:[\n'foo'\n+\nbar\n]=\n\"value\"\n> ... </\na\n>\nIf you need to pass a complex dynamic argument, it's probably better to use a\ncomputed property\n, which we will cover shortly.\nWhen using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\ntemplate\n<\na\n:[\nsomeAttr\n]=\n\"value\"\n> ... </\na\n>\nThe above will be converted to\n:[someattr]\nin in-DOM templates. If your component has a\nsomeAttr\nproperty instead of\nsomeattr\n, your code won't work. Templates inside Single-File Components are\nnot\nsubject to this constraint.\nModifiers\n\u200b\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the\n.prevent\nmodifier tells the\nv-on\ndirective to call\nevent.preventDefault()\non the triggered event:\ntemplate\n<\nform\n@\nsubmit\n.\nprevent\n=\n\"\nonSubmit\n\"\n>...</\nform\n>\nYou'll see other examples of modifiers later,\nfor\nv-on\nand\nfor\nv-model\n, when we explore those features.\nAnd finally, here's the full directive syntax visualized:\nEdit this page on GitHub",
  "content_markdown": "# Template Syntax [\u200b](#template-syntax)\n\n[Watch an interactive video lesson on Scrimba](https://scrimba.com/links/vue-template-syntax \"Free Vue.js Template Syntax Lesson\")\n\nVue uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue templates are syntactically valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\n\nUnder the hood, Vue compiles the templates into highly-optimized JavaScript code. Combined with the reactivity system, Vue can intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\n\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also [directly write render functions](/guide/extras/render-function) instead of templates, with optional JSX support. However, do note that they do not enjoy the same level of compile-time optimizations as templates.\n\n## Text Interpolation [\u200b](#text-interpolation)\n\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\n\ntemplate\n\n```\n<span>Message: {{ msg }}</span>\n```\n\nThe mustache tag will be replaced with the value of the `msg` property [from the corresponding component instance](/guide/essentials/reactivity-fundamentals#declaring-reactive-state). It will also be updated whenever the `msg` property changes.\n\n## Raw HTML [\u200b](#raw-html)\n\nThe double mustaches interpret the data as plain text, not HTML. In order to output real HTML, you will need to use the [`v-html` directive](/api/built-in-directives#v-html):\n\ntemplate\n\n```\n<p>Using text interpolation: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n\nUsing text interpolation: <span style=\"color: red\">This should be red.</span>\n\nUsing v-html directive: This should be red.\n\nHere we're encountering something new. The `v-html` attribute you're seeing is called a **directive**. Directives are prefixed with `v-` to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, we're basically saying \"keep this element's inner HTML up-to-date with the `rawHtml` property on the current active instance.\"\n\nThe contents of the `span` will be replaced with the value of the `rawHtml` property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use `v-html` to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\n\nSecurity Warning\n\nDynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS vulnerabilities](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.\n\n## Attribute Bindings [\u200b](#attribute-bindings)\n\nMustaches cannot be used inside HTML attributes. Instead, use a [`v-bind` directive](/api/built-in-directives#v-bind):\n\ntemplate\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n```\n\nThe `v-bind` directive instructs Vue to keep the element's `id` attribute in sync with the component's `dynamicId` property. If the bound value is `null` or `undefined`, then the attribute will be removed from the rendered element.\n\n### Shorthand [\u200b](#shorthand)\n\nBecause `v-bind` is so commonly used, it has a dedicated shorthand syntax:\n\ntemplate\n\n```\n<div :id=\"dynamicId\"></div>\n```\n\nAttributes that start with `:` may look a bit different from normal HTML, but it is in fact a valid character for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is optional, but you will likely appreciate it when you learn more about its usage later.\n\n> For the rest of the guide, we will be using the shorthand syntax in code examples, as that's the most common usage for Vue developers.\n\n### Same-name Shorthand [\u200b](#same-name-shorthand)\n\n- Only supported in 3.4+\n\nIf the attribute has the same name as the variable name of the JavaScript value being bound, the syntax can be further shortened to omit the attribute value:\n\ntemplate\n\n```\n<!-- same as :id=\"id\" -->\n<div :id></div>\n\n<!-- this also works -->\n<div v-bind:id></div>\n```\n\nThis is similar to the property shorthand syntax when declaring objects in JavaScript. Note this is a feature that is only available in Vue 3.4 and above.\n\n### Boolean Attributes [\u200b](#boolean-attributes)\n\n[Boolean attributes](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes) are attributes that can indicate true / false values by their presence on an element. For example, [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled) is one of the most commonly used boolean attributes.\n\n`v-bind` works a bit differently in this case:\n\ntemplate\n\n```\n<button :disabled=\"isButtonDisabled\">Button</button>\n```\n\nThe `disabled` attribute will be included if `isButtonDisabled` has a [truthy value](https://developer.mozilla.org/en-US/docs/Glossary/Truthy). It will also be included if the value is an empty string, maintaining consistency with `<button disabled=\"\">`. For other [falsy values](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) the attribute will be omitted.\n\n### Dynamically Binding Multiple Attributes [\u200b](#dynamically-binding-multiple-attributes)\n\nIf you have a JavaScript object representing multiple attributes that looks like this:\n\njs\n\n```\nconst objectOfAttrs = {\n  id: 'container',\n  class: 'wrapper',\n  style: 'background-color:green'\n}\n```\n\njs\n\n```\ndata() {\n  return {\n    objectOfAttrs: {\n      id: 'container',\n      class: 'wrapper'\n    }\n  }\n}\n```\n\nYou can bind them to a single element by using `v-bind` without an argument:\n\ntemplate\n\n```\n<div v-bind=\"objectOfAttrs\"></div>\n```\n\n## Using JavaScript Expressions [\u200b](#using-javascript-expressions)\n\nSo far we've only been binding to simple property keys in our templates. But Vue actually supports the full power of JavaScript expressions inside all data bindings:\n\ntemplate\n\n```\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div :id=\"`list-${id}`\"></div>\n```\n\nThese expressions will be evaluated as JavaScript in the data scope of the current component instance.\n\nIn Vue templates, JavaScript expressions can be used in the following positions:\n\n- Inside text interpolations (mustaches)\n- In the attribute value of any Vue directives (special attributes that start with `v-`)\n\n### Expressions Only [\u200b](#expressions-only)\n\nEach binding can only contain **one single expression**. An expression is a piece of code that can be evaluated to a value. A simple check is whether it can be used after `return`.\n\nTherefore, the following will **NOT** work:\n\ntemplate\n\n```\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\n```\n\n### Calling Functions [\u200b](#calling-functions)\n\nIt is possible to call a component-exposed method inside a binding expression:\n\ntemplate\n\n```\n<time :title=\"toTitleDate(date)\" :datetime=\"date\">\n  {{ formatDate(date) }}\n</time>\n```\n\nTIP\n\nFunctions called inside binding expressions will be called every time the component updates, so they should **not** have any side effects, such as changing data or triggering asynchronous operations.\n\n### Restricted Globals Access [\u200b](#restricted-globals-access)\n\nTemplate expressions are sandboxed and only have access to a [restricted list of globals](https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3). The list exposes commonly used built-in globals such as `Math` and `Date`.\n\nGlobals not explicitly included in the list, for example user-attached properties on `window`, will not be accessible in template expressions. You can, however, explicitly define additional globals for all Vue expressions by adding them to [`app.config.globalProperties`](/api/application#app-config-globalproperties).\n\n## Directives [\u200b](#directives)\n\nDirectives are special attributes with the `v-` prefix. Vue provides a number of [built-in directives](/api/built-in-directives), including `v-html` and `v-bind` which we have introduced above.\n\nDirective attribute values are expected to be single JavaScript expressions (with the exception of `v-for`, `v-on` and `v-slot`, which will be discussed in their respective sections later). A directive's job is to reactively apply updates to the DOM when the value of its expression changes. Take [`v-if`](/api/built-in-directives#v-if) as an example:\n\ntemplate\n\n```\n<p v-if=\"seen\">Now you see me</p>\n```\n\nHere, the `v-if` directive would remove or insert the `<p>` element based on the truthiness of the value of the expression `seen`.\n\n### Arguments [\u200b](#arguments)\n\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the `v-bind` directive is used to reactively update an HTML attribute:\n\ntemplate\n\n```\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>\n```\n\nHere, `href` is the argument, which tells the `v-bind` directive to bind the element's `href` attribute to the value of the expression `url`. In the shorthand, everything before the argument (i.e., `v-bind:`) is condensed into a single character, `:`.\n\nAnother example is the `v-on` directive, which listens to DOM events:\n\ntemplate\n\n```\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>\n```\n\nHere, the argument is the event name to listen to: `click`. `v-on` has a corresponding shorthand, namely the `@` character. We will talk about event handling in more detail too.\n\n### Dynamic Arguments [\u200b](#dynamic-arguments)\n\nIt is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n\ntemplate\n\n```\n<!--\nNote that there are some constraints to the argument expression,\nas explained in the \"Dynamic Argument Value Constraints\" and \"Dynamic Argument Syntax Constraints\" sections below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :[attributeName]=\"url\"> ... </a>\n```\n\nHere, `attributeName` will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, `attributeName`, whose value is `\"href\"`, then this binding will be equivalent to `v-bind:href`.\n\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n\ntemplate\n\n```\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @[eventName]=\"doSomething\"> ... </a>\n```\n\nIn this example, when `eventName`'s value is `\"focus\"`, `v-on:[eventName]` will be equivalent to `v-on:focus`.\n\n#### Dynamic Argument Value Constraints [\u200b](#dynamic-argument-value-constraints)\n\nDynamic arguments are expected to evaluate to a string, with the exception of `null`. The special value `null` can be used to explicitly remove the binding. Any other non-string value will trigger a warning.\n\n#### Dynamic Argument Syntax Constraints [\u200b](#dynamic-argument-syntax-constraints)\n\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n\ntemplate\n\n```\n<!-- This will trigger a compiler warning. -->\n<a :['foo' + bar]=\"value\"> ... </a>\n```\n\nIf you need to pass a complex dynamic argument, it's probably better to use a [computed property](/guide/essentials/computed), which we will cover shortly.\n\nWhen using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n\ntemplate\n\n```\n<a :[someAttr]=\"value\"> ... </a>\n```\n\nThe above will be converted to `:[someattr]` in in-DOM templates. If your component has a `someAttr` property instead of `someattr`, your code won't work. Templates inside Single-File Components are **not** subject to this constraint.\n\n### Modifiers [\u200b](#modifiers)\n\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the `.prevent` modifier tells the `v-on` directive to call `event.preventDefault()` on the triggered event:\n\ntemplate\n\n```\n<form @submit.prevent=\"onSubmit\">...</form>\n```\n\nYou'll see other examples of modifiers later, [for `v-on`](/guide/essentials/event-handling#event-modifiers) and [for `v-model`](/guide/essentials/forms#modifiers), when we explore those features.\n\nAnd finally, here's the full directive syntax visualized:\n\n![directive syntax graph](/assets/directive.DtZKvoAo.png)\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/template-syntax.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:48.925902+00:00",
  "content_length": 11237,
  "content_hash": "327fdb473d9c1fc4"
}