{
  "id": "vue-patterns__guide_essentials_event-handling_html",
  "source_id": "vue-patterns",
  "source_name": "Vue.js Patterns",
  "category": "framework_specific",
  "url": "https://vuejs.org/guide/essentials/event-handling.html",
  "title": "Event Handling\u200b",
  "content": "Event Handling\n\u200b\nWatch a free video lesson on Vue School\nWatch a free video lesson on Vue School\nListening to Events\n\u200b\nWe can use the\nv-on\ndirective, which we typically shorten to the\n@\nsymbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be\nv-on:click=\"handler\"\nor with the shortcut,\n@click=\"handler\"\n.\nThe handler value can be one of the following:\nInline handlers:\nInline JavaScript to be executed when the event is triggered (similar to the native\nonclick\nattribute).\nMethod handlers:\nA property name or path that points to a method defined on the component.\nInline Handlers\n\u200b\nInline handlers are typically used in simple cases, for example:\njs\nconst\ncount\n=\nref\n(\n0\n)\njs\ndata\n() {\nreturn\n{\ncount:\n0\n}\n}\ntemplate\n<\nbutton\n@\nclick\n=\n\"\ncount\n++\n\"\n>Add 1</\nbutton\n>\n<\np\n>Count is: {{ count }}</\np\n>\nTry it in the Playground\nTry it in the Playground\nMethod Handlers\n\u200b\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why\nv-on\ncan also accept the name or path of a component method you'd like to call.\nFor example:\njs\nconst\nname\n=\nref\n(\n'Vue.js'\n)\nfunction\ngreet\n(\nevent\n) {\nalert\n(\n`Hello ${\nname\n.\nvalue\n}!`\n)\n// `event` is the native DOM event\nif\n(event) {\nalert\n(event.target.tagName)\n}\n}\njs\ndata\n() {\nreturn\n{\nname:\n'Vue.js'\n}\n},\nmethods\n: {\ngreet\n(event) {\n// `this` inside methods points to the current active instance\nalert\n(\n`Hello ${\nthis\n.\nname\n}!`\n)\n// `event` is the native DOM event\nif\n(event) {\nalert\n(event.target.tagName)\n}\n}\n}\ntemplate\n<!-- `greet` is the name of the method defined above -->\n<\nbutton\n@\nclick\n=\n\"\ngreet\n\"\n>Greet</\nbutton\n>\nTry it in the Playground\nTry it in the Playground\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via\nevent.target\n.\nSee also:\nTyping Event Handlers\nSee also:\nTyping Event Handlers\nMethod vs. Inline Detection\n\u200b\nThe template compiler detects method handlers by checking whether the\nv-on\nvalue string is a valid JavaScript identifier or property access path. For example,\nfoo\n,\nfoo.bar\nand\nfoo['bar']\nare treated as method handlers, while\nfoo()\nand\ncount++\nare treated as inline handlers.\nCalling Methods in Inline Handlers\n\u200b\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\njs\nfunction\nsay\n(\nmessage\n) {\nalert\n(message)\n}\njs\nmethods\n: {\nsay\n(message) {\nalert\n(message)\n}\n}\ntemplate\n<\nbutton\n@\nclick\n=\n\"\nsay\n(\n'hello'\n)\n\"\n>Say hello</\nbutton\n>\n<\nbutton\n@\nclick\n=\n\"\nsay\n(\n'bye'\n)\n\"\n>Say bye</\nbutton\n>\nTry it in the Playground\nTry it in the Playground\nAccessing Event Argument in Inline Handlers\n\u200b\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special\n$event\nvariable, or use an inline arrow function:\ntemplate\n<!-- using $event special variable -->\n<\nbutton\n@\nclick\n=\n\"\nwarn\n(\n'Form cannot be submitted yet.'\n, $event)\n\"\n>\nSubmit\n</\nbutton\n>\n<!-- using inline arrow function -->\n<\nbutton\n@\nclick\n=\n\"\n(\nevent\n)\n=>\nwarn\n(\n'Form cannot be submitted yet.'\n, event)\n\"\n>\nSubmit\n</\nbutton\n>\njs\nfunction\nwarn\n(\nmessage\n,\nevent\n) {\n// now we have access to the native event\nif\n(event) {\nevent.\npreventDefault\n()\n}\nalert\n(message)\n}\njs\nmethods\n: {\nwarn\n(message, event) {\n// now we have access to the native event\nif\n(event) {\nevent.\npreventDefault\n()\n}\nalert\n(message)\n}\n}\nEvent Modifiers\n\u200b\nIt is a very common need to call\nevent.preventDefault()\nor\nevent.stopPropagation()\ninside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\nTo address this problem, Vue provides\nevent modifiers\nfor\nv-on\n. Recall that modifiers are directive postfixes denoted by a dot.\n.stop\n.prevent\n.self\n.capture\n.once\n.passive\ntemplate\n<!-- the click event's propagation will be stopped -->\n<\na\n@\nclick\n.\nstop\n=\n\"\ndoThis\n\"\n></\na\n>\n<!-- the submit event will no longer reload the page -->\n<\nform\n@\nsubmit\n.\nprevent\n=\n\"\nonSubmit\n\"\n></\nform\n>\n<!-- modifiers can be chained -->\n<\na\n@\nclick\n.stop.\nprevent\n=\n\"\ndoThat\n\"\n></\na\n>\n<!-- just the modifier -->\n<\nform\n@\nsubmit\n.\nprevent\n></\nform\n>\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<\ndiv\n@\nclick\n.\nself\n=\n\"\ndoThat\n\"\n>...</\ndiv\n>\nTIP\nOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using\n@click.prevent.self\nwill prevent\nclick's default action on the element itself and its children\n, while\n@click.self.prevent\nwill only prevent click's default action on the element itself.\nThe\n.capture\n,\n.once\n, and\n.passive\nmodifiers mirror the\noptions of the native\naddEventListener\nmethod\n:\ntemplate\n<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<\ndiv\n@\nclick\n.\ncapture\n=\n\"\ndoThis\n\"\n>...</\ndiv\n>\n<!-- the click event will be triggered at most once -->\n<\na\n@\nclick\n.\nonce\n=\n\"\ndoThis\n\"\n></\na\n>\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<\ndiv\n@\nscroll\n.\npassive\n=\n\"\nonScroll\n\"\n>...</\ndiv\n>\nThe\n.passive\nmodifier is typically used with touch event listeners for\nimproving performance on mobile devices\n.\nTIP\nDo not use\n.passive\nand\n.prevent\ntogether, because\n.passive\nalready indicates to the browser that you\ndo not\nintend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.\nKey Modifiers\n\u200b\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for\nv-on\nor\n@\nwhen listening for key events:\ntemplate\n<!-- only call `submit` when the `key` is `Enter` -->\n<\ninput\n@\nkeyup\n.\nenter\n=\n\"\nsubmit\n\"\n/>\nYou can directly use any valid key names exposed via\nKeyboardEvent.key\nas modifiers by converting them to kebab-case.\ntemplate\n<\ninput\n@\nkeyup\n.\npage-down\n=\n\"\nonPageDown\n\"\n/>\nIn the above example, the handler will only be called if\n$event.key\nis equal to\n'PageDown'\n.\nKey Aliases\n\u200b\nVue provides aliases for the most commonly used keys:\n.enter\n.tab\n.delete\n(captures both \"Delete\" and \"Backspace\" keys)\n.esc\n.space\n.up\n.down\n.left\n.right\nSystem Modifier Keys\n\u200b\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n.ctrl\n.alt\n.shift\n.meta\nNote\nOn Macintosh keyboards, meta is the command key (\u2318). On Windows keyboards, meta is the Windows key (\u229e). On Sun Microsystems keyboards, meta is marked as a solid diamond (\u25c6). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled \u201cMETA\u201d. On Symbolics keyboards, meta is labeled \u201cMETA\u201d or \u201cMeta\u201d.\nFor example:\ntemplate\n<!-- Alt + Enter -->\n<\ninput\n@\nkeyup\n.alt.\nenter\n=\n\"\nclear\n\"\n/>\n<!-- Ctrl + Click -->\n<\ndiv\n@\nclick\n.\nctrl\n=\n\"\ndoSomething\n\"\n>Do something</\ndiv\n>\nTIP\nNote that modifier keys are different from regular keys and when used with\nkeyup\nevents, they have to be pressed when the event is emitted. In other words,\nkeyup.ctrl\nwill only trigger if you release a key while holding down\nctrl\n. It won't trigger if you release the\nctrl\nkey alone.\n.exact\nModifier\n\u200b\nThe\n.exact\nmodifier allows control of the exact combination of system modifiers needed to trigger an event.\ntemplate\n<!-- this will fire even if Alt or Shift is also pressed -->\n<\nbutton\n@\nclick\n.\nctrl\n=\n\"\nonClick\n\"\n>A</\nbutton\n>\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<\nbutton\n@\nclick\n.ctrl.\nexact\n=\n\"\nonCtrlClick\n\"\n>A</\nbutton\n>\n<!-- this will only fire when no system modifiers are pressed -->\n<\nbutton\n@\nclick\n.\nexact\n=\n\"\nonClick\n\"\n>A</\nbutton\n>\nMouse Button Modifiers\n\u200b\n.left\n.right\n.middle\nThese modifiers restrict the handler to events triggered by a specific mouse button.\nNote, however, that\n.left\n,\n.right\n, and\n.middle\nmodifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the\n.left\nmodifier handler. Or a trackpad might trigger the\n.left\nhandler with a one-finger tap, the\n.right\nhandler with a two-finger tap, and the\n.middle\nhandler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever.\nEdit this page on GitHub",
  "content_markdown": "# Event Handling [\u200b](#event-handling)\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/user-events-in-vue-3?friend=vuejs \"Free Vue.js Events Lesson\")\n\n[Watch a free video lesson on Vue School](https://vueschool.io/lessons/vue-fundamentals-capi-user-events-in-vue-3?friend=vuejs \"Free Vue.js Events Lesson\")\n\n## Listening to Events [\u200b](#listening-to-events)\n\nWe can use the `v-on` directive, which we typically shorten to the `@` symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be `v-on:click=\"handler\"` or with the shortcut, `@click=\"handler\"`.\n\nThe handler value can be one of the following:\n\n1. **Inline handlers:** Inline JavaScript to be executed when the event is triggered (similar to the native `onclick` attribute).\n2. **Method handlers:** A property name or path that points to a method defined on the component.\n\n## Inline Handlers [\u200b](#inline-handlers)\n\nInline handlers are typically used in simple cases, for example:\n\njs\n\n```\nconst count = ref(0)\n```\n\njs\n\n```\ndata() {\n  return {\n    count: 0\n  }\n}\n```\n\ntemplate\n\n```\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNo9jssKgzAURH/lko0tgrbbEqX+Q5fZaLxiqHmQ3LgJ+fdqFZcD58xMYp1z1RqRvRgP0itHEJCia4VR2llPkMDjBBkmbzUUG1oII4y0JhBIGw2hh2Znbo+7MLw+WjZ/C4TaLT3hnogPkcgaeMtFyW8j2GmXpWBtN47w5PWBHLhrPzPCKfWDXRHmPsCAaOBfgSOkdH3IGUhpDBWv9/e8vsZZ/gFFhFJN)\n\n[Try it in the Playground](https://play.vuejs.org/#eNo9jcEKgzAQRH9lyKlF0PYqqdR/6DGXaLYo1RjiRgrivzepIizLzu7sm1XUzuVLIFEKObe+d1wpS183eYahtw4DY1UWMJr15ZpmxYAnDt7uF0BxOwXL5Evc0kbxlmyxxZLFyY2CaXSDZkqKZROYJ4tnO/Tt56HEgckyJaraGNxlsVt2u6teHeF40s20EDo9oyGy+CPIYF1xULBt4H6kOZeFiwBZnOFi+wH0B1hk)\n\n## Method Handlers [\u200b](#method-handlers)\n\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why `v-on` can also accept the name or path of a component method you'd like to call.\n\nFor example:\n\njs\n\n```\nconst name = ref('Vue.js')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` is the native DOM event\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\n```\n\njs\n\n```\ndata() {\n  return {\n    name: 'Vue.js'\n  }\n},\nmethods: {\n  greet(event) {\n    // `this` inside methods points to the current active instance\n    alert(`Hello ${this.name}!`)\n    // `event` is the native DOM event\n    if (event) {\n      alert(event.target.tagName)\n    }\n  }\n}\n```\n\ntemplate\n\n```\n<!-- `greet` is the name of the method defined above -->\n<button @click=\"greet\">Greet</button>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNpVj0FLxDAQhf/KMwjtXtq7dBcFQS/qzVMOrWFao2kSkkkvpf/dJIuCEBgm771vZnbx4H23JRJ3YogqaM+IxMlfpNWrd4GxI9CMA3NwK5psbaSVVjkbGXZaCediaJv3RN1XbE5FnZNVrJ3FEoi4pY0sn7BLC0yGArfjMxnjcLsXQrdNJtFxM+Ys0PcYa2CEjuBPylNYb4THtxdUobj0jH/YX3D963gKC5WyvGZ+xR7S5jf01yPzeblhWr2ZmErHw0dizivfK6PV91mKursUl6dSh/4qZ+vQ/+XE8QODonDi)\n\n[Try it in the Playground](https://play.vuejs.org/#eNplUE1LxDAQ/StjEbYL0t5LXRQEvag3Tz00prNtNE1CMilC6X83SUkRhJDJfLz3Jm8tHo2pFo9FU7SOW2Ho0in8MdoSDHhlXhKsnQIYGLHyvL8BLJK3KmcAis3YwOnDY/XlTnt1i2G7i/eMNOnBNRkwWkQqcUFFByVAXUNPk3A9COXEgBkGRgtFDkgDTQjcWxuAwDiJBeMsMcUxszCJlsr+BaXUcLtGwiqut930579KST1IBd5Aqlgie3p/hdTIk+IK//bMGqleEbMjxjC+BZVDIv0+m9CpcNr6MDgkhLORjDBm1H56Iq3ggUvBv++7IhnUFZfnGNt6b4fRtj5wxfYL9p+Sjw==)\n\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via `event.target`.\n\nSee also: [Typing Event Handlers](/guide/typescript/composition-api#typing-event-handlers)\n\nSee also: [Typing Event Handlers](/guide/typescript/options-api#typing-event-handlers)\n\n### Method vs. Inline Detection [\u200b](#method-vs-inline-detection)\n\nThe template compiler detects method handlers by checking whether the `v-on` value string is a valid JavaScript identifier or property access path. For example, `foo`, `foo.bar` and `foo['bar']` are treated as method handlers, while `foo()` and `count++` are treated as inline handlers.\n\n## Calling Methods in Inline Handlers [\u200b](#calling-methods-in-inline-handlers)\n\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\n\njs\n\n```\nfunction say(message) {\n  alert(message)\n}\n```\n\njs\n\n```\nmethods: {\n  say(message) {\n    alert(message)\n  }\n}\n```\n\ntemplate\n\n```\n<button @click=\"say('hello')\">Say hello</button>\n<button @click=\"say('bye')\">Say bye</button>\n```\n\n[Try it in the Playground](https://play.vuejs.org/#eNp9jTEOwjAMRa8SeSld6I5CBWdg9ZJGBiJSN2ocpKjq3UmpFDGx+Vn//b/ANYTjOxGcQEc7uyAqkqTQI98TW3ETq2jyYaQYzYNatSArZTzNUn/IK7Ludr2IBYTG4I3QRqKHJFJ6LtY7+zojbIXNk7yfmhahv5msvqS7PfnHGjJVp9w/hu7qKKwfEd1NSg==)\n\n[Try it in the Playground](https://play.vuejs.org/#eNptjUEKwjAQRa8yZFO7sfsSi57B7WzGdjTBtA3NVC2ldzehEFwIw8D7vM9f1cX742tmVSsd2sl6aXDgjx8ngY7vNDuBFQeAnsWMXagToQAEWg49h0APLncDAIUcT5LzlKJsqRBfPF3ljQjCvXcknEj0bRYZBzi3zrbPE6o0UBhblKiaKy1grK52J/oA//23IcmNBD8dXeVBtX0BF0pXsg==)\n\n## Accessing Event Argument in Inline Handlers [\u200b](#accessing-event-argument-in-inline-handlers)\n\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special `$event` variable, or use an inline arrow function:\n\ntemplate\n\n```\n<!-- using $event special variable -->\n<button @click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n\n<!-- using inline arrow function -->\n<button @click=\"(event) => warn('Form cannot be submitted yet.', event)\">\n  Submit\n</button>\n```\n\njs\n\n```\nfunction warn(message, event) {\n  // now we have access to the native event\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n```\n\njs\n\n```\nmethods: {\n  warn(message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n## Event Modifiers [\u200b](#event-modifiers)\n\nIt is a very common need to call `event.preventDefault()` or `event.stopPropagation()` inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides **event modifiers** for `v-on`. Recall that modifiers are directive postfixes denoted by a dot.\n\n- `.stop`\n- `.prevent`\n- `.self`\n- `.capture`\n- `.once`\n- `.passive`\n\ntemplate\n\n```\n<!-- the click event's propagation will be stopped -->\n<a @click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form @submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a @click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form @submit.prevent></form>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div @click.self=\"doThat\">...</div>\n```\n\nTIP\n\nOrder matters when using modifiers because the relevant code is generated in the same order. Therefore using `@click.prevent.self` will prevent **click's default action on the element itself and its children**, while `@click.self.prevent` will only prevent click's default action on the element itself.\n\nThe `.capture`, `.once`, and `.passive` modifiers mirror the [options of the native `addEventListener` method](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options):\n\ntemplate\n\n```\n<!-- use capture mode when adding the event listener     -->\n<!-- i.e. an event targeting an inner element is handled -->\n<!-- here before being handled by that element           -->\n<div @click.capture=\"doThis\">...</div>\n\n<!-- the click event will be triggered at most once -->\n<a @click.once=\"doThis\"></a>\n\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div @scroll.passive=\"onScroll\">...</div>\n```\n\nThe `.passive` modifier is typically used with touch event listeners for [improving performance on mobile devices](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#improving_scroll_performance_using_passive_listeners).\n\nTIP\n\nDo not use `.passive` and `.prevent` together, because `.passive` already indicates to the browser that you *do not* intend to prevent the event's default behavior, and you will likely see a warning from the browser if you do so.\n\n## Key Modifiers [\u200b](#key-modifiers)\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for `v-on` or `@` when listening for key events:\n\ntemplate\n\n```\n<!-- only call `submit` when the `key` is `Enter` -->\n<input @keyup.enter=\"submit\" />\n```\n\nYou can directly use any valid key names exposed via [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values) as modifiers by converting them to kebab-case.\n\ntemplate\n\n```\n<input @keyup.page-down=\"onPageDown\" />\n```\n\nIn the above example, the handler will only be called if `$event.key` is equal to `'PageDown'`.\n\n### Key Aliases [\u200b](#key-aliases)\n\nVue provides aliases for the most commonly used keys:\n\n- `.enter`\n- `.tab`\n- `.delete` (captures both \"Delete\" and \"Backspace\" keys)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n### System Modifier Keys [\u200b](#system-modifier-keys)\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\nNote\n\nOn Macintosh keyboards, meta is the command key (\u2318). On Windows keyboards, meta is the Windows key (\u229e). On Sun Microsystems keyboards, meta is marked as a solid diamond (\u25c6). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled \u201cMETA\u201d. On Symbolics keyboards, meta is labeled \u201cMETA\u201d or \u201cMeta\u201d.\n\nFor example:\n\ntemplate\n\n```\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n\n<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n\nTIP\n\nNote that modifier keys are different from regular keys and when used with `keyup` events, they have to be pressed when the event is emitted. In other words, `keyup.ctrl` will only trigger if you release a key while holding down `ctrl`. It won't trigger if you release the `ctrl` key alone.\n\n### `.exact` Modifier [\u200b](#exact-modifier)\n\nThe `.exact` modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\ntemplate\n\n```\n<!-- this will fire even if Alt or Shift is also pressed -->\n<button @click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button @click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button @click.exact=\"onClick\">A</button>\n```\n\n## Mouse Button Modifiers [\u200b](#mouse-button-modifiers)\n\n- `.left`\n- `.right`\n- `.middle`\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\nNote, however, that `.left`, `.right`, and `.middle` modifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the `.left` modifier handler. Or a trackpad might trigger the `.left` handler with a one-finger tap, the `.right` handler with a two-finger tap, and the `.middle` handler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever.\n\n[Edit this page on GitHub](https://github.com/vuejs/docs/edit/main/src/guide/essentials/event-handling.md)",
  "tags": [
    "vue",
    "framework",
    "patterns"
  ],
  "extracted_at": "2026-02-03T12:55:59.397500+00:00",
  "content_length": 8960,
  "content_hash": "d9f4b5a04aa0597a"
}