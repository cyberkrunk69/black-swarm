{
  "id": "swr__docs_pagination",
  "source_id": "swr",
  "source_name": "SWR",
  "category": "loading_state_patterns",
  "url": "https://swr.vercel.app/docs/pagination",
  "title": "Pagination",
  "content": "Pagination\nPlease update to the latest version (\u2265 0.3.0) to use this API. The previous\nuseSWRPages\nAPI is now deprecated.\nSWR provides a dedicated API\nuseSWRInfinite\nto support common UI patterns such as\npagination\nand\ninfinite loading\n.\nWhen to Use\nuseSWR\nPagination\nFirst of all, we might\nNOT\nneed\nuseSWRInfinite\nbut can use just\nuseSWR\nif we are building something like this:\n...which is a typical pagination UI. Let's see how it can be easily implemented with\nuseSWR\n:\nfunction\nApp\n() {\nconst\n[\npageIndex\n,\nsetPageIndex\n]\n=\nuseState\n(\n0\n);\n// The API URL includes the page index, which is a React state.\nconst\n{\ndata\n}\n=\nuseSWR\n(\n`/api/data?page=${\npageIndex\n}`\n, fetcher);\n// ... handle loading and error states\nreturn\n<\ndiv\n>\n{data.\nmap\n(\nitem\n=>\n<\ndiv\nkey\n=\n{item.id}>{item.name}</\ndiv\n>)}\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n-\n1\n)}>Previous</\nbutton\n>\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n+\n1\n)}>Next</\nbutton\n>\n</\ndiv\n>\n}\nFurthermore, we can create an abstraction for this \"page component\":\nfunction\nPage\n({\nindex\n}) {\nconst\n{\ndata\n}\n=\nuseSWR\n(\n`/api/data?page=${\nindex\n}`\n, fetcher);\n// ... handle loading and error states\nreturn\ndata.\nmap\n(\nitem\n=>\n<\ndiv\nkey\n=\n{item.id}>{item.name}</\ndiv\n>)\n}\nfunction\nApp\n() {\nconst\n[\npageIndex\n,\nsetPageIndex\n]\n=\nuseState\n(\n0\n);\nreturn\n<\ndiv\n>\n<\nPage\nindex\n=\n{pageIndex}/>\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n-\n1\n)}>Previous</\nbutton\n>\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n+\n1\n)}>Next</\nbutton\n>\n</\ndiv\n>\n}\nBecause of SWR's cache, we get the benefit to preload the next page. We render the next page inside\na hidden div, so SWR will trigger the data fetching of the next page. When the user navigates to the next page, the data is already there:\nfunction\nApp\n() {\nconst\n[\npageIndex\n,\nsetPageIndex\n]\n=\nuseState\n(\n0\n);\nreturn\n<\ndiv\n>\n<\nPage\nindex\n=\n{pageIndex}/>\n<\ndiv\nstyle\n=\n{{ display:\n'none'\n}}><\nPage\nindex\n=\n{pageIndex\n+\n1\n}/></\ndiv\n>\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n-\n1\n)}>Previous</\nbutton\n>\n<\nbutton\nonClick\n=\n{()\n=>\nsetPageIndex\n(pageIndex\n+\n1\n)}>Next</\nbutton\n>\n</\ndiv\n>\n}\nWith just 1 line of code, we get a much better UX. The\nuseSWR\nhook is so powerful,\nthat most scenarios are covered by it.\nInfinite Loading\nSometimes we want to build an\ninfinite loading\nUI, with a \"Load More\" button that appends data\nto the list (or done automatically when you scroll):\nTo implement this, we need to make\ndynamic number of requests\non this page. React Hooks have\na couple of rules\n,\nso we\nCANNOT\ndo something like this:\nfunction\nApp\n() {\nconst\n[\ncnt\n,\nsetCnt\n]\n=\nuseState\n(\n1\n)\nconst\nlist\n=\n[]\nfor\n(\nlet\ni\n=\n0\n; i\n<\ncnt; i\n++\n) {\n// \ud83d\udea8 This is wrong! Commonly, you can't use hooks inside a loop.\nconst\n{\ndata\n}\n=\nuseSWR\n(\n`/api/data?page=${\ni\n}`\n)\nlist.\npush\n(data)\n}\nreturn\n<\ndiv\n>\n{list.\nmap\n((\ndata\n,\ni\n)\n=>\n<\ndiv\nkey\n=\n{i}>{\ndata.\nmap\n(\nitem\n=>\n<\ndiv\nkey\n=\n{item.id}>{item.name}</\ndiv\n>)\n}</\ndiv\n>)}\n<\nbutton\nonClick\n=\n{()\n=>\nsetCnt\n(cnt\n+\n1\n)}>Load More</\nbutton\n>\n</\ndiv\n>\n}\nInstead, we can use the\n<Page />\nabstraction that we created to achieve it:\nfunction\nApp\n() {\nconst\n[\ncnt\n,\nsetCnt\n]\n=\nuseState\n(\n1\n)\nconst\npages\n=\n[]\nfor\n(\nlet\ni\n=\n0\n; i\n<\ncnt; i\n++\n) {\npages.\npush\n(<\nPage\nindex\n=\n{i}\nkey\n=\n{i} />)\n}\nreturn\n<\ndiv\n>\n{pages}\n<\nbutton\nonClick\n=\n{()\n=>\nsetCnt\n(cnt\n+\n1\n)}>Load More</\nbutton\n>\n</\ndiv\n>\n}\nAdvanced Cases\nHowever, in some advanced use cases, the solution above doesn't work.\nFor example, we are still implementing the same \"Load More\" UI, but also need to display a number\nabout how many items are there in total. We can't use the\n<Page />\nsolution anymore because\nthe top level UI (\n<App />\n) needs the data inside each page:\nfunction\nApp\n() {\nconst\n[\ncnt\n,\nsetCnt\n]\n=\nuseState\n(\n1\n)\nconst\npages\n=\n[]\nfor\n(\nlet\ni\n=\n0\n; i\n<\ncnt; i\n++\n) {\npages.\npush\n(<\nPage\nindex\n=\n{i}\nkey\n=\n{i} />)\n}\nreturn\n<\ndiv\n>\n<\np\n>??? items</\np\n>\n{pages}\n<\nbutton\nonClick\n=\n{()\n=>\nsetCnt\n(cnt\n+\n1\n)}>Load More</\nbutton\n>\n</\ndiv\n>\n}\nAlso, if the pagination API is\ncursor based\n, that solution doesn't work either. Because each page\nneeds the data from the previous page, they're not isolated.\nThat's how this new\nuseSWRInfinite\nHook can help.\nuseSWRInfinite\nuseSWRInfinite\ngives us the ability to trigger a number of requests with one Hook. This is how it looks:\nimport\nuseSWRInfinite\nfrom\n'swr/infinite'\n// ...\nconst\n{\ndata\n,\nerror\n,\nisLoading\n,\nisValidating\n,\nmutate\n,\nsize\n,\nsetSize\n}\n=\nuseSWRInfinite\n(\ngetKey, fetcher\n?\n, options\n?\n)\nSimilar to\nuseSWR\n, this new Hook accepts a function that returns the request key, a fetcher function, and options.\nIt returns all the values that\nuseSWR\nreturns, including 2 extra values: the page size and a page size setter, like a React state.\nIn infinite loading, one\npage\nis one request, and our goal is to fetch multiple pages and render them.\nIf you are using SWR 0.x versions,\nuseSWRInfinite\nneeds to be imported from\nswr\n:\nimport { useSWRInfinite } from 'swr'\nAPI\nParameters\ngetKey\n: a function that accepts the index and the previous page data, returns the key of a page\nfetcher\n: same as\nuseSWR\n's\nfetcher function\noptions\n: accepts all the options that\nuseSWR\nsupports, with 4 extra options:\ninitialSize = 1\n: number of pages should be loaded initially\nrevalidateAll = false\n: always try to revalidate all pages\nrevalidateFirstPage = true\n: always try to revalidate the first page\npersistSize = false\n: don't reset the page size to 1 (or\ninitialSize\nif set) when the first page's key changes\nparallel = false\n: fetches multiple pages in parallel\nNote that the\ninitialSize\noption is not allowed to change in the lifecycle.\nReturn Values\ndata\n: an array of fetch response values of each page\nerror\n: same as\nuseSWR\n's\nerror\nisLoading\n: same as\nuseSWR\n's\nisLoading\nisValidating\n: same as\nuseSWR\n's\nisValidating\nmutate\n: same as\nuseSWR\n's bound mutate function but manipulates the data array\nsize\n: the number of pages that\nwill\nbe fetched and returned\nsetSize\n: set the number of pages that need to be fetched\nExample 1: Index Based Paginated API\nFor normal index based APIs:\nGET /users?page=0&limit=10\n[\n{ name: 'Alice', ... },\n{ name: 'Bob', ... },\n{ name: 'Cathy', ... },\n...\n]\n// A function to get the SWR key of each page,\n// its return value will be accepted by `fetcher`.\n// If `null` is returned, the request of that page won't start.\nconst\ngetKey\n=\n(\npageIndex\n,\npreviousPageData\n)\n=>\n{\nif\n(previousPageData\n&&\n!\npreviousPageData.\nlength\n)\nreturn\nnull\n// reached the end\nreturn\n`/users?page=${\npageIndex\n}&limit=10`\n// SWR key\n}\nfunction\nApp\n() {\nconst\n{\ndata\n,\nsize\n,\nsetSize\n}\n=\nuseSWRInfinite\n(getKey, fetcher)\nif\n(\n!\ndata)\nreturn\n'loading'\n// We can now calculate the number of all users\nlet\ntotalUsers\n=\n0\nfor\n(\nlet\ni\n=\n0\n; i\n<\ndata.\nlength\n; i\n++\n) {\ntotalUsers\n+=\ndata[i].\nlength\n}\nreturn\n<\ndiv\n>\n<\np\n>{totalUsers} users listed</\np\n>\n{data.\nmap\n((\nusers\n,\nindex\n)\n=>\n{\n// `data` is an array of each page's API response.\nreturn\nusers.\nmap\n(\nuser\n=>\n<\ndiv\nkey\n=\n{user.id}>{user.name}</\ndiv\n>)\n})}\n<\nbutton\nonClick\n=\n{()\n=>\nsetSize\n(size\n+\n1\n)}>Load More</\nbutton\n>\n</\ndiv\n>\n}\nThe\ngetKey\nfunction is the major difference between\nuseSWRInfinite\nand\nuseSWR\n.\nIt accepts the index of the current page, as well as the data from the previous page.\nSo both index based and cursor based pagination API can be supported nicely.\nAlso\ndata\nis no longer just one API response. It's an array of multiple API responses:\n// `data` will look like this\n[\n[\n{ name:\n'Alice'\n,\n...\n},\n{ name:\n'Bob'\n,\n...\n},\n{ name:\n'Cathy'\n,\n...\n},\n...\n],\n[\n{ name:\n'John'\n,\n...\n},\n{ name:\n'Paul'\n,\n...\n},\n{ name:\n'George'\n,\n...\n},\n...\n],\n...\n]\nExample 2: Cursor or Offset Based Paginated API\nLet's say the API now requires a cursor and returns the next cursor alongside with the data:\nGET /users?cursor=123&limit=10\n{\ndata: [\n{ name: 'Alice' },\n{ name: 'Bob' },\n{ name: 'Cathy' },\n...\n],\nnextCursor: 456\n}\nWe can change our\ngetKey\nfunction to:\nconst\ngetKey\n=\n(\npageIndex\n,\npreviousPageData\n)\n=>\n{\n// reached the end\nif\n(previousPageData\n&&\n!\npreviousPageData.data)\nreturn\nnull\n// first page, we don't have `previousPageData`\nif\n(pageIndex\n===\n0\n)\nreturn\n`/users?limit=10`\n// add the cursor to the API endpoint\nreturn\n`/users?cursor=${\npreviousPageData\n.\nnextCursor\n}&limit=10`\n}\nParallel Fetching Mode\nPlease update to the latest version (\u2265 2.1.0) to use this API.\nThe default behavior of useSWRInfinite is to fetch data for each page in sequence, as key creation is based on the previously fetched data. However, fetching data sequentially for a large number of pages may not be optimal, particularly if the pages are not interdependent. By specifying\nparallel\noption to\ntrue\nwill let you fetch pages independently in parallel, which can significantly speed up the loading process.\n// parallel = false (default)\n// page1 ===> page2 ===> page3 ===> done\n//\n// parallel = true\n// page1 ==> done\n// page2 =====> done\n// page3 ===> done\n//\n// previousPageData is always `null`\nconst\ngetKey\n=\n(\npageIndex\n,\npreviousPageData\n)\n=>\n{\nreturn\n`/users?page=${\npageIndex\n}&limit=10`\n}\nfunction\nApp\n() {\nconst\n{\ndata\n}\n=\nuseSWRInfinite\n(getKey, fetcher, { parallel:\ntrue\n})\n}\nThe\npreviousPageData\nargument of the\ngetKey\nfunction becomes\nnull\nwhen you enable the\nparallel\noption.\nRevalidate Specific Pages\nPlease update to the latest version (\u2265 2.2.5) to use this API.\nThe default behavior of the mutation of\nuseSWRInfinite\nis to revalidate all pages that have been loaded. But you might want to revalidate only the specific pages that have been changed. You can revalidate only specific pages by passing a function to the\nrevalidate\noption.\nThe\nrevalidate\nfunction is called for each page.\nfunction\nApp\n() {\nconst\n{\ndata\n,\nmutate\n,\nsize\n}\n=\nuseSWRInfinite\n(\n(\nindex\n)\n=>\n[\n`/api/?page=${\nindex\n+\n1\n}`\n, index\n+\n1\n],\nfetcher\n);\nmutate\n(data, {\n// only revalidate the last page\nrevalidate\n: (\npageData\n, [\nurl\n,\npage\n])\n=>\npage\n===\nsize\n});\n}\nGlobal Mutate with\nuseSWRInfinite\nuseSWRInfinite\nstores all page data into the cache with a special cache key along with each page data, so you have to use\nunstable_serialize\nin\nswr/infinite\nto revalidate the data with the global mutate.\nimport\n{ useSWRConfig }\nfrom\n\"swr\"\nimport\n{ unstable_serialize }\nfrom\n\"swr/infinite\"\nfunction\nApp\n() {\nconst\n{\nmutate\n}\n=\nuseSWRConfig\n()\nmutate\n(\nunstable_serialize\n(getKey))\n}\nAs the name implies,\nunstable_serialize\nis not a stable API, so we might change it in the future.\nAdvanced Features\nHere is an example\nshowing how you can implement the following features with\nuseSWRInfinite\n:\nloading states\nshow a special UI if it's empty\ndisable the \"Load More\" button if reached the end\nchangeable data source\nrefresh the entire list",
  "content_markdown": "# Pagination\n\nPlease update to the latest version (\u2265 0.3.0) to use this API. The previous `useSWRPages` API is now deprecated.\n\nSWR provides a dedicated API `useSWRInfinite` to support common UI patterns such as **pagination** and **infinite loading**.\n\n## [When to Use `useSWR`](#when-to-use-useswr)\n\n### [Pagination](#pagination)\n\nFirst of all, we might **NOT** need `useSWRInfinite` but can use just `useSWR` if we are building something like this:\n\n...which is a typical pagination UI. Let's see how it can be easily implemented with\n`useSWR`:\n\n```\nfunction App () {\n  const [pageIndex, setPageIndex] = useState(0);\n\n  // The API URL includes the page index, which is a React state.\n  const { data } = useSWR(`/api/data?page=${pageIndex}`, fetcher);\n\n  // ... handle loading and error states\n\n  return <div>\n    {data.map(item => <div key={item.id}>{item.name}</div>)}\n    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>\n    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>\n  </div>\n}\n```\n\nFurthermore, we can create an abstraction for this \"page component\":\n\n```\nfunction Page ({ index }) {\n  const { data } = useSWR(`/api/data?page=${index}`, fetcher);\n\n  // ... handle loading and error states\n\n  return data.map(item => <div key={item.id}>{item.name}</div>)\n}\n\nfunction App () {\n  const [pageIndex, setPageIndex] = useState(0);\n\n  return <div>\n    <Page index={pageIndex}/>\n    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>\n    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>\n  </div>\n}\n```\n\nBecause of SWR's cache, we get the benefit to preload the next page. We render the next page inside\na hidden div, so SWR will trigger the data fetching of the next page. When the user navigates to the next page, the data is already there:\n\n```\nfunction App () {\n  const [pageIndex, setPageIndex] = useState(0);\n\n  return <div>\n    <Page index={pageIndex}/>\n    <div style={{ display: 'none' }}><Page index={pageIndex + 1}/></div>\n    <button onClick={() => setPageIndex(pageIndex - 1)}>Previous</button>\n    <button onClick={() => setPageIndex(pageIndex + 1)}>Next</button>\n  </div>\n}\n```\n\nWith just 1 line of code, we get a much better UX. The `useSWR` hook is so powerful,\nthat most scenarios are covered by it.\n\n### [Infinite Loading](#infinite-loading)\n\nSometimes we want to build an **infinite loading** UI, with a \"Load More\" button that appends data\nto the list (or done automatically when you scroll):\n\nTo implement this, we need to make **dynamic number of requests** on this page. React Hooks have [a couple of rules](https://react.dev/reference/rules/rules-of-hooks),\nso we **CANNOT** do something like this:\n\n```\nfunction App () {\n  const [cnt, setCnt] = useState(1)\n\n  const list = []\n  for (let i = 0; i < cnt; i++) {\n    // \ud83d\udea8 This is wrong! Commonly, you can't use hooks inside a loop.\n    const { data } = useSWR(`/api/data?page=${i}`)\n    list.push(data)\n  }\n\n  return <div>\n    {list.map((data, i) =>\n      <div key={i}>{\n        data.map(item => <div key={item.id}>{item.name}</div>)\n      }</div>)}\n    <button onClick={() => setCnt(cnt + 1)}>Load More</button>\n  </div>\n}\n```\n\nInstead, we can use the `<Page />` abstraction that we created to achieve it:\n\n```\nfunction App () {\n  const [cnt, setCnt] = useState(1)\n\n  const pages = []\n  for (let i = 0; i < cnt; i++) {\n    pages.push(<Page index={i} key={i} />)\n  }\n\n  return <div>\n    {pages}\n    <button onClick={() => setCnt(cnt + 1)}>Load More</button>\n  </div>\n}\n```\n\n### [Advanced Cases](#advanced-cases)\n\nHowever, in some advanced use cases, the solution above doesn't work.\n\nFor example, we are still implementing the same \"Load More\" UI, but also need to display a number\nabout how many items are there in total. We can't use the `<Page />` solution anymore because\nthe top level UI (`<App />`) needs the data inside each page:\n\n```\nfunction App () {\n  const [cnt, setCnt] = useState(1)\n\n  const pages = []\n  for (let i = 0; i < cnt; i++) {\n    pages.push(<Page index={i} key={i} />)\n  }\n\n  return <div>\n    <p>??? items</p>\n    {pages}\n    <button onClick={() => setCnt(cnt + 1)}>Load More</button>\n  </div>\n}\n```\n\nAlso, if the pagination API is **cursor based**, that solution doesn't work either. Because each page\nneeds the data from the previous page, they're not isolated.\n\nThat's how this new `useSWRInfinite` Hook can help.\n\n## [useSWRInfinite](#useswrinfinite)\n\n`useSWRInfinite` gives us the ability to trigger a number of requests with one Hook. This is how it looks:\n\n```\nimport useSWRInfinite from 'swr/infinite'\n\n// ...\nconst { data, error, isLoading, isValidating, mutate, size, setSize } = useSWRInfinite(\n  getKey, fetcher?, options?\n)\n```\n\nSimilar to `useSWR`, this new Hook accepts a function that returns the request key, a fetcher function, and options.\nIt returns all the values that `useSWR` returns, including 2 extra values: the page size and a page size setter, like a React state.\n\nIn infinite loading, one *page* is one request, and our goal is to fetch multiple pages and render them.\n\nIf you are using SWR 0.x versions, `useSWRInfinite` needs to be imported from `swr`:  \n`import { useSWRInfinite } from 'swr'`\n\n### [API](#api)\n\n#### [Parameters](#parameters)\n\n- `getKey`: a function that accepts the index and the previous page data, returns the key of a page\n- `fetcher`: same as `useSWR`'s [fetcher function](/en/docs/data-fetching)\n- `options`: accepts all the options that `useSWR` supports, with 4 extra options:\n  - `initialSize = 1`: number of pages should be loaded initially\n  - `revalidateAll = false`: always try to revalidate all pages\n  - `revalidateFirstPage = true`: always try to revalidate the first page\n  - `persistSize = false`: don't reset the page size to 1 (or `initialSize` if set) when the first page's key changes\n  - `parallel = false`: fetches multiple pages in parallel\n\nNote that the `initialSize` option is not allowed to change in the lifecycle.\n\n#### [Return Values](#return-values)\n\n- `data`: an array of fetch response values of each page\n- `error`: same as `useSWR`'s `error`\n- `isLoading`: same as `useSWR`'s `isLoading`\n- `isValidating`: same as `useSWR`'s `isValidating`\n- `mutate`: same as `useSWR`'s bound mutate function but manipulates the data array\n- `size`: the number of pages that *will* be fetched and returned\n- `setSize`: set the number of pages that need to be fetched\n\n### [Example 1: Index Based Paginated API](#example-1-index-based-paginated-api)\n\nFor normal index based APIs:\n\n```\nGET /users?page=0&limit=10\n[\n  { name: 'Alice', ... },\n  { name: 'Bob', ... },\n  { name: 'Cathy', ... },\n  ...\n]\n```\n\n```\n// A function to get the SWR key of each page,\n// its return value will be accepted by `fetcher`.\n// If `null` is returned, the request of that page won't start.\nconst getKey = (pageIndex, previousPageData) => {\n  if (previousPageData && !previousPageData.length) return null // reached the end\n  return `/users?page=${pageIndex}&limit=10`                    // SWR key\n}\n\nfunction App () {\n  const { data, size, setSize } = useSWRInfinite(getKey, fetcher)\n  if (!data) return 'loading'\n\n  // We can now calculate the number of all users\n  let totalUsers = 0\n  for (let i = 0; i < data.length; i++) {\n    totalUsers += data[i].length\n  }\n\n  return <div>\n    <p>{totalUsers} users listed</p>\n    {data.map((users, index) => {\n      // `data` is an array of each page's API response.\n      return users.map(user => <div key={user.id}>{user.name}</div>)\n    })}\n    <button onClick={() => setSize(size + 1)}>Load More</button>\n  </div>\n}\n```\n\nThe `getKey` function is the major difference between `useSWRInfinite` and `useSWR`.\nIt accepts the index of the current page, as well as the data from the previous page.\nSo both index based and cursor based pagination API can be supported nicely.\n\nAlso `data` is no longer just one API response. It's an array of multiple API responses:\n\n```\n// `data` will look like this\n[\n  [\n    { name: 'Alice', ... },\n    { name: 'Bob', ... },\n    { name: 'Cathy', ... },\n    ...\n  ],\n  [\n    { name: 'John', ... },\n    { name: 'Paul', ... },\n    { name: 'George', ... },\n    ...\n  ],\n  ...\n]\n```\n\n### [Example 2: Cursor or Offset Based Paginated API](#example-2-cursor-or-offset-based-paginated-api)\n\nLet's say the API now requires a cursor and returns the next cursor alongside with the data:\n\n```\nGET /users?cursor=123&limit=10\n{\n  data: [\n    { name: 'Alice' },\n    { name: 'Bob' },\n    { name: 'Cathy' },\n    ...\n  ],\n  nextCursor: 456\n}\n```\n\nWe can change our `getKey` function to:\n\n```\nconst getKey = (pageIndex, previousPageData) => {\n  // reached the end\n  if (previousPageData && !previousPageData.data) return null\n\n  // first page, we don't have `previousPageData`\n  if (pageIndex === 0) return `/users?limit=10`\n\n  // add the cursor to the API endpoint\n  return `/users?cursor=${previousPageData.nextCursor}&limit=10`\n}\n```\n\n### [Parallel Fetching Mode](#parallel-fetching-mode)\n\nPlease update to the latest version (\u2265 2.1.0) to use this API.\n\nThe default behavior of useSWRInfinite is to fetch data for each page in sequence, as key creation is based on the previously fetched data. However, fetching data sequentially for a large number of pages may not be optimal, particularly if the pages are not interdependent. By specifying `parallel` option to `true` will let you fetch pages independently in parallel, which can significantly speed up the loading process.\n\n```\n// parallel = false (default)\n// page1 ===> page2 ===> page3 ===> done\n//\n// parallel = true\n// page1 ==> done\n// page2 =====> done\n// page3 ===> done\n//\n// previousPageData is always `null`\nconst getKey = (pageIndex, previousPageData) => {\n  return `/users?page=${pageIndex}&limit=10`\n}\n\nfunction App () {\n  const { data } = useSWRInfinite(getKey, fetcher, { parallel: true })\n}\n```\n\nThe `previousPageData` argument of the `getKey` function becomes `null` when you enable the `parallel` option.\n\n### [Revalidate Specific Pages](#revalidate-specific-pages)\n\nPlease update to the latest version (\u2265 2.2.5) to use this API.\n\nThe default behavior of the mutation of `useSWRInfinite` is to revalidate all pages that have been loaded. But you might want to revalidate only the specific pages that have been changed. You can revalidate only specific pages by passing a function to the `revalidate` option.\n\nThe `revalidate` function is called for each page.\n\n```\nfunction App() {\n  const { data, mutate, size } = useSWRInfinite(\n    (index) => [`/api/?page=${index + 1}`, index + 1],\n    fetcher\n  );\n\n  mutate(data, {\n    // only revalidate the last page\n    revalidate: (pageData, [url, page]) => page === size\n  });\n}\n```\n\n### [Global Mutate with `useSWRInfinite`](#global-mutate-with-useswrinfinite)\n\n`useSWRInfinite` stores all page data into the cache with a special cache key along with each page data, so you have to use `unstable_serialize` in `swr/infinite` to revalidate the data with the global mutate.\n\n```\nimport { useSWRConfig } from \"swr\"\nimport { unstable_serialize } from \"swr/infinite\"\n\nfunction App() {\n    const { mutate } = useSWRConfig()\n    mutate(unstable_serialize(getKey))\n}\n```\n\nAs the name implies, `unstable_serialize` is not a stable API, so we might change it in the future.\n\n### [Advanced Features](#advanced-features)\n\n[Here is an example](/en/examples/infinite-loading) showing how you can implement the following features with `useSWRInfinite`:\n\n- loading states\n- show a special UI if it's empty\n- disable the \"Load More\" button if reached the end\n- changeable data source\n- refresh the entire list",
  "tags": [
    "swr",
    "vercel",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:53:06.101452+00:00",
  "content_length": 10642,
  "content_hash": "af82c739eaaf9be9"
}