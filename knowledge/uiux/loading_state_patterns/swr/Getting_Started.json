{
  "id": "swr__docs_getting-started",
  "source_id": "swr",
  "source_name": "SWR",
  "category": "loading_state_patterns",
  "url": "https://swr.vercel.app/docs/getting-started",
  "title": "Getting Started",
  "content": "Getting Started\nInstallation\nInside your React project directory, run the following:\nnpm\npnpm\nyarn\nbun\nnpm\ni\nswr\nQuick Start\nFor normal RESTful APIs with JSON data, first you need to create a\nfetcher\nfunction, which is just a wrapper of the native\nfetch\n:\nconst\nfetcher\n=\n(\n...\nargs\n)\n=>\nfetch\n(\n...\nargs).\nthen\n(\nres\n=>\nres.\njson\n())\nIf you want to use GraphQL API or libs like Axios, you can create your own fetcher function.\nCheck\nhere\nfor more examples.\nThen you can import\nuseSWR\nand start using it inside any function components:\nimport\nuseSWR\nfrom\n'swr'\nfunction\nProfile\n({\nuserId\n}) {\nconst\n{\ndata\n,\nerror\n,\nisLoading\n}\n=\nuseSWR\n(\n`/api/user/${\nuserId\n}`\n, fetcher)\nif\n(error)\nreturn\n<\ndiv\n>failed to load</\ndiv\n>\nif\n(isLoading)\nreturn\n<\ndiv\n>loading...</\ndiv\n>\n// render data\nreturn\n<\ndiv\n>hello {data.name}!</\ndiv\n>\n}\nNormally, there're 3 possible states of a request: \"loading\", \"ready\", or \"error\". You can use the value of\ndata\n,\nerror\nand\nisLoading\nto\ndetermine the current state of the request, and return the corresponding UI.\nMake It Reusable\nWhen building a web app, you might need to reuse the data in many places of the UI. It is incredibly easy to create reusable data hooks\non top of SWR:\nfunction\nuseUser\n(\nid\n) {\nconst\n{\ndata\n,\nerror\n,\nisLoading\n}\n=\nuseSWR\n(\n`/api/user/${\nid\n}`\n, fetcher)\nreturn\n{\nuser: data,\nisLoading,\nisError: error\n}\n}\nAnd use it in your components:\nfunction\nAvatar\n({\nuserId\n}) {\nconst\n{\nuser\n,\nisLoading\n,\nisError\n}\n=\nuseUser\n(userId)\nif\n(isLoading)\nreturn\n<\nSpinner\n/>\nif\n(isError)\nreturn\n<\nError\n/>\nreturn\n<\nimg\nsrc\n=\n{user.avatar} />\n}\nBy adopting this pattern, you can forget about\nfetching\ndata in the imperative way: start the request, update the loading state, and return the final result.\nInstead, your code is more declarative: you just need to specify what data is used by the component.\nExample\nIn a real-world example, our website shows a navbar and the content, both depend on\nuser\n:\nTraditionally, we fetch data once using\nuseEffect\nin the top level component, and pass it to child components via props (notice that we don't handle error state for now):\n// page component\nfunction\nPage\n({\nuserId\n}) {\nconst\n[\nuser\n,\nsetUser\n]\n=\nuseState\n(\nnull\n)\n// fetch data\nuseEffect\n(()\n=>\n{\nfetch\n(\n`/api/user/${\nuserId\n}`\n)\n.\nthen\n(\nres\n=>\nres.\njson\n())\n.\nthen\n(\ndata\n=>\nsetUser\n(data))\n}, [userId])\n// global loading state\nif\n(\n!\nuser)\nreturn\n<\nSpinner\n/>\nreturn\n<\ndiv\n>\n<\nNavbar\nuser\n=\n{user} />\n<\nContent\nuser\n=\n{user} />\n</\ndiv\n>\n}\n// child components\nfunction\nNavbar\n({\nuser\n}) {\nreturn\n<\ndiv\n>\n...\n<\nAvatar\nuser\n=\n{user} />\n</\ndiv\n>\n}\nfunction\nContent\n({\nuser\n}) {\nreturn\n<\nh1\n>Welcome back, {user.name}</\nh1\n>\n}\nfunction\nAvatar\n({\nuser\n}) {\nreturn\n<\nimg\nsrc\n=\n{user.avatar}\nalt\n=\n{user.name} />\n}\nUsually, we need to keep all the data fetching in the top level component and add props to every component deep down the tree.\nThe code will become harder to maintain if we add more data dependency to the page.\nAlthough we can avoid passing props using\nContext\n, there's still the dynamic content problem:\ncomponents inside the page content can be dynamic, and the top level component might not know what data will be needed by its child components.\nSWR solves the problem perfectly. With the\nuseUser\nhook we just created, the code can be refactored to:\n// page component\nfunction\nPage\n({\nuserId\n}) {\nreturn\n<\ndiv\n>\n<\nNavbar\nuserId\n=\n{userId} />\n<\nContent\nuserId\n=\n{userId} />\n</\ndiv\n>\n}\n// child components\nfunction\nNavbar\n({\nuserId\n}) {\nreturn\n<\ndiv\n>\n...\n<\nAvatar\nuserId\n=\n{userId} />\n</\ndiv\n>\n}\nfunction\nContent\n({\nuserId\n}) {\nconst\n{\nuser\n,\nisLoading\n}\n=\nuseUser\n(userId)\nif\n(isLoading)\nreturn\n<\nSpinner\n/>\nreturn\n<\nh1\n>Welcome back, {user.name}</\nh1\n>\n}\nfunction\nAvatar\n({\nuserId\n}) {\nconst\n{\nuser\n,\nisLoading\n}\n=\nuseUser\n(userId)\nif\n(isLoading)\nreturn\n<\nSpinner\n/>\nreturn\n<\nimg\nsrc\n=\n{user.avatar}\nalt\n=\n{user.name} />\n}\nData is now\nbound\nto the components which need the data, and all components are\nindependent\nto each other.\nAll the parent components don't need to know anything about the data or passing data around. They just render.\nThe code is much simpler and easier to maintain now.\nThe most beautiful thing is that there will be only\n1 request\nsent to the API, because they use the same SWR key and\nthe request is\ndeduped\n,\ncached\nand\nshared\nautomatically.\nAlso, the application now has the ability to refetch the data on\nuser focus or network reconnect\n!\nThat means, when the user's laptop wakes from sleep or they switch between browser tabs, the data will be refreshed automatically.",
  "content_markdown": "# Getting Started\n\n## [Installation](#installation)\n\nInside your React project directory, run the following:\n\nnpmpnpmyarnbun\n\n```\nnpm i swr\n```\n\n## [Quick Start](#quick-start)\n\nFor normal RESTful APIs with JSON data, first you need to create a `fetcher` function, which is just a wrapper of the native `fetch`:\n\n```\nconst fetcher = (...args) => fetch(...args).then(res => res.json())\n```\n\nIf you want to use GraphQL API or libs like Axios, you can create your own fetcher function.\nCheck [here](/docs/data-fetching) for more examples.\n\nThen you can import `useSWR` and start using it inside any function components:\n\n```\nimport useSWR from 'swr'\n\nfunction Profile ({ userId }) {\n  const { data, error, isLoading } = useSWR(`/api/user/${userId}`, fetcher)\n\n  if (error) return <div>failed to load</div>\n  if (isLoading) return <div>loading...</div>\n\n  // render data\n  return <div>hello {data.name}!</div>\n}\n```\n\nNormally, there're 3 possible states of a request: \"loading\", \"ready\", or \"error\". You can use the value of `data`, `error` and `isLoading` to\ndetermine the current state of the request, and return the corresponding UI.\n\n## [Make It Reusable](#make-it-reusable)\n\nWhen building a web app, you might need to reuse the data in many places of the UI. It is incredibly easy to create reusable data hooks\non top of SWR:\n\n```\nfunction useUser (id) {\n  const { data, error, isLoading } = useSWR(`/api/user/${id}`, fetcher)\n\n  return {\n    user: data,\n    isLoading,\n    isError: error\n  }\n}\n```\n\nAnd use it in your components:\n\n```\nfunction Avatar ({ userId }) {\n  const { user, isLoading, isError } = useUser(userId)\n\n  if (isLoading) return <Spinner />\n  if (isError) return <Error />\n  return <img src={user.avatar} />\n}\n```\n\nBy adopting this pattern, you can forget about **fetching** data in the imperative way: start the request, update the loading state, and return the final result.\nInstead, your code is more declarative: you just need to specify what data is used by the component.\n\n## [Example](#example)\n\nIn a real-world example, our website shows a navbar and the content, both depend on `user`:\n\nTraditionally, we fetch data once using `useEffect` in the top level component, and pass it to child components via props (notice that we don't handle error state for now):\n\n```\n// page component\n\nfunction Page ({ userId }) {\n  const [user, setUser] = useState(null)\n\n  // fetch data\n  useEffect(() => {\n    fetch(`/api/user/${userId}`)\n      .then(res => res.json())\n      .then(data => setUser(data))\n  }, [userId])\n\n  // global loading state\n  if (!user) return <Spinner/>\n\n  return <div>\n    <Navbar user={user} />\n    <Content user={user} />\n  </div>\n}\n\n// child components\n\nfunction Navbar ({ user }) {\n  return <div>\n    ...\n    <Avatar user={user} />\n  </div>\n}\n\nfunction Content ({ user }) {\n  return <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar ({ user }) {\n  return <img src={user.avatar} alt={user.name} />\n}\n```\n\nUsually, we need to keep all the data fetching in the top level component and add props to every component deep down the tree.\nThe code will become harder to maintain if we add more data dependency to the page.\n\nAlthough we can avoid passing props using [Context](https://react.dev/learn/passing-data-deeply-with-context), there's still the dynamic content problem:\ncomponents inside the page content can be dynamic, and the top level component might not know what data will be needed by its child components.\n\nSWR solves the problem perfectly. With the `useUser` hook we just created, the code can be refactored to:\n\n```\n// page component\n\nfunction Page ({ userId }) {\n  return <div>\n    <Navbar userId={userId} />\n    <Content userId={userId} />\n  </div>\n}\n\n// child components\n\nfunction Navbar ({ userId }) {\n  return <div>\n    ...\n    <Avatar userId={userId} />\n  </div>\n}\n\nfunction Content ({ userId }) {\n  const { user, isLoading } = useUser(userId)\n  if (isLoading) return <Spinner />\n  return <h1>Welcome back, {user.name}</h1>\n}\n\nfunction Avatar ({ userId }) {\n  const { user, isLoading } = useUser(userId)\n  if (isLoading) return <Spinner />\n  return <img src={user.avatar} alt={user.name} />\n}\n```\n\nData is now **bound** to the components which need the data, and all components are **independent** to each other.\nAll the parent components don't need to know anything about the data or passing data around. They just render.\nThe code is much simpler and easier to maintain now.\n\nThe most beautiful thing is that there will be only **1 request** sent to the API, because they use the same SWR key and\nthe request is **deduped**, **cached** and **shared** automatically.\n\nAlso, the application now has the ability to refetch the data on [user focus or network reconnect](/en/docs/revalidation)!\nThat means, when the user's laptop wakes from sleep or they switch between browser tabs, the data will be refreshed automatically.",
  "tags": [
    "swr",
    "vercel",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:52.964203+00:00",
  "content_length": 4558,
  "content_hash": "b6e6c75659e8b241"
}