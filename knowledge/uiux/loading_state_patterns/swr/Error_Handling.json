{
  "id": "swr__docs_error-handling",
  "source_id": "swr",
  "source_name": "SWR",
  "category": "loading_state_patterns",
  "url": "https://swr.vercel.app/docs/error-handling",
  "title": "Error Handling",
  "content": "Error Handling\nIf an error is thrown inside\nfetcher\n, it will be returned as\nerror\nby the hook.\nconst\nfetcher\n=\nurl\n=>\nfetch\n(url).\nthen\n(\nr\n=>\nr.\njson\n())\n// ...\nconst\n{\ndata\n,\nerror\n}\n=\nuseSWR\n(\n'/api/user'\n, fetcher)\nThe\nerror\nobject will be defined if the fetch promise is rejected.\nStatus Code and Error Object\nSometimes we want an API to return an error object alongside the status code.\nBoth of them are useful for the client.\nWe can customize our\nfetcher\nto return more information. If the status code is not\n2xx\n,\nwe consider it an error even if it can be parsed as JSON:\nconst\nfetcher\n=\nasync\nurl\n=>\n{\nconst\nres\n=\nawait\nfetch\n(url)\n// If the status code is not in the range 200-299,\n// we still try to parse and throw it.\nif\n(\n!\nres.ok) {\nconst\nerror\n=\nnew\nError\n(\n'An error occurred while fetching the data.'\n)\n// Attach extra info to the error object.\nerror.info\n=\nawait\nres.\njson\n()\nerror.status\n=\nres.status\nthrow\nerror\n}\nreturn\nres.\njson\n()\n}\n// ...\nconst\n{\ndata\n,\nerror\n}\n=\nuseSWR\n(\n'/api/user'\n, fetcher)\n// error.info === {\n//   message: \"You are not authorized to access this resource.\",\n//   documentation_url: \"...\"\n// }\n// error.status === 403\nNote that\ndata\nand\nerror\ncan exist at the same time. So the UI can display the existing data,\nwhile knowing the upcoming request has failed.\nHere\nwe have an example.\nError Retry\nSWR uses the\nexponential backoff algorithm\nto retry the request on error.\nThe algorithm allows the app to recover from errors quickly, but not waste resources retrying too often.\nYou can also override this behavior via the\nonErrorRetry\noption:\nuseSWR\n(\n'/api/user'\n, fetcher, {\nonErrorRetry\n: (\nerror\n,\nkey\n,\nconfig\n,\nrevalidate\n, {\nretryCount\n})\n=>\n{\n// Never retry on 404.\nif\n(error.status\n===\n404\n)\nreturn\n// Never retry for a specific key.\nif\n(key\n===\n'/api/user'\n)\nreturn\n// Only retry up to 10 times.\nif\n(retryCount\n>=\n10\n)\nreturn\n// Retry after 5 seconds.\nsetTimeout\n(()\n=>\nrevalidate\n({ retryCount }),\n5000\n)\n}\n})\nThis callback gives you the flexibility to retry based on various conditions. You can also disable it by setting\nshouldRetryOnError: false\n.\nIt's also possible to provide it via the\nGlobal Configuration\ncontext.\nGlobal Error Report\nYou can always get the\nerror\nobject inside the component reactively.\nBut in case you want to handle the error globally, to notify the UI to show a\ntoast\nor a\nsnackbar\n, or report it somewhere such as\nSentry\n,\nthere's an\nonError\nevent:\n<\nSWRConfig\nvalue\n=\n{{\nonError\n: (\nerror\n,\nkey\n)\n=>\n{\nif\n(error.status\n!==\n403\n&&\nerror.status\n!==\n404\n) {\n// We can send the error to Sentry,\n// or show a notification UI.\n}\n}\n}}>\n<\nMyApp\n/>\n</\nSWRConfig\n>",
  "content_markdown": "# Error Handling\n\nIf an error is thrown inside [`fetcher`](/en/docs/data-fetching), it will be returned as `error` by the hook.\n\n```\nconst fetcher = url => fetch(url).then(r => r.json())\n\n// ...\nconst { data, error } = useSWR('/api/user', fetcher)\n```\n\nThe `error` object will be defined if the fetch promise is rejected.\n\n## [Status Code and Error Object](#status-code-and-error-object)\n\nSometimes we want an API to return an error object alongside the status code.\nBoth of them are useful for the client.\n\nWe can customize our `fetcher` to return more information. If the status code is not `2xx`,\nwe consider it an error even if it can be parsed as JSON:\n\n```\nconst fetcher = async url => {\n  const res = await fetch(url)\n\n  // If the status code is not in the range 200-299,\n  // we still try to parse and throw it.\n  if (!res.ok) {\n    const error = new Error('An error occurred while fetching the data.')\n    // Attach extra info to the error object.\n    error.info = await res.json()\n    error.status = res.status\n    throw error\n  }\n\n  return res.json()\n}\n\n// ...\nconst { data, error } = useSWR('/api/user', fetcher)\n// error.info === {\n//   message: \"You are not authorized to access this resource.\",\n//   documentation_url: \"...\"\n// }\n// error.status === 403\n```\n\nNote that `data` and `error` can exist at the same time. So the UI can display the existing data,\nwhile knowing the upcoming request has failed.\n\n[Here](/en/examples/error-handling) we have an example.\n\n## [Error Retry](#error-retry)\n\nSWR uses the [exponential backoff algorithm](https://en.wikipedia.org/wiki/Exponential_backoff) to retry the request on error.\nThe algorithm allows the app to recover from errors quickly, but not waste resources retrying too often.\n\nYou can also override this behavior via the [onErrorRetry](/en/docs/api#options) option:\n\n```\nuseSWR('/api/user', fetcher, {\n  onErrorRetry: (error, key, config, revalidate, { retryCount }) => {\n    // Never retry on 404.\n    if (error.status === 404) return\n\n    // Never retry for a specific key.\n    if (key === '/api/user') return\n\n    // Only retry up to 10 times.\n    if (retryCount >= 10) return\n\n    // Retry after 5 seconds.\n    setTimeout(() => revalidate({ retryCount }), 5000)\n  }\n})\n```\n\nThis callback gives you the flexibility to retry based on various conditions. You can also disable it by setting `shouldRetryOnError: false`.\n\nIt's also possible to provide it via the [Global Configuration](/en/docs/global-configuration) context.\n\n## [Global Error Report](#global-error-report)\n\nYou can always get the `error` object inside the component reactively.\nBut in case you want to handle the error globally, to notify the UI to show a [toast](https://vercel.com/design/toast) or a [snackbar](https://material.io/components/snackbars), or report it somewhere such as [Sentry](https://sentry.io),\nthere's an [`onError`](/en/docs/api#options) event:\n\n```\n<SWRConfig value={{\n  onError: (error, key) => {\n    if (error.status !== 403 && error.status !== 404) {\n      // We can send the error to Sentry,\n      // or show a notification UI.\n    }\n  }\n}}>\n  <MyApp />\n</SWRConfig>\n```",
  "tags": [
    "swr",
    "vercel",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:59.320648+00:00",
  "content_length": 2639,
  "content_hash": "ffee4d66c16ca7f9"
}