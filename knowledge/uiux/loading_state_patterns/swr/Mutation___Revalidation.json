{
  "id": "swr__docs_mutation",
  "source_id": "swr",
  "source_name": "SWR",
  "category": "loading_state_patterns",
  "url": "https://swr.vercel.app/docs/mutation",
  "title": "Mutation & Revalidation",
  "content": "Mutation & Revalidation\nSWR provides the\nmutate\nand\nuseSWRMutation\nAPIs for mutating remote data and related cache.\nmutate\nThere're 2 ways to use the\nmutate\nAPI to mutate the data, the global mutate API which can mutate any key and the bound mutate API which only can mutate the data of corresponding SWR hook.\nGlobal Mutate\nThe recommended way to get the global mutator is to use the\nuseSWRConfig\nhook:\nimport\n{ useSWRConfig }\nfrom\n\"swr\"\nfunction\nApp\n() {\nconst\n{\nmutate\n}\n=\nuseSWRConfig\n()\nmutate\n(key, data, options)\n}\nYou can also import it globally:\nimport\n{ mutate }\nfrom\n\"swr\"\nfunction\nApp\n() {\nmutate\n(key, data, options)\n}\nUsing global mutator only with the\nkey\nparameter will\nnot update the cache or trigger revalidation\nunless there is a mounted SWR hook using the same key.\nBound Mutate\nBound mutate is the short path to mutate the current key with data. Which\nkey\nis bounded to the\nkey\npassing to\nuseSWR\n, and receive the\ndata\nas the first argument.\nIt is functionally equivalent to the global\nmutate\nfunction in the previous section but does not require the\nkey\nparameter:\nimport\nuseSWR\nfrom\n'swr'\nfunction\nProfile\n() {\nconst\n{\ndata\n,\nmutate\n}\n=\nuseSWR\n(\n'/api/user'\n, fetcher)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>My name is {data.name}.</\nh1\n>\n<\nbutton\nonClick\n=\n{\nasync\n()\n=>\n{\nconst\nnewName\n=\ndata.name.\ntoUpperCase\n()\n// send a request to the API to update the data\nawait\nrequestUpdateUsername\n(newName)\n// update the local data immediately and revalidate (refetch)\n// NOTE: key is not required when using useSWR's mutate as it's pre-bound\nmutate\n({\n...\ndata, name: newName })\n}}>Uppercase my name!</\nbutton\n>\n</\ndiv\n>\n)\n}\nRevalidation\nWhen you call\nmutate(key)\n(or just\nmutate()\nwith the bound mutate API) without any data, it will trigger a revalidation (mark the data as expired and trigger a refetch)\nfor the resource. This example shows how to automatically refetch the login info (e.g. inside\n<Profile/>\n)\nwhen the user clicks the \u201cLogout\u201d button:\nimport\nuseSWR, { useSWRConfig }\nfrom\n'swr'\nfunction\nApp\n() {\nconst\n{\nmutate\n}\n=\nuseSWRConfig\n()\nreturn\n(\n<\ndiv\n>\n<\nProfile\n/>\n<\nbutton\nonClick\n=\n{()\n=>\n{\n// set the cookie as expired\ndocument.cookie\n=\n'token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'\n// tell all SWRs with this key to revalidate\nmutate\n(\n'/api/user'\n)\n}}>\nLogout\n</\nbutton\n>\n</\ndiv\n>\n)\n}\nIt broadcasts to SWR hooks under the same\ncache provider\nscope. If no cache provider exists, it will broadcast to all SWR hooks.\nAPI\nParameters\nkey\n: same as\nuseSWR\n's\nkey\n, but a function behaves as\na filter function\ndata\n: data to update the client cache, or an async function for the remote mutation\noptions\n: accepts the following options\noptimisticData\n: data to immediately update the client cache, or a function that receives current data and returns the new client cache data, usually used in optimistic UI.\nrevalidate = true\n: should the cache revalidate once the asynchronous update resolves. If set to a function, the function receives\ndata\nand\nkey\n.\npopulateCache = true\n: should the result of the remote mutation be written to the cache, or a function that receives new result and current result as arguments and returns the mutation result.\nrollbackOnError = true\n: should the cache rollback if the remote mutation errors, or a function that receives the error thrown from fetcher as arguments and returns a boolean whether should rollback or not.\nthrowOnError = true\n: should the mutate call throw the error when fails.\nReturn Values\nmutate\nreturns the results the\ndata\nparameter has been resolved. The function passed to\nmutate\nwill return an updated data which is used to update the corresponding cache value. If there is an error thrown while executing the function, the error will be thrown so it can be handled appropriately.\ntry\n{\nconst\nuser\n=\nawait\nmutate\n(\n'/api/user'\n,\nupdateUser\n(newUser))\n}\ncatch\n(error) {\n// Handle an error while updating the user here\n}\nuseSWRMutation\nSWR also provides\nuseSWRMutation\nas a hook for remote mutations. The remote mutations are only triggered manually, instead of automatically like\nuseSWR\n.\nAlso, this hook doesn\u2019t share states with other\nuseSWRMutation\nhooks.\nimport\nuseSWRMutation\nfrom\n'swr/mutation'\n// Fetcher implementation.\n// The extra argument will be passed via the `arg` property of the 2nd parameter.\n// In the example below, `arg` will be `'my_token'`\nasync\nfunction\nupdateUser\n(\nurl\n, {\narg\n}\n:\n{\narg\n:\nstring\n}) {\nawait\nfetch\n(url, {\nmethod:\n'POST'\n,\nheaders: {\nAuthorization:\n`Bearer ${\narg\n}`\n}\n})\n}\nfunction\nProfile\n() {\n// A useSWR + mutate like API, but it will not start the request automatically.\nconst\n{\ntrigger\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, updateUser, options)\nreturn\n<\nbutton\nonClick\n=\n{()\n=>\n{\n// Trigger `updateUser` with a specific argument.\ntrigger\n(\n'my_token'\n)\n}}>Update User</\nbutton\n>\n}\nAPI\nParameters\nkey\n: same as\nmutate\n's\nkey\nfetcher(key, { arg })\n: an async function for remote mutation\noptions\n: an optional object with the following properties:\noptimisticData\n: same as\nmutate\n's\noptimisticData\nrevalidate = true\n: same as\nmutate\n's\nrevalidate\npopulateCache = false\n: same as\nmutate\n's\npopulateCache\n, but the default is\nfalse\nrollbackOnError = true\n: same as\nmutate\n's\nrollbackOnError\nthrowOnError = true\n: same as\nmutate\n's\nthrowOnError\nonSuccess(data, key, config)\n:\u3000 callback function when a remote mutation has been finished successfully\nonError(err, key, config)\n: callback function when a remote mutation has returned an error\nReturn Values\ndata\n: data for the given key returned from\nfetcher\nerror\n: error thrown by\nfetcher\n(or undefined)\ntrigger(arg, options)\n: a function to trigger a remote mutation\nreset\n: a function to reset the state (\ndata\n,\nerror\n,\nisMutating\n)\nisMutating\n: if there's an ongoing remote mutation\nBasic Usage\nimport\nuseSWRMutation\nfrom\n'swr/mutation'\nasync\nfunction\nsendRequest\n(\nurl\n, {\narg\n}\n:\n{\narg\n:\n{\nusername\n:\nstring\n}}) {\nreturn\nfetch\n(url, {\nmethod:\n'POST'\n,\nbody:\nJSON\n.\nstringify\n(arg)\n}).\nthen\n(\nres\n=>\nres.\njson\n())\n}\nfunction\nApp\n() {\nconst\n{\ntrigger\n,\nisMutating\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, sendRequest,\n/* options */\n)\nreturn\n(\n<\nbutton\ndisabled\n=\n{isMutating}\nonClick\n=\n{\nasync\n()\n=>\n{\ntry\n{\nconst\nresult\n=\nawait\ntrigger\n({ username:\n'johndoe'\n},\n/* options */\n)\n}\ncatch\n(e) {\n// error handling\n}\n}}\n>\nCreate User\n</\nbutton\n>\n)\n}\nIf you want to use the mutation results in rendering, you can get them from the return values of\nuseSWRMutation\n.\nconst\n{\ntrigger\n,\ndata\n,\nerror\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, sendRequest)\nuseSWRMutation\nshares a cache store with\nuseSWR\n, so it can detect and avoid race conditions between\nuseSWR\n. It also supports\nmutate\n's functionalities like optimistic updates and rollback on errors. You can pass these options\nuseSWRMutation\nand its\ntrigger\nfunction.\nconst\n{\ntrigger\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, updateUser, {\noptimisticData\n:\ncurrent\n=>\n({\n...\ncurrent, name: newName })\n})\n// or\ntrigger\n(newName, {\noptimisticData\n:\ncurrent\n=>\n({\n...\ncurrent, name: newName })\n})\nDefer loading data until needed\nYou can also use\nuseSWRMutation\nfor loading data.\nuseSWRMutation\nwon't start requesting until\ntrigger\nis called, so you can defer loading data when you actually need it.\nimport\n{ useState }\nfrom\n'react'\nimport\nuseSWRMutation\nfrom\n'swr/mutation'\nconst\nfetcher\n=\nurl\n=>\nfetch\n(url).\nthen\n(\nres\n=>\nres.\njson\n())\nconst\nPage\n=\n()\n=>\n{\nconst\n[\nshow\n,\nsetShow\n]\n=\nuseState\n(\nfalse\n)\n// data is undefined until trigger is called\nconst\n{\ndata\n:\nuser\n,\ntrigger\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, fetcher);\nreturn\n(\n<\ndiv\n>\n<\nbutton\nonClick\n=\n{()\n=>\n{\ntrigger\n();\nsetShow\n(\ntrue\n);\n}}>Show User</\nbutton\n>\n{show\n&&\nuser\n?\n<\ndiv\n>{user.name}</\ndiv\n>\n:\nnull\n}\n</\ndiv\n>\n);\n}\nOptimistic Updates\nIn many cases, applying local mutations to data is a good way to make changes\nfeel faster \u2014 no need to wait for the remote source of data.\nWith the\noptimisticData\noption, you can update your local data manually, while\nwaiting for the remote mutation to finish. Composing\nrollbackOnError\nyou can also\ncontrol when to rollback the data.\nimport\nuseSWR, { useSWRConfig }\nfrom\n'swr'\nfunction\nProfile\n() {\nconst\n{\nmutate\n}\n=\nuseSWRConfig\n()\nconst\n{\ndata\n}\n=\nuseSWR\n(\n'/api/user'\n, fetcher)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>My name is {data.name}.</\nh1\n>\n<\nbutton\nonClick\n=\n{\nasync\n()\n=>\n{\nconst\nnewName\n=\ndata.name.\ntoUpperCase\n()\nconst\nuser\n=\n{\n...\ndata, name: newName }\nconst\noptions\n=\n{\noptimisticData: user,\nrollbackOnError\n(\nerror\n) {\n// If it's timeout abort error, don't rollback\nreturn\nerror.name\n!==\n'AbortError'\n},\n}\n// updates the local data immediately\n// send a request to update the data\n// triggers a revalidation (refetch) to make sure our local data is correct\nmutate\n(\n'/api/user'\n,\nupdateFn\n(user), options);\n}}>Uppercase my name!</\nbutton\n>\n</\ndiv\n>\n)\n}\nThe\nupdateFn\nshould be a promise or asynchronous function to handle the remote mutation, it should return updated data.\nYou can also pass a function to\noptimisticData\nto make it depending on the current data:\nimport\nuseSWR, { useSWRConfig }\nfrom\n'swr'\nfunction\nProfile\n() {\nconst\n{\nmutate\n}\n=\nuseSWRConfig\n()\nconst\n{\ndata\n}\n=\nuseSWR\n(\n'/api/user'\n, fetcher)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>My name is {data.name}.</\nh1\n>\n<\nbutton\nonClick\n=\n{\nasync\n()\n=>\n{\nconst\nnewName\n=\ndata.name.\ntoUpperCase\n()\nmutate\n(\n'/api/user'\n,\nupdateUserName\n(newName), {\noptimisticData\n:\nuser\n=>\n({\n...\nuser, name: newName }),\nrollbackOnError:\ntrue\n});\n}}>Uppercase my name!</\nbutton\n>\n</\ndiv\n>\n)\n}\nYou can also create the same thing with\nuseSWRMutation\nand\ntrigger\n:\nimport\nuseSWRMutation\nfrom\n'swr/mutation'\nfunction\nProfile\n() {\nconst\n{\ntrigger\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, updateUserName)\nreturn\n(\n<\ndiv\n>\n<\nh1\n>My name is {data.name}.</\nh1\n>\n<\nbutton\nonClick\n=\n{\nasync\n()\n=>\n{\nconst\nnewName\n=\ndata.name.\ntoUpperCase\n()\ntrigger\n(newName, {\noptimisticData\n:\nuser\n=>\n({\n...\nuser, name: newName }),\nrollbackOnError:\ntrue\n})\n}}>Uppercase my name!</\nbutton\n>\n</\ndiv\n>\n)\n}\nRollback on Errors\nWhen you have\noptimisticData\nset, it\u2019s possible that the optimistic data gets\ndisplayed to the user, but the remote mutation fails. In this case, you can leverage\nrollbackOnError\nto revert the local cache to the previous state, to make sure\nthe user is seeing the correct data.\nUpdate Cache After Mutation\nSometimes, the remote mutation request directly returns the updated data, so there is no need to do an extra fetch to load it.\nYou can enable the\npopulateCache\noption to update the cache for\nuseSWR\nwith the response of the mutation:\nconst\nupdateTodo\n=\n()\n=>\nfetch\n(\n'/api/todos/1'\n, {\nmethod:\n'PATCH'\n,\nbody:\nJSON\n.\nstringify\n({ completed:\ntrue\n})\n})\nmutate\n(\n'/api/todos'\n, updateTodo, {\npopulateCache\n: (\nupdatedTodo\n,\ntodos\n)\n=>\n{\n// filter the list, and return it with the updated item\nconst\nfilteredTodos\n=\ntodos.\nfilter\n(\ntodo\n=>\ntodo.id\n!==\n'1'\n)\nreturn\n[\n...\nfilteredTodos, updatedTodo]\n},\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\nrevalidate:\nfalse\n})\nOr with the\nuseSWRMutation\nhook:\nuseSWRMutation\n(\n'/api/todos'\n, updateTodo, {\npopulateCache\n: (\nupdatedTodo\n,\ntodos\n)\n=>\n{\n// filter the list, and return it with the updated item\nconst\nfilteredTodos\n=\ntodos.\nfilter\n(\ntodo\n=>\ntodo.id\n!==\n'1'\n)\nreturn\n[\n...\nfilteredTodos, updatedTodo]\n},\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\nrevalidate:\nfalse\n})\nWhen combined with\noptimisticData\nand\nrollbackOnError\n, you\u2019ll get a perfect optimistic UI experience.\nAvoid Race Conditions\nBoth\nmutate\nand\nuseSWRMutation\ncan avoid race conditions between\nuseSWR\n. For example,\nfunction\nProfile\n() {\nconst\n{\ndata\n}\n=\nuseSWR\n(\n'/api/user'\n, getUser, { revalidateInterval:\n3000\n})\nconst\n{\ntrigger\n}\n=\nuseSWRMutation\n(\n'/api/user'\n, updateUser)\nreturn\n<>\n{data\n?\ndata.username\n:\nnull\n}\n<\nbutton\nonClick\n=\n{()\n=>\ntrigger\n()}>Update User</\nbutton\n>\n</>\n}\nThe normal\nuseSWR\nhook might refresh its data any time due to focus, polling, or other conditions. This way the displayed username\ncan be as fresh as possible. However, since we have a mutation there that can happen at the nearly same time of a refetch of\nuseSWR\n, there\ncould be a race condition that\ngetUser\nrequest starts earlier, but takes longer than\nupdateUser\n.\nLuckily,\nuseSWRMutation\nhandles this for you automatically. After the mutation, it will tell\nuseSWR\nto ditch the ongoing request and revalidate,\nso the stale data will never be displayed.\nMutate Based on Current Data\nSometimes, you want to update a part of your data based on the current data.\nWith\nmutate\n, you can pass an async function which will receive the current cached value, if any, and returns an updated document.\nmutate\n(\n'/api/todos'\n,\nasync\ntodos\n=>\n{\n// let's update the todo with ID `1` to be completed,\n// this API returns the updated data\nconst\nupdatedTodo\n=\nawait\nfetch\n(\n'/api/todos/1'\n, {\nmethod:\n'PATCH'\n,\nbody:\nJSON\n.\nstringify\n({ completed:\ntrue\n})\n})\n// filter the list, and return it with the updated item\nconst\nfilteredTodos\n=\ntodos.\nfilter\n(\ntodo\n=>\ntodo.id\n!==\n'1'\n)\nreturn\n[\n...\nfilteredTodos, updatedTodo]\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\n}, { revalidate:\nfalse\n})\nMutate Multiple Items\nThe global\nmutate\nAPI accepts a filter function, which accepts\nkey\nas the argument and returns which keys to revalidate. The filter function is applied to all the existing cache keys:\nimport\n{ mutate }\nfrom\n'swr'\n// Or from the hook if you customized the cache provider:\n// { mutate } = useSWRConfig()\nmutate\n(\nkey\n=>\ntypeof\nkey\n===\n'string'\n&&\nkey.\nstartsWith\n(\n'/api/item?id='\n),\nundefined\n,\n{ revalidate:\ntrue\n}\n)\nThis also works with any key type like an array. The mutation matches all keys, of which the first element is\n'item'\n.\nuseSWR\n([\n'item'\n,\n123\n],\n...\n)\nuseSWR\n([\n'item'\n,\n124\n],\n...\n)\nuseSWR\n([\n'item'\n,\n125\n],\n...\n)\nmutate\n(\nkey\n=>\nArray.\nisArray\n(key)\n&&\nkey[\n0\n]\n===\n'item'\n,\nundefined\n,\n{ revalidate:\nfalse\n}\n)\nThe filter function is applied to all existing cache keys, so you should not assume the shape of keys when using multiple shapes of keys.\n// \u2705 matching array key\nmutate\n((\nkey\n)\n=>\nkey[\n0\n].\nstartsWith\n(\n'/api'\n), data)\n// \u2705 matching string key\nmutate\n((\nkey\n)\n=>\ntypeof\nkey\n===\n'string'\n&&\nkey.\nstartsWith\n(\n'/api'\n), data)\n// \u274c ERROR: mutate uncertain keys (array or string)\nmutate\n((\nkey\n:\nany\n)\n=>\n/\n\\/\napi\n/\n.\ntest\n(key.\ntoString\n()))\nYou can use the filter function to clear all cache data, which is useful when logging out:\nconst\nclearCache\n=\n()\n=>\nmutate\n(\n()\n=>\ntrue\n,\nundefined\n,\n{ revalidate:\nfalse\n}\n)\n// ...clear cache on logout\nclearCache\n()",
  "content_markdown": "# Mutation & Revalidation\n\nSWR provides the [`mutate`](/en/docs/mutation#mutate) and [`useSWRMutation`](/en/docs/mutation#useswrmutation) APIs for mutating remote data and related cache.\n\n## [`mutate`](#mutate)\n\nThere're 2 ways to use the `mutate` API to mutate the data, the global mutate API which can mutate any key and the bound mutate API which only can mutate the data of corresponding SWR hook.\n\n#### [Global Mutate](#global-mutate)\n\nThe recommended way to get the global mutator is to use the [`useSWRConfig`](/en/docs/global-configuration#access-to-global-configurations) hook:\n\n```\nimport { useSWRConfig } from \"swr\"\n\nfunction App() {\n  const { mutate } = useSWRConfig()\n  mutate(key, data, options)\n}\n```\n\nYou can also import it globally:\n\n```\nimport { mutate } from \"swr\"\n\nfunction App() {\n  mutate(key, data, options)\n}\n```\n\nUsing global mutator only with the `key` parameter will ***not update the cache or trigger revalidation*** unless there is a mounted SWR hook using the same key.\n\n#### [Bound Mutate](#bound-mutate)\n\nBound mutate is the short path to mutate the current key with data. Which `key` is bounded to the `key` passing to `useSWR`, and receive the `data` as the first argument.\n\nIt is functionally equivalent to the global `mutate` function in the previous section but does not require the `key` parameter:\n\n```\nimport useSWR from 'swr'\n\nfunction Profile () {\n  const { data, mutate } = useSWR('/api/user', fetcher)\n\n  return (\n    <div>\n      <h1>My name is {data.name}.</h1>\n      <button onClick={async () => {\n        const newName = data.name.toUpperCase()\n        // send a request to the API to update the data\n        await requestUpdateUsername(newName)\n        // update the local data immediately and revalidate (refetch)\n        // NOTE: key is not required when using useSWR's mutate as it's pre-bound\n        mutate({ ...data, name: newName })\n      }}>Uppercase my name!</button>\n    </div>\n  )\n}\n```\n\n#### [Revalidation](#revalidation)\n\nWhen you call `mutate(key)` (or just `mutate()` with the bound mutate API) without any data, it will trigger a revalidation (mark the data as expired and trigger a refetch)\nfor the resource. This example shows how to automatically refetch the login info (e.g. inside `<Profile/>`)\nwhen the user clicks the \u201cLogout\u201d button:\n\n```\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction App () {\n  const { mutate } = useSWRConfig()\n\n  return (\n    <div>\n      <Profile />\n      <button onClick={() => {\n        // set the cookie as expired\n        document.cookie = 'token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;'\n\n        // tell all SWRs with this key to revalidate\n        mutate('/api/user')\n      }}>\n        Logout\n      </button>\n    </div>\n  )\n}\n```\n\nIt broadcasts to SWR hooks under the same [cache provider](/en/docs/advanced/cache) scope. If no cache provider exists, it will broadcast to all SWR hooks.\n\n### [API](#api)\n\n#### [Parameters](#parameters)\n\n- `key`: same as `useSWR`'s `key`, but a function behaves as [a filter function](/en/docs/mutation#mutate-multiple-items)\n- `data`: data to update the client cache, or an async function for the remote mutation\n- `options`: accepts the following options\n  - `optimisticData`: data to immediately update the client cache, or a function that receives current data and returns the new client cache data, usually used in optimistic UI.\n  - `revalidate = true`: should the cache revalidate once the asynchronous update resolves. If set to a function, the function receives `data` and `key`.\n  - `populateCache = true`: should the result of the remote mutation be written to the cache, or a function that receives new result and current result as arguments and returns the mutation result.\n  - `rollbackOnError = true`: should the cache rollback if the remote mutation errors, or a function that receives the error thrown from fetcher as arguments and returns a boolean whether should rollback or not.\n  - `throwOnError = true`: should the mutate call throw the error when fails.\n\n#### [Return Values](#return-values)\n\n`mutate` returns the results the `data` parameter has been resolved. The function passed to `mutate` will return an updated data which is used to update the corresponding cache value. If there is an error thrown while executing the function, the error will be thrown so it can be handled appropriately.\n\n```\ntry {\n  const user = await mutate('/api/user', updateUser(newUser))\n} catch (error) {\n  // Handle an error while updating the user here\n}\n```\n\n## [`useSWRMutation`](#useswrmutation)\n\nSWR also provides `useSWRMutation` as a hook for remote mutations. The remote mutations are only triggered manually, instead of automatically like `useSWR`.\n\nAlso, this hook doesn\u2019t share states with other `useSWRMutation` hooks.\n\n```\nimport useSWRMutation from 'swr/mutation'\n\n// Fetcher implementation.\n// The extra argument will be passed via the `arg` property of the 2nd parameter.\n// In the example below, `arg` will be `'my_token'`\nasync function updateUser(url, { arg }: { arg: string }) {\n  await fetch(url, {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${arg}`\n    }\n  })\n}\n\nfunction Profile() {\n  // A useSWR + mutate like API, but it will not start the request automatically.\n  const { trigger } = useSWRMutation('/api/user', updateUser, options)\n\n  return <button onClick={() => {\n    // Trigger `updateUser` with a specific argument.\n    trigger('my_token')\n  }}>Update User</button>\n}\n```\n\n### [API](#useswrmutation-api)\n\n#### [Parameters](#useswrmutation-parameters)\n\n- `key`: same as [`mutate`](/en/docs/mutation#mutate)'s `key`\n- `fetcher(key, { arg })`: an async function for remote mutation\n- `options`: an optional object with the following properties:\n  - `optimisticData`: same as `mutate`'s `optimisticData`\n  - `revalidate = true`: same as `mutate`'s `revalidate`\n  - `populateCache = false`: same as `mutate`'s `populateCache`, but the default is `false`\n  - `rollbackOnError = true`: same as `mutate`'s `rollbackOnError`\n  - `throwOnError = true`: same as `mutate`'s `throwOnError`\n  - `onSuccess(data, key, config)`:\u3000 callback function when a remote mutation has been finished successfully\n  - `onError(err, key, config)`: callback function when a remote mutation has returned an error\n\n#### [Return Values](#useswrmutation-return-values)\n\n- `data`: data for the given key returned from `fetcher`\n- `error`: error thrown by `fetcher` (or undefined)\n- `trigger(arg, options)`: a function to trigger a remote mutation\n- `reset`: a function to reset the state (`data`, `error`, `isMutating`)\n- `isMutating`: if there's an ongoing remote mutation\n\n### [Basic Usage](#useswrmutation-basic-usage)\n\n```\nimport useSWRMutation from 'swr/mutation'\n\nasync function sendRequest(url, { arg }: { arg: { username: string }}) {\n  return fetch(url, {\n    method: 'POST',\n    body: JSON.stringify(arg)\n  }).then(res => res.json())\n}\n\nfunction App() {\n  const { trigger, isMutating } = useSWRMutation('/api/user', sendRequest, /* options */)\n\n  return (\n    <button\n      disabled={isMutating}\n      onClick={async () => {\n        try {\n          const result = await trigger({ username: 'johndoe' }, /* options */)\n        } catch (e) {\n          // error handling\n        }\n      }}\n    >\n      Create User\n    </button>\n  )\n}\n```\n\nIf you want to use the mutation results in rendering, you can get them from the return values of `useSWRMutation`.\n\n```\nconst { trigger, data, error } = useSWRMutation('/api/user', sendRequest)\n```\n\n`useSWRMutation` shares a cache store with `useSWR`, so it can detect and avoid race conditions between `useSWR`. It also supports `mutate`'s functionalities like optimistic updates and rollback on errors. You can pass these options `useSWRMutation` and its `trigger` function.\n\n```\nconst { trigger } = useSWRMutation('/api/user', updateUser, {\n  optimisticData: current => ({ ...current, name: newName })\n})\n\n// or\n\ntrigger(newName, {\n  optimisticData: current => ({ ...current, name: newName })\n})\n```\n\n### [Defer loading data until needed](#defer-loading-data-until-needed)\n\nYou can also use `useSWRMutation` for loading data. `useSWRMutation` won't start requesting until `trigger` is called, so you can defer loading data when you actually need it.\n\n```\nimport { useState } from 'react'\nimport useSWRMutation from 'swr/mutation'\n\nconst fetcher = url => fetch(url).then(res => res.json())\n\nconst Page = () => {\n  const [show, setShow] = useState(false)\n  // data is undefined until trigger is called\n  const { data: user, trigger } = useSWRMutation('/api/user', fetcher);\n\n  return (\n    <div>\n      <button onClick={() => {\n        trigger();\n        setShow(true);\n      }}>Show User</button>\n      {show && user ? <div>{user.name}</div> : null}\n    </div>\n  );\n}\n```\n\n## [Optimistic Updates](#optimistic-updates)\n\nIn many cases, applying local mutations to data is a good way to make changes\nfeel faster \u2014 no need to wait for the remote source of data.\n\nWith the `optimisticData` option, you can update your local data manually, while\nwaiting for the remote mutation to finish. Composing `rollbackOnError` you can also\ncontrol when to rollback the data.\n\n```\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction Profile () {\n  const { mutate } = useSWRConfig()\n  const { data } = useSWR('/api/user', fetcher)\n\n  return (\n    <div>\n      <h1>My name is {data.name}.</h1>\n      <button onClick={async () => {\n        const newName = data.name.toUpperCase()\n        const user = { ...data, name: newName }\n        const options = {\n          optimisticData: user,\n          rollbackOnError(error) {\n            // If it's timeout abort error, don't rollback\n            return error.name !== 'AbortError'\n          },\n        }\n\n        // updates the local data immediately\n        // send a request to update the data\n        // triggers a revalidation (refetch) to make sure our local data is correct\n        mutate('/api/user', updateFn(user), options);\n      }}>Uppercase my name!</button>\n    </div>\n  )\n}\n```\n\n> The **`updateFn`** should be a promise or asynchronous function to handle the remote mutation, it should return updated data.\n\nYou can also pass a function to `optimisticData` to make it depending on the current data:\n\n```\nimport useSWR, { useSWRConfig } from 'swr'\n\nfunction Profile () {\n  const { mutate } = useSWRConfig()\n  const { data } = useSWR('/api/user', fetcher)\n\n  return (\n    <div>\n      <h1>My name is {data.name}.</h1>\n      <button onClick={async () => {\n        const newName = data.name.toUpperCase()\n        mutate('/api/user', updateUserName(newName), {\n          optimisticData: user => ({ ...user, name: newName }),\n          rollbackOnError: true\n        });\n      }}>Uppercase my name!</button>\n    </div>\n  )\n}\n```\n\nYou can also create the same thing with `useSWRMutation` and `trigger`:\n\n```\nimport useSWRMutation from 'swr/mutation'\n\nfunction Profile () {\n  const { trigger } = useSWRMutation('/api/user', updateUserName)\n\n  return (\n    <div>\n      <h1>My name is {data.name}.</h1>\n      <button onClick={async () => {\n        const newName = data.name.toUpperCase()\n\n        trigger(newName, {\n          optimisticData: user => ({ ...user, name: newName }),\n          rollbackOnError: true\n        })\n      }}>Uppercase my name!</button>\n    </div>\n  )\n}\n```\n\n## [Rollback on Errors](#rollback-on-errors)\n\nWhen you have `optimisticData` set, it\u2019s possible that the optimistic data gets\ndisplayed to the user, but the remote mutation fails. In this case, you can leverage\n`rollbackOnError` to revert the local cache to the previous state, to make sure\nthe user is seeing the correct data.\n\n## [Update Cache After Mutation](#update-cache-after-mutation)\n\nSometimes, the remote mutation request directly returns the updated data, so there is no need to do an extra fetch to load it.\nYou can enable the `populateCache` option to update the cache for `useSWR` with the response of the mutation:\n\n```\nconst updateTodo = () => fetch('/api/todos/1', {\n  method: 'PATCH',\n  body: JSON.stringify({ completed: true })\n})\n\nmutate('/api/todos', updateTodo, {\n  populateCache: (updatedTodo, todos) => {\n    // filter the list, and return it with the updated item\n    const filteredTodos = todos.filter(todo => todo.id !== '1')\n    return [...filteredTodos, updatedTodo]\n  },\n  // Since the API already gives us the updated information,\n  // we don't need to revalidate here.\n  revalidate: false\n})\n```\n\nOr with the `useSWRMutation` hook:\n\n```\nuseSWRMutation('/api/todos', updateTodo, {\n  populateCache: (updatedTodo, todos) => {\n    // filter the list, and return it with the updated item\n    const filteredTodos = todos.filter(todo => todo.id !== '1')\n    return [...filteredTodos, updatedTodo]\n  },\n  // Since the API already gives us the updated information,\n  // we don't need to revalidate here.\n  revalidate: false\n})\n```\n\nWhen combined with `optimisticData` and `rollbackOnError`, you\u2019ll get a perfect optimistic UI experience.\n\n## [Avoid Race Conditions](#avoid-race-conditions)\n\nBoth `mutate` and `useSWRMutation` can avoid race conditions between `useSWR`. For example,\n\n```\nfunction Profile() {\n  const { data } = useSWR('/api/user', getUser, { revalidateInterval: 3000 })\n  const { trigger } = useSWRMutation('/api/user', updateUser)\n\n  return <>\n    {data ? data.username : null}\n    <button onClick={() => trigger()}>Update User</button>\n  </>\n}\n```\n\nThe normal `useSWR` hook might refresh its data any time due to focus, polling, or other conditions. This way the displayed username\ncan be as fresh as possible. However, since we have a mutation there that can happen at the nearly same time of a refetch of `useSWR`, there\ncould be a race condition that `getUser` request starts earlier, but takes longer than `updateUser`.\n\nLuckily, `useSWRMutation` handles this for you automatically. After the mutation, it will tell `useSWR` to ditch the ongoing request and revalidate,\nso the stale data will never be displayed.\n\n## [Mutate Based on Current Data](#mutate-based-on-current-data)\n\nSometimes, you want to update a part of your data based on the current data.\n\nWith `mutate`, you can pass an async function which will receive the current cached value, if any, and returns an updated document.\n\n```\nmutate('/api/todos', async todos => {\n  // let's update the todo with ID `1` to be completed,\n  // this API returns the updated data\n  const updatedTodo = await fetch('/api/todos/1', {\n    method: 'PATCH',\n    body: JSON.stringify({ completed: true })\n  })\n\n  // filter the list, and return it with the updated item\n  const filteredTodos = todos.filter(todo => todo.id !== '1')\n  return [...filteredTodos, updatedTodo]\n// Since the API already gives us the updated information,\n// we don't need to revalidate here.\n}, { revalidate: false })\n```\n\n## [Mutate Multiple Items](#mutate-multiple-items)\n\nThe global `mutate` API accepts a filter function, which accepts `key` as the argument and returns which keys to revalidate. The filter function is applied to all the existing cache keys:\n\n```\nimport { mutate } from 'swr'\n// Or from the hook if you customized the cache provider:\n// { mutate } = useSWRConfig()\n\nmutate(\n  key => typeof key === 'string' && key.startsWith('/api/item?id='),\n  undefined,\n  { revalidate: true }\n)\n```\n\nThis also works with any key type like an array. The mutation matches all keys, of which the first element is `'item'`.\n\n```\nuseSWR(['item', 123], ...)\nuseSWR(['item', 124], ...)\nuseSWR(['item', 125], ...)\n\nmutate(\n  key => Array.isArray(key) && key[0] === 'item',\n  undefined,\n  { revalidate: false }\n)\n```\n\nThe filter function is applied to all existing cache keys, so you should not assume the shape of keys when using multiple shapes of keys.\n\n```\n// \u2705 matching array key\nmutate((key) => key[0].startsWith('/api'), data)\n// \u2705 matching string key\nmutate((key) => typeof key === 'string' && key.startsWith('/api'), data)\n\n// \u274c ERROR: mutate uncertain keys (array or string)\nmutate((key: any) => /\\/api/.test(key.toString()))\n```\n\nYou can use the filter function to clear all cache data, which is useful when logging out:\n\n```\nconst clearCache = () => mutate(\n  () => true,\n  undefined,\n  { revalidate: false }\n)\n\n// ...clear cache on logout\nclearCache()\n```",
  "tags": [
    "swr",
    "vercel",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:53:04.336786+00:00",
  "content_length": 14577,
  "content_hash": "191975b365006810"
}