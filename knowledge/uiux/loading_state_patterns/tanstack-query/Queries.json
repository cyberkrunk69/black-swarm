{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_queries",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/queries",
  "title": "Queries",
  "content": "Query Basics\nA query is a declarative dependency on an asynchronous source of data that is tied to a\nunique key\n. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using\nMutations\ninstead.\nTo subscribe to a query in your components or custom hooks, call the\nuseQuery\nhook with at least:\nA\nunique key for the query\nA function that returns a promise that:\nResolves the data, or\nThrows an error\ntsx\nimport { useQuery } from '@tanstack/react-query'\n\nfunction App() {\n  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n}\nThe\nunique key\nyou provide is used internally for refetching, caching, and sharing your queries throughout your application.\nThe query result returned by\nuseQuery\ncontains all of the information about the query that you'll need for templating and any other usage of the data:\ntsx\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\nThe\nresult\nobject contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:\nisPending\nor\nstatus === 'pending'\n- The query has no data yet\nisError\nor\nstatus === 'error'\n- The query encountered an error\nisSuccess\nor\nstatus === 'success'\n- The query was successful and data is available\nBeyond those primary states, more information is available depending on the state of the query:\nerror\n- If the query is in an\nisError\nstate, the error is available via the\nerror\nproperty.\ndata\n- If the query is in an\nisSuccess\nstate, the data is available via the\ndata\nproperty.\nisFetching\n- In any state, if the query is fetching at any time (including background refetching)\nisFetching\nwill be\ntrue\n.\nFor\nmost\nqueries, it's usually sufficient to check for the\nisPending\nstate, then the\nisError\nstate, then finally, assume that the data is available and render the successful state:\ntsx\nfunction Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (isPending) {\n    return <span>Loading...</span>\n  }\n\n  if (isError) {\n    return <span>Error: {error.message}</span>\n  }\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\nIf booleans aren't your thing, you can always use the\nstatus\nstate as well:\ntsx\nfunction Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (status === 'pending') {\n    return <span>Loading...</span>\n  }\n\n  if (status === 'error') {\n    return <span>Error: {error.message}</span>\n  }\n\n  // also status === 'success', but \"else\" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\nTypeScript will also narrow the type of\ndata\ncorrectly if you've checked for\npending\nand\nerror\nbefore accessing it.\nFetchStatus\nIn addition to the\nstatus\nfield, you will also get an additional\nfetchStatus\nproperty with the following options:\nfetchStatus === 'fetching'\n- The query is currently fetching.\nfetchStatus === 'paused'\n- The query wanted to fetch, but it is paused. Read more about this in the\nNetwork Mode\nguide.\nfetchStatus === 'idle'\n- The query is not doing anything at the moment.\nWhy two different states?\nBackground refetches and stale-while-revalidate logic make all combinations for\nstatus\nand\nfetchStatus\npossible. For example:\na query in\nsuccess\nstatus will usually be in\nidle\nfetchStatus, but it could also be in\nfetching\nif a background refetch is happening.\na query that mounts and has no data will usually be in\npending\nstatus and\nfetching\nfetchStatus, but it could also be\npaused\nif there is no network connection.\nSo keep in mind that a query can be in\npending\nstate without actually fetching data. As a rule of thumb:\nThe\nstatus\ngives information about the\ndata\n: Do we have any or not?\nThe\nfetchStatus\ngives information about the\nqueryFn\n: Is it running or not?\nFurther Reading\nFor an alternative way of performing status checks, have a look at\nthis article by TkDodo\n.",
  "content_markdown": "[## Query Basics](#query-basics)\n\nA query is a declarative dependency on an asynchronous source of data that is tied to a **unique key**. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using [Mutations](/query/latest/docs/framework/react/guides/mutations) instead.\n\nTo subscribe to a query in your components or custom hooks, call the useQuery hook with at least:\n\n- A **unique key for the query**\n- A function that returns a promise that:\n  - Resolves the data, or\n  - Throws an error\n\ntsx\n\n```\nimport { useQuery } from '@tanstack/react-query'\n\nfunction App() {\n  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n}\n```\n\nThe **unique key** you provide is used internally for refetching, caching, and sharing your queries throughout your application.\n\nThe query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:\n\ntsx\n\n```\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n```\n\nThe result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:\n\n- isPending or status === 'pending' - The query has no data yet\n- isError or status === 'error' - The query encountered an error\n- isSuccess or status === 'success' - The query was successful and data is available\n\nBeyond those primary states, more information is available depending on the state of the query:\n\n- error - If the query is in an isError state, the error is available via the error property.\n- data - If the query is in an isSuccess state, the data is available via the data property.\n- isFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.\n\nFor **most** queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:\n\ntsx\n\n```\nfunction Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (isPending) {\n    return <span>Loading...</span>\n  }\n\n  if (isError) {\n    return <span>Error: {error.message}</span>\n  }\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nIf booleans aren't your thing, you can always use the status state as well:\n\ntsx\n\n```\nfunction Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n  if (status === 'pending') {\n    return <span>Loading...</span>\n  }\n\n  if (status === 'error') {\n    return <span>Error: {error.message}</span>\n  }\n\n  // also status === 'success', but \"else\" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nTypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.\n\n[### FetchStatus](#fetchstatus)\n\nIn addition to the status field, you will also get an additional fetchStatus property with the following options:\n\n- fetchStatus === 'fetching' - The query is currently fetching.\n- fetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the [Network Mode](/query/latest/docs/framework/react/guides/network-mode) guide.\n- fetchStatus === 'idle' - The query is not doing anything at the moment.\n\n[### Why two different states?](#why-two-different-states)\n\nBackground refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:\n\n- a query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.\n- a query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.\n\nSo keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:\n\n- The status gives information about the data: Do we have any or not?\n- The fetchStatus gives information about the queryFn: Is it running or not?\n\n[## Further Reading](#further-reading)\n\nFor an alternative way of performing status checks, have a look at [this article by TkDodo](https://tkdodo.eu/blog/status-checks-in-react-query).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:23.924161+00:00",
  "content_length": 4247,
  "content_hash": "fe8ba6d8abebc87d"
}