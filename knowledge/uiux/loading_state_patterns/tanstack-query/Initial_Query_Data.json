{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_initial-",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/initial-query-data",
  "title": "Initial Query Data",
  "content": "There are many ways to supply initial data for a query to the cache before you need it:\nDeclaratively:\nProvide\ninitialData\nto a query to prepopulate its cache if empty\nImperatively:\nPrefetch the data using\nqueryClient.prefetchQuery\nManually place the data into the cache using\nqueryClient.setQueryData\nUsing\ninitialData\nto prepopulate a query\nThere may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the\nconfig.initialData\noption to set the initial data for a query and skip the initial loading state!\nIMPORTANT:\ninitialData\nis persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use\nplaceholderData\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\nstaleTime\nand\ninitialDataUpdatedAt\nBy default,\ninitialData\nis treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the\nstaleTime\noption.\nIf you configure your query observer with\ninitialData\n, and no\nstaleTime\n(the default\nstaleTime: 0\n), the query will immediately refetch when it mounts:\ntsx\n// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\nIf you configure your query observer with\ninitialData\nand a\nstaleTime\nof\n1000\nms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\nSo what if your\ninitialData\nisn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called\ninitialDataUpdatedAt\n. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what\nDate.now()\nprovides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by\n1000\n.\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\nThis option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the\ninitialData\nis older than the\nstaleTime\n. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.\nIf you would rather treat your data as\nprefetched data\n, we recommend that you use the\nprefetchQuery\nor\nfetchQuery\nAPIs to populate the cache beforehand, thus letting you configure your\nstaleTime\nindependently from your initialData\nInitial Data Function\nIf the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the\ninitialData\nvalue. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\nInitial Data from Cache\nIn some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\nInitial Data from the cache with\ninitialDataUpdatedAt\nGetting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial\nstaleTime\nto keep your query from refetching immediately, it's suggested that you pass the source query's\ndataUpdatedAt\nto\ninitialDataUpdatedAt\n. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.\ntsx\nconst result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\nConditional Initial Data from Cache\nIf the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the\nqueryClient.getQueryState\nmethod instead to get more information about the source query, including a\nstate.dataUpdatedAt\ntimestamp you can use to decide if the query is \"fresh\" enough for your needs:\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\nFurther reading\nFor a comparison between\nInitial Data\nand\nPlaceholder Data\n, see the\narticle by TkDodo\n.",
  "content_markdown": "There are many ways to supply initial data for a query to the cache before you need it:\n\n- Declaratively:\n  - Provide initialData to a query to prepopulate its cache if empty\n- Imperatively:\n  - [Prefetch the data using queryClient.prefetchQuery](/query/latest/docs/framework/react/guides/prefetching)\n  - [Manually place the data into the cache using queryClient.setQueryData](/query/latest/docs/framework/react/guides/prefetching)\n\n[## Using initialData to prepopulate a query](#using-initialdata-to-prepopulate-a-query)\n\nThere may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!\n\n> IMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n```\n\n[### staleTime and initialDataUpdatedAt](#staletime-and-initialdataupdatedat)\n\nBy default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.\n\n- If you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:\n\n  tsx\n\n  ```\n  // Will show initialTodos immediately, but also immediately refetch todos after mount\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    initialData: initialTodos,\n  })\n  ```\n- If you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.\n\n  tsx\n\n  ```\n  // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    initialData: initialTodos,\n    staleTime: 1000,\n  })\n  ```\n- So what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.\n\n  tsx\n\n  ```\n  // Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    initialData: initialTodos,\n    staleTime: 60 * 1000, // 1 minute\n    // This could be 10 seconds ago or 10 minutes ago\n    initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n  })\n  ```\n\n  This option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.\n\n  > If you would rather treat your data as **prefetched data**, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData\n\n[### Initial Data Function](#initial-data-function)\n\nIf the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\n```\n\n[### Initial Data from Cache](#initial-data-from-cache)\n\nIn some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\n```\n\n[### Initial Data from the cache with initialDataUpdatedAt](#initial-data-from-the-cache-with-initialdataupdatedat)\n\nGetting initial data from the cache means the source query you're using to look up the initial data from is likely old. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\n```\n\n[### Conditional Initial Data from Cache](#conditional-initial-data-from-cache)\n\nIf the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is \"fresh\" enough for your needs:\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\n```\n\n[## Further reading](#further-reading)\n\nFor a comparison between Initial Data and Placeholder Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:38.336427+00:00",
  "content_length": 6354,
  "content_hash": "09b9970ba63bfe26"
}