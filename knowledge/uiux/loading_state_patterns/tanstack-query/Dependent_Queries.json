{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_dependen",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/dependent-queries",
  "title": "Dependent Queries",
  "content": "useQuery dependent Query\nDependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the\nenabled\noption to tell a query when it is ready to run:\ntsx\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\nconst userId = user?.id\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\nThe\nprojects\nquery will start in:\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'idle'\nAs soon as the\nuser\nis available, the\nprojects\nquery will be\nenabled\nand will then transition to:\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'fetching'\nOnce we have the projects, it will go to:\ntsx\nstatus: 'success'\nisPending: false\nfetchStatus: 'idle'\nuseQueries dependent Query\nDynamic parallel query -\nuseQueries\ncan depend on a previous query also, here's how to achieve this:\ntsx\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : [], // if userIds is undefined, an empty array will be returned\n})\nNote\nthat\nuseQueries\nreturn an\narray of query results\nA note about performance\nDependent queries by definition constitutes a form of\nrequest waterfall\n, which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.\nIn the example above, instead of first fetching\ngetUserByEmail\nto be able to\ngetProjectsByUser\n, introducing a new\ngetProjectsByUserEmail\nquery would flatten the waterfall.",
  "content_markdown": "[## useQuery dependent Query](#usequery-dependent-query)\n\nDependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:\n\ntsx\n\n```\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\nconst userId = user?.id\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n```\n\nThe projects query will start in:\n\ntsx\n\n```\nstatus: 'pending'\nisPending: true\nfetchStatus: 'idle'\n```\n\nAs soon as the user is available, the projects query will be enabled and will then transition to:\n\ntsx\n\n```\nstatus: 'pending'\nisPending: true\nfetchStatus: 'fetching'\n```\n\nOnce we have the projects, it will go to:\n\ntsx\n\n```\nstatus: 'success'\nisPending: false\nfetchStatus: 'idle'\n```\n\n[## useQueries dependent Query](#usequeries-dependent-query)\n\nDynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:\n\ntsx\n\n```\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : [], // if userIds is undefined, an empty array will be returned\n})\n```\n\n**Note** that useQueries return an **array of query results**\n\n[## A note about performance](#a-note-about-performance)\n\nDependent queries by definition constitutes a form of [request waterfall](/query/latest/docs/framework/react/guides/request-waterfalls), which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.\n\nIn the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:32.028742+00:00",
  "content_length": 2277,
  "content_hash": "f4c8c9f74a9a4fdc"
}