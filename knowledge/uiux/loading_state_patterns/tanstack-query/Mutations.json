{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_mutation",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/mutations",
  "title": "Mutations",
  "content": "Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a\nuseMutation\nhook.\nHere's an example of a mutation that adds a new todo to the server:\ntsx\nfunction App() {\n  const mutation = useMutation({\n    mutationFn: (newTodo) => {\n      return axios.post('/todos', newTodo)\n    },\n  })\n\n  return (\n    <div>\n      {mutation.isPending ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n}\nA mutation can only be in one of the following states at any given moment:\nisIdle\nor\nstatus === 'idle'\n- The mutation is currently idle or in a fresh/reset state\nisPending\nor\nstatus === 'pending'\n- The mutation is currently running\nisError\nor\nstatus === 'error'\n- The mutation encountered an error\nisSuccess\nor\nstatus === 'success'\n- The mutation was successful and mutation data is available\nBeyond those primary states, more information is available depending on the state of the mutation:\nerror\n- If the mutation is in an\nerror\nstate, the error is available via the\nerror\nproperty.\ndata\n- If the mutation is in a\nsuccess\nstate, the data is available via the\ndata\nproperty.\nIn the example above, you also saw that you can pass variables to your mutations function by calling the\nmutate\nfunction with a\nsingle variable or object\n.\nEven with just variables, mutations aren't all that special, but when used with the\nonSuccess\noption, the\nQuery Client's\ninvalidateQueries\nmethod\nand the\nQuery Client's\nsetQueryData\nmethod\n, mutations become a very powerful tool.\nIMPORTANT: The\nmutate\nfunction is an asynchronous function, which means you cannot use it directly in an event callback in\nReact 16 and earlier\n. If you need to access the event in\nonSubmit\nyou need to wrap\nmutate\nin another function. This is due to\nReact event pooling\n.\ntsx\n// This will not work in React 16 and earlier\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (event) => {\n      event.preventDefault()\n      return fetch('/api', new FormData(event.target))\n    },\n  })\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (formData) => {\n      return fetch('/api', formData)\n    },\n  })\n  const onSubmit = (event) => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n  return <form onSubmit={onSubmit}>...</form>\n}\nResetting Mutation State\nIt's sometimes the case that you need to clear the\nerror\nor\ndata\nof a mutation request. To do this, you can use the\nreset\nfunction to handle this:\ntsx\nconst CreateTodo = () => {\n  const [title, setTitle] = useState('')\n  const mutation = useMutation({ mutationFn: createTodo })\n\n  const onCreateTodo = (e) => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type=\"text\"\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <br />\n      <button type=\"submit\">Create Todo</button>\n    </form>\n  )\n}\nMutation Side Effects\nuseMutation\ncomes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both\ninvalidating and refetching queries after mutations\nand even\noptimistic updates\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onMutate: (variables, context) => {\n    // A mutation is about to happen!\n\n    // Optionally return a result containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${onMutateResult.id}`)\n  },\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // Error or success... doesn't matter!\n  },\n})\nWhen returning a promise in any of the callback functions it will first be awaited before the next callback is called:\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n})\nYou might find that you want to\ntrigger additional callbacks\nbeyond the ones defined on\nuseMutation\nwhen calling\nmutate\n. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the\nmutate\nfunction after your mutation variable. Supported options include:\nonSuccess\n,\nonError\nand\nonSettled\n. Please keep in mind that those additional callbacks won't run if your component unmounts\nbefore\nthe mutation finishes.\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n})\n\nmutate(todo, {\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n})\nConsecutive mutations\nThere is a slight difference in handling\nonSuccess\n,\nonError\nand\nonSettled\ncallbacks when it comes to consecutive mutations. When passed to the\nmutate\nfunction, they will be fired up only\nonce\nand only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the\nmutate\nfunction is called. On the contrary,\nuseMutation\nhandlers execute for each\nmutate\ncall.\nBe aware that most likely,\nmutationFn\npassed to\nuseMutation\nis asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of\nmutate\nfunction calls.\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // Will be called 3 times\n  },\n})\n\nconst todos = ['Todo 1', 'Todo 2', 'Todo 3']\ntodos.forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, variables, onMutateResult, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\nPromises\nUse\nmutateAsync\ninstead of\nmutate\nto get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.\ntsx\nconst mutation = useMutation({ mutationFn: addTodo })\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\nRetry\nBy default, TanStack Query will not retry a mutation on error, but it is possible with the\nretry\noption:\ntsx\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\nIf mutations fail because the device is offline, they will be retried in the same order when the device reconnects.\nPersist mutations\nMutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:\ntsx\nconst queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables, context) => {\n    // Cancel current queries for the todos list\n    await context.client.cancelQueries({ queryKey: ['todos'] })\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n    // Return a result with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, onMutateResult, context) => {\n    // Replace optimistic todo in the todos list with the result\n    context.client.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === onMutateResult.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // Remove optimistic todo from the todos list\n    context.client.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\nPersisting Offline mutations\nIf you persist offline mutations with the\npersistQueryClient plugin\n, mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.\nThis is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling\nresumePausedMutations\nmight yield an error:\nNo mutationFn found\n.\ntsx\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults(['todos'], {\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\nexport default function App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{ persister }}\n      onSuccess={() => {\n        // resume mutations after initial restore from localStorage was successful\n        queryClient.resumePausedMutations()\n      }}\n    >\n      <RestOfTheApp />\n    </PersistQueryClientProvider>\n  )\n}\nWe also have an extensive\noffline example\nthat covers both queries and mutations.\nMutation Scopes\nPer default, all mutations run in parallel - even if you invoke\n.mutate()\nof the same mutation multiple times. Mutations can be given a\nscope\nwith an\nid\nto avoid that. All mutations with the same\nscope.id\nwill run in serial, which means when they are triggered, they will start in\nisPaused: true\nstate if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.\ntsx\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  scope: {\n    id: 'todo',\n  },\n})\nFurther reading\nFor more information about mutations, have a look at\nTkDodo's article on Mastering Mutations in React Query\n.",
  "content_markdown": "Unlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.\n\nHere's an example of a mutation that adds a new todo to the server:\n\ntsx\n\n```\nfunction App() {\n  const mutation = useMutation({\n    mutationFn: (newTodo) => {\n      return axios.post('/todos', newTodo)\n    },\n  })\n\n  return (\n    <div>\n      {mutation.isPending ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n}\n```\n\nA mutation can only be in one of the following states at any given moment:\n\n- isIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state\n- isPending or status === 'pending' - The mutation is currently running\n- isError or status === 'error' - The mutation encountered an error\n- isSuccess or status === 'success' - The mutation was successful and mutation data is available\n\nBeyond those primary states, more information is available depending on the state of the mutation:\n\n- error - If the mutation is in an error state, the error is available via the error property.\n- data - If the mutation is in a success state, the data is available via the data property.\n\nIn the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a **single variable or object**.\n\nEven with just variables, mutations aren't all that special, but when used with the onSuccess option, the [Query Client's invalidateQueries method](/query/latest/docs/reference/QueryClient#queryclientinvalidatequeries) and the [Query Client's setQueryData method](/query/latest/docs/reference/QueryClient#queryclientsetquerydata), mutations become a very powerful tool.\n\n> IMPORTANT: The mutate function is an asynchronous function, which means you cannot use it directly in an event callback in **React 16 and earlier**. If you need to access the event in onSubmit you need to wrap mutate in another function. This is due to [React event pooling](https://reactjs.org/docs/legacy-event-pooling.html).\n\ntsx\n\n```\n// This will not work in React 16 and earlier\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (event) => {\n      event.preventDefault()\n      return fetch('/api', new FormData(event.target))\n    },\n  })\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (formData) => {\n      return fetch('/api', formData)\n    },\n  })\n  const onSubmit = (event) => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n  return <form onSubmit={onSubmit}>...</form>\n}\n```\n\n[## Resetting Mutation State](#resetting-mutation-state)\n\nIt's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:\n\ntsx\n\n```\nconst CreateTodo = () => {\n  const [title, setTitle] = useState('')\n  const mutation = useMutation({ mutationFn: createTodo })\n\n  const onCreateTodo = (e) => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type=\"text\"\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <br />\n      <button type=\"submit\">Create Todo</button>\n    </form>\n  )\n}\n```\n\n[## Mutation Side Effects](#mutation-side-effects)\n\nuseMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both [invalidating and refetching queries after mutations](/query/latest/docs/framework/react/guides/invalidations-from-mutations) and even [optimistic updates](/query/latest/docs/framework/react/guides/optimistic-updates)\n\ntsx\n\n```\nuseMutation({\n  mutationFn: addTodo,\n  onMutate: (variables, context) => {\n    // A mutation is about to happen!\n\n    // Optionally return a result containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${onMutateResult.id}`)\n  },\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n```\n\nWhen returning a promise in any of the callback functions it will first be awaited before the next callback is called:\n\ntsx\n\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n})\n```\n\nYou might find that you want to **trigger additional callbacks** beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts *before* the mutation finishes.\n\ntsx\n\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // I will fire first\n  },\n})\n\nmutate(todo, {\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, onMutateResult, context) => {\n    // I will fire second!\n  },\n})\n```\n\n[### Consecutive mutations](#consecutive-mutations)\n\nThere is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only *once* and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.\n\n> Be aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.\n\ntsx\n\n```\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, onMutateResult, context) => {\n    // Will be called 3 times\n  },\n})\n\nconst todos = ['Todo 1', 'Todo 2', 'Todo 3']\ntodos.forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, variables, onMutateResult, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\n```\n\n[## Promises](#promises)\n\nUse mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.\n\ntsx\n\n```\nconst mutation = useMutation({ mutationFn: addTodo })\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\n```\n\n[## Retry](#retry)\n\nBy default, TanStack Query will not retry a mutation on error, but it is possible with the retry option:\n\ntsx\n\n```\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n```\n\nIf mutations fail because the device is offline, they will be retried in the same order when the device reconnects.\n\n[## Persist mutations](#persist-mutations)\n\nMutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:\n\ntsx\n\n```\nconst queryClient = new QueryClient()\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables, context) => {\n    // Cancel current queries for the todos list\n    await context.client.cancelQueries({ queryKey: ['todos'] })\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n    // Add optimistic todo to todos list\n    context.client.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n    // Return a result with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, onMutateResult, context) => {\n    // Replace optimistic todo in the todos list with the result\n    context.client.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === onMutateResult.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, onMutateResult, context) => {\n    // Remove optimistic todo from the todos list\n    context.client.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== onMutateResult.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\n```\n\n[### Persisting Offline mutations](#persisting-offline-mutations)\n\nIf you persist offline mutations with the [persistQueryClient plugin](/query/latest/docs/framework/react/plugins/persistQueryClient), mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.\n\nThis is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.\n\ntsx\n\n```\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults(['todos'], {\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\nexport default function App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{ persister }}\n      onSuccess={() => {\n        // resume mutations after initial restore from localStorage was successful\n        queryClient.resumePausedMutations()\n      }}\n    >\n      <RestOfTheApp />\n    </PersistQueryClientProvider>\n  )\n}\n```\n\nWe also have an extensive [offline example](/query/latest/docs/framework/react/examples/offline) that covers both queries and mutations.\n\n[## Mutation Scopes](#mutation-scopes)\n\nPer default, all mutations run in parallel - even if you invoke .mutate() of the same mutation multiple times. Mutations can be given a scope with an id to avoid that. All mutations with the same scope.id will run in serial, which means when they are triggered, they will start in isPaused: true state if there is already a mutation for that scope in progress. They will be put into a queue and will automatically resume once their time in the queue has come.\n\ntsx\n\n```\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  scope: {\n    id: 'todo',\n  },\n})\n```\n\n[## Further reading](#further-reading)\n\nFor more information about mutations, have a look at [TkDodo's article on Mastering Mutations in React Query](https://tkdodo.eu/blog/mastering-mutations-in-react-query).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:43.269234+00:00",
  "content_length": 11451,
  "content_hash": "a3c00bde0d307936"
}