{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_query-ke",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/query-keys",
  "title": "Query Keys",
  "content": "At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using\nJSON.stringify\n, and\nunique to the query's data\n, you can use it!\nSimple Query Keys\nThe simplest form of a key is an array with constants values. This format is useful for:\nGeneric List/Index resources\nNon-hierarchical resources\ntsx\n// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\nArray Keys with variables\nWhen a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:\nHierarchical or nested resources\nIt's common to pass an ID, index, or other primitive to uniquely identify the item\nQueries with additional parameters\nIt's common to pass an object of additional options\ntsx\n// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\nQuery Keys are hashed deterministically!\nThis means that no matter the order of keys in objects, all of the following queries are considered equal:\ntsx\nuseQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\nThe following query keys, however, are not equal. Array item order matters!\ntsx\nuseQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\nIf your query function depends on a variable, include it in your query key\nSince query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that\nchange\n. For example:\ntsx\nfunction Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ['todos', todoId],\n    queryFn: () => fetchTodoById(todoId),\n  })\n}\nNote that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes,\nqueries will be refetched automatically\n(depending on your\nstaleTime\nsettings). See the\nexhaustive-deps\nsection for more information and examples.\nFurther reading\nFor tips on organizing Query Keys in larger applications, have a look at\nEffective React Query Keys\nand check the\nQuery Key Factory Package\nfrom\nthe\nCommunity Resources\n.",
  "content_markdown": "At its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable using JSON.stringify, and **unique to the query's data**, you can use it!\n\n[## Simple Query Keys](#simple-query-keys)\n\nThe simplest form of a key is an array with constants values. This format is useful for:\n\n- Generic List/Index resources\n- Non-hierarchical resources\n\ntsx\n\n```\n// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\n```\n\n[## Array Keys with variables](#array-keys-with-variables)\n\nWhen a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:\n\n- Hierarchical or nested resources\n  - It's common to pass an ID, index, or other primitive to uniquely identify the item\n- Queries with additional parameters\n  - It's common to pass an object of additional options\n\ntsx\n\n```\n// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\n```\n\n[## Query Keys are hashed deterministically!](#query-keys-are-hashed-deterministically)\n\nThis means that no matter the order of keys in objects, all of the following queries are considered equal:\n\ntsx\n\n```\nuseQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n```\n\nThe following query keys, however, are not equal. Array item order matters!\n\ntsx\n\n```\nuseQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\n```\n\n[## If your query function depends on a variable, include it in your query key](#if-your-query-function-depends-on-a-variable-include-it-in-your-query-key)\n\nSince query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that **change**. For example:\n\ntsx\n\n```\nfunction Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ['todos', todoId],\n    queryFn: () => fetchTodoById(todoId),\n  })\n}\n```\n\nNote that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, *queries will be refetched automatically* (depending on your staleTime settings). See the [exhaustive-deps](/query/latest/docs/eslint/exhaustive-deps) section for more information and examples.\n\n[## Further reading](#further-reading)\n\nFor tips on organizing Query Keys in larger applications, have a look at [Effective React Query Keys](https://tkdodo.eu/blog/effective-react-query-keys) and check the [Query Key Factory Package](https://github.com/lukemorales/query-key-factory) from\nthe [Community Resources](/query/latest/docs/community-resources).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:26.579321+00:00",
  "content_length": 2832,
  "content_hash": "c19d8670fde1392e"
}