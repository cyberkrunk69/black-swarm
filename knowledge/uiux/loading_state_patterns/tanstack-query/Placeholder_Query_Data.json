{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_placehol",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/placeholder-query-data",
  "title": "Placeholder Query Data",
  "content": "What is placeholder data?\nPlaceholder data allows a query to behave as if it already has data, similar to the\ninitialData\noption, but\nthe data is not persisted to the cache\n. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.\nExample: An individual blog post query could pull \"preview\" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.\nThere are a few ways to supply placeholder data for a query to the cache before you need it:\nDeclaratively:\nProvide\nplaceholderData\nto a query to prepopulate its cache if empty\nImperatively:\nPrefetch or fetch the data using\nqueryClient\nand the\nplaceholderData\noption\nWhen we use\nplaceholderData\n, our Query will not be in a\npending\nstate - it will start out as being in\nsuccess\nstate, because we have\ndata\nto display - even if that data is just \"placeholder\" data. To distinguish it from \"real\" data, we will also have the\nisPlaceholderData\nflag set to\ntrue\non the Query result.\nPlaceholder Data as a Value\ntsx\nfunction Todos() {\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData: placeholderTodos,\n  })\n}\nPlaceholder Data Memoization\nIf the process for accessing a query's placeholder data is intensive or just not something you want to perform on every render, you can memoize the value:\ntsx\nfunction Todos() {\n  const placeholderData = useMemo(() => generateFakeTodos(), [])\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData,\n  })\n}\nPlaceholder Data as a Function\nplaceholderData\ncan also be a function, where you can get access to the data and Query meta information of a \"previous\" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from\n['todos', 1]\nto\n['todos', 2]\n, we can keep displaying \"old\" data instead of having to show a loading spinner while data is\ntransitioning\nfrom one Query to the next. For more information, see\nPaginated Queries\n.\ntsx\nconst result = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => fetch(`/todos/${id}`),\n  placeholderData: (previousData, previousQuery) => previousData,\n})\nPlaceholder Data from Cache\nIn some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:\ntsx\nfunction BlogPost({ blogPostId }) {\n  const queryClient = useQueryClient()\n  const result = useQuery({\n    queryKey: ['blogPost', blogPostId],\n    queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n    placeholderData: () => {\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\n      // query as the placeholder data for this blogPost query\n      return queryClient\n        .getQueryData(['blogPosts'])\n        ?.find((d) => d.id === blogPostId)\n    },\n  })\n}\nFurther reading\nFor a comparison between\nPlaceholder Data\nand\nInitial Data\n, see the\narticle by TkDodo\n.",
  "content_markdown": "[## What is placeholder data?](#what-is-placeholder-data)\n\nPlaceholder data allows a query to behave as if it already has data, similar to the initialData option, but **the data is not persisted to the cache**. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.\n\n> Example: An individual blog post query could pull \"preview\" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.\n\nThere are a few ways to supply placeholder data for a query to the cache before you need it:\n\n- Declaratively:\n  - Provide placeholderData to a query to prepopulate its cache if empty\n- Imperatively:\n  - [Prefetch or fetch the data using queryClient and the placeholderData option](/query/latest/docs/framework/react/guides/prefetching)\n\nWhen we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just \"placeholder\" data. To distinguish it from \"real\" data, we will also have the isPlaceholderData flag set to true on the Query result.\n\n[## Placeholder Data as a Value](#placeholder-data-as-a-value)\n\ntsx\n\n```\nfunction Todos() {\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData: placeholderTodos,\n  })\n}\n```\n\n[### Placeholder Data Memoization](#placeholder-data-memoization)\n\nIf the process for accessing a query's placeholder data is intensive or just not something you want to perform on every render, you can memoize the value:\n\ntsx\n\n```\nfunction Todos() {\n  const placeholderData = useMemo(() => generateFakeTodos(), [])\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData,\n  })\n}\n```\n\n[## Placeholder Data as a Function](#placeholder-data-as-a-function)\n\nplaceholderData can also be a function, where you can get access to the data and Query meta information of a \"previous\" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from ['todos', 1] to ['todos', 2], we can keep displaying \"old\" data instead of having to show a loading spinner while data is *transitioning* from one Query to the next. For more information, see [Paginated Queries](/query/latest/docs/framework/react/guides/paginated-queries).\n\ntsx\n\n```\nconst result = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => fetch(`/todos/${id}`),\n  placeholderData: (previousData, previousQuery) => previousData,\n})\n```\n\n[### Placeholder Data from Cache](#placeholder-data-from-cache)\n\nIn some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:\n\ntsx\n\n```\nfunction BlogPost({ blogPostId }) {\n  const queryClient = useQueryClient()\n  const result = useQuery({\n    queryKey: ['blogPost', blogPostId],\n    queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n    placeholderData: () => {\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\n      // query as the placeholder data for this blogPost query\n      return queryClient\n        .getQueryData(['blogPosts'])\n        ?.find((d) => d.id === blogPostId)\n    },\n  })\n}\n```\n\n[## Further reading](#further-reading)\n\nFor a comparison between Placeholder Data and Initial Data, see the [article by TkDodo](https://tkdodo.eu/blog/placeholder-and-initial-data-in-react-query).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:36.420253+00:00",
  "content_length": 3513,
  "content_hash": "20035c2d9b844ddd"
}