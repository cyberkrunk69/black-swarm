{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_infinite",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries",
  "title": "Infinite Queries",
  "content": "Rendering lists that can additively \"load more\" data onto an existing set of data or \"infinite scroll\" is also a very common UI pattern. TanStack Query supports a useful version of\nuseQuery\ncalled\nuseInfiniteQuery\nfor querying these types of lists.\nWhen using\nuseInfiniteQuery\n, you'll notice a few things are different:\ndata\nis now an object containing infinite query data:\ndata.pages\narray containing the fetched pages\ndata.pageParams\narray containing the page params used to fetch the pages\nThe\nfetchNextPage\nand\nfetchPreviousPage\nfunctions are now available (\nfetchNextPage\nis required)\nThe\ninitialPageParam\noption is now available (and required) to specify the initial page param\nThe\ngetNextPageParam\nand\ngetPreviousPageParam\noptions are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function\nA\nhasNextPage\nboolean is now available and is\ntrue\nif\ngetNextPageParam\nreturns a value other than\nnull\nor\nundefined\nA\nhasPreviousPage\nboolean is now available and is\ntrue\nif\ngetPreviousPageParam\nreturns a value other than\nnull\nor\nundefined\nThe\nisFetchingNextPage\nand\nisFetchingPreviousPage\nbooleans are now available to distinguish between a background refresh state and a loading more state\nNote: Options\ninitialData\nor\nplaceholderData\nneed to conform to the same structure of an object with\ndata.pages\nand\ndata.pageParams\nproperties.\nExample\nLet's assume we have an API that returns pages of\nprojects\n3 at a time based on a\ncursor\nindex along with a cursor that can be used to fetch the next group of projects:\ntsx\nfetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\nWith this information, we can create a \"Load More\" UI by:\nWaiting for\nuseInfiniteQuery\nto request the first group of data by default\nReturning the information for the next query in\ngetNextPageParam\nCalling\nfetchNextPage\nfunction\ntsx\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetching}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n              ? 'Load More'\n              : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\nIt's essential to understand that calling\nfetchNextPage\nwhile an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering\nfetchNextPage\nsimultaneously.\nRemember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.\nIf you intend to enable simultaneous fetching, you can utilize the\n{ cancelRefetch: false }\noption (default: true) within\nfetchNextPage\n.\nTo ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an\nisFetching\nstate, especially if the user won't directly control that call.\njsx\n<List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />\nWhat happens when an infinite query needs to be refetched?\nWhen an infinite query becomes\nstale\nand needs to be refetched, each group is fetched\nsequentially\n, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.\nWhat if I want to implement a bi-directional infinite list?\nBi-directional lists can be implemented by using the\ngetPreviousPageParam\n,\nfetchPreviousPage\n,\nhasPreviousPage\nand\nisFetchingPreviousPage\nproperties and functions.\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\nWhat if I want to show the pages in reversed order?\nSometimes you may want to show the pages in reversed order. If this is case, you can use the\nselect\noption:\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\nWhat if I want to manually update the infinite query?\nManually removing first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\nManually removing a single value from an individual page:\ntsx\nconst newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\nKeep only the first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0, 1),\n  pageParams: data.pageParams.slice(0, 1),\n}))\nMake sure to always keep the same data structure of pages and pageParams!\nWhat if I want to limit the number of pages?\nIn some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:\nwhen the user can load a large number of pages (memory usage)\nwhen you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)\nThe solution is to use a \"Limited Infinite Query\". This is made possible by using the\nmaxPages\noption in conjunction with\ngetNextPageParam\nand\ngetPreviousPageParam\nto allow fetching pages when needed in both directions.\nIn the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\nWhat if my API doesn't return a cursor?\nIf your API doesn't return a cursor, you can use the\npageParam\nas a cursor. Because\ngetNextPageParam\nand\ngetPreviousPageParam\nalso get the\npageParam\nof the current page, you can use it to calculate the next / previous page param.\ntsx\nreturn useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n})\nFurther reading\nTo get a better understanding of how Infinite Queries work under the hood, see the article\nHow Infinite Queries work\n.",
  "content_markdown": "Rendering lists that can additively \"load more\" data onto an existing set of data or \"infinite scroll\" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.\n\nWhen using useInfiniteQuery, you'll notice a few things are different:\n\n- data is now an object containing infinite query data:\n- data.pages array containing the fetched pages\n- data.pageParams array containing the page params used to fetch the pages\n- The fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)\n- The initialPageParam option is now available (and required) to specify the initial page param\n- The getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function\n- A hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined\n- A hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined\n- The isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state\n\n> Note: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.\n\n[## Example](#example)\n\nLet's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:\n\ntsx\n\n```\nfetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n```\n\nWith this information, we can create a \"Load More\" UI by:\n\n- Waiting for useInfiniteQuery to request the first group of data by default\n- Returning the information for the next query in getNextPageParam\n- Calling fetchNextPage function\n\ntsx\n\n```\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetching}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n              ? 'Load More'\n              : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\n```\n\nIt's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.\n\nRemember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.\n\nIf you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.\n\nTo ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.\n\njsx\n\n```\n<List onEndReached={() => hasNextPage && !isFetching && fetchNextPage()} />\n```\n\n[## What happens when an infinite query needs to be refetched?](#what-happens-when-an-infinite-query-needs-to-be-refetched)\n\nWhen an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.\n\n[## What if I want to implement a bi-directional infinite list?](#what-if-i-want-to-implement-a-bi-directional-infinite-list)\n\nBi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.\n\ntsx\n\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\n```\n\n[## What if I want to show the pages in reversed order?](#what-if-i-want-to-show-the-pages-in-reversed-order)\n\nSometimes you may want to show the pages in reversed order. If this is case, you can use the select option:\n\ntsx\n\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\n```\n\n[## What if I want to manually update the infinite query?](#what-if-i-want-to-manually-update-the-infinite-query)\n[### Manually removing first page:](#manually-removing-first-page)\n\ntsx\n\n```\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\n```\n\n[### Manually removing a single value from an individual page:](#manually-removing-a-single-value-from-an-individual-page)\n\ntsx\n\n```\nconst newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\n```\n\n[### Keep only the first page:](#keep-only-the-first-page)\n\ntsx\n\n```\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0, 1),\n  pageParams: data.pageParams.slice(0, 1),\n}))\n```\n\nMake sure to always keep the same data structure of pages and pageParams!\n\n[## What if I want to limit the number of pages?](#what-if-i-want-to-limit-the-number-of-pages)\n\nIn some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:\n\n- when the user can load a large number of pages (memory usage)\n- when you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)\n\nThe solution is to use a \"Limited Infinite Query\". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.\n\nIn the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.\n\ntsx\n\n```\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\n```\n\n[## What if my API doesn't return a cursor?](#what-if-my-api-doesnt-return-a-cursor)\n\nIf your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.\n\ntsx\n\n```\nreturn useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n      return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n      return undefined\n    }\n    return firstPageParam - 1\n  },\n})\n```\n\n[## Further reading](#further-reading)\n\nTo get a better understanding of how Infinite Queries work under the hood, see the article [How Infinite Queries work](https://tkdodo.eu/blog/how-infinite-queries-work).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:47.805181+00:00",
  "content_length": 8105,
  "content_hash": "bf44eb2b8019747c"
}