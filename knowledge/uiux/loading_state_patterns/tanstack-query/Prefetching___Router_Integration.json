{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_prefetch",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/prefetching",
  "title": "Prefetching & Router Integration",
  "content": "When you know or suspect that a certain piece of data will be needed, you can use prefetching to populate the cache with that data ahead of time, leading to a faster experience.\nThere are a few different prefetching patterns:\nIn event handlers\nIn components\nVia router integration\nDuring Server Rendering (another form of router integration)\nIn this guide, we'll take a look at the first three, while the fourth will be covered in depth in the\nServer Rendering & Hydration guide\nand the\nAdvanced Server Rendering guide\n.\nOne specific use of prefetching is to avoid Request Waterfalls, for an in-depth background and explanation of those, see the\nPerformance & Request Waterfalls guide\n.\nprefetchQuery & prefetchInfiniteQuery\nBefore jumping into the different specific prefetch patterns, let's look at the\nprefetchQuery\nand\nprefetchInfiniteQuery\nfunctions. First a few basics:\nOut of the box, these functions use the default\nstaleTime\nconfigured for the\nqueryClient\nto determine whether existing data in the cache is fresh or needs to be fetched again\nYou can also pass a specific\nstaleTime\nlike this:\nprefetchQuery({ queryKey: ['todos'], queryFn: fn, staleTime: 5000 })\nThis\nstaleTime\nis only used for the prefetch, you still need to set it for any\nuseQuery\ncall as well\nIf you want to ignore\nstaleTime\nand instead always return data if it's available in the cache, you can use the\nensureQueryData\nfunction.\nTip: If you are prefetching on the server, set a default\nstaleTime\nhigher than\n0\nfor that\nqueryClient\nto avoid having to pass in a specific\nstaleTime\nto each prefetch call\nIf no instances of\nuseQuery\nappear for a prefetched query, it will be deleted and garbage collected after the time specified in\ngcTime\nThese functions return\nPromise<void>\nand thus never return query data. If that's something you need, use\nfetchQuery\n/\nfetchInfiniteQuery\ninstead.\nThe prefetch functions never throw errors because they usually try to fetch again in a\nuseQuery\nwhich is a nice graceful fallback. If you need to catch errors, use\nfetchQuery\n/\nfetchInfiniteQuery\ninstead.\nThis is how you use\nprefetchQuery\n:\ntsx\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the\npages\noption, in which case you also have to provide a\ngetNextPageParam\nfunction:\ntsx\nconst prefetchProjects = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\nNext, let's look at how you can use these and other ways to prefetch in different situations.\nPrefetch in event handlers\nA straightforward form of prefetching is doing it when the user interacts with something. In this example we'll use\nqueryClient.prefetchQuery\nto start a prefetch on\nonMouseEnter\nor\nonFocus\n.\ntsx\nfunction ShowDetailsButton() {\n  const queryClient = useQueryClient()\n\n  const prefetch = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['details'],\n      queryFn: getDetailsData,\n      // Prefetch only fires when data is older than the staleTime,\n      // so in a case like this you definitely want to set one\n      staleTime: 60000,\n    })\n  }\n\n  return (\n    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>\n      Show Details\n    </button>\n  )\n}\nPrefetch in components\nPrefetching during the component lifecycle is useful when we know some child or descendant will need a particular piece of data, but we can't render that until some other query has finished loading. Let's borrow an example from the Request Waterfall guide to explain:\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\nThis results in a request waterfall looking like this:\n1. |> getArticleById()\n2.   |> getArticleCommentsById()\nAs mentioned in that guide, one way to flatten this waterfall and improve performance is to hoist the\ngetArticleCommentsById\nquery to the parent and pass down the result as a prop, but what if this is not feasible or desirable, for example when the components are unrelated and have multiple levels between them?\nIn that case, we can instead prefetch the query in the parent. The simplest way to do this is to use a query but ignore the result:\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  // Prefetch\n  useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n    // Optional optimization to avoid rerenders when this query changes:\n    notifyOnChangeProps: [],\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\nThis starts fetching\n'article-comments'\nimmediately and flattens the waterfall:\n1. |> getArticleById()\n1. |> getArticleCommentsById()\nIf you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use\nuseSuspenseQueries\nto prefetch, since the prefetch would block the component from rendering. You also can not use\nuseQuery\nfor the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. For this scenario, you can use the\nusePrefetchQuery\nor the\nusePrefetchInfiniteQuery\nhooks available in the library.\nYou can now use\nuseSuspenseQuery\nin the component that actually needs the data. You\nmight\nwant to wrap this later component in its own\n<Suspense>\nboundary so the \"secondary\" query we are prefetching does not block rendering of the \"primary\" data.\ntsx\nfunction ArticleLayout({ id }) {\n  usePrefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  return (\n    <Suspense fallback=\"Loading article\">\n      <Article id={id} />\n    </Suspense>\n  )\n}\n\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useSuspenseQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  ...\n}\nAnother way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use\nqueryClient.prefetchQuery\n:\ntsx\nconst queryClient = useQueryClient()\nconst { data: articleData, isPending } = useQuery({\n  queryKey: ['article', id],\n  queryFn: (...args) => {\n    queryClient.prefetchQuery({\n      queryKey: ['article-comments', id],\n      queryFn: getArticleCommentsById,\n    })\n\n    return getArticleById(...args)\n  },\n})\nPrefetching in an effect also works, but note that if you are using\nuseSuspenseQuery\nin the same component, this effect wont run until\nafter\nthe query finishes which might not be what you want.\ntsx\nconst queryClient = useQueryClient()\n\nuseEffect(() => {\n  queryClient.prefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n}, [queryClient, id])\nTo recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:\nPrefetch before a suspense boundary using\nusePrefetchQuery\nor\nusePrefetchInfiniteQuery\nhooks\nUse\nuseQuery\nor\nuseSuspenseQueries\nand ignore the result\nPrefetch inside the query function\nPrefetch in an effect\nLet's look at a slightly more advanced case next.\nDependent Queries & Code Splitting\nSometimes we want to prefetch conditionally, based on the result of another fetch. Consider this example borrowed from the\nPerformance & Request Waterfalls guide\n:\ntsx\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n  ...\n}\nAs noted over in that guide, this example leads to the following double request waterfall:\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n3.     |> getGraphDataById()\nIf we can not restructure our API so\ngetFeed()\nalso returns the\ngetGraphDataById()\ndata when necessary, there is no way to get rid of the\ngetFeed->getGraphDataById\nwaterfall, but by leveraging conditional prefetching, we can at least load the code and data in parallel. Just like described above, there are multiple ways to do this, but for this example, we'll do it in the query function:\ntsx\nfunction Feed() {\n  const queryClient = useQueryClient()\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: async (...args) => {\n      const feed = await getFeed(...args)\n\n      for (const feedItem of feed) {\n        if (feedItem.type === 'GRAPH') {\n          queryClient.prefetchQuery({\n            queryKey: ['graph', feedItem.id],\n            queryFn: getGraphDataById,\n          })\n        }\n      }\n\n      return feed\n    }\n  })\n\n  ...\n}\nThis would load the code and data in parallel:\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n2.   |> getGraphDataById()\nThere is a tradeoff however, in that the code for\ngetGraphDataById\nis now included in the parent bundle instead of in\nJS for <GraphFeedItem>\nso you'll need to determine what's the best performance tradeoff on a case by case basis. If\nGraphFeedItem\nare likely, it's probably worth to include the code in the parent. If they are exceedingly rare, it's probably not.\nRouter Integration\nBecause data fetching in the component tree itself can easily lead to request waterfalls and the different fixes for that can be cumbersome as they accumulate throughout the application, an attractive way to do prefetching is integrating it at the router level.\nIn this approach, you explicitly declare for each\nroute\nwhat data is going to be needed for that component tree, ahead of time. Because Server Rendering has traditionally needed all data to be loaded before rendering starts, this has been the dominating approach for SSR'd apps for a long time. This is still a common approach and you can read more about it in the\nServer Rendering & Hydration guide\n.\nFor now, let's focus on the client side case and look at an example of how you can make this work with\nTanstack Router\n. These examples leave out a lot of setup and boilerplate to stay concise, you can check out a\nfull React Query example\nover in the\nTanstack Router docs\n.\nWhen integrating at the router level, you can choose to either\nblock\nrendering of that route until all data is present, or you can start a prefetch but not await the result. That way, you can start rendering the route as soon as possible. You can also mix these two approaches and await some critical data, but start rendering before all the secondary data has finished loading. In this example, we'll configure an\n/article\nroute to not render until the article data has finished loading, as well as start prefetching comments as soon as possible, but not block rendering the route if comments haven't finished loading yet.\ntsx\nconst queryClient = new QueryClient()\nconst routerContext = new RouterContext()\nconst rootRoute = routerContext.createRootRoute({\n  component: () => { ... }\n})\n\nconst articleRoute = new Route({\n  getParentRoute: () => rootRoute,\n  path: 'article',\n  beforeLoad: () => {\n    return {\n      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },\n      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },\n    }\n  },\n  loader: async ({\n    context: { queryClient },\n    routeContext: { articleQueryOptions, commentsQueryOptions },\n  }) => {\n    // Fetch comments asap, but don't block\n    queryClient.prefetchQuery(commentsQueryOptions)\n\n    // Don't render the route at all until article has been fetched\n    await queryClient.prefetchQuery(articleQueryOptions)\n  },\n  component: ({ useRouteContext }) => {\n    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()\n    const articleQuery = useQuery(articleQueryOptions)\n    const commentsQuery = useQuery(commentsQueryOptions)\n\n    return (\n      ...\n    )\n  },\n  errorComponent: () => 'Oh crap!',\n})\nIntegration with other routers is also possible, see the\nreact-router\nfor another demonstration.\nManually Priming a Query\nIf you already have the data for your query synchronously available, you don't need to prefetch it. You can just use the\nQuery Client's\nsetQueryData\nmethod\nto directly add or update a query's cached result by key.\ntsx\nqueryClient.setQueryData(['todos'], todos)\nFurther reading\nFor a deep-dive on how to get data into your Query Cache before you fetch, see the\narticle Seeding the Query Cache by TkDodo\n.\nIntegrating with Server Side routers and frameworks is very similar to what we just saw, with the addition that the data has to be passed from the server to the client to be hydrated into the cache there. To learn how, continue on to the\nServer Rendering & Hydration guide\n.",
  "content_markdown": "When you know or suspect that a certain piece of data will be needed, you can use prefetching to populate the cache with that data ahead of time, leading to a faster experience.\n\nThere are a few different prefetching patterns:\n\n1. In event handlers\n2. In components\n3. Via router integration\n4. During Server Rendering (another form of router integration)\n\nIn this guide, we'll take a look at the first three, while the fourth will be covered in depth in the [Server Rendering & Hydration guide](/query/latest/docs/framework/react/guides/ssr) and the [Advanced Server Rendering guide](/query/latest/docs/framework/react/guides/advanced-ssr).\n\nOne specific use of prefetching is to avoid Request Waterfalls, for an in-depth background and explanation of those, see the [Performance & Request Waterfalls guide](/query/latest/docs/framework/react/guides/request-waterfalls).\n\n[## prefetchQuery & prefetchInfiniteQuery](#prefetchquery--prefetchinfinitequery)\n\nBefore jumping into the different specific prefetch patterns, let's look at the prefetchQuery and prefetchInfiniteQuery functions. First a few basics:\n\n- Out of the box, these functions use the default staleTime configured for the queryClient to determine whether existing data in the cache is fresh or needs to be fetched again\n- You can also pass a specific staleTime like this: prefetchQuery({ queryKey: ['todos'], queryFn: fn, staleTime: 5000 })\n  - This staleTime is only used for the prefetch, you still need to set it for any useQuery call as well\n  - If you want to ignore staleTime and instead always return data if it's available in the cache, you can use the ensureQueryData function.\n  - Tip: If you are prefetching on the server, set a default staleTime higher than 0 for that queryClient to avoid having to pass in a specific staleTime to each prefetch call\n- If no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime\n- These functions return Promise<void> and thus never return query data. If that's something you need, use fetchQuery/fetchInfiniteQuery instead.\n- The prefetch functions never throw errors because they usually try to fetch again in a useQuery which is a nice graceful fallback. If you need to catch errors, use fetchQuery/fetchInfiniteQuery instead.\n\nThis is how you use prefetchQuery:\n\ntsx\n\n```\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\n```\n\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:\n\ntsx\n\n```\nconst prefetchProjects = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\n```\n\nNext, let's look at how you can use these and other ways to prefetch in different situations.\n\n[## Prefetch in event handlers](#prefetch-in-event-handlers)\n\nA straightforward form of prefetching is doing it when the user interacts with something. In this example we'll use queryClient.prefetchQuery to start a prefetch on onMouseEnter or onFocus.\n\ntsx\n\n```\nfunction ShowDetailsButton() {\n  const queryClient = useQueryClient()\n\n  const prefetch = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['details'],\n      queryFn: getDetailsData,\n      // Prefetch only fires when data is older than the staleTime,\n      // so in a case like this you definitely want to set one\n      staleTime: 60000,\n    })\n  }\n\n  return (\n    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>\n      Show Details\n    </button>\n  )\n}\n```\n\n[## Prefetch in components](#prefetch-in-components)\n\nPrefetching during the component lifecycle is useful when we know some child or descendant will need a particular piece of data, but we can't render that until some other query has finished loading. Let's borrow an example from the Request Waterfall guide to explain:\n\ntsx\n\n```\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\n```\n\nThis results in a request waterfall looking like this:\n\n```\n1. |> getArticleById()\n2.   |> getArticleCommentsById()\n```\n\nAs mentioned in that guide, one way to flatten this waterfall and improve performance is to hoist the getArticleCommentsById query to the parent and pass down the result as a prop, but what if this is not feasible or desirable, for example when the components are unrelated and have multiple levels between them?\n\nIn that case, we can instead prefetch the query in the parent. The simplest way to do this is to use a query but ignore the result:\n\ntsx\n\n```\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  // Prefetch\n  useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n    // Optional optimization to avoid rerenders when this query changes:\n    notifyOnChangeProps: [],\n  })\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  ...\n}\n```\n\nThis starts fetching 'article-comments' immediately and flattens the waterfall:\n\n```\n1. |> getArticleById()\n1. |> getArticleCommentsById()\n```\n\nIf you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use useSuspenseQueries to prefetch, since the prefetch would block the component from rendering. You also can not use useQuery for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. For this scenario, you can use the [usePrefetchQuery](/query/latest/docs/framework/react/reference/usePrefetchQuery) or the [usePrefetchInfiniteQuery](/query/latest/docs/framework/react/reference/usePrefetchInfiniteQuery) hooks available in the library.\n\nYou can now use useSuspenseQuery in the component that actually needs the data. You *might* want to wrap this later component in its own <Suspense> boundary so the \"secondary\" query we are prefetching does not block rendering of the \"primary\" data.\n\ntsx\n\n```\nfunction ArticleLayout({ id }) {\n  usePrefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n  return (\n    <Suspense fallback=\"Loading article\">\n      <Article id={id} />\n    </Suspense>\n  )\n}\n\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useSuspenseQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n  ...\n}\n```\n\nAnother way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use queryClient.prefetchQuery:\n\ntsx\n\n```\nconst queryClient = useQueryClient()\nconst { data: articleData, isPending } = useQuery({\n  queryKey: ['article', id],\n  queryFn: (...args) => {\n    queryClient.prefetchQuery({\n      queryKey: ['article-comments', id],\n      queryFn: getArticleCommentsById,\n    })\n\n    return getArticleById(...args)\n  },\n})\n```\n\nPrefetching in an effect also works, but note that if you are using useSuspenseQuery in the same component, this effect wont run until *after* the query finishes which might not be what you want.\n\ntsx\n\n```\nconst queryClient = useQueryClient()\n\nuseEffect(() => {\n  queryClient.prefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n}, [queryClient, id])\n```\n\nTo recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:\n\n- Prefetch before a suspense boundary using usePrefetchQuery or usePrefetchInfiniteQuery hooks\n- Use useQuery or useSuspenseQueries and ignore the result\n- Prefetch inside the query function\n- Prefetch in an effect\n\nLet's look at a slightly more advanced case next.\n\n[### Dependent Queries & Code Splitting](#dependent-queries--code-splitting)\n\nSometimes we want to prefetch conditionally, based on the result of another fetch. Consider this example borrowed from the [Performance & Request Waterfalls guide](/query/latest/docs/framework/react/guides/request-waterfalls):\n\ntsx\n\n```\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n  ...\n}\n```\n\nAs noted over in that guide, this example leads to the following double request waterfall:\n\n```\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n3.     |> getGraphDataById()\n```\n\nIf we can not restructure our API so getFeed() also returns the getGraphDataById() data when necessary, there is no way to get rid of the getFeed->getGraphDataById waterfall, but by leveraging conditional prefetching, we can at least load the code and data in parallel. Just like described above, there are multiple ways to do this, but for this example, we'll do it in the query function:\n\ntsx\n\n```\nfunction Feed() {\n  const queryClient = useQueryClient()\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: async (...args) => {\n      const feed = await getFeed(...args)\n\n      for (const feedItem of feed) {\n        if (feedItem.type === 'GRAPH') {\n          queryClient.prefetchQuery({\n            queryKey: ['graph', feedItem.id],\n            queryFn: getGraphDataById,\n          })\n        }\n      }\n\n      return feed\n    }\n  })\n\n  ...\n}\n```\n\nThis would load the code and data in parallel:\n\n```\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n2.   |> getGraphDataById()\n```\n\nThere is a tradeoff however, in that the code for getGraphDataById is now included in the parent bundle instead of in JS for <GraphFeedItem> so you'll need to determine what's the best performance tradeoff on a case by case basis. If GraphFeedItem are likely, it's probably worth to include the code in the parent. If they are exceedingly rare, it's probably not.\n\n[## Router Integration](#router-integration)\n\nBecause data fetching in the component tree itself can easily lead to request waterfalls and the different fixes for that can be cumbersome as they accumulate throughout the application, an attractive way to do prefetching is integrating it at the router level.\n\nIn this approach, you explicitly declare for each *route* what data is going to be needed for that component tree, ahead of time. Because Server Rendering has traditionally needed all data to be loaded before rendering starts, this has been the dominating approach for SSR'd apps for a long time. This is still a common approach and you can read more about it in the [Server Rendering & Hydration guide](/query/latest/docs/framework/react/guides/ssr).\n\nFor now, let's focus on the client side case and look at an example of how you can make this work with [Tanstack Router](https://tanstack.com/router). These examples leave out a lot of setup and boilerplate to stay concise, you can check out a [full React Query example](https://tanstack.com/router/latest/docs/framework/react/examples/basic-react-query-file-based) over in the [Tanstack Router docs](https://tanstack.com/router/latest/docs).\n\nWhen integrating at the router level, you can choose to either *block* rendering of that route until all data is present, or you can start a prefetch but not await the result. That way, you can start rendering the route as soon as possible. You can also mix these two approaches and await some critical data, but start rendering before all the secondary data has finished loading. In this example, we'll configure an /article route to not render until the article data has finished loading, as well as start prefetching comments as soon as possible, but not block rendering the route if comments haven't finished loading yet.\n\ntsx\n\n```\nconst queryClient = new QueryClient()\nconst routerContext = new RouterContext()\nconst rootRoute = routerContext.createRootRoute({\n  component: () => { ... }\n})\n\nconst articleRoute = new Route({\n  getParentRoute: () => rootRoute,\n  path: 'article',\n  beforeLoad: () => {\n    return {\n      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },\n      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },\n    }\n  },\n  loader: async ({\n    context: { queryClient },\n    routeContext: { articleQueryOptions, commentsQueryOptions },\n  }) => {\n    // Fetch comments asap, but don't block\n    queryClient.prefetchQuery(commentsQueryOptions)\n\n    // Don't render the route at all until article has been fetched\n    await queryClient.prefetchQuery(articleQueryOptions)\n  },\n  component: ({ useRouteContext }) => {\n    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()\n    const articleQuery = useQuery(articleQueryOptions)\n    const commentsQuery = useQuery(commentsQueryOptions)\n\n    return (\n      ...\n    )\n  },\n  errorComponent: () => 'Oh crap!',\n})\n```\n\nIntegration with other routers is also possible, see the [react-router](/query/latest/docs/framework/react/examples/react-router) for another demonstration.\n\n[## Manually Priming a Query](#manually-priming-a-query)\n\nIf you already have the data for your query synchronously available, you don't need to prefetch it. You can just use the [Query Client's setQueryData method](/query/latest/docs/reference/QueryClient#queryclientsetquerydata) to directly add or update a query's cached result by key.\n\ntsx\n\n```\nqueryClient.setQueryData(['todos'], todos)\n```\n\n[## Further reading](#further-reading)\n\nFor a deep-dive on how to get data into your Query Cache before you fetch, see the [article Seeding the Query Cache by TkDodo](https://tkdodo.eu/blog/seeding-the-query-cache).\n\nIntegrating with Server Side routers and frameworks is very similar to what we just saw, with the addition that the data has to be passed from the server to the client to be hydrated into the cache there. To learn how, continue on to the [Server Rendering & Hydration guide](/query/latest/docs/framework/react/guides/ssr).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:40.261708+00:00",
  "content_length": 14439,
  "content_hash": "598ebab51d14170c"
}