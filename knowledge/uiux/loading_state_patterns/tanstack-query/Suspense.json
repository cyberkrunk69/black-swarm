{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_suspense",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/suspense",
  "title": "Suspense",
  "content": "React Query can also be used with React's Suspense for Data Fetching APIs. For this, we have dedicated hooks:\nuseSuspenseQuery\nuseSuspenseInfiniteQuery\nuseSuspenseQueries\nAdditionally, you can use the\nuseQuery().promise\nand\nReact.use()\n(Experimental)\nWhen using suspense mode,\nstatus\nstates and\nerror\nobjects are not needed and are then replaced by usage of the\nReact.Suspense\ncomponent (including the use of the\nfallback\nprop and React error boundaries for catching errors). Please read the\nResetting Error Boundaries\nand look at the\nSuspense Example\nfor more information on how to set up suspense mode.\nIf you want mutations to propagate errors to the nearest error boundary (similar to queries), you can set the\nthrowOnError\noption to\ntrue\nas well.\nEnabling suspense mode for a query:\ntsx\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\nconst { data } = useSuspenseQuery({ queryKey, queryFn })\nThis works nicely in TypeScript, because\ndata\nis guaranteed to be defined (as errors and loading states are handled by Suspense- and ErrorBoundaries).\nOn the flip side, you therefore can't conditionally enable / disable the Query. This generally shouldn't be necessary for dependent Queries because with suspense, all your Queries inside one component are fetched in serial.\nplaceholderData\nalso doesn't exist for this Query. To prevent the UI from being replaced by a fallback during an update, wrap your updates that change the QueryKey into\nstartTransition\n.\nthrowOnError default\nNot all errors are thrown to the nearest Error Boundary per default - we're only throwing errors if there is no other data to show. That means if a Query ever successfully got data in the cache, the component will render, even if data is\nstale\n. Thus, the default for\nthrowOnError\nis:\nthrowOnError: (error, query) => typeof query.state.data === 'undefined'\nSince you can't change\nthrowOnError\n(because it would allow for\ndata\nto become potentially\nundefined\n), you have to throw errors manually if you want all errors to be handled by Error Boundaries:\ntsx\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\nconst { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn })\n\nif (error && !isFetching) {\n  throw error\n}\n\n// continue rendering data\nResetting Error Boundaries\nWhether you are using\nsuspense\nor\nthrowOnError\nin your queries, you will need a way to let queries know that you want to try again when re-rendering after some error occurred.\nQuery errors can be reset with the\nQueryErrorResetBoundary\ncomponent or with the\nuseQueryErrorResetBoundary\nhook.\nWhen using the component it will reset any query errors within the boundaries of the component:\ntsx\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\nWhen using the hook it will reset any query errors within the closest\nQueryErrorResetBoundary\n. If there is no boundary defined it will reset them globally:\ntsx\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\nFetch-on-render vs Render-as-you-fetch\nOut of the box, React Query in\nsuspense\nmode works really well as a\nFetch-on-render\nsolution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a\nRender-as-you-fetch\nmodel, we recommend implementing\nPrefetching\non routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.\nSuspense on the Server with streaming\nIf you are using\nNextJs\n, you can use our\nexperimental\nintegration for Suspense on the Server:\n@tanstack/react-query-next-experimental\n. This package will allow you to fetch data on the server (in a client component) by just calling\nuseSuspenseQuery\nin your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve.\nTo achieve this, wrap your app in the\nReactQueryStreamedHydration\ncomponent:\ntsx\n// app/providers.tsx\n'use client'\n\nimport {\n  isServer,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n  if (isServer) {\n    // Server: always make a new query client\n    return makeQueryClient()\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\nexport function Providers(props: { children: React.ReactNode }) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient()\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\nFor more information, check out the\nNextJs Suspense Streaming Example\nand the\nAdvanced Rendering & Hydration\nguide.\nUsing\nuseQuery().promise\nand\nReact.use()\n(Experimental)\nTo enable this feature, you need to set the\nexperimental_prefetchInRender\noption to\ntrue\nwhen creating your\nQueryClient\nExample code:\ntsx\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      experimental_prefetchInRender: true,\n    },\n  },\n})\nUsage:\ntsx\nimport React from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { fetchTodos, type Todo } from './api'\n\nfunction TodoList({ query }: { query: UseQueryResult<Todo[]> }) {\n  const data = React.use(query.promise)\n\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nexport function App() {\n  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n\n  return (\n    <>\n      <h1>Todos</h1>\n      <React.Suspense fallback={<div>Loading...</div>}>\n        <TodoList query={query} />\n      </React.Suspense>\n    </>\n  )\n}\nFor a more complete example, see\nsuspense example on GitHub\n.\nFor a Next.js streaming example, see\nnextjs-suspense-streaming example on GitHub\n.",
  "content_markdown": "React Query can also be used with React's Suspense for Data Fetching APIs. For this, we have dedicated hooks:\n\n- [useSuspenseQuery](/query/latest/docs/framework/react/reference/useSuspenseQuery)\n- [useSuspenseInfiniteQuery](/query/latest/docs/framework/react/reference/useSuspenseInfiniteQuery)\n- [useSuspenseQueries](/query/latest/docs/framework/react/reference/useSuspenseQueries)\n- Additionally, you can use the useQuery().promise and React.use() (Experimental)\n\nWhen using suspense mode, status states and error objects are not needed and are then replaced by usage of the React.Suspense component (including the use of the fallback prop and React error boundaries for catching errors). Please read the [Resetting Error Boundaries](#resetting-error-boundaries) and look at the [Suspense Example](/query/latest/docs/framework/react/examples/suspense) for more information on how to set up suspense mode.\n\nIf you want mutations to propagate errors to the nearest error boundary (similar to queries), you can set the throwOnError option to true as well.\n\nEnabling suspense mode for a query:\n\ntsx\n\n```\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\nconst { data } = useSuspenseQuery({ queryKey, queryFn })\n```\n\nThis works nicely in TypeScript, because data is guaranteed to be defined (as errors and loading states are handled by Suspense- and ErrorBoundaries).\n\nOn the flip side, you therefore can't conditionally enable / disable the Query. This generally shouldn't be necessary for dependent Queries because with suspense, all your Queries inside one component are fetched in serial.\n\nplaceholderData also doesn't exist for this Query. To prevent the UI from being replaced by a fallback during an update, wrap your updates that change the QueryKey into [startTransition](https://react.dev/reference/react/Suspense#preventing-unwanted-fallbacks).\n\n[### throwOnError default](#throwonerror-default)\n\nNot all errors are thrown to the nearest Error Boundary per default - we're only throwing errors if there is no other data to show. That means if a Query ever successfully got data in the cache, the component will render, even if data is stale. Thus, the default for throwOnError is:\n\n```\nthrowOnError: (error, query) => typeof query.state.data === 'undefined'\n```\n\nSince you can't change throwOnError (because it would allow for data to become potentially undefined), you have to throw errors manually if you want all errors to be handled by Error Boundaries:\n\ntsx\n\n```\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\nconst { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn })\n\nif (error && !isFetching) {\n  throw error\n}\n\n// continue rendering data\n```\n\n[## Resetting Error Boundaries](#resetting-error-boundaries)\n\nWhether you are using **suspense** or **throwOnError** in your queries, you will need a way to let queries know that you want to try again when re-rendering after some error occurred.\n\nQuery errors can be reset with the QueryErrorResetBoundary component or with the useQueryErrorResetBoundary hook.\n\nWhen using the component it will reset any query errors within the boundaries of the component:\n\ntsx\n\n```\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\n```\n\nWhen using the hook it will reset any query errors within the closest QueryErrorResetBoundary. If there is no boundary defined it will reset them globally:\n\ntsx\n\n```\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\nconst App = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\n```\n\n[## Fetch-on-render vs Render-as-you-fetch](#fetch-on-render-vs-render-as-you-fetch)\n\nOut of the box, React Query in suspense mode works really well as a **Fetch-on-render** solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a **Render-as-you-fetch** model, we recommend implementing [Prefetching](/query/latest/docs/framework/react/guides/prefetching) on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.\n\n[## Suspense on the Server with streaming](#suspense-on-the-server-with-streaming)\n\nIf you are using NextJs, you can use our **experimental** integration for Suspense on the Server: @tanstack/react-query-next-experimental. This package will allow you to fetch data on the server (in a client component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve.\n\nTo achieve this, wrap your app in the ReactQueryStreamedHydration component:\n\ntsx\n\n```\n// app/providers.tsx\n'use client'\n\nimport {\n  isServer,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  })\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined\n\nfunction getQueryClient() {\n  if (isServer) {\n    // Server: always make a new query client\n    return makeQueryClient()\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient()\n    return browserQueryClient\n  }\n}\n\nexport function Providers(props: { children: React.ReactNode }) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient()\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\n```\n\nFor more information, check out the [NextJs Suspense Streaming Example](/query/latest/docs/framework/react/examples/nextjs-suspense-streaming) and the [Advanced Rendering & Hydration](/query/latest/docs/framework/react/guides/advanced-ssr) guide.\n\n[## Using useQuery().promise and React.use() (Experimental)](#using-usequerypromise-and-reactuse-experimental)\n> To enable this feature, you need to set the experimental\\_prefetchInRender option to true when creating your QueryClient\n\n**Example code:**\n\ntsx\n\n```\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      experimental_prefetchInRender: true,\n    },\n  },\n})\n```\n\n**Usage:**\n\ntsx\n\n```\nimport React from 'react'\nimport { useQuery } from '@tanstack/react-query'\nimport { fetchTodos, type Todo } from './api'\n\nfunction TodoList({ query }: { query: UseQueryResult<Todo[]> }) {\n  const data = React.use(query.promise)\n\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nexport function App() {\n  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })\n\n  return (\n    <>\n      <h1>Todos</h1>\n      <React.Suspense fallback={<div>Loading...</div>}>\n        <TodoList query={query} />\n      </React.Suspense>\n    </>\n  )\n}\n```\n\nFor a more complete example, see [suspense example on GitHub](https://github.com/TanStack/query/tree/main/examples/react/suspense).\n\nFor a Next.js streaming example, see [nextjs-suspense-streaming example on GitHub](https://github.com/TanStack/query/tree/main/examples/react/nextjs-suspense-streaming).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:49.679833+00:00",
  "content_length": 7837,
  "content_hash": "12fc3b281d267300"
}