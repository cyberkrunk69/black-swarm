{
  "id": "tanstack-query__query_latest_docs_framework_react_guides_optimist",
  "source_id": "tanstack-query",
  "source_name": "TanStack Query",
  "category": "loading_state_patterns",
  "url": "https://tanstack.com/query/latest/docs/framework/react/guides/optimistic-updates",
  "title": "Optimistic Updates",
  "content": "React Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the\nonMutate\noption to update your cache directly, or leverage the returned\nvariables\nto update your UI from the\nuseMutation\nresult.\nVia the UI\nThis is the simpler variant, as it doesn't interact with the cache directly.\ntsx\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  // make sure to _return_ the Promise from the query invalidation\n  // so that the mutation stays in `pending` state until the refetch is finished\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\nconst { isPending, submittedAt, variables, mutate, isError } = addTodoMutation\nyou will then have access to\naddTodoMutation.variables\n, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation\nisPending\n:\ntsx\n<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}\n</ul>\nWe're rendering a temporary item with a different\nopacity\nas long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a \"normal item\" in our list.\nIf the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the\nisError\nstate of the mutation.\nvariables\nare\nnot\ncleared when the mutation errors, so we can still access them, maybe even show a retry button:\ntsx\n{\n  isError && (\n    <li style={{ color: 'red' }}>\n      {variables}\n      <button onClick={() => mutate(variables)}>Retry</button>\n    </li>\n  )\n}\nIf the mutation and the query don't live in the same component\nThis approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated\nuseMutationState\nhook. It is best combined with a\nmutationKey\n:\ntsx\n// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo'],\n})\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\nvariables\nwill be an\nArray\n, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select\nmutation.state.submittedAt\n. This will even make displaying concurrent optimistic updates a breeze.\nVia the cache\nWhen you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.\nTo do this,\nuseMutation\n's\nonMutate\nhandler option allows you to return a value that will later be passed to both\nonError\nand\nonSettled\nhandlers as the last argument. In most cases, it is most useful to pass a rollback function.\nUpdating a list of todos when adding a new todo\ntsx\nconst queryClient = useQueryClient()\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo, context) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await context.client.cancelQueries({ queryKey: ['todos'] })\n\n    // Snapshot the previous value\n    const previousTodos = context.client.getQueryData(['todos'])\n\n    // Optimistically update to the new value\n    context.client.setQueryData(['todos'], (old) => [...old, newTodo])\n\n    // Return a result with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the result returned from onMutate to roll back\n  onError: (err, newTodo, onMutateResult, context) => {\n    context.client.setQueryData(['todos'], onMutateResult.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: (data, error, variables, onMutateResult, context) =>\n    context.client.invalidateQueries({ queryKey: ['todos'] }),\n})\nUpdating a single todo\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo, context) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n    // Snapshot the previous value\n    const previousTodo = context.client.getQueryData(['todos', newTodo.id])\n\n    // Optimistically update to the new value\n    context.client.setQueryData(['todos', newTodo.id], newTodo)\n\n    // Return a result with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the result we returned above\n  onError: (err, newTodo, onMutateResult, context) => {\n    context.client.setQueryData(\n      ['todos', onMutateResult.newTodo.id],\n      onMutateResult.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo, error, variables, onMutateResult, context) =>\n    context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),\n})\nYou can also use the\nonSettled\nfunction in place of the separate\nonError\nand\nonSuccess\nhandlers if you wish:\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: async (newTodo, error, variables, onMutateResult, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\nWhen to use what\nIf you only have one place where the optimistic result should be shown, using\nvariables\nand updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.\nHowever, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.\nFurther reading\nHave a look at the guide by TkDodo on\nConcurrent Optimistic Updates\n.",
  "content_markdown": "React Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.\n\n[## Via the UI](#via-the-ui)\n\nThis is the simpler variant, as it doesn't interact with the cache directly.\n\ntsx\n\n```\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  // make sure to _return_ the Promise from the query invalidation\n  // so that the mutation stays in `pending` state until the refetch is finished\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\nconst { isPending, submittedAt, variables, mutate, isError } = addTodoMutation\n```\n\nyou will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation isPending:\n\ntsx\n\n```\n<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}\n</ul>\n```\n\nWe're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a \"normal item\" in our list.\n\nIf the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are *not* cleared when the mutation errors, so we can still access them, maybe even show a retry button:\n\ntsx\n\n```\n{\n  isError && (\n    <li style={{ color: 'red' }}>\n      {variables}\n      <button onClick={() => mutate(variables)}>Retry</button>\n    </li>\n  )\n}\n```\n\n[### If the mutation and the query don't live in the same component](#if-the-mutation-and-the-query-dont-live-in-the-same-component)\n\nThis approach works very well if the mutation and the query live in the same component. However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:\n\ntsx\n\n```\n// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo'],\n})\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\n```\n\nvariables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.\n\n[## Via the cache](#via-the-cache)\n\nWhen you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.\n\nTo do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.\n\n[### Updating a list of todos when adding a new todo](#updating-a-list-of-todos-when-adding-a-new-todo)\n\ntsx\n\n```\nconst queryClient = useQueryClient()\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo, context) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await context.client.cancelQueries({ queryKey: ['todos'] })\n\n    // Snapshot the previous value\n    const previousTodos = context.client.getQueryData(['todos'])\n\n    // Optimistically update to the new value\n    context.client.setQueryData(['todos'], (old) => [...old, newTodo])\n\n    // Return a result with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the result returned from onMutate to roll back\n  onError: (err, newTodo, onMutateResult, context) => {\n    context.client.setQueryData(['todos'], onMutateResult.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: (data, error, variables, onMutateResult, context) =>\n    context.client.invalidateQueries({ queryKey: ['todos'] }),\n})\n```\n\n[### Updating a single todo](#updating-a-single-todo)\n\ntsx\n\n```\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo, context) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await context.client.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n    // Snapshot the previous value\n    const previousTodo = context.client.getQueryData(['todos', newTodo.id])\n\n    // Optimistically update to the new value\n    context.client.setQueryData(['todos', newTodo.id], newTodo)\n\n    // Return a result with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the result we returned above\n  onError: (err, newTodo, onMutateResult, context) => {\n    context.client.setQueryData(\n      ['todos', onMutateResult.newTodo.id],\n      onMutateResult.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo, error, variables, onMutateResult, context) =>\n    context.client.invalidateQueries({ queryKey: ['todos', newTodo.id] }),\n})\n```\n\nYou can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:\n\ntsx\n\n```\nuseMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: async (newTodo, error, variables, onMutateResult, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\n```\n\n[## When to use what](#when-to-use-what)\n\nIf you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.\n\nHowever, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.\n\n[## Further reading](#further-reading)\n\nHave a look at the guide by TkDodo on [Concurrent Optimistic Updates](https://tkdodo.eu/blog/concurrent-optimistic-updates-in-react-query).",
  "tags": [
    "tanstack",
    "query",
    "react",
    "data-fetching"
  ],
  "extracted_at": "2026-02-03T12:52:45.781870+00:00",
  "content_length": 6450,
  "content_hash": "368f31b6f104ad9e"
}