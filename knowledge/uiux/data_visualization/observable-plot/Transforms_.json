{
  "id": "observable-plot__plot_features_transforms",
  "source_id": "observable-plot",
  "source_name": "Observable Plot",
  "category": "data_visualization",
  "url": "https://observablehq.com/plot/features/transforms",
  "title": "Transforms\u200b",
  "content": "Transforms\n\u200b\nTransforms\nderive data as part of the plot specification. This accelerates what is often the most onerous task in visualization: getting data into the right shape.\nFor example, given a\ndataset of highway traffic\nmeasured as vehicles per hour by location, plotting every observation is straightforward: use a\ntick\n(or\ndot\n) and assign\nx\n= vehicles per hour and\ny\n= location. But to draw a quantifiable insight, we may want a summary statistic such as the\nmedian\ntraffic by location. \ud83d\udc69\u200d\ud83d\udcbb Below we use the\ngroup transform\nto group by location and apply a\nmedian\nreducer to position the\nred\ntick.\nFork\njs\nPlot.\nplot\n({\nmarginLeft:\n120\n,\nx: {label:\n\"Vehicles per hour (thousands)\"\n,\ntransform\n: (\nx\n)\n=>\nx\n/\n1000\n},\ny: {label:\nnull\n},\nmarks: [\nPlot.\nruleX\n([\n0\n]),\nPlot.\ntickX\n(\ntraffic,\n{x:\n\"vehicles\"\n, y:\n\"location\"\n, strokeOpacity:\n0.3\n}\n),\nPlot.\ntickX\n(\ntraffic,\nPlot.\ngroupY\n(\n{x:\n\"median\"\n},\n{x:\n\"vehicles\"\n, y:\n\"location\"\n, stroke:\n\"red\"\n, strokeWidth:\n4\n, sort: {y:\n\"x\"\n}}\n)\n)\n]\n})\nAs you might expect, traffic varies significantly throughout the day, so perhaps it would be better to look at the median by hour by location? Instead of grouping only by\ny\n, we can group by both\nx\nand\ny\nto produce a heatmap.\nFork\njs\nPlot.\nplot\n({\nmarginLeft:\n120\n,\npadding:\n0\n,\ny: {label:\nnull\n},\ncolor: {scheme:\n\"YlGnBu\"\n, legend:\ntrue\n, zero:\ntrue\n},\nmarks: [\nPlot.\ncell\n(\ntraffic,\nPlot.\ngroup\n(\n{fill:\n\"median\"\n},\n{\nx\n: (\nd\n)\n=>\nd.date.\ngetUTCHours\n(), y:\n\"location\"\n, fill:\n\"vehicles\"\n, inset:\n0.5\n, sort: {y:\n\"fill\"\n}}\n)\n)\n]\n})\nPlot includes many useful transforms! For example, you can compute a\nrolling average\nto smooth a noisy signal,\nstack layers\nfor a streamgraph, or\ndodge dots\nfor a beeswarm. Plot\u2019s various built-in transforms include:\nbin\n,\ncentroid\n,\ndodge\n,\nfilter\n,\ngroup\n,\nhexbin\n,\ninterval\n,\nmap\n,\nnormalize\n,\nreverse\n,\nselect\n,\nshuffle\n,\nsort\n,\nstack\n,\ntree\n, and\nwindow\n. If these don\u2019t meet your needs, you can even implement a\ncustom transform\n.\nTransforms are never required \u2014\u00a0you can always aggregate and derive data yourself outside of Plot, and then pass in the binned values. For example, we could use\nd3.bin\nto compute a histogram of athletes\u2019\u00a0weights as an array of {\nx0\n,\nx1\n,\nlength\n} objects.\njs\nbins\n=\nd3.\nbin\n().\nthresholds\n(\n80\n).\nvalue\n((\nd\n)\n=>\nd.weight)(olympians)\nWe can then pass that to the\nrect mark\n, assigning to the\nx1\n,\nx2\n, and\ny2\nchannels:\njs\nPlot.\nrectY\n(bins, {x1:\n\"x0\"\n, x2:\n\"x1\"\n, y2:\n\"length\"\n}).\nplot\n()\nINFO\nThis is for demonstration only; you wouldn\u2019t normally bin \u201cby hand\u201d\u00a0as shown here.\nBut Plot\u2019s transforms are often more convenient, especially in conjunction with Plot\u2019s other features such as\nfaceting\nand automatic grouping by\nz\n. For example, if we want to add a color encoding to our histogram, we simply add the\nfill\noption and the bin transform partitions each bin accordingly; doing this with d3.bin would be a lot more work!\nFork\njs\nPlot.\nrectY\n(olympians, Plot.\nbinX\n({y:\n\"count\"\n}, {x:\n\"weight\"\n, fill:\n\"sex\"\n})).\nplot\n({color: {legend:\ntrue\n}})\nPlot\u2019s transforms typically take two\noptions\nobjects as arguments: the first object contains the\ntransform\noptions (above,\n{y: \"count\"}\n), while the second object contains\nmark\noptions to be \u201cpassed through\u201d to the mark (\n{x: \"weight\", fill: \"sex\"}\n). The transform returns a new options object representing the\ntransformed\nmark options to be passed to a mark.\nBreaking down the above code:\njs\nconst\noptions\n=\n{x:\n\"weight\"\n, fill:\n\"sex\"\n};\n// initial mark options\nconst\nbinOptions\n=\n{y:\n\"count\"\n};\n// bin transform options\nconst\nbinned\n=\nPlot.\nbinX\n(binOptions, options);\n// transformed mark options\nconst\nrect\n=\nPlot.\nrectY\n(olympians, binned);\n// rect mark\nconst\nplot\n=\nrect.\nplot\n({color: {legend:\ntrue\n}});\n// plot!\nTIP\nIf a transform isn\u2019t doing what you expect, try inspecting the options object returned by the transform. Does it contain the options you expect?\nTransforms can derive channels (such as\ny\nabove) as well as changing the default options. For example, the bin transform sets default insets for a one-pixel gap between adjacent rects.\nTransforms are composable: you can pass\noptions\nthrough more than one transform before passing it to a mark. For example, above it\u2019s a bit difficult to compare the weight distribution by sex because there are fewer\nfemale\nthan\nmale\nathletes in the data. We can remove this effect using the\nnormalize transform\nwith the\nsum\nreducer.\nFork\njs\nPlot.\nplot\n({\ny: {percent:\ntrue\n},\nmarks: [\nPlot.\nrectY\n(\nolympians,\nPlot.\nnormalizeY\n(\n\"sum\"\n,\n// normalize each series by the sum per series\nPlot.\nbinX\n(\n{y2:\n\"count\"\n},\n// disable implicit stack transform\n{x:\n\"weight\"\n, fill:\n\"sex\"\n, mixBlendMode:\n\"multiply\"\n}\n)\n)\n)\n]\n})\nAnd, as you may have wondered above, many of Plot\u2019s\nmarks\nprovide implicit transforms: for example, the\nrectY mark\napplies an implicit\nstackY transform\nif you use the\ny\noption, and the\ndot mark\napplies an implicit\nsort transform\nto mitigate the effect of occlusion by drawing the smallest dots on top.\nCustom transforms\n\u200b\nFor greater control, you can also implement a custom\ntransform\nfunction, allowing data, indexes, or channels to be derived prior to rendering. Custom transforms are rarely implemented directly; see the built-in transforms above. For example, below we implement the\nfilter transform\n\u201cby hand\u201d as a custom transform to show the unemployment rates only in Michigan metropolitan divisions.\nFork\njs\nPlot.\nplot\n({\ny: {\ngrid:\ntrue\n,\nlabel:\n\"Unemployment (%)\"\n},\ncolor: {\ndomain: [\nfalse\n,\ntrue\n],\nrange: [\n\"#ccc\"\n,\n\"red\"\n]\n},\nmarks: [\nPlot.\nruleY\n([\n0\n]),\nPlot.\nline\n(bls, {\nx:\n\"date\"\n,\ny:\n\"unemployment\"\n,\nz:\n\"division\"\n,\ntransform\n: (\ndata\n,\nfacets\n)\n=>\n({\ndata,\nfacets: facets.\nmap\n((\nfacet\n)\n=>\n{\nreturn\nfacet.\nfilter\n((\ni\n)\n=>\n{\nreturn\n/\n, MI\n/\n.\ntest\n(data[i].division);\n});\n})\n})\n})\n]\n})\nThe\ntransform\nfunction is passed three arguments,\ndata\n,\nfacets\n, and\noptions\nrepresenting the mark\u2019s data and facet indexes, and the plot\u2019s options; it must then return a {\ndata\n,\nfacets\n} object with the transformed data and facet indexes. The\nfacets\nare represented as a nested array of arrays such as [[0, 1, 3, \u2026], [2, 5, 10, \u2026], \u2026]; each element in\nfacets\nspecifies the zero-based indexes of elements in\ndata\nthat are in a given facet (\ni.e.\n, have a distinct value in the associated\nfx\nor\nfy\ndimension).\nIf the\ntransform\noption is specified, it supersedes any basic transforms (\ni.e.\n, the\nfilter\n,\nsort\nand\nreverse\noptions are ignored). However, the\ntransform\noption is rarely used directly; instead one of Plot\u2019s built-in transforms are used, and these transforms automatically compose with the basic\nfilter\n,\nsort\nand\nreverse\ntransforms.\nWhile transform functions often produce new\ndata\nor\nfacets\n, they may return the passed-in\ndata\nand\nfacets\nas-is, and often have a side effect of constructing derived channels. For example, the count of elements in a\ngroupX transform\nmight be returned as a new\ny\nchannel. In this case, the transform is typically expressed as an options transform: a function that takes a mark\noptions\nobject and returns a new, transformed options object, where the returned options object implements the\ntransform\noption. Transform functions should not mutate the input\ndata\nor\nfacets\n. Likewise options transforms should not mutate the input\noptions\nobject.\nWhen implementing a custom transform for generic usage, keep in mind that it needs to be compatible with Plot\u2019s\nfaceting system\n, which partitions the original dataset into discrete subsets.\nCustom initializers\n^0.5.0\n\u200b\nInitializers are a special class of transform; whereas transforms operate in abstract data space, initializers operate in screen space such as pixel coordinates and colors. For example, initializers can modify a marks\u2019 positions to avoid occlusion. Initializers are invoked\nafter\nthe initial scales are constructed and can modify the channels or derive new channels; these in turn may (or may not, as desired) be passed to scales. Plot\u2019s\nhexbin\nand\ndodge\ntransforms are initializers.\nYou can specify a custom initializer by specifying a function as the mark\ninitializer\noption. This function is called after the scales have been computed, and receives as inputs the (possibly transformed) array of\ndata\n, the\nfacets\nindex of elements of this array that belong to each facet, the input\nchannels\n(as an object of named channels), the\nscales\n, and the\ndimensions\n. The mark itself is the\nthis\ncontext. The initializer function must return an object with\ndata\n,\nfacets\n, and new\nchannels\n. Any new channels are merged with existing channels, replacing channels of the same name.\nIf an initializer desires a channel that is not supported by the downstream mark, additional channels can be declared using the mark\nchannels\noption.\ntransform(\noptions\n,\ntransform\n)\n^0.4.3\n\u200b\njs\nPlot.\ntransform\n(options, (\ndata\n,\nfacets\n)\n=>\n{\nreturn\n{\ndata,\nfacets: facets.\nmap\n((\nI\n)\n=>\nI\n.\nfilter\n(()\n=>\nMath.\nrandom\n()\n>\n0.5\n))\n};\n})\nGiven an\noptions\nobject that may specify some basic transforms (\nfilter\n,\nsort\n, or\nreverse\n) or a custom\ntransform\nfunction, composes those transforms if any with the given\ntransform\nfunction, returning a new\noptions\nobject. If a custom\ntransform\nfunction is present on the given\noptions\n, any basic transforms are ignored. Any additional input\noptions\nare passed through in the returned\noptions\nobject. This method facilitates applying the basic transforms prior to applying the given custom\ntransform\nand is used internally by Plot\u2019s built-in transforms.\ninitializer(\noptions\n,\ninitializer\n)\n^0.5.0\n\u200b\nThis helper composes the\ninitializer\nfunction with any other transforms present in the\noptions\n, and returns a new\noptions\nobject. It is used internally by Plot\u2019s built-in initializer transforms.\nvalueof(\ndata\n,\nvalue\n,\ntype\n)\n\u200b\njs\nPlot.\nvalueof\n(aapl,\n\"Close\"\n)\nGiven an iterable\ndata\nand some\nvalue\naccessor, returns an array (a column) of the specified\ntype\nwith the corresponding value of each element of the data. The\nvalue\naccessor may be one of the following types:\na string - corresponding to the field accessor (\n(d) => d[value]\n)\nan accessor function - called as\ntype\n.from(\ndata\n,\nvalue\n)\na number, Date, or boolean \u2014 resulting in an array uniformly filled with the\nvalue\nan object with a\ntransform\nmethod \u2014 called as\nvalue\n.transform(\ndata\n)\nan array of values - returning the same\nnull or undefined - returning the same\nIf\ntype\nis specified, it must be Array or a similar class that implements the\nArray.from\ninterface such as a typed array. When\ntype\nis Array or a typed array class, the return value of valueof will be an instance of the same (or null or undefined). When\ntype\nis a typed array, values will be implicitly coerced numbers, and if\ntype\nis Float64Array, Float32Array, or a subclass of the same, null values will be implicitly replaced with NaN. If\ntype\nis not specified, valueof may return either an array or a typed array (or null or undefined).\nvalueof is not guaranteed to return a new array. When a transform method is used, or when the given\nvalue\nis an array that is compatible with the requested\ntype\n, the array may be returned as-is without making a copy.\ncolumn(\nsource\n)\n^0.4.3\n\u200b\njs\nconst\n[\nX\n,\nsetX\n]\n=\nPlot.\ncolumn\n();\nThis helper for constructing derived columns returns a [\ncolumn\n,\nsetColumn\n] array. The\ncolumn\nobject implements\ncolumn\n.transform, returning whatever value was most recently passed to\nsetColumn\n. If\nsetColumn\nis not called, then\ncolumn\n.transform returns undefined. If a\nsource\nis specified, then\ncolumn\n.label exposes the given\nsource\n\u2019s label, if any: if\nsource\nis a string as when representing a named field of data, then\ncolumn\n.label is\nsource\n; otherwise\ncolumn\n.label propagates\nsource\n.label. This allows derived columns to propagate a human-readable axis or legend label.\nThis method is used by Plot\u2019s transforms to derive channels; the associated columns are populated (derived) when the\ntransform\noption function is invoked.\nidentity\n^0.6.2\n\u200b\njs\nPlot.\ncontour\n(data, {width: w, height: h, fill: Plot.identity})\nThis channel helper returns a source array as-is, avoiding an extra copy when defining a channel as being equal to the data.\nindexOf\n^0.6.6\n\u200b\njs\nPlot.\nlineY\n(numbers, {x: Plot.indexOf, y: Plot.identity})\nThis channel helper returns an array of numbers [0, 1, 2, 3, \u2026]. It is used internally by marks with zero-based index defaults for channels.",
  "content_markdown": "# Transforms [\u200b](#transforms)\n\n**Transforms** derive data as part of the plot specification. This accelerates what is often the most onerous task in visualization: getting data into the right shape.\n\nFor example, given a [dataset of highway traffic](https://gist.github.com/chrtze/c74efb46cadb6a908bbbf5227934bfea) measured as vehicles per hour by location, plotting every observation is straightforward: use a [tick](./../marks/tick) (or [dot](./../marks/dot)) and assign **x** = vehicles per hour and **y** = location. But to draw a quantifiable insight, we may want a summary statistic such as the *median* traffic by location. \ud83d\udc69\u200d\ud83d\udcbb Below we use the [group transform](./../transforms/group) to group by location and apply a *median* reducer to position the red tick.\n\n[Fork](https://observablehq.com/@observablehq/plot-sorted-groups \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marginLeft: 120,\n  x: {label: \"Vehicles per hour (thousands)\", transform: (x) => x / 1000},\n  y: {label: null},\n  marks: [\n    Plot.ruleX([0]),\n    Plot.tickX(\n      traffic,\n      {x: \"vehicles\", y: \"location\", strokeOpacity: 0.3}\n    ),\n    Plot.tickX(\n      traffic,\n      Plot.groupY(\n        {x: \"median\"},\n        {x: \"vehicles\", y: \"location\", stroke: \"red\", strokeWidth: 4, sort: {y: \"x\"}}\n      )\n    )\n  ]\n})\n```\n\nAs you might expect, traffic varies significantly throughout the day, so perhaps it would be better to look at the median by hour by location? Instead of grouping only by **y**, we can group by both **x** and **y** to produce a heatmap.\n\n[Fork](https://observablehq.com/@observablehq/plot-sorted-heatmap \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marginLeft: 120,\n  padding: 0,\n  y: {label: null},\n  color: {scheme: \"YlGnBu\", legend: true, zero: true},\n  marks: [\n    Plot.cell(\n      traffic,\n      Plot.group(\n        {fill: \"median\"},\n        {x: (d) => d.date.getUTCHours(), y: \"location\", fill: \"vehicles\", inset: 0.5, sort: {y: \"fill\"}}\n      )\n    )\n  ]\n})\n```\n\nPlot includes many useful transforms! For example, you can compute a [rolling average](./../transforms/window) to smooth a noisy signal, [stack layers](./../transforms/stack) for a streamgraph, or [dodge dots](./../transforms/dodge) for a beeswarm. Plot\u2019s various built-in transforms include: [bin](./../transforms/bin), [centroid](./../transforms/centroid), [dodge](./../transforms/dodge), [filter](./../transforms/filter), [group](./../transforms/group), [hexbin](./../transforms/hexbin), [interval](./../transforms/interval), [map](./../transforms/map), [normalize](./../transforms/normalize), [reverse](./../transforms/sort#reverse), [select](./../transforms/select), [shuffle](./../transforms/sort#shuffle), [sort](./../transforms/sort), [stack](./../transforms/stack), [tree](./../transforms/tree), and [window](./../transforms/window). If these don\u2019t meet your needs, you can even implement a [custom transform](#custom-transforms).\n\nTransforms are never required \u2014\u00a0you can always aggregate and derive data yourself outside of Plot, and then pass in the binned values. For example, we could use [d3.bin](https://d3js.org/d3-array/bin) to compute a histogram of athletes\u2019\u00a0weights as an array of {*x0*, *x1*, *length*} objects.\n\njs\n\n```\nbins = d3.bin().thresholds(80).value((d) => d.weight)(olympians)\n```\n\nWe can then pass that to the [rect mark](./../marks/rect), assigning to the **x1**, **x2**, and **y2** channels:\n\njs\n\n```\nPlot.rectY(bins, {x1: \"x0\", x2: \"x1\", y2: \"length\"}).plot()\n```\n\nINFO\n\nThis is for demonstration only; you wouldn\u2019t normally bin \u201cby hand\u201d\u00a0as shown here.\n\nBut Plot\u2019s transforms are often more convenient, especially in conjunction with Plot\u2019s other features such as [faceting](./facets) and automatic grouping by **z**. For example, if we want to add a color encoding to our histogram, we simply add the **fill** option and the bin transform partitions each bin accordingly; doing this with d3.bin would be a lot more work!\n\n[Fork](https://observablehq.com/@observablehq/plot-vertical-histogram \"Open on Observable\")\n\njs\n\n```\nPlot.rectY(olympians, Plot.binX({y: \"count\"}, {x: \"weight\", fill: \"sex\"})).plot({color: {legend: true}})\n```\n\nPlot\u2019s transforms typically take two *options* objects as arguments: the first object contains the *transform* options (above, `{y: \"count\"}`), while the second object contains *mark* options to be \u201cpassed through\u201d to the mark (`{x: \"weight\", fill: \"sex\"}`). The transform returns a new options object representing the *transformed* mark options to be passed to a mark.\n\nBreaking down the above code:\n\njs\n\n```\nconst options = {x: \"weight\", fill: \"sex\"}; // initial mark options\nconst binOptions = {y: \"count\"}; // bin transform options\nconst binned = Plot.binX(binOptions, options); // transformed mark options\nconst rect = Plot.rectY(olympians, binned); // rect mark\nconst plot = rect.plot({color: {legend: true}}); // plot!\n```\n\nTIP\n\nIf a transform isn\u2019t doing what you expect, try inspecting the options object returned by the transform. Does it contain the options you expect?\n\nTransforms can derive channels (such as **y** above) as well as changing the default options. For example, the bin transform sets default insets for a one-pixel gap between adjacent rects.\n\nTransforms are composable: you can pass *options* through more than one transform before passing it to a mark. For example, above it\u2019s a bit difficult to compare the weight distribution by sex because there are fewer female than male athletes in the data. We can remove this effect using the [normalize transform](./../transforms/normalize) with the *sum* reducer.\n\n[Fork](https://observablehq.com/@observablehq/plot-overlapping-relative-histogram \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  y: {percent: true},\n  marks: [\n    Plot.rectY(\n      olympians,\n      Plot.normalizeY(\n        \"sum\", // normalize each series by the sum per series\n        Plot.binX(\n          {y2: \"count\"}, // disable implicit stack transform\n          {x: \"weight\", fill: \"sex\", mixBlendMode: \"multiply\"}\n        )\n      )\n    )\n  ]\n})\n```\n\nAnd, as you may have wondered above, many of Plot\u2019s [marks](./marks) provide implicit transforms: for example, the [rectY mark](./../marks/rect) applies an implicit [stackY transform](./../transforms/stack) if you use the **y** option, and the [dot mark](./../marks/dot) applies an implicit [sort transform](./../transforms/sort) to mitigate the effect of occlusion by drawing the smallest dots on top.\n\n## Custom transforms [\u200b](#custom-transforms)\n\nFor greater control, you can also implement a custom **transform** function, allowing data, indexes, or channels to be derived prior to rendering. Custom transforms are rarely implemented directly; see the built-in transforms above. For example, below we implement the [filter transform](./../transforms/filter) \u201cby hand\u201d as a custom transform to show the unemployment rates only in Michigan metropolitan divisions.\n\n[Fork](https://observablehq.com/@observablehq/plot-custom-transform-example \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  y: {\n    grid: true,\n    label: \"Unemployment (%)\"\n  },\n  color: {\n    domain: [false, true],\n    range: [\"#ccc\", \"red\"]\n  },\n  marks: [\n    Plot.ruleY([0]),\n    Plot.line(bls, {\n      x: \"date\",\n      y: \"unemployment\",\n      z: \"division\",\n      transform: (data, facets) => ({\n        data,\n        facets: facets.map((facet) => {\n          return facet.filter((i) => {\n            return /, MI /.test(data[i].division);\n          });\n        })\n      })\n    })\n  ]\n})\n```\n\nThe **transform** function is passed three arguments, *data*, *facets*, and *options* representing the mark\u2019s data and facet indexes, and the plot\u2019s options; it must then return a {*data*, *facets*} object with the transformed data and facet indexes. The *facets* are represented as a nested array of arrays such as [[0, 1, 3, \u2026], [2, 5, 10, \u2026], \u2026]; each element in *facets* specifies the zero-based indexes of elements in *data* that are in a given facet (*i.e.*, have a distinct value in the associated *fx* or *fy* dimension).\n\nIf the **transform** option is specified, it supersedes any basic transforms (*i.e.*, the **filter**, **sort** and **reverse** options are ignored). However, the **transform** option is rarely used directly; instead one of Plot\u2019s built-in transforms are used, and these transforms automatically compose with the basic **filter**, **sort** and **reverse** transforms.\n\nWhile transform functions often produce new *data* or *facets*, they may return the passed-in *data* and *facets* as-is, and often have a side effect of constructing derived channels. For example, the count of elements in a [groupX transform](./../transforms/group) might be returned as a new *y* channel. In this case, the transform is typically expressed as an options transform: a function that takes a mark *options* object and returns a new, transformed options object, where the returned options object implements the **transform** option. Transform functions should not mutate the input *data* or *facets*. Likewise options transforms should not mutate the input *options* object.\n\nWhen implementing a custom transform for generic usage, keep in mind that it needs to be compatible with Plot\u2019s [faceting system](./facets), which partitions the original dataset into discrete subsets.\n\n## Custom initializers [^0.5.0](https://github.com/observablehq/plot/releases/tag/v0.5.0 \"added in v0.5.0\") [\u200b](#custom-initializers)\n\nInitializers are a special class of transform; whereas transforms operate in abstract data space, initializers operate in screen space such as pixel coordinates and colors. For example, initializers can modify a marks\u2019 positions to avoid occlusion. Initializers are invoked *after* the initial scales are constructed and can modify the channels or derive new channels; these in turn may (or may not, as desired) be passed to scales. Plot\u2019s [hexbin](./../transforms/hexbin) and [dodge](./../transforms/dodge) transforms are initializers.\n\nYou can specify a custom initializer by specifying a function as the mark **initializer** option. This function is called after the scales have been computed, and receives as inputs the (possibly transformed) array of *data*, the *facets* index of elements of this array that belong to each facet, the input *channels* (as an object of named channels), the *scales*, and the *dimensions*. The mark itself is the *this* context. The initializer function must return an object with *data*, *facets*, and new *channels*. Any new channels are merged with existing channels, replacing channels of the same name.\n\nIf an initializer desires a channel that is not supported by the downstream mark, additional channels can be declared using the mark **channels** option.\n\n## transform(*options*, *transform*) [^0.4.3](https://github.com/observablehq/plot/releases/tag/v0.4.3 \"added in v0.4.3\") [\u200b](#transform)\n\njs\n\n```\nPlot.transform(options, (data, facets) => {\n  return {\n    data,\n    facets: facets.map((I) => I.filter(() => Math.random() > 0.5))\n  };\n})\n```\n\nGiven an *options* object that may specify some basic transforms (**filter**, **sort**, or **reverse**) or a custom **transform** function, composes those transforms if any with the given *transform* function, returning a new *options* object. If a custom **transform** function is present on the given *options*, any basic transforms are ignored. Any additional input *options* are passed through in the returned *options* object. This method facilitates applying the basic transforms prior to applying the given custom *transform* and is used internally by Plot\u2019s built-in transforms.\n\n## initializer(*options*, *initializer*) [^0.5.0](https://github.com/observablehq/plot/releases/tag/v0.5.0 \"added in v0.5.0\") [\u200b](#initializer)\n\nThis helper composes the *initializer* function with any other transforms present in the *options*, and returns a new *options* object. It is used internally by Plot\u2019s built-in initializer transforms.\n\n## valueof(*data*, *value*, *type*) [\u200b](#valueof)\n\njs\n\n```\nPlot.valueof(aapl, \"Close\")\n```\n\nGiven an iterable *data* and some *value* accessor, returns an array (a column) of the specified *type* with the corresponding value of each element of the data. The *value* accessor may be one of the following types:\n\n- a string - corresponding to the field accessor (`(d) => d[value]`)\n- an accessor function - called as *type*.from(*data*, *value*)\n- a number, Date, or boolean \u2014 resulting in an array uniformly filled with the *value*\n- an object with a **transform** method \u2014 called as *value*.transform(*data*)\n- an array of values - returning the same\n- null or undefined - returning the same\n\nIf *type* is specified, it must be Array or a similar class that implements the [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) interface such as a typed array. When *type* is Array or a typed array class, the return value of valueof will be an instance of the same (or null or undefined). When *type* is a typed array, values will be implicitly coerced numbers, and if *type* is Float64Array, Float32Array, or a subclass of the same, null values will be implicitly replaced with NaN. If *type* is not specified, valueof may return either an array or a typed array (or null or undefined).\n\nvalueof is not guaranteed to return a new array. When a transform method is used, or when the given *value* is an array that is compatible with the requested *type*, the array may be returned as-is without making a copy.\n\n## column(*source*) [^0.4.3](https://github.com/observablehq/plot/releases/tag/v0.4.3 \"added in v0.4.3\") [\u200b](#column)\n\njs\n\n```\nconst [X, setX] = Plot.column();\n```\n\nThis helper for constructing derived columns returns a [*column*, *setColumn*] array. The *column* object implements *column*.transform, returning whatever value was most recently passed to *setColumn*. If *setColumn* is not called, then *column*.transform returns undefined. If a *source* is specified, then *column*.label exposes the given *source*\u2019s label, if any: if *source* is a string as when representing a named field of data, then *column*.label is *source*; otherwise *column*.label propagates *source*.label. This allows derived columns to propagate a human-readable axis or legend label.\n\nThis method is used by Plot\u2019s transforms to derive channels; the associated columns are populated (derived) when the **transform** option function is invoked.\n\n## identity [^0.6.2](https://github.com/observablehq/plot/releases/tag/v0.6.2 \"added in v0.6.2\") [\u200b](#identity)\n\njs\n\n```\nPlot.contour(data, {width: w, height: h, fill: Plot.identity})\n```\n\nThis channel helper returns a source array as-is, avoiding an extra copy when defining a channel as being equal to the data.\n\n## indexOf [^0.6.6](https://github.com/observablehq/plot/releases/tag/v0.6.6 \"added in v0.6.6\") [\u200b](#indexOf)\n\njs\n\n```\nPlot.lineY(numbers, {x: Plot.indexOf, y: Plot.identity})\n```\n\nThis channel helper returns an array of numbers [0, 1, 2, 3, \u2026]. It is used internally by marks with zero-based index defaults for channels.",
  "tags": [
    "observable",
    "plot",
    "visualization",
    "d3"
  ],
  "extracted_at": "2026-02-03T12:50:59.897670+00:00",
  "content_length": 12355,
  "content_hash": "ce52f8535799c367"
}