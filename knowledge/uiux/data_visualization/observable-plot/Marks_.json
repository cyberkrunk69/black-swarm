{
  "id": "observable-plot__plot_features_marks",
  "source_id": "observable-plot",
  "source_name": "Observable Plot",
  "category": "data_visualization",
  "url": "https://observablehq.com/plot/features/marks",
  "title": "Marks\u200b",
  "content": "Marks\n\u200b\nTIP\nIf you aren\u2019t yet up and running with Plot, please read our\ngetting started guide\nfirst. Tinkering with the code below will give a better sense of how Plot works.\nPlot doesn\u2019t have chart types; instead, you construct charts by layering\nmarks\n.\nMarks are geometric shapes\n\u200b\nPlot provides a variety of mark types. Think of marks as the \u201cvisual vocabulary\u201d \u2014\u00a0the painter\u2019s palette \ud83c\udfa8, but of shapes instead of colors \u2014\u00a0that you pull from when composing a chart. Each mark type produces a certain type of geometric shape.\nFor example, the\ndot mark\ndraws stroked circles (by default).\nFork\njs\nPlot.\ndot\n(gistemp, {x:\n\"Date\"\n, y:\n\"Anomaly\"\n}).\nplot\n()\nThe\nline mark\ndraws connected line segments (also known as a\npolyline\nor\npolygonal chain\n).\nFork\njs\nPlot.\nlineY\n(gistemp, {x:\n\"Date\"\n, y:\n\"Anomaly\"\n}).\nplot\n()\nAnd the\nbar mark\ndraws rectangular bars in either a horizontal (barX\u2192) or vertical (barY\u2191) orientation.\nFork\njs\nPlot.\nbarX\n(alphabet, {x:\n\"frequency\"\n, y:\n\"letter\"\n}).\nplot\n()\nSo instead of looking for a chart type, consider the shape of the primary graphical elements in your chart, and look for the corresponding mark type. If a chart has only a single mark, the mark type\nis\neffectively the chart type: the bar mark is used to make a bar chart, the area mark is used to make an area chart, and so on.\nMarks are layered\n\u200b\nThe big advantage of mark types over chart types is that you can compose multiple marks of different types into a single\nplot\n. For example, below an\narea\nand\nline\nare used to plot the same sequence of values, while a\nrule\nemphasizes\ny\n= 0.\nFork\njs\nPlot.\nplot\n({\nmarks: [\nPlot.\nruleY\n([\n0\n]),\nPlot.\nareaY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n, fillOpacity:\n0.2\n}),\nPlot.\nlineY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n})\n]\n})\nEach mark supplies its own data; a quick way to combine multiple datasets into a chart is to declare a separate mark for each. You can even use\narray\n.map\nto create multiple marks from nested data.\nFork\njs\nPlot.\nplot\n({\nmarks: [\n[goog, aapl].\nmap\n((\nstock\n)\n=>\nPlot.\nlineY\n(stock, {x:\n\"Date\"\n, y:\n\"Close\"\n}))\n]\n})\nMarks may also be a function which returns an\nSVG element\n, if you wish to insert arbitrary content. (Here we use\nHypertext Literal\nto generate an SVG gradient.)\nFork\njs\nPlot.\nplot\n({\nmarks: [\n()\n=>\nhtl.\nsvg\n`<defs>\n<linearGradient id=\"gradient\" gradientTransform=\"rotate(90)\">\n<stop offset=\"15%\" stop-color=\"purple\" />\n<stop offset=\"75%\" stop-color=\"red\" />\n<stop offset=\"100%\" stop-color=\"gold\" />\n</linearGradient>\n</defs>`\n,\nPlot.\nbarY\n(alphabet, {x:\n\"letter\"\n, y:\n\"frequency\"\n, fill:\n\"url(#gradient)\"\n}),\nPlot.\nruleY\n([\n0\n])\n]\n})\nAnd marks may be null or undefined, which produce no output; this is useful for showing marks conditionally (\ne.g.\n, when a box is checked).\nShow area:\nFork\njs\nPlot.\nplot\n({\nmarks: [\nPlot.\nruleY\n([\n0\n]),\narea\n?\nPlot.\nareaY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n, fillOpacity:\n0.2\n})\n:\nnull\n,\nPlot.\nlineY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n})\n]\n})\nMarks use scales\n\u200b\nMarks are (typically) not positioned in literal pixels, or colored in literal colors, as in a conventional graphics system. Instead you provide abstract values such as time and temperature \u2014\u00a0marks are drawn \u201cin data space\u201d \u2014\u00a0and\nscales\nencode these into visual values such as position and color. And best of all, Plot automatically creates\naxes\nand\nlegends\nto document the scales\u2019 encodings.\nData is passed through scales automatically during rendering; the mark controls which scales are used. The\nx\nand\ny\noptions are typically bound to the\nx\nand\ny\nscales, respectively, while the\nfill\nand\nstroke\noptions are typically bound to the\ncolor\nscale. Changing a scale\u2019s definition, say by overriding its\ndomain\n(the extent of abstract input values) or\ntype\n, affects the appearance of all marks that use the scale.\nFork\njs\nPlot.\nplot\n({\ny: {\ntype:\n\"log\"\n,\ndomain: [\n30\n,\n300\n],\ngrid:\ntrue\n},\nmarks: [\nPlot.\nlineY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n})\n]\n})\nMarks have tidy data\n\u200b\nA single mark can draw multiple shapes. A mark generally produces a shape \u2014\u00a0such as a rectangle or circle \u2014\u00a0for each element in the data.\nFork\njs\nPlot.\ndot\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n}).\nplot\n()\nIt\u2019s more complicated than that, though, since some marks produce shapes that incorporate\nmultiple\ndata points. Pass the same data to a\nline\nand you\u2019ll get a single polyline.\nFork\njs\nPlot.\nlineY\n(aapl, {x:\n\"Date\"\n, y:\n\"Close\"\n}).\nplot\n()\nAnd a line mark isn\u2019t even guaranteed to produce a single polyline \u2014\u00a0there can be multiple polylines, as in a line chart with multiple series (using\nz\n).\nFork\njs\nPlot.\nlineY\n(bls, {x:\n\"date\"\n, y:\n\"unemployment\"\n, z:\n\"division\"\n}).\nplot\n()\nPlot favors\ntidy data\nstructured as an array of objects, where each object represents an observation (a row), and each object property represents an observed value; all objects in the array should have the same property names (the columns).\nFor example, say we have hourly readings from two sensors\nA\nand\nB\n. You can represent the sensor log as an array of objects like so:\njs\nlinedata\n=\n[\n{hour:\n0\n, value:\n8\n, sensor:\n\"A\"\n},\n{hour:\n0\n, value:\n6\n, sensor:\n\"B\"\n},\n{hour:\n1\n, value:\n7\n, sensor:\n\"A\"\n},\n{hour:\n1\n, value:\n5\n, sensor:\n\"B\"\n},\n{hour:\n2\n, value:\n3\n, sensor:\n\"A\"\n},\n{hour:\n2\n, value:\n0\n, sensor:\n\"B\"\n},\n{hour:\n3\n, value:\n9\n, sensor:\n\"A\"\n},\n{hour:\n3\n, value:\n2\n, sensor:\n\"B\"\n}\n]\nTIP\nFor larger datasets, you can more efficiently pass data using an\nApache Arrow\ntable as a columnar data representation.\n^0.6.16\nThen you can pass the data to the line mark, and extract named columns from the data for the desired options:\nFork\njs\nPlot.\nlineY\n(linedata, {x:\n\"hour\"\n, y:\n\"value\"\n, stroke:\n\"sensor\"\n}).\nplot\n()\nAnother common way to extract a column from tabular data is an accessor function. This function is invoked for each element in the data (each row), and returns the corresponding observed value, as with\narray\n.map\n.\nFork\njs\nPlot.\nlineY\n(linedata, {\nx\n: (\nd\n)\n=>\nd.hour,\ny\n: (\nd\n)\n=>\nd.value,\nstroke\n:\u00a0(\nd\n)\n=>\nd.sensor\n}).\nplot\n()\nFor greater efficiency, Plot also supports columnar data: you can use an\nApache Arrow\ntable as data instead of an array of objects.\n^0.6.16\nYou can even pass parallel arrays of values, or Apache Arrow vectors, to each channel.\njs\nPlot.\nlineY\n({length: linedata.\nlength\n}, {\nx: linedata.\nmap\n((\nd\n)\n=>\nd.hour),\ny: linedata.\nmap\n((\nd\n)\n=>\nd.value),\nstroke:\u00a0linedata.\nmap\n((\nd\n)\n=>\nd.sensor)\n}).\nplot\n()\nTIP\nNote that when accessor functions or parallel arrays are used instead of field names, automatic axis labels (\nhour\nand\nvalue\n) are lost. These can be restored using the\nlabel\noption on the\nx\nand\ny\nscales.\nMarks imply data types\n\u200b\nData comes in different types: quantitative (or temporal) values can be subtracted, ordinal values can be ordered, and nominal (or categorical) values can only be the same or different.\nINFO\nBecause nominal values often need some arbitrary order for display purposes \u2014\u00a0often alphabetical \u2014\u00a0Plot uses the term\nordinal\nto refer to both ordinal and nominal data.\nSome marks work with any type of data, while other marks have certain requirements or assumptions of data. For example, a line should only be used when both\nx\nand\ny\nare quantitative or temporal, and when the data is in a meaningful order (such as chronological). This is because the line mark will interpolate between adjacent points to draw line segments. If\nx\nor\ny\nis nominal \u2014\u00a0say the names of countries \u2014\u00a0it doesn\u2019t make sense to use a line because there is no half-way point between two nominal values.\nFork\njs\nPlot.\nlineY\n([\n\"please\"\n,\n\"don\u2019t\"\n,\n\"do\"\n,\n\"this\"\n]).\nplot\n()\n// \ud83c\udf36\ufe0f\nWARNING\nWhile Plot aspires to give good defaults and helpful warnings, Plot won\u2019t prevent you from creating a meaningless chart.\nOnly you\ncan prevent bogus charts!\nIn particular, beware the simple \u201cbar\u201d! A bar mark is used for a bar chart, but a rect mark is needed for a histogram. Plot has four different mark types for drawing rectangles:\nuse\nrect\nwhen both\nx\nand\ny\nare quantitative\nuse\nbarX\nwhen\nx\nis quantitative and\ny\nis ordinal\nuse\nbarY\nwhen\nx\nis ordinal and\ny\nis quantitative\nuse\ncell\nwhen both\nx\nand\ny\nare ordinal\nPlot encourages you to think about data types as you visualize because data types often imply semantics. For example, do you notice anything strange about the bar chart below?\nFork\njs\nPlot\n.\nbarY\n(timeseries, {x:\n\"year\"\n, y:\n\"population\"\n})\n// \ud83c\udf36\ufe0f\n.\nplot\n({x: {tickFormat:\n\"\"\n}})\nHere\u2019s the underlying data:\njs\ntimeseries\n=\n[\n{year:\n2014\n, population:\n7295.290765\n},\n{year:\n2015\n, population:\n7379.797139\n},\n{year:\n2016\n, population:\n7464.022049\n},\n{year:\n2017\n, population:\n7547.858925\n},\n{year:\n2019\n, population:\n7713.468100\n},\n{year:\n2020\n, population:\n7794.798739\n}\n]\nThe data is missing the population for the year 2018! Because the barY mark implies an ordinal\nx\nscale, the gap is hidden. Switching to the rectY mark (with the\ninterval\noption to indicate that these are annual observations) reveals the missing data.\nFork\njs\nPlot\n.\nrectY\n(timeseries, {x:\n\"year\"\n, y:\n\"population\"\n, interval:\n1\n})\n.\nplot\n({x: {tickFormat:\n\"\"\n}})\nAlternatively, you can keep the barY mark and apply the\ninterval\noption to the\nx\nscale.\nFork\njs\nPlot\n.\nbarY\n(timeseries, {x:\n\"year\"\n, y:\n\"population\"\n})\n.\nplot\n({x: {tickFormat:\n\"\"\n, interval:\n1\n}})\nMarks have options\n\u200b\nWhen constructing a mark, you can specify options to change the mark\u2019s appearance. These options are passed as a second argument to the mark constructor. (The first argument is the required data.) For example, if you want filled dots instead of stroked ones, pass the desired color to the\nfill\noption:\nFork\njs\nPlot.\ndot\n(gistemp, {x:\n\"Date\"\n, y:\n\"Anomaly\"\n, fill:\n\"red\"\n}).\nplot\n()\nAs the name suggests, options are generally optional; Plot tries to provide good defaults for whatever you don\u2019t specify. Plot even has\nshorthand\nfor various common forms of data. Below, we extract an array of numbers from the\ngistemp\ndataset, and use the line mark shorthand to set\nx\n= index and\ny\n= identity.\nFork\njs\nPlot.\nlineY\n(gistemp.\nmap\n((\nd\n)\n=>\nd.Anomaly)).\nplot\n()\nSome marks even provide default\ntransforms\n, say for\nstacking\n!\nTIP\nBecause Plot strives to be concise, there are many default behaviors, some of which can be subtle. If Plot isn\u2019t doing what you expect, try disabling the defaults by specifying options explicitly.\nIn addition to the standard options such as\nfill\nand\nstroke\nthat are supported by all mark types, each mark type can support options unique to that type. For example, the dot mark takes a\nsymbol\noption so you can draw things other than circles. See the documentation for each mark type to see what it supports.\nMarks have channels\n\u200b\nChannels are mark options that can be used to encode data. These options allow the value to vary with the data, such as a different position or color for each dot. To use a channel, supply it with a column of data, typically as:\na field (column) name,\nan accessor function, or\nan array of values of the same length and order as the data.\nNot all mark options can be expressed as channels. For example,\nstroke\ncan be a channel but\nstrokeDasharray\ncannot. This is mostly a pragmatic limitation \u2014\u00a0it would be harder to implement Plot if every option were expressible as a channel \u2014\u00a0but it also serves to guide you towards options that are intended for encoding data.\nTIP\nTo vary the definition of a constant option with data, create multiple marks with your different constant options, and then filter the data for each mark to achieve the desired result.\nSome options can be either a channel or a constant depending on the provided value. For example, if you set the\nfill\noption to\npurple\n, Plot interprets it as a literal color.\nFork\njs\nPlot\n.\nbarX\n(timeseries, {x:\n\"population\"\n, y:\n\"year\"\n, fill:\n\"purple\"\n})\n.\nplot\n({y: {label:\nnull\n, tickFormat:\n\"\"\n}})\nWhereas if the\nfill\noption is a string but\nnot\na valid CSS color, Plot assumes you mean the corresponding column of the data and interprets it as a channel.\nFork\njs\nPlot\n.\nbarX\n(timeseries, {x:\n\"population\"\n, y:\n\"year\"\n, fill:\n\"year\"\n})\n.\nplot\n({y: {label:\nnull\n, tickFormat:\n\"\"\n}})\nIf the\nfill\noption is a function, it is interpreted as a channel.\nFork\njs\nPlot\n.\nbarX\n(timeseries, {x:\n\"population\"\n, y:\n\"year\"\n,\nfill\n: (\nd\n)\n=>\nd.year})\n.\nplot\n({y: {label:\nnull\n, tickFormat:\n\"\"\n}})\nLastly, note that while channels are normally bound to a\nscale\n, you can bypass the\ncolor\nscale here by supplying literal color values to the\nfill\nchannel.\nFork\njs\nPlot\n.\nbarX\n(timeseries, {x:\n\"population\"\n, y:\n\"year\"\n,\nfill\n: (\nd\n)\n=>\nd.year\n&\n1\n?\n\"red\"\n:\n\"currentColor\"\n})\n.\nplot\n({y: {label:\nnull\n, tickFormat:\n\"\"\n}})\nBut rather than supplying literal values, it is more semantic to provide abstract values and use scales. In addition to centralizing the encoding definition (if used by multiple marks), it allows Plot to generate a legend.\neven\nodd\nFork\njs\nPlot\n.\nbarX\n(timeseries, {x:\n\"population\"\n, y:\n\"year\"\n,\nfill\n: (\nd\n)\n=>\nd.year\n&\n1\n?\n\"odd\"\n:\n\"even\"\n})\n.\nplot\n({y: {label:\nnull\n, tickFormat:\n\"\"\n}, color: {legend:\ntrue\n}})\nYou can then specify the\ncolor\nscale\u2019s\ndomain\nand\nrange\nto control the encoding.\nMark options\n\u200b\nMark constructors take two arguments:\ndata\nand\noptions\n. Together these describe a tabular dataset and how to visualize it. Option values that must be the same for all of a mark\u2019s generated shapes are known as\nconstants\n, whereas option values that may vary across a mark\u2019s generated shapes are known as\nchannels\n. Channels are typically bound to\nscales\nand encode abstract data values, such as time or temperature, as visual values, such as position or color. (Channels can also be used to order ordinal domains; see the\nsort\noption\n.)\nA mark\u2019s data is most commonly an array of objects representing a tabular dataset, such as the result of loading a CSV file, while a mark\u2019s options bind channels (such as\nx\nand\ny\n) to columns in the data (such as\nunits\nand\nfruit\n).\njs\nsales\n=\n[\n{units:\n10\n, fruit:\n\"peach\"\n},\n{units:\n20\n, fruit:\n\"pear\"\n},\n{units:\n40\n, fruit:\n\"plum\"\n},\n{units:\n30\n, fruit:\n\"plum\"\n}\n]\njs\nPlot.\ndot\n(sales, {x:\n\"units\"\n, y:\n\"fruit\"\n})\nWhile a column name such as\n\"units\"\nis the most concise way of specifying channel values, values can also be specified as functions for greater flexibility, say to transform data or derive a new column on the fly. Channel functions are invoked for each datum (\nd\n) in the data and return the corresponding channel value. (This is similar to how D3\u2019s\nselection\n.attr\naccepts functions, though note that Plot channel functions should return abstract values, not visual values.)\njs\nPlot.\ndot\n(sales, {\nx\n: (\nd\n)\n=>\nd.units\n*\n1000\n,\ny\n: (\nd\n)\n=>\nd.fruit})\nPlot also supports columnar data for greater efficiency with bigger datasets; for example, data can be specified as any array of the appropriate length (or any iterable or value compatible with\nArray.from\n), and then separate arrays of values can be passed as\noptions\n.\njs\nindex\n=\n[\n0\n,\n1\n,\n2\n,\n3\n]\njs\nunits\n=\n[\n10\n,\n20\n,\n40\n,\n30\n]\njs\nfruits\n=\n[\n\"peach\"\n,\n\"pear\"\n,\n\"plum\"\n,\n\"plum\"\n]\njs\nPlot.\ndot\n(index, {x: units, y: fruits})\nChannel values can also be specified as numbers for constant values, say for a fixed baseline with an\narea\n.\njs\nPlot.\narea\n(aapl, {x1:\n\"Date\"\n, y1:\n0\n, y2:\n\"Close\"\n})\nMissing and invalid data are handled specifically for each mark type and channel. In most cases, if the provided channel value for a given datum is null, undefined, or (strictly) NaN, the mark will implicitly filter the datum and not generate a corresponding output. In some cases, such as the radius (\nr\n) of a dot, the channel value must additionally be positive. Plot.line and Plot.area will stop the path before any invalid point and start again at the next valid point, thus creating interruptions rather than interpolating between valid points. Titles will only be added if they are non-empty.\nAll marks support the following style options:\nfill\n- fill color\nfillOpacity\n- fill opacity (a number between 0 and 1)\nstroke\n- stroke color\nstrokeWidth\n- stroke width (in pixels)\nstrokeOpacity\n- stroke opacity (a number between 0 and 1)\nstrokeLinejoin\n- how to join lines (\nbevel\n,\nmiter\n,\nmiter-clip\n, or\nround\n)\nstrokeLinecap\n- how to cap lines (\nbutt\n,\nround\n, or\nsquare\n)\nstrokeMiterlimit\n- to limit the length of\nmiter\njoins\nstrokeDasharray\n- a comma-separated list of dash lengths (typically in pixels)\nstrokeDashoffset\n- the\nstroke dash offset\n(typically in pixels)\nopacity\n- object opacity (a number between 0 and 1)\nmixBlendMode\n- the\nblend mode\n(\ne.g.\n,\nmultiply\n)\nimageFilter\n- a CSS\nfilter\n(\ne.g.\n,\nblur(5px)\n)\n^0.6.7\nshapeRendering\n- the\nshape-rendering mode\n(\ne.g.\n,\ncrispEdges\n)\npaintOrder\n- the\npaint order\n(\ne.g.\n,\nstroke\n)\ndx\n- horizontal offset (in pixels; defaults to 0)\ndy\n- vertical offset (in pixels; defaults to 0)\ntarget\n- link target (e.g., \u201c_blank\u201d for a new window); for use with the\nhref\nchannel\nclassName\n- the\nclass attribute\n, if any (defaults to null)\n^0.6.16\nariaDescription\n- a textual description of the mark\u2019s contents\nariaHidden\n- if true, hide this content from the accessibility tree\npointerEvents\n- the\npointer events\n(\ne.g.\n,\nnone\n)\nclip\n- whether and how to clip the mark\ntip\n- whether to generate an implicit\npointer\ntip\n^0.6.7\nIf the\nclip\noption\nis\nframe\n(or equivalently true), the mark is clipped to the frame\u2019s dimensions. If the\nclip\noption is null (or equivalently false), the mark is not clipped. If the\nclip\noption is\nsphere\n, the mark will be clipped to the projected sphere (\ne.g.\n, the front hemisphere when using the orthographic projection); a\ngeographic projection\nis required in this case. Lastly if the\nclip\noption is a GeoJSON object\n^0.6.17\n, the mark will be clipped to the projected geometry.\nIf the\ntip\noption is true, a\ntip mark\nwith the\npointer transform\nwill be derived from this mark and placed atop all other marks, offering details on demand. If the\ntip\noption is set to an options object, these options will be passed to the derived tip mark. If the\ntip\noption (or, if an object, its\npointer\noption) is set to\nx\n,\ny\n, or\nxy\n,\npointerX\n,\npointerY\n, or\npointer\nwill be used, respectively; otherwise the pointing mode will be chosen automatically. (If the\ntip\nmark option is truthy, the\ntitle\nchannel is no longer applied using an SVG title element as this would conflict with the tip mark.)\nFor all marks except\ntext\n, the\ndx\nand\ndy\noptions are rendered as a transform property, possibly including a 0.5px offset on low-density screens.\nAll marks support the following optional channels:\nfill\n- a fill color; bound to the\ncolor\nscale\nfillOpacity\n- a fill opacity; bound to the\nopacity\nscale\nstroke\n- a stroke color; bound to the\ncolor\nscale\nstrokeOpacity\n- a stroke opacity; bound to the\nopacity\nscale\nstrokeWidth\n- a stroke width (in pixels)\nopacity\n- an object opacity; bound to the\nopacity\nscale\ntitle\n- an accessible, short-text description (a string of text, possibly with newlines)\nhref\n- a URL to link to\nariaLabel\n- a short label representing the value in the accessibility tree\nThe\nfill\n,\nfillOpacity\n,\nstroke\n,\nstrokeWidth\n,\nstrokeOpacity\n, and\nopacity\noptions can be specified as either channels or constants. When the fill or stroke is specified as a function or array, it is interpreted as a channel; when the fill or stroke is specified as a string, it is interpreted as a constant if a valid CSS color and otherwise it is interpreted as a column name for a channel. Similarly when the fill opacity, stroke opacity, object opacity, stroke width, or radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\nThe scale associated with any channel can be overridden by specifying the channel as an object with a\nvalue\nproperty specifying the channel values and a\nscale\nproperty specifying the desired scale name or null for an unscaled channel. For example, to force the\nstroke\nchannel to be unscaled, interpreting the associated values as literal color strings:\njs\nPlot.\ndot\n(data, {stroke: {value:\n\"fieldName\"\n, scale:\nnull\n}})\nTo instead force the\nstroke\nchannel to be bound to the\ncolor\nscale regardless of the provided values, say:\njs\nPlot.\ndot\n(data, {stroke: {value:\n\"fieldName\"\n, scale:\n\"color\"\n}})\nThe color channels (\nfill\nand\nstroke\n) are bound to the\ncolor\nscale by default, unless the provided values are all valid CSS color strings or nullish, in which case the values are interpreted literally and unscaled.\nIn addition to functions of data, arrays, and column names, channel values can be specified as an object with a\ntransform\nmethod; this transform method is passed the mark\u2019s array of data and must return the corresponding array of channel values. (Whereas a channel value specified as a function is invoked repeatedly for each element in the mark\u2019s data, similar to\narray\n.map, the transform method is invoked only once being passed the entire array of data.) For example, to pass the mark\u2019s data directly to the\nx\nchannel, equivalent to\nPlot.identity\n:\njs\nPlot.\ndot\n(numbers, {x: {\ntransform\n: (\ndata\n)\n=>\ndata}})\nThe\ntitle\n,\nhref\n, and\nariaLabel\noptions can\nonly\nbe specified as channels. When these options are specified as a string, the string refers to the name of a column in the mark\u2019s associated data. If you\u2019d like every instance of a particular mark to have the same value, specify the option as a function that returns the desired value,\ne.g.\n() => \"Hello, world!\"\n.\nFor marks that support the\nframeAnchor\noption, it may be specified as one of the four sides (\ntop\n,\nright\n,\nbottom\n,\nleft\n), one of the four corners (\ntop-left\n,\ntop-right\n,\nbottom-right\n,\nbottom-left\n), or the\nmiddle\nof the frame.\nAll marks support the following\ntransform\noptions:\nfilter\n- apply the\nfilter transform\nsort\n- apply the\nsort transform\nreverse\n- apply the\nreverse transform\ntransform\n- apply a\ncustom transform\ninitializer\n- apply a\ncustom initializer\nThe\nsort\noption, when not specified as a channel value (such as a field name or an accessor function), can also be used to\nimpute ordinal scale domains\n.\nInsets\n\u200b\nRect-like marks support insets: a positive inset moves the respective side in (towards the opposing side), whereas a negative inset moves the respective side out (away from the opposing side). Insets are specified in pixels using the following options:\ninset\n- shorthand for all four insets\ninsetTop\n- inset the top edge\ninsetRight\n- inset the right edge\ninsetBottom\n- inset the bottom edge\ninsetLeft\n- inset the left edge\nInsets default to zero. Insets are commonly used to create a one-pixel gap between adjacent bars in histograms; the\nbin transform\nprovides default insets. (Note that the\nband scale padding\ndefaults to 0.1 as an alternative to insets.)\nRounded corners\n\u200b\nRect-like marks support rounded corners. Each corner (or side) is individually addressable\n^0.6.16\nusing the following options:\nr\n- the radius for all four corners\nrx1\n- the radius for the\nx1\n-\ny1\nand\nx1\n-\ny2\ncorners\nrx2\n- the radius for the\nx2\n-\ny1\nand\nx2\n-\ny2\ncorners\nry1\n- the radius for the\nx1\n-\ny1\nand\nx2\n-\ny1\ncorners\nry2\n- the radius for the\nx1\n-\ny2\nand\nx2\n-\ny2\ncorners\nrx1y1\n- the radius for the\nx1\n-\ny1\ncorner\nrx1y2\n- the radius for the\nx1\n-\ny2\ncorner\nrx2y1\n- the radius for the\nx2\n-\ny1\ncorner\nrx2y2\n- the radius for the\nx2\n-\ny2\ncorner\nrx\n- the\nx\n-radius\nfor elliptical corners\nry\n- the\ny\n-radius\nfor elliptical corners\nCorner radii are specified in either pixels or, for\nrx\nand\nry\n, as percentages (strings) or the keyword\nauto\n. If the corner radii are too big, they are reduced proportionally.\nmarks(...\nmarks\n)\n^0.2.0\n\u200b\njs\nPlot.\nmarks\n(\nPlot.\nruleY\n([\n0\n]),\nPlot.\nareaY\n(data, {fill: color, fillOpacity,\n...\noptions}),\nPlot.\nlineY\n(data, {stroke: color,\n...\noptions})\n)\nA convenience method for composing a mark from a series of other marks. Returns an array of marks that implements the\nmark\n.plot function. See the\nbox mark\nimplementation for an example.",
  "content_markdown": "# Marks [\u200b](#Marks)\n\nTIP\n\nIf you aren\u2019t yet up and running with Plot, please read our [getting started guide](./../getting-started) first. Tinkering with the code below will give a better sense of how Plot works.\n\nPlot doesn\u2019t have chart types; instead, you construct charts by layering **marks**.\n\n## Marks are geometric shapes [\u200b](#marks-are-geometric-shapes)\n\nPlot provides a variety of mark types. Think of marks as the \u201cvisual vocabulary\u201d \u2014\u00a0the painter\u2019s palette \ud83c\udfa8, but of shapes instead of colors \u2014\u00a0that you pull from when composing a chart. Each mark type produces a certain type of geometric shape.\n\nFor example, the [dot mark](./../marks/dot) draws stroked circles (by default).\n\n[Fork](https://observablehq.com/@observablehq/plot-temporal-scatterplot \"Open on Observable\")\n\njs\n\n```\nPlot.dot(gistemp, {x: \"Date\", y: \"Anomaly\"}).plot()\n```\n\nThe [line mark](./../marks/line) draws connected line segments (also known as a *polyline* or *polygonal chain*).\n\n[Fork](https://observablehq.com/@observablehq/plot-temporal-line-chart \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(gistemp, {x: \"Date\", y: \"Anomaly\"}).plot()\n```\n\nAnd the [bar mark](./../marks/bar) draws rectangular bars in either a horizontal (barX\u2192) or vertical (barY\u2191) orientation.\n\n[Fork](https://observablehq.com/@observablehq/plot-alphabet-bar-chart \"Open on Observable\")\n\njs\n\n```\nPlot.barX(alphabet, {x: \"frequency\", y: \"letter\"}).plot()\n```\n\nSo instead of looking for a chart type, consider the shape of the primary graphical elements in your chart, and look for the corresponding mark type. If a chart has only a single mark, the mark type *is* effectively the chart type: the bar mark is used to make a bar chart, the area mark is used to make an area chart, and so on.\n\n## Marks are layered [\u200b](#marks-are-layered)\n\nThe big advantage of mark types over chart types is that you can compose multiple marks of different types into a single [plot](./plots). For example, below an [area](./../marks/area) and [line](./../marks/line) are used to plot the same sequence of values, while a [rule](./../marks/rule) emphasizes *y* = 0.\n\n[Fork](https://observablehq.com/@observablehq/plot-layered-marks-2 \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marks: [\n    Plot.ruleY([0]),\n    Plot.areaY(aapl, {x: \"Date\", y: \"Close\", fillOpacity: 0.2}),\n    Plot.lineY(aapl, {x: \"Date\", y: \"Close\"})\n  ]\n})\n```\n\nEach mark supplies its own data; a quick way to combine multiple datasets into a chart is to declare a separate mark for each. You can even use [*array*.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) to create multiple marks from nested data.\n\n[Fork](https://observablehq.com/@observablehq/plot-layered-marks-2 \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marks: [\n    [goog, aapl].map((stock) => Plot.lineY(stock, {x: \"Date\", y: \"Close\"}))\n  ]\n})\n```\n\nMarks may also be a function which returns an [SVG element](https://developer.mozilla.org/en-US/docs/Web/SVG/Element), if you wish to insert arbitrary content. (Here we use [Hypertext Literal](https://github.com/observablehq/htl) to generate an SVG gradient.)\n\n[Fork](https://observablehq.com/@observablehq/plot-gradient-bars \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marks: [\n    () => htl.svg`<defs>\n      <linearGradient id=\"gradient\" gradientTransform=\"rotate(90)\">\n        <stop offset=\"15%\" stop-color=\"purple\" />\n        <stop offset=\"75%\" stop-color=\"red\" />\n        <stop offset=\"100%\" stop-color=\"gold\" />\n      </linearGradient>\n    </defs>`,\n    Plot.barY(alphabet, {x: \"letter\", y: \"frequency\", fill: \"url(#gradient)\"}),\n    Plot.ruleY([0])\n  ]\n})\n```\n\nAnd marks may be null or undefined, which produce no output; this is useful for showing marks conditionally (*e.g.*, when a box is checked).\n\nShow area:\n\n[Fork](https://observablehq.com/@observablehq/plot-optional-marks \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  marks: [\n    Plot.ruleY([0]),\n    area ? Plot.areaY(aapl, {x: \"Date\", y: \"Close\", fillOpacity: 0.2}) : null,\n    Plot.lineY(aapl, {x: \"Date\", y: \"Close\"})\n  ]\n})\n```\n\n## Marks use scales [\u200b](#marks-use-scales)\n\nMarks are (typically) not positioned in literal pixels, or colored in literal colors, as in a conventional graphics system. Instead you provide abstract values such as time and temperature \u2014\u00a0marks are drawn \u201cin data space\u201d \u2014\u00a0and [scales](./scales) encode these into visual values such as position and color. And best of all, Plot automatically creates [axes](./../marks/axis) and [legends](./legends) to document the scales\u2019 encodings.\n\nData is passed through scales automatically during rendering; the mark controls which scales are used. The **x** and **y** options are typically bound to the *x* and *y* scales, respectively, while the **fill** and **stroke** options are typically bound to the *color* scale. Changing a scale\u2019s definition, say by overriding its **domain** (the extent of abstract input values) or **type**, affects the appearance of all marks that use the scale.\n\n[Fork](https://observablehq.com/@observablehq/plot-aapl-log-scale \"Open on Observable\")\n\njs\n\n```\nPlot.plot({\n  y: {\n    type: \"log\",\n    domain: [30, 300],\n    grid: true\n  },\n  marks: [\n    Plot.lineY(aapl, {x: \"Date\", y: \"Close\"})\n  ]\n})\n```\n\n## Marks have tidy data [\u200b](#marks-have-tidy-data)\n\nA single mark can draw multiple shapes. A mark generally produces a shape \u2014\u00a0such as a rectangle or circle \u2014\u00a0for each element in the data.\n\n[Fork](https://observablehq.com/@observablehq/plot-tidy-data \"Open on Observable\")\n\njs\n\n```\nPlot.dot(aapl, {x: \"Date\", y: \"Close\"}).plot()\n```\n\nIt\u2019s more complicated than that, though, since some marks produce shapes that incorporate *multiple* data points. Pass the same data to a [line](./../marks/line) and you\u2019ll get a single polyline.\n\n[Fork](https://observablehq.com/@observablehq/plot-tidy-data \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(aapl, {x: \"Date\", y: \"Close\"}).plot()\n```\n\nAnd a line mark isn\u2019t even guaranteed to produce a single polyline \u2014\u00a0there can be multiple polylines, as in a line chart with multiple series (using **z**).\n\n[Fork](https://observablehq.com/@observablehq/plot-multiple-series-line-chart \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(bls, {x: \"date\", y: \"unemployment\", z: \"division\"}).plot()\n```\n\nPlot favors [tidy data](http://vita.had.co.nz/papers/tidy-data.html) structured as an array of objects, where each object represents an observation (a row), and each object property represents an observed value; all objects in the array should have the same property names (the columns).\n\nFor example, say we have hourly readings from two sensors *A* and *B*. You can represent the sensor log as an array of objects like so:\n\njs\n\n```\nlinedata = [\n  {hour: 0, value: 8, sensor: \"A\"},\n  {hour: 0, value: 6, sensor: \"B\"},\n  {hour: 1, value: 7, sensor: \"A\"},\n  {hour: 1, value: 5, sensor: \"B\"},\n  {hour: 2, value: 3, sensor: \"A\"},\n  {hour: 2, value: 0, sensor: \"B\"},\n  {hour: 3, value: 9, sensor: \"A\"},\n  {hour: 3, value: 2, sensor: \"B\"}\n]\n```\n\nTIP\n\nFor larger datasets, you can more efficiently pass data using an [Apache Arrow](https://arrow.apache.org/docs/js/) table as a columnar data representation. [^0.6.16](https://github.com/observablehq/plot/releases/tag/v0.6.16 \"added in v0.6.16\")\n\nThen you can pass the data to the line mark, and extract named columns from the data for the desired options:\n\n[Fork](https://observablehq.com/@observablehq/plot-accessors \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(linedata, {x: \"hour\", y: \"value\", stroke:\u00a0\"sensor\"}).plot()\n```\n\nAnother common way to extract a column from tabular data is an accessor function. This function is invoked for each element in the data (each row), and returns the corresponding observed value, as with [*array*.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).\n\n[Fork](https://observablehq.com/@observablehq/plot-accessors \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(linedata, {\n  x: (d) => d.hour,\n  y: (d) => d.value,\n  stroke:\u00a0(d) => d.sensor\n}).plot()\n```\n\nFor greater efficiency, Plot also supports columnar data: you can use an [Apache Arrow](https://arrow.apache.org/docs/js/) table as data instead of an array of objects. [^0.6.16](https://github.com/observablehq/plot/releases/tag/v0.6.16 \"added in v0.6.16\") You can even pass parallel arrays of values, or Apache Arrow vectors, to each channel.\n\njs\n\n```\nPlot.lineY({length: linedata.length}, {\n  x: linedata.map((d) => d.hour),\n  y: linedata.map((d) => d.value),\n  stroke:\u00a0linedata.map((d) => d.sensor)\n}).plot()\n```\n\nTIP\n\nNote that when accessor functions or parallel arrays are used instead of field names, automatic axis labels (*hour* and *value*) are lost. These can be restored using the **label** option on the *x* and *y* scales.\n\n## Marks imply data types [\u200b](#marks-imply-data-types)\n\nData comes in different types: quantitative (or temporal) values can be subtracted, ordinal values can be ordered, and nominal (or categorical) values can only be the same or different.\n\nINFO\n\nBecause nominal values often need some arbitrary order for display purposes \u2014\u00a0often alphabetical \u2014\u00a0Plot uses the term *ordinal* to refer to both ordinal and nominal data.\n\nSome marks work with any type of data, while other marks have certain requirements or assumptions of data. For example, a line should only be used when both *x* and *y* are quantitative or temporal, and when the data is in a meaningful order (such as chronological). This is because the line mark will interpolate between adjacent points to draw line segments. If *x* or *y* is nominal \u2014\u00a0say the names of countries \u2014\u00a0it doesn\u2019t make sense to use a line because there is no half-way point between two nominal values.\n\n[Fork](https://observablehq.com/@observablehq/plot-dont-do-this \"Open on Observable\")\n\njs\n\n```\nPlot.lineY([\"please\", \"don\u2019t\", \"do\", \"this\"]).plot() // \ud83c\udf36\ufe0f\n```\n\nWARNING\n\nWhile Plot aspires to give good defaults and helpful warnings, Plot won\u2019t prevent you from creating a meaningless chart. *Only you* can prevent bogus charts!\n\nIn particular, beware the simple \u201cbar\u201d! A bar mark is used for a bar chart, but a rect mark is needed for a histogram. Plot has four different mark types for drawing rectangles:\n\n- use [rect](./../marks/rect) when both *x* and *y* are quantitative\n- use [barX](./../marks/bar) when *x* is quantitative and *y* is ordinal\n- use [barY](./../marks/bar) when *x* is ordinal and *y* is quantitative\n- use [cell](./../marks/cell) when both *x* and *y* are ordinal\n\nPlot encourages you to think about data types as you visualize because data types often imply semantics. For example, do you notice anything strange about the bar chart below?\n\n[Fork](https://observablehq.com/@observablehq/plot-the-missing-bar \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barY(timeseries, {x: \"year\", y: \"population\"}) // \ud83c\udf36\ufe0f\n  .plot({x: {tickFormat: \"\"}})\n```\n\nHere\u2019s the underlying data:\n\njs\n\n```\ntimeseries = [\n  {year: 2014, population: 7295.290765},\n  {year: 2015, population: 7379.797139},\n  {year: 2016, population: 7464.022049},\n  {year: 2017, population: 7547.858925},\n  {year: 2019, population: 7713.468100},\n  {year: 2020, population: 7794.798739}\n]\n```\n\nThe data is missing the population for the year 2018! Because the barY mark implies an ordinal *x* scale, the gap is hidden. Switching to the rectY mark (with the **interval** option to indicate that these are annual observations) reveals the missing data.\n\n[Fork](https://observablehq.com/@observablehq/plot-the-missing-bar \"Open on Observable\")\n\njs\n\n```\nPlot\n  .rectY(timeseries, {x: \"year\", y: \"population\", interval: 1})\n  .plot({x: {tickFormat: \"\"}})\n```\n\nAlternatively, you can keep the barY mark and apply the **interval** option to the *x* scale.\n\n[Fork](https://observablehq.com/@observablehq/plot-the-missing-bar \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barY(timeseries, {x: \"year\", y: \"population\"})\n  .plot({x: {tickFormat: \"\", interval: 1}})\n```\n\n## Marks have options [\u200b](#marks-have-options)\n\nWhen constructing a mark, you can specify options to change the mark\u2019s appearance. These options are passed as a second argument to the mark constructor. (The first argument is the required data.) For example, if you want filled dots instead of stroked ones, pass the desired color to the **fill** option:\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-options \"Open on Observable\")\n\njs\n\n```\nPlot.dot(gistemp, {x: \"Date\", y: \"Anomaly\", fill: \"red\"}).plot()\n```\n\nAs the name suggests, options are generally optional; Plot tries to provide good defaults for whatever you don\u2019t specify. Plot even has [shorthand](./shorthand) for various common forms of data. Below, we extract an array of numbers from the `gistemp` dataset, and use the line mark shorthand to set *x* = index and *y* = identity.\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-options \"Open on Observable\")\n\njs\n\n```\nPlot.lineY(gistemp.map((d) => d.Anomaly)).plot()\n```\n\nSome marks even provide default [transforms](./transforms), say for [stacking](./../transforms/stack)!\n\nTIP\n\nBecause Plot strives to be concise, there are many default behaviors, some of which can be subtle. If Plot isn\u2019t doing what you expect, try disabling the defaults by specifying options explicitly.\n\nIn addition to the standard options such as **fill** and **stroke** that are supported by all mark types, each mark type can support options unique to that type. For example, the dot mark takes a **symbol** option so you can draw things other than circles. See the documentation for each mark type to see what it supports.\n\n## Marks have channels [\u200b](#marks-have-channels)\n\nChannels are mark options that can be used to encode data. These options allow the value to vary with the data, such as a different position or color for each dot. To use a channel, supply it with a column of data, typically as:\n\n- a field (column) name,\n- an accessor function, or\n- an array of values of the same length and order as the data.\n\nNot all mark options can be expressed as channels. For example, **stroke** can be a channel but **strokeDasharray** cannot. This is mostly a pragmatic limitation \u2014\u00a0it would be harder to implement Plot if every option were expressible as a channel \u2014\u00a0but it also serves to guide you towards options that are intended for encoding data.\n\nTIP\n\nTo vary the definition of a constant option with data, create multiple marks with your different constant options, and then filter the data for each mark to achieve the desired result.\n\nSome options can be either a channel or a constant depending on the provided value. For example, if you set the **fill** option to *purple*, Plot interprets it as a literal color.\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-channels \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barX(timeseries, {x: \"population\", y: \"year\", fill: \"purple\"})\n  .plot({y: {label: null, tickFormat: \"\"}})\n```\n\nWhereas if the **fill** option is a string but *not* a valid CSS color, Plot assumes you mean the corresponding column of the data and interprets it as a channel.\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-channels \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barX(timeseries, {x: \"population\", y: \"year\", fill: \"year\"})\n  .plot({y: {label: null, tickFormat: \"\"}})\n```\n\nIf the **fill** option is a function, it is interpreted as a channel.\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-channels \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barX(timeseries, {x: \"population\", y: \"year\", fill: (d) => d.year})\n  .plot({y: {label: null, tickFormat: \"\"}})\n```\n\nLastly, note that while channels are normally bound to a [scale](#marks-use-scales), you can bypass the *color* scale here by supplying literal color values to the **fill** channel.\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-channels \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barX(timeseries, {x: \"population\", y: \"year\", fill: (d) => d.year & 1 ? \"red\" : \"currentColor\"})\n  .plot({y: {label: null, tickFormat: \"\"}})\n```\n\nBut rather than supplying literal values, it is more semantic to provide abstract values and use scales. In addition to centralizing the encoding definition (if used by multiple marks), it allows Plot to generate a legend.\n\nevenodd\n\n[Fork](https://observablehq.com/@observablehq/plot-marks-have-channels \"Open on Observable\")\n\njs\n\n```\nPlot\n  .barX(timeseries, {x: \"population\", y: \"year\", fill: (d) => d.year & 1 ? \"odd\" : \"even\"})\n  .plot({y: {label: null, tickFormat: \"\"}, color: {legend: true}})\n```\n\nYou can then specify the *color* scale\u2019s **domain** and **range** to control the encoding.\n\n## Mark options [\u200b](#mark-options)\n\nMark constructors take two arguments: **data** and **options**. Together these describe a tabular dataset and how to visualize it. Option values that must be the same for all of a mark\u2019s generated shapes are known as *constants*, whereas option values that may vary across a mark\u2019s generated shapes are known as *channels*. Channels are typically bound to [scales](./scales) and encode abstract data values, such as time or temperature, as visual values, such as position or color. (Channels can also be used to order ordinal domains; see the [**sort** option](./scales#sort-mark-option).)\n\nA mark\u2019s data is most commonly an array of objects representing a tabular dataset, such as the result of loading a CSV file, while a mark\u2019s options bind channels (such as *x* and *y*) to columns in the data (such as *units* and *fruit*).\n\njs\n\n```\nsales = [\n  {units: 10, fruit: \"peach\"},\n  {units: 20, fruit: \"pear\"},\n  {units: 40, fruit: \"plum\"},\n  {units: 30, fruit: \"plum\"}\n]\n```\n\njs\n\n```\nPlot.dot(sales, {x: \"units\", y: \"fruit\"})\n```\n\nWhile a column name such as `\"units\"` is the most concise way of specifying channel values, values can also be specified as functions for greater flexibility, say to transform data or derive a new column on the fly. Channel functions are invoked for each datum (*d*) in the data and return the corresponding channel value. (This is similar to how D3\u2019s [*selection*.attr](https://d3js.org/d3-selection/modifying#selection_attr) accepts functions, though note that Plot channel functions should return abstract values, not visual values.)\n\njs\n\n```\nPlot.dot(sales, {x: (d) => d.units * 1000, y: (d) => d.fruit})\n```\n\nPlot also supports columnar data for greater efficiency with bigger datasets; for example, data can be specified as any array of the appropriate length (or any iterable or value compatible with [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)), and then separate arrays of values can be passed as *options*.\n\njs\n\n```\nindex = [0, 1, 2, 3]\n```\n\njs\n\n```\nunits = [10, 20, 40, 30]\n```\n\njs\n\n```\nfruits = [\"peach\", \"pear\", \"plum\", \"plum\"]\n```\n\njs\n\n```\nPlot.dot(index, {x: units, y: fruits})\n```\n\nChannel values can also be specified as numbers for constant values, say for a fixed baseline with an [area](./../marks/area).\n\njs\n\n```\nPlot.area(aapl, {x1: \"Date\", y1: 0, y2: \"Close\"})\n```\n\nMissing and invalid data are handled specifically for each mark type and channel. In most cases, if the provided channel value for a given datum is null, undefined, or (strictly) NaN, the mark will implicitly filter the datum and not generate a corresponding output. In some cases, such as the radius (*r*) of a dot, the channel value must additionally be positive. Plot.line and Plot.area will stop the path before any invalid point and start again at the next valid point, thus creating interruptions rather than interpolating between valid points. Titles will only be added if they are non-empty.\n\nAll marks support the following style options:\n\n- **fill** - fill color\n- **fillOpacity** - fill opacity (a number between 0 and 1)\n- **stroke** - stroke color\n- **strokeWidth** - stroke width (in pixels)\n- **strokeOpacity** - stroke opacity (a number between 0 and 1)\n- **strokeLinejoin** - how to join lines (*bevel*, *miter*, *miter-clip*, or *round*)\n- **strokeLinecap** - how to cap lines (*butt*, *round*, or *square*)\n- **strokeMiterlimit** - to limit the length of *miter* joins\n- **strokeDasharray** - a comma-separated list of dash lengths (typically in pixels)\n- **strokeDashoffset** - the [stroke dash offset](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dashoffset) (typically in pixels)\n- **opacity** - object opacity (a number between 0 and 1)\n- **mixBlendMode** - the [blend mode](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode) (*e.g.*, *multiply*)\n- **imageFilter** - a CSS [filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter) (*e.g.*, *blur(5px)*) [^0.6.7](https://github.com/observablehq/plot/releases/tag/v0.6.7 \"added in v0.6.7\")\n- **shapeRendering** - the [shape-rendering mode](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering) (*e.g.*, *crispEdges*)\n- **paintOrder** - the [paint order](https://developer.mozilla.org/en-US/docs/Web/CSS/paint-order) (*e.g.*, *stroke*)\n- **dx** - horizontal offset (in pixels; defaults to 0)\n- **dy** - vertical offset (in pixels; defaults to 0)\n- **target** - link target (e.g., \u201c\\_blank\u201d for a new window); for use with the **href** channel\n- **className** - the [class attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class), if any (defaults to null) [^0.6.16](https://github.com/observablehq/plot/releases/tag/v0.6.16 \"added in v0.6.16\")\n- **ariaDescription** - a textual description of the mark\u2019s contents\n- **ariaHidden** - if true, hide this content from the accessibility tree\n- **pointerEvents** - the [pointer events](https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events) (*e.g.*, *none*)\n- **clip** - whether and how to clip the mark\n- **tip** - whether to generate an implicit [pointer](./../interactions/pointer) [tip](./../marks/tip) [^0.6.7](https://github.com/observablehq/plot/releases/tag/v0.6.7 \"added in v0.6.7\")\n\nIf the **clip** option is *frame* (or equivalently true), the mark is clipped to the frame\u2019s dimensions. If the **clip** option is null (or equivalently false), the mark is not clipped. If the **clip** option is *sphere*, the mark will be clipped to the projected sphere (*e.g.*, the front hemisphere when using the orthographic projection); a [geographic projection](./projections) is required in this case. Lastly if the **clip** option is a GeoJSON object [^0.6.17](https://github.com/observablehq/plot/releases/tag/v0.6.17 \"added in v0.6.17\"), the mark will be clipped to the projected geometry.\n\nIf the **tip** option is true, a [tip mark](./../marks/tip) with the [pointer transform](./../interactions/pointer) will be derived from this mark and placed atop all other marks, offering details on demand. If the **tip** option is set to an options object, these options will be passed to the derived tip mark. If the **tip** option (or, if an object, its **pointer** option) is set to *x*, *y*, or *xy*, [pointerX](./../interactions/pointer#pointerX), [pointerY](./../interactions/pointer#pointerY), or [pointer](./../interactions/pointer#pointer) will be used, respectively; otherwise the pointing mode will be chosen automatically. (If the **tip** mark option is truthy, the **title** channel is no longer applied using an SVG title element as this would conflict with the tip mark.)\n\nFor all marks except [text](./../marks/text), the **dx** and **dy** options are rendered as a transform property, possibly including a 0.5px offset on low-density screens.\n\nAll marks support the following optional channels:\n\n- **fill** - a fill color; bound to the *color* scale\n- **fillOpacity** - a fill opacity; bound to the *opacity* scale\n- **stroke** - a stroke color; bound to the *color* scale\n- **strokeOpacity** - a stroke opacity; bound to the *opacity* scale\n- **strokeWidth** - a stroke width (in pixels)\n- **opacity** - an object opacity; bound to the *opacity* scale\n- **title** - an accessible, short-text description (a string of text, possibly with newlines)\n- **href** - a URL to link to\n- **ariaLabel** - a short label representing the value in the accessibility tree\n\nThe **fill**, **fillOpacity**, **stroke**, **strokeWidth**, **strokeOpacity**, and **opacity** options can be specified as either channels or constants. When the fill or stroke is specified as a function or array, it is interpreted as a channel; when the fill or stroke is specified as a string, it is interpreted as a constant if a valid CSS color and otherwise it is interpreted as a column name for a channel. Similarly when the fill opacity, stroke opacity, object opacity, stroke width, or radius is specified as a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\n\nThe scale associated with any channel can be overridden by specifying the channel as an object with a *value* property specifying the channel values and a *scale* property specifying the desired scale name or null for an unscaled channel. For example, to force the **stroke** channel to be unscaled, interpreting the associated values as literal color strings:\n\njs\n\n```\nPlot.dot(data, {stroke: {value: \"fieldName\", scale: null}})\n```\n\nTo instead force the **stroke** channel to be bound to the *color* scale regardless of the provided values, say:\n\njs\n\n```\nPlot.dot(data, {stroke: {value: \"fieldName\", scale: \"color\"}})\n```\n\nThe color channels (**fill** and **stroke**) are bound to the *color* scale by default, unless the provided values are all valid CSS color strings or nullish, in which case the values are interpreted literally and unscaled.\n\nIn addition to functions of data, arrays, and column names, channel values can be specified as an object with a *transform* method; this transform method is passed the mark\u2019s array of data and must return the corresponding array of channel values. (Whereas a channel value specified as a function is invoked repeatedly for each element in the mark\u2019s data, similar to *array*.map, the transform method is invoked only once being passed the entire array of data.) For example, to pass the mark\u2019s data directly to the **x** channel, equivalent to [Plot.identity](./transforms#identity):\n\njs\n\n```\nPlot.dot(numbers, {x: {transform: (data) => data}})\n```\n\nThe **title**, **href**, and **ariaLabel** options can *only* be specified as channels. When these options are specified as a string, the string refers to the name of a column in the mark\u2019s associated data. If you\u2019d like every instance of a particular mark to have the same value, specify the option as a function that returns the desired value, *e.g.* `() => \"Hello, world!\"`.\n\nFor marks that support the **frameAnchor** option, it may be specified as one of the four sides (*top*, *right*, *bottom*, *left*), one of the four corners (*top-left*, *top-right*, *bottom-right*, *bottom-left*), or the *middle* of the frame.\n\nAll marks support the following [transform](./transforms) options:\n\n- **filter** - apply the [filter transform](./../transforms/filter)\n- **sort** - apply the [sort transform](./../transforms/sort)\n- **reverse** - apply the [reverse transform](./../transforms/sort#reverse)\n- **transform** - apply a [custom transform](./transforms#custom-transforms)\n- **initializer** - apply a [custom initializer](./transforms#custom-initializers)\n\nThe **sort** option, when not specified as a channel value (such as a field name or an accessor function), can also be used to [impute ordinal scale domains](./scales#sort-mark-option).\n\n### Insets [\u200b](#insets)\n\nRect-like marks support insets: a positive inset moves the respective side in (towards the opposing side), whereas a negative inset moves the respective side out (away from the opposing side). Insets are specified in pixels using the following options:\n\n- **inset** - shorthand for all four insets\n- **insetTop** - inset the top edge\n- **insetRight** - inset the right edge\n- **insetBottom** - inset the bottom edge\n- **insetLeft** - inset the left edge\n\nInsets default to zero. Insets are commonly used to create a one-pixel gap between adjacent bars in histograms; the [bin transform](./../transforms/bin) provides default insets. (Note that the [band scale padding](./scales#position-scale-options) defaults to 0.1 as an alternative to insets.)\n\n### Rounded corners [\u200b](#rounded-corners)\n\nRect-like marks support rounded corners. Each corner (or side) is individually addressable [^0.6.16](https://github.com/observablehq/plot/releases/tag/v0.6.16 \"added in v0.6.16\") using the following options:\n\n- **r** - the radius for all four corners\n- **rx1** - the radius for the **x1**-**y1** and **x1**-**y2** corners\n- **rx2** - the radius for the **x2**-**y1** and **x2**-**y2** corners\n- **ry1** - the radius for the **x1**-**y1** and **x2**-**y1** corners\n- **ry2** - the radius for the **x1**-**y2** and **x2**-**y2** corners\n- **rx1y1** - the radius for the **x1**-**y1** corner\n- **rx1y2** - the radius for the **x1**-**y2** corner\n- **rx2y1** - the radius for the **x2**-**y1** corner\n- **rx2y2** - the radius for the **x2**-**y2** corner\n- **rx** - the [*x*-radius](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rx) for elliptical corners\n- **ry** - the [*y*-radius](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ry) for elliptical corners\n\nCorner radii are specified in either pixels or, for **rx** and **ry**, as percentages (strings) or the keyword *auto*. If the corner radii are too big, they are reduced proportionally.\n\n## marks(...*marks*) [^0.2.0](https://github.com/observablehq/plot/releases/tag/v0.2.0 \"added in v0.2.0\") [\u200b](#marks)\n\njs\n\n```\nPlot.marks(\n  Plot.ruleY([0]),\n  Plot.areaY(data, {fill: color, fillOpacity, ...options}),\n  Plot.lineY(data, {stroke: color, ...options})\n)\n```\n\nA convenience method for composing a mark from a series of other marks. Returns an array of marks that implements the *mark*.plot function. See the [box mark](./../marks/box) implementation for an example.",
  "tags": [
    "observable",
    "plot",
    "visualization",
    "d3"
  ],
  "extracted_at": "2026-02-03T12:50:56.126448+00:00",
  "content_length": 23733,
  "content_hash": "7d5aba54372b2c1f"
}