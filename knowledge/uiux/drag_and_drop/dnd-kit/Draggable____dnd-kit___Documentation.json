{
  "id": "dnd-kit__api-documentation_draggable",
  "source_id": "dnd-kit",
  "source_name": "dnd kit",
  "category": "drag_and_drop",
  "url": "https://docs.dndkit.com/api-documentation/draggable",
  "title": "Draggable | @dnd-kit \u2013 Documentation",
  "content": "Use the\nuseDraggable\nhook turn DOM nodes into draggable sources that can be picked up, moved and dropped over\ndroppable\ncontainers.\nUsage\nThe\nuseDraggable\nhook isn't particularly opinionated about how your app should be structured.\nNode ref\nAt minimum though, you need to pass the\nsetNodeRef\nfunction that is returned by the\nuseDraggable\nhook to a DOM element so that it can access the underlying DOM node and keep track of it to\ndetect collisions and intersections\nwith other\ndroppable\nelements.\nAlways try to use the  DOM element that is most\nsemantic\nin the context of your app. \nCheck out our\nAccessibility guide\nto learn more about how you can help provide a better experience for screen readers.\nIdentifier\nThe\nid\nargument is a string that should be a unique identifier, meaning there should be no other\ndraggable\nelements that share that same identifier within a given\nDndContext\nprovider.\nListeners\nThe\nuseDraggable\nhook requires that you attach\nlisteners\nto the DOM node that you would like to become the activator to start dragging.\nWhile we could have attached these listeners manually to the node  provided to\nsetNodeRef\n, there are actually a number of key advantages to forcing the consumer to manually attach the listeners.\nFlexibility\nWhile many drag and drop libraries need to expose the concept of \"drag handles\", creating a drag handle with the\nuseDraggable\nhook is as simple as manually attaching the listeners to a different DOM element than the one that is set as the draggable source DOM node:\nWhen attaching the listeners to a different element than the node that is draggable, make sure you also attach the attributes to the same node that has the listeners attached so that it is still\naccessible\n.\nYou can even have multiple drag handles if that makes sense in the context of your application:\nPerformance\nThis strategy also means that we're able to use\nReact synthetic events\n, which ultimately leads to improved performance over manually attaching event listeners to each individual node.\n\nWhy? Because rather than having to attach individual event listeners for each draggable DOM node, React attaches a single event listener for every type of event we listen to on the\ndocument\n. Once click on one of the draggable nodes happens, React's listener on the document dispatches a SyntheticEvent back to the original handler.\nTransforms\nIn order to actually see your draggable items move on screen, you'll need to move the item using CSS. You can use inline styles, CSS variables, or even CSS-in-JS libraries to pass the\ntransform\nproperty as CSS to your draggable element.\nFor performance reasons, we strongly recommend you use the\ntransform\nCSS property to move your draggable item on the screen, as other positional properties such as\ntop\n,\nleft\nor\nmargin\ncan cause expensive repaints.  Learn more about\nCSS transforms\n.\nAfter an item starts being dragged, the\ntransform\nproperty will be populated with the\ntranslate\ncoordinates you'll need to move the item on the screen.  The\ntransform\nobject adheres to the following shape:\n{x: number, y: number, scaleX: number, scaleY: number}\nThe\nx\nand\ny\ncoordinates represent the delta from the point of origin of your draggable element since it started being dragged.\nThe\nscaleX\nand\nscaleY\nproperties represent the difference in scale between the item that is dragged and the droppable container it is currently over. This is useful for building interfaces where the draggable item needs to adapt to the size of the droppable container it is currently over.\nThe\nCSS\nhelper is entirely optional; it's a convenient helper for generating\nCSS transform\nstrings, and is equivalent to manually constructing the string as such:\nAttributes\nThe\nuseDraggable\nhook\nprovides a set of sensible default attributes for draggable items. We recommend you attach these to the HTML element you are attaching the draggable listeners to.\nWe encourage you to manually attach the attributes that you think make sense in the context of your application rather than using them all without considering whether it makes sense to do so.\nFor example, if the HTML element you are attaching the\nuseDraggable\nlisteners\nto is already a semantic\nbutton\n, although it's harmless to do so, there's no need to add the\nrole=\"button\"\nattribute, since that is already the default role.\nAttribute\nDefault value\nDescription\nrole\n\"button\"\nIf possible, we recommend you use a semantic\n<button>\nelement for the DOM element you plan on attaching draggable listeners to.\nIn case that's not possible, make sure you include the\nrole=\"button\"\nattribute, which is the default value.\ntabIndex\n\"0\"\nIn order for your draggable elements to receive keyboard focus, they\nneed\nto have the\ntabindex\nattribute set to\n0\nif they are not natively interactive elements (such as the HTML\nbutton\nelement). For this reason, the\nuseDraggable\nhook sets the\ntabindex=\"0\"\nattribute by default.\naria-roledescription\n\"draggable\"\nWhile\ndraggable\nis a sensible default, we recommend you customize this value to something that is tailored to the use case you are building.\naria-describedby\n\"DndContext-[uniqueId]\"\nEach draggable item is provided a unique\naria-describedby\nID that points to the\nscreen reader instructions\nto be read out when a draggable item receives focus.\nTo learn more about the best practices for making draggable interfaces accessible, read the full accessibility guide:\nAccessibility\nRecommendations\ntouch-action\nWe highly recommend you specify the\ntouch-action\nCSS property for all of your draggable elements.\nThe\ntouch-action\nCSS property sets how an element's region can be manipulated by a touchscreen user (for example, by zooming features built into the browser).\n\nSource:\nMDN\nIn general, we recommend you set the\ntouch-action\nproperty to\nnone\nfor draggable elements in order to prevent scrolling on mobile devices.\nFor\nPointer Events,\nthere is no way to prevent the default behaviour of the browser on touch devices when interacting with a draggable element from the pointer event listeners. Using\ntouch-action: none;\nis the only way to reliably prevent scrolling for pointer events.\nFurther,  using\ntouch-action: none;\nis currently the only reliable way to prevent scrolling in iOS Safari for both Touch and Pointer events.\nIf your draggable item is part of a scrollable list, we recommend you use a drag handle and set\ntouch-action\nto\nnone\nonly for the drag handle, so that the contents of the list can still be scrolled, but that initiating a drag from the drag handle does not scroll the page.\nOnce a\npointerdown\nor\ntouchstart\nevent has been initiated, any changes to the\ntouch-action\nvalue will be ignored. Programmatically changing the\ntouch-action\nvalue for an element from\nauto\nto\nnone\nafter a pointer or touch event has been initiated will not result in the user agent aborting or suppressing any default behavior for that event for as long as that pointer is active  (for more details, refer to the\nPointer Events Level 2 Spec\n).\nDrag Overlay\nThe\n<DragOverlay>\ncomponent provides a way to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport.\nTo learn more about how to use drag overlays, read the in-depth guide:\nDrag Overlay\nLast updated\n5 years ago",
  "content_markdown": "![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MN0Kqdqp2CU1CxUV_hg%252F-MN0LCrhtymDDEQ6kaJj%252Fdraggable-large.svg%3Falt%3Dmedia%26token%3D16954bf4-1357-4890-9e99-a74ca336ddf1&width=768&dpr=3&quality=100&sign=151c59c1&sv=2)\n\nUse the `useDraggable` hook turn DOM nodes into draggable sources that can be picked up, moved and dropped over [droppable](/api-documentation/droppable) containers.\n\n## Usage\n\nThe `useDraggable` hook isn't particularly opinionated about how your app should be structured.\n\n### Node ref\n\nAt minimum though, you need to pass the `setNodeRef` function that is returned by the `useDraggable` hook to a DOM element so that it can access the underlying DOM node and keep track of it to [detect collisions and intersections](/api-documentation/context-provider/collision-detection-algorithms) with other [droppable](/api-documentation/droppable) elements.\n\nAlways try to use the DOM element that is most [semantic](https://developer.mozilla.org/en-US/docs/Glossary/Semantics) in the context of your app.\nCheck out our [Accessibility guide](/guides/accessibility) to learn more about how you can help provide a better experience for screen readers.\n\n### Identifier\n\nThe `id` argument is a string that should be a unique identifier, meaning there should be no other **draggable** elements that share that same identifier within a given [`DndContext`](/api-documentation/context-provider) provider.\n\n### Listeners\n\nThe `useDraggable` hook requires that you attach `listeners` to the DOM node that you would like to become the activator to start dragging.\n\nWhile we could have attached these listeners manually to the node provided to `setNodeRef`, there are actually a number of key advantages to forcing the consumer to manually attach the listeners.\n\n#### Flexibility\n\nWhile many drag and drop libraries need to expose the concept of \"drag handles\", creating a drag handle with the `useDraggable` hook is as simple as manually attaching the listeners to a different DOM element than the one that is set as the draggable source DOM node:\n\nWhen attaching the listeners to a different element than the node that is draggable, make sure you also attach the attributes to the same node that has the listeners attached so that it is still [accessible](/guides/accessibility).\n\nYou can even have multiple drag handles if that makes sense in the context of your application:\n\n#### Performance\n\nThis strategy also means that we're able to use [React synthetic events](https://reactjs.org/docs/events.html), which ultimately leads to improved performance over manually attaching event listeners to each individual node.\nWhy? Because rather than having to attach individual event listeners for each draggable DOM node, React attaches a single event listener for every type of event we listen to on the `document`. Once click on one of the draggable nodes happens, React's listener on the document dispatches a SyntheticEvent back to the original handler.\n\n### Transforms\n\nIn order to actually see your draggable items move on screen, you'll need to move the item using CSS. You can use inline styles, CSS variables, or even CSS-in-JS libraries to pass the `transform` property as CSS to your draggable element.\n\nFor performance reasons, we strongly recommend you use the `transform` CSS property to move your draggable item on the screen, as other positional properties such as `top`, `left` or `margin` can cause expensive repaints. Learn more about [CSS transforms](https://developer.mozilla.org/en-US/docs/Web/CSS/transform).\n\nAfter an item starts being dragged, the `transform` property will be populated with the `translate` coordinates you'll need to move the item on the screen. The `transform` object adheres to the following shape: `{x: number, y: number, scaleX: number, scaleY: number}`\n\nThe `x` and `y` coordinates represent the delta from the point of origin of your draggable element since it started being dragged.\n\nThe `scaleX` and `scaleY` properties represent the difference in scale between the item that is dragged and the droppable container it is currently over. This is useful for building interfaces where the draggable item needs to adapt to the size of the droppable container it is currently over.\n\nThe `CSS` helper is entirely optional; it's a convenient helper for generating [CSS transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform) strings, and is equivalent to manually constructing the string as such:\n\n### Attributes\n\nThe `useDraggable` hookprovides a set of sensible default attributes for draggable items. We recommend you attach these to the HTML element you are attaching the draggable listeners to.\n\nWe encourage you to manually attach the attributes that you think make sense in the context of your application rather than using them all without considering whether it makes sense to do so.\n\nFor example, if the HTML element you are attaching the `useDraggable` `listeners` to is already a semantic `button`, although it's harmless to do so, there's no need to add the `role=\"button\"` attribute, since that is already the default role.\n\nAttribute\n\nDefault value\n\nDescription\n\n`role`\n\n`\"button\"`\n\nIf possible, we recommend you use a semantic `<button>` element for the DOM element you plan on attaching draggable listeners to.\n\nIn case that's not possible, make sure you include the `role=\"button\"`attribute, which is the default value.\n\n`tabIndex`\n\n`\"0\"`\n\nIn order for your draggable elements to receive keyboard focus, they **need** to have the `tabindex` attribute set to `0` if they are not natively interactive elements (such as the HTML `button` element). For this reason, the `useDraggable` hook sets the `tabindex=\"0\"` attribute by default.\n\n`aria-roledescription`\n\n`\"draggable\"`\n\nWhile `draggable` is a sensible default, we recommend you customize this value to something that is tailored to the use case you are building.\n\n`aria-describedby`\n\n`\"DndContext-[uniqueId]\"`\n\nEach draggable item is provided a unique `aria-describedby` ID that points to the [screen reader instructions](/api-documentation/context-provider#screen-reader-instructions) to be read out when a draggable item receives focus.\n\nTo learn more about the best practices for making draggable interfaces accessible, read the full accessibility guide:\n\n[Accessibility](/guides/accessibility)\n\n### Recommendations\n\n#### `touch-action`\n\nWe highly recommend you specify the `touch-action` CSS property for all of your draggable elements.\n\n> The `touch-action` CSS property sets how an element's region can be manipulated by a touchscreen user (for example, by zooming features built into the browser).\n> Source: [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action)\n\nIn general, we recommend you set the `touch-action` property to `none` for draggable elements in order to prevent scrolling on mobile devices.\n\nFor [Pointer Events,](/api-documentation/sensors/pointer) there is no way to prevent the default behaviour of the browser on touch devices when interacting with a draggable element from the pointer event listeners. Using `touch-action: none;` is the only way to reliably prevent scrolling for pointer events.\n\nFurther, using `touch-action: none;` is currently the only reliable way to prevent scrolling in iOS Safari for both Touch and Pointer events.\n\nIf your draggable item is part of a scrollable list, we recommend you use a drag handle and set `touch-action` to `none` only for the drag handle, so that the contents of the list can still be scrolled, but that initiating a drag from the drag handle does not scroll the page.\n\nOnce a `pointerdown` or `touchstart` event has been initiated, any changes to the `touch-action` value will be ignored. Programmatically changing the `touch-action` value for an element from `auto` to `none` after a pointer or touch event has been initiated will not result in the user agent aborting or suppressing any default behavior for that event for as long as that pointer is active (for more details, refer to the [Pointer Events Level 2 Spec](https://www.w3.org/TR/pointerevents2/#determining-supported-touch-behavior)).\n\n## Drag Overlay\n\nThe `<DragOverlay>` component provides a way to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport.\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MPLpbsfQHd26rAwapkQ%252F-MPPblr-tx81-ZakW6gn%252FDragOverlay.png%3Falt%3Dmedia%26token%3Dc2d84cda-d1bb-4560-8056-f430599b414c&width=768&dpr=3&quality=100&sign=fde8bc11&sv=2)\n\nTo learn more about how to use drag overlays, read the in-depth guide:\n\n[Drag Overlay](/api-documentation/draggable/drag-overlay)\n\nLast updated 5 years ago",
  "tags": [
    "dnd-kit",
    "drag-drop",
    "sortable",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:54:19.954561+00:00",
  "content_length": 7247,
  "content_hash": "bfebe0e967aeabf1"
}