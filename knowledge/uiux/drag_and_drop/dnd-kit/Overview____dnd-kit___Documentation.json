{
  "id": "dnd-kit__",
  "source_id": "dnd-kit",
  "source_name": "dnd kit",
  "category": "drag_and_drop",
  "url": "https://docs.dndkit.com/",
  "title": "Overview | @dnd-kit \u2013 Documentation",
  "content": "Feature packed:\ncustomizable collision detection algorithms, multiple activators, draggable overlay, drag handles, auto-scrolling, constraints, and so much more.\nBuilt for React:\nexposes hooks such as\nuseDraggable\nand\nuseDroppable\n, and  won't require you to re-architect your app or create additional wrapper DOM nodes.\nSupports a wide range of use cases:\nlists, grids, multiple containers, nested contexts, variable sized items, virtualized lists, 2D Games, and more.\nZero dependencies and modular:\nthe core of the library weighs around 10kb minified and has no external dependencies. It's built around built-in React state management and context, which keeps the library lean.\nBuilt-in support for multiple input methods:\nPointer, mouse, touch and keyboard sensors.\nFully customizable & extensible:\nCustomize every detail \u2013 animations, transitions, behaviours, styles. Build your own\nsensors\n,\ncollision detection algorithms\n, customize key bindings and so much more.\nAccessibility:\nKeyboard support, sensible default aria attributes, customizable screen reader instructions and live regions built-in.\nPerformance:\nIt was built with performance in mind in order to support silky smooth animations.\nPresets:\nNeed to build a sortable interface? Check out\n@dnd-kit/sortable\n, which is a thin layer built on top of\n@dnd-kit/core\n. More presets coming in the future.\nThe core library of\ndnd kit\nexposes two main concepts:\nDraggable elements\nDroppable areas\nAugment your existing components using the\nuseDraggable\nand\nuseDroppable\nhooks, or combine both to create components that can both be dragged and dropped over.\nHandle events and customize the behaviour of your draggable elements and droppable areas using the\n<DndContext>\nprovider.  Configure\nsensors\nto handle different input methods.\nUse the\n<DragOverlay>\ncomponent to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport.\nCheck out our quick start guide to learn how get started:\nQuick start\nExtensibility\nExtensibility is at the core of\ndnd kit\n. It was built to be lean and extensible. It ships with the features we believe most people will want most of the time, and provides extension points to build the rest on top of\n@dnd-kit/core\n.\nA prime example of the level of extensibility of\ndnd kit\nis the\nSortable preset\n, which is built using the extension points that are exposed by\n@dnd-kit/core\n.\nThe primary extension points are:\nSensors\nModifiers\nCustom collision detection algorithms\nAccessibility\nBuilding drag and drop interfaces that are accessible to everyone isn't easy, and requires thoughtful consideration.\nThe\n@dnd-kit/core\nlibrary provides a number of starting points to help you make your drag and drop interfaces accessible:\nKeyboard support\nout of the box\nCustomizable screen reader instructions\nfor how to interact with draggable items\nCustomizable live region updates\nto provide screen reader announcements in real-time of what is currently happening with draggable and droppable elements.\nSensible defaults for attributes\nthat should be passed to draggable elements\nCheck out our Accessibility guide to learn more about how you can help make your drag and drop interface accessible for everyone:\nAccessibility\nArchitecture\nUnlike many drag and drop libraries,\ndnd kit\nis\nintentionally\nnot\nbuilt on top of the\nHTML5 Drag and drop API\n. This was a deliberate architectural decision, that does come with tradeoffs that you should be aware of before deciding to use it. For most web applications, we believe the benefits outweigh the tradeoffs.\nThe HTML5 Drag and drop API has some severe\nlimitations\n. It does not support touch devices, which means that the libraries that are built on top of it need to expose an entirely different implementation to support touch devices. This typically increases the complexity of the codebase and the overall bundle size of the library. Further, it requires workarounds to implement common use cases such as customizing the drag preview, locking dragging to a specific axis or to the bounds of a container, or animating the dragged item as it is picked up.\nThe main\ntradeoff\nwith not using the HTML5 Drag and drop API is that you won't be able to drag from the desktop or between windows. If the drag and drop use-case you have in mind involves this kind of functionality, you'll definitely want to use a library that's built on top of the HTML 5 Drag and drop API. We highly recommend you check out\nreact-dnd\nfor a React library that's has a native HTML 5 Drag and drop backend.\nPerformance\nMinimizing DOM mutations\ndnd kit\nlets you build drag and drop interfaces without having to mutate the DOM every time an item needs to shift position.\nThis is possible because\ndnd kit\nlazily calculates and stores the initial positions and client rects of your droppable containers when a drag operation is initiated. These positions are passed down to your components that use\nuseDraggable\nand\nuseDroppable\nso that you can compute the new positions of your items while a drag operation is underway, and move them to their new positions using performant CSS properties that do not trigger a repaint such as\ntranslate3d\nand\nscale\n. For an example of how this can be achieved, check out the implementation of the sorting strategies that are exposed by the\n@dnd-kit/sortable\nlibrary.\nThis isn't to say that you can't shift the position of the items in the DOM while dragging, this is something that\nis supported\nand sometimes inevitable. In some cases, it won't be possible to know in advance what the new position and layout of the item until you move it in the DOM. Just know that these kind of mutations to the DOM while dragging are much more expensive and will cause a repaint, so if possible, prefer computing the new positions using\ntranslate3d\nand\nscale\n.\nSynthetic events\nSensors use\nSyntheticEvent listeners\nfor the activator events of all sensors, which leads to improved performance over manually adding event listeners to each individual draggable node.\nLast updated\n3 years ago",
  "content_markdown": "- **Feature packed:** customizable collision detection algorithms, multiple activators, draggable overlay, drag handles, auto-scrolling, constraints, and so much more.\n- **Built for React:** exposes hooks such as [`useDraggable`](/api-documentation/draggable/usedraggable) and [`useDroppable`](/api-documentation/droppable/usedroppable), and won't require you to re-architect your app or create additional wrapper DOM nodes.\n- **Supports a wide range of use cases:** lists, grids, multiple containers, nested contexts, variable sized items, virtualized lists, 2D Games, and more.\n- **Zero dependencies and modular:** the core of the library weighs around 10kb minified and has no external dependencies. It's built around built-in React state management and context, which keeps the library lean.\n- **Built-in support for multiple input methods:** Pointer, mouse, touch and keyboard sensors.\n- **Fully customizable & extensible:** Customize every detail \u2013 animations, transitions, behaviours, styles. Build your own [sensors](/api-documentation/sensors), [collision detection algorithms](/api-documentation/context-provider/collision-detection-algorithms), customize key bindings and so much more.\n- **Accessibility:** Keyboard support, sensible default aria attributes, customizable screen reader instructions and live regions built-in.\n- **Performance:** It was built with performance in mind in order to support silky smooth animations.\n- **Presets:** Need to build a sortable interface? Check out [`@dnd-kit/sortable`](/presets/sortable), which is a thin layer built on top of `@dnd-kit/core`. More presets coming in the future.\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-x-prod.appspot.com%2Fo%2Fspaces%252F-MMujhzqaYbBEEmDxnZO%252Fuploads%252FrFnN48FwW1TuQlqZmp58%252Fconcepts-illustration-large.svg%3Falt%3Dmedia%26token%3D451a9922-8aba-426b-bd91-fa4721a71ef7&width=768&dpr=3&quality=100&sign=a73ed3c&sv=2)\n\nThe core library of **dnd kit** exposes two main concepts:\n\n- [Draggable elements](/api-documentation/draggable)\n- [Droppable areas](/api-documentation/droppable)\n\nAugment your existing components using the [`useDraggable`](/api-documentation/draggable/usedraggable) and [`useDroppable`](/api-documentation/droppable/usedroppable) hooks, or combine both to create components that can both be dragged and dropped over.\n\nHandle events and customize the behaviour of your draggable elements and droppable areas using the [`<DndContext>`](/api-documentation/context-provider) provider. Configure [sensors](/api-documentation/sensors) to handle different input methods.\n\nUse the [`<DragOverlay>`](/api-documentation/draggable/drag-overlay) component to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport.\n\nCheck out our quick start guide to learn how get started:\n\n[Quick start](/introduction/getting-started)\n\n### Extensibility\n\nExtensibility is at the core of **dnd kit**. It was built to be lean and extensible. It ships with the features we believe most people will want most of the time, and provides extension points to build the rest on top of `@dnd-kit/core`.\n\nA prime example of the level of extensibility of **dnd kit** is the [Sortable preset](/presets/sortable), which is built using the extension points that are exposed by `@dnd-kit/core`.\n\nThe primary extension points are:\n\n- [Sensors](/api-documentation/sensors)\n- [Modifiers](/api-documentation/modifiers)\n- [Custom collision detection algorithms](/api-documentation/context-provider/collision-detection-algorithms#custom-collision-detection-strategies)\n\n### Accessibility\n\nBuilding drag and drop interfaces that are accessible to everyone isn't easy, and requires thoughtful consideration.\n\nThe `@dnd-kit/core` library provides a number of starting points to help you make your drag and drop interfaces accessible:\n\n- [Keyboard support](/api-documentation/sensors/keyboard) out of the box\n- [Customizable screen reader instructions](/guides/accessibility#screen-reader-instructions) for how to interact with draggable items\n- [Customizable live region updates](/guides/accessibility#screen-reader-announcements-using-live-regions) to provide screen reader announcements in real-time of what is currently happening with draggable and droppable elements.\n- [Sensible defaults for attributes](/api-documentation/draggable/usedraggable#attributes) that should be passed to draggable elements\n\nCheck out our Accessibility guide to learn more about how you can help make your drag and drop interface accessible for everyone:\n\n[Accessibility](/guides/accessibility)\n\n### Architecture\n\nUnlike many drag and drop libraries, **dnd kit** isintentionally **not** built on top of the [HTML5 Drag and drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API). This was a deliberate architectural decision, that does come with tradeoffs that you should be aware of before deciding to use it. For most web applications, we believe the benefits outweigh the tradeoffs.\n\nThe HTML5 Drag and drop API has some severe **limitations**. It does not support touch devices, which means that the libraries that are built on top of it need to expose an entirely different implementation to support touch devices. This typically increases the complexity of the codebase and the overall bundle size of the library. Further, it requires workarounds to implement common use cases such as customizing the drag preview, locking dragging to a specific axis or to the bounds of a container, or animating the dragged item as it is picked up.\n\nThe main **tradeoff** with not using the HTML5 Drag and drop API is that you won't be able to drag from the desktop or between windows. If the drag and drop use-case you have in mind involves this kind of functionality, you'll definitely want to use a library that's built on top of the HTML 5 Drag and drop API. We highly recommend you check out [react-dnd](https://github.com/react-dnd/react-dnd/) for a React library that's has a native HTML 5 Drag and drop backend.\n\n### Performance\n\n#### **Minimizing DOM mutations**\n\n**dnd kit** lets you build drag and drop interfaces without having to mutate the DOM every time an item needs to shift position.\n\nThis is possible because **dnd kit** lazily calculates and stores the initial positions and client rects of your droppable containers when a drag operation is initiated. These positions are passed down to your components that use `useDraggable` and `useDroppable` so that you can compute the new positions of your items while a drag operation is underway, and move them to their new positions using performant CSS properties that do not trigger a repaint such as `translate3d` and `scale`. For an example of how this can be achieved, check out the implementation of the sorting strategies that are exposed by the [`@dnd-kit/sortable`](/presets/sortable) library.\n\nThis isn't to say that you can't shift the position of the items in the DOM while dragging, this is something that **is supported** and sometimes inevitable. In some cases, it won't be possible to know in advance what the new position and layout of the item until you move it in the DOM. Just know that these kind of mutations to the DOM while dragging are much more expensive and will cause a repaint, so if possible, prefer computing the new positions using `translate3d` and `scale`.\n\n#### Synthetic events\n\nSensors use [SyntheticEvent listeners](https://reactjs.org/docs/events.html) for the activator events of all sensors, which leads to improved performance over manually adding event listeners to each individual draggable node.\n\nLast updated 3 years ago",
  "tags": [
    "dnd-kit",
    "drag-drop",
    "sortable",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:54:14.677257+00:00",
  "content_length": 6055,
  "content_hash": "0cbc629b3469da5e"
}