{
  "id": "dnd-kit__guides_accessibility",
  "source_id": "dnd-kit",
  "source_name": "dnd kit",
  "category": "drag_and_drop",
  "url": "https://docs.dndkit.com/guides/accessibility",
  "title": "Accessibility | @dnd-kit \u2013 Documentation",
  "content": "Introduction\nIf you're new to accessibility for the web, the\nWeb Almanac by HTTP Archive\nhas an excellent primer on the subject and the state of web accessibility that you should read before diving into this guide:\nhttps://almanac.httparchive.org/en/2021/accessibility\nWeb accessibility is about achieving feature and information parity and giving complete access to all aspects of an interface to disabled people.\nA digital product or website is simply not complete if it is not usable by everyone. If it excludes certain disabled populations, this is discrimination and potentially grounds for fines and/or lawsuits.\n\u2013 Source:\nWeb Almanac by HTTP Archive\nPeople with varying disabilities use different assistive technologies to help them experience the web.\nThe\nTools and Techniques\narticle from the Web Accessibility Initiative (WAI) of the W3C covers how users can perceive, understand and interact with the web using different assistive technologies.\nSome assistive technologies for the web include:\nScreen readers\nVoice control\nScreen magnifiers\nInput devices (such as the keyboard, pointers and switch devices)\nWhen building accessible interfaces for the web, it's important to keep the three  following questions in mind:\nIdentity:\nWhat element is the user interacting with?\nOperation:\nHow can the user interact with the element?\nState:\nWhat is the current state of the element?\nIn this guide, we'll focus on how to make drag and drop interfaces that are keyboard accessible and provide identity, operation instructions and live state updates for screen readers.\nBuilding accessible drag and drop interfaces\nBuilding drag and drop interfaces that are accessible to everyone isn't easy, and requires thoughtful consideration.\nThe\n@dnd-kit/core\nlibrary provides a number of sensible defaults to help you make your drag and drop interfaces accessible.\nThese sensible defaults should be seen as\nstarting points\nrather than something you can set and forget; there is no one-size-fits-all solution to web accessibility.\nYou know your application best, and while these sensible defaults will go a long way to help making your application more accessible, in most cases you'll want to customize these  so that they are tailored to the context of your application.\nThe three main areas of focus for this guide to help you make your drag and drop interface more accessible are:\nKeyboard support\nScreen reader instructions\nLive regions to provide screen reader announcements\nKeyboard support\nOne of the\nfive rules of ARIA\nis that all interactive ARIA controls must be usable with the keyboard.\nWhen creating widgets that a user can click or tap, drag, and drop, a user must also be able to\nnavigate to the widget\nand\nperform an equivalent action using the keyboard\n.\nFor drag and drop interfaces, this means that the activator element that initiates the drag action must:\nBe able to receive focus\nA user must be able to activate the action associated with the element using\nboth\nthe\nenter\n(on Windows) or\nreturn\n(on macOS) and the\nspace\nkey.\nBoth these guidelines should be respected to comply with the\nthird rule of ARIA\n.\nThe\n@dnd-kit/core\nlibrary ships with a\nKeyboard sensor\nthat adheres to these guidelines. The keyboard sensor is one of the two sensors that are enabled by default on the\n<DndContext>\nprovider component.\nFocus\nIn order for the Keyboard sensor to function properly, the activator element that receives the\nuseDraggable\nlisteners\nmust\nbe able to receive focus.\nThe\ntabindex\nattribute dictates the order in which focus moves throughout the document.\nNatively interactive elements such as\nbuttons\n,\nanchor tags\nand\nform controls\nhave a default\ntabindex\nvalue of\n0\n.\nCustom elements that are intended to be interactive and receive keyboard focus need to have an explicitly assigned\ntabindex=\"0\"\n(for example,\ndiv\nand\nli\nelements)\nIn other words, in order for your draggable activator elements to be able to receive keyboard focus, they\nneed\nto have the\ntabindex\nattribute set to\n0\nif\nthey are not natively interactive elements (such as the HTML\nbutton\nelement).\nFor this reason, the\nuseDraggable\nhook sets the\ntabindex=\"0\"\nattribute by default.\nKeyboard shortcuts\nOnce a draggable activator element receives focus, the\nenter\n(on Windows) or\nreturn\n(on macOS) and the\nspace\nkeys can be used to initiate a drag operation and pick up the draggable item.\nThe arrow keys are used to move the draggable item in any given direction.\nAfter an item is picked up, it can be dropped using the\nenter\n(on Windows) or\nreturn\n(on macOS) and the\nspace\nkeys.\nA drag operation can be cancelled using the\nescape\nkey. It is recommended to allow users to cancel the drag operation using the\nescape\nkey for all sensors, not just the Keyboard sensor.\nThe keyboard shortcuts of the Keyboard sensor can be\ncustomized\n, but we discourage you to do so unless you maintain support for the\nenter\n,\nreturn\nand\nspace\nkeys to follow the guidelines set by the third rule of ARIA.\nBy default, the\nKeyboard sensor\nmoves in any given direction by\n25\npixels when the arrow keys are pressed while dragging.\nThis is an arbitrary default that is likely not suited for all use-cases. We encourage you to customize this behaviour and tailor it to the context of your application using the\ngetNextCoordinates\noption\nof the Keyboard sensor.\nFor example, the\nuseSortable\nhook ships with an augmented version of the Keyboard sensor that uses the\ngetNextCoordinates\noption behind the scenes to find the coordinates of the next sortable element in any given direction when an arrow key is pressed.\nIn order to let users learn how to interact with draggable elements using these keyboard shortcuts, it's important to provide screen reader instructions.\nScreen reader instructions\nIn order to users know how to interact with draggable items using only the keyboard, it's important to provide information to the user that their focus is currently on a draggable item, along with clear instruction  on how to pick up a a draggable item, how to move it, how to drop it and how to cancel the operation.\nRole\nTo let users know that their focus is currently on a draggable item, the\nuseDraggable\nhook provides the\nrole\nand\naria-roledescription\n, and\naria-describedby\nattributes by default:\nAttribute\nDefault value\nDescription\nrole\n\"button\"\nThe ARIA\n\"role\"\nattribute lets you explicitly define the role for an element, which communicates its purpose to assistive technologies.\nIf possible, we recommend you use a semantic\n<button>\nelement for the DOM element you plan on attaching draggable listeners to. \n\nIn case that's not possible, make sure you include the\nrole=\"button\"\nattribute, which is the default value.\naria-roledescription\n\"draggable\"\nDefines a human-readable, localized description for the role of an element that is read by screen readers.\nWhile\ndraggable\nis a sensible default, we recommend you customize this value to something that is tailored to your use-case.\naria-describedby\n\"DndContext-[uniqueId]\"\nEach draggable item is provided a unique\naria-describedby\nID that points to the voiceover instructions to be read out when a draggable item receives focus\nThe\nrole\nand\naria-roledescription\nattributes can be customized via the\noptions passed to the\nuseDraggable\nhook\n.\nTo customize the\naria-describedby\ninstructions, refer to the section below.\nInstructions\nBy default, each\n<DndContext>\ncomponent renders a unique HTML element that is rendered off-screen to be used to provide these instructions to screen readers.\nThe default instructions are:\nTo pick up a draggable item, press space or enter. \nWhile dragging, use the arrow keys to move the item in any given direction.\nPress space or enter again to drop the item in its new position, or press escape to cancel.\nWe recommend you customize and localize these instructions to your application and use-case using the\nscreenReaderInstructions\nprop of\n<DndContext>\n.\nFor example, if you were building a sortable grocery shopping list, you may want to tailor the instructions like so:\nTo pick up a grocery list item, press space or enter. \nUse the up and down arrow keys to update the position of the item in the grocery list.\nPress space or enter again to drop the item in its new position, or press escape to cancel.\nIf your application supports multiple languages, make sure you also translate these instructions. The\n<DndContext>\ncomponent only ships with instructions in English due to bundle size concerns.\nScreen reader announcements using live regions\nLive regions\nare used to notify screen readers of content changes.\nWhen building accessible drag and drop interfaces, live regions should be used to provide screen reader announcements in real-time of time-sensitive information of what is currently happening with draggable and droppable elements without having to move focus .\nBy default, each\n<DndContext>\ncomponent renders a unique HTML element that is rendered off-screen to be used for live screen-reader announcements of events like when a drag operation has started, when a draggable item has been dragged over a droppable container, when a drag operation has ended, and when a drag operation has been cancelled.\nThese instructions can be customized using the\nannouncements\nprop of\nDndContext\n.\nThe default announcements are:\nWhile these default announcements are sensible defaults that should cover most simple use cases, you know your application best, and we highly recommend that you customize these to provide a screen reader experience that is more tailored to the use case you are building.\nWhen authoring screen reader announcements that rely on an element's position (index) in a list, use positions rather than indices to describe the element's current position.\nHere's an example of index based announcements and why you should avoid them:\nItem with index 0 was picked up. Item was moved to index 1 of 4.\nPosition based announcements are much more intuitive and natural:\nItem at position 1 was picked up. Item was moved to position 2 of 5.\nFor example, when building a sortable list, you could write custom announcements that are tailored to that use-case using position based announcements:\nThe example above assumes that the\nclosestCenter\ncollision detection strategy\nis used, so the\nover\nproperty should always be defined.\nIf your application supports multiple languages, make sure you also translate these announcements. The\n<DndContext>\ncomponent only ships with announcements in English due to bundle size concerns.\nLast updated\n3 years ago",
  "content_markdown": "## Introduction\n\nIf you're new to accessibility for the web, the *Web Almanac by HTTP Archive* has an excellent primer on the subject and the state of web accessibility that you should read before diving into this guide: <https://almanac.httparchive.org/en/2021/accessibility>\n\n> Web accessibility is about achieving feature and information parity and giving complete access to all aspects of an interface to disabled people.\n>\n> A digital product or website is simply not complete if it is not usable by everyone. If it excludes certain disabled populations, this is discrimination and potentially grounds for fines and/or lawsuits.\n>\n> \u2013 Source: [Web Almanac by HTTP Archive](https://almanac.httparchive.org/en/2020/accessibility#screen-reader-only-text)\n\nPeople with varying disabilities use different assistive technologies to help them experience the web.\n\nThe [Tools and Techniques](https://www.w3.org/WAI/people-use-web/tools-techniques/) article from the Web Accessibility Initiative (WAI) of the W3C covers how users can perceive, understand and interact with the web using different assistive technologies.\n\nSome assistive technologies for the web include:\n\n- Screen readers\n- Voice control\n- Screen magnifiers\n- Input devices (such as the keyboard, pointers and switch devices)\n\nWhen building accessible interfaces for the web, it's important to keep the three following questions in mind:\n\n1. **Identity:** What element is the user interacting with?\n2. **Operation:** How can the user interact with the element?\n3. **State:** What is the current state of the element?\n\nIn this guide, we'll focus on how to make drag and drop interfaces that are keyboard accessible and provide identity, operation instructions and live state updates for screen readers.\n\n## Building accessible drag and drop interfaces\n\nBuilding drag and drop interfaces that are accessible to everyone isn't easy, and requires thoughtful consideration.\n\nThe `@dnd-kit/core` library provides a number of sensible defaults to help you make your drag and drop interfaces accessible.\n\nThese sensible defaults should be seen as *starting points* rather than something you can set and forget; there is no one-size-fits-all solution to web accessibility.\n\nYou know your application best, and while these sensible defaults will go a long way to help making your application more accessible, in most cases you'll want to customize these so that they are tailored to the context of your application.\n\nThe three main areas of focus for this guide to help you make your drag and drop interface more accessible are:\n\n- [Keyboard support](/guides/accessibility#keyboard-support)\n- [Screen reader instructions](/guides/accessibility#screen-reader-instructions)\n- [Live regions to provide screen reader announcements](/guides/accessibility#screen-reader-announcements-using-live-regions)\n\n### Keyboard support\n\nOne of the [five rules of ARIA](https://www.w3.org/TR/using-aria/#rule3) is that all interactive ARIA controls must be usable with the keyboard.\n\nWhen creating widgets that a user can click or tap, drag, and drop, a user must also be able to **navigate to the widget** and **perform an equivalent action using the keyboard**.\n\nFor drag and drop interfaces, this means that the activator element that initiates the drag action must:\n\n- Be able to receive focus\n- A user must be able to activate the action associated with the element using **both** the `enter` (on Windows) or `return` (on macOS) and the `space` key.\n\nBoth these guidelines should be respected to comply with the [third rule of ARIA](https://www.w3.org/TR/using-aria/#3rdrule).\n\nThe `@dnd-kit/core` library ships with a [Keyboard sensor](/api-documentation/sensors/keyboard) that adheres to these guidelines. The keyboard sensor is one of the two sensors that are enabled by default on the [`<DndContext>`](/api-documentation/context-provider) provider component.\n\n#### Focus\n\nIn order for the Keyboard sensor to function properly, the activator element that receives the `useDraggable` [listeners](/api-documentation/draggable/usedraggable#listeners) **must** be able to receive focus.\n\nThe `tabindex` attribute dictates the order in which focus moves throughout the document.\n\n- Natively interactive elements such as [buttons](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button), [anchor tags](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) and [form controls](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormControlsCollection) have a default `tabindex` value of `0`.\n- Custom elements that are intended to be interactive and receive keyboard focus need to have an explicitly assigned `tabindex=\"0\"`(for example, `div` and `li` elements)\n\nIn other words, in order for your draggable activator elements to be able to receive keyboard focus, they *need* to have the `tabindex` attribute set to `0` **if** they are not natively interactive elements (such as the HTML `button` element).\n\nFor this reason, the `useDraggable` hook sets the `tabindex=\"0\"` attribute by default.\n\n#### Keyboard shortcuts\n\nOnce a draggable activator element receives focus, the `enter` (on Windows) or `return` (on macOS) and the `space` keys can be used to initiate a drag operation and pick up the draggable item.\n\nThe arrow keys are used to move the draggable item in any given direction.\n\nAfter an item is picked up, it can be dropped using the `enter` (on Windows) or `return` (on macOS) and the `space` keys.\n\nA drag operation can be cancelled using the `escape` key. It is recommended to allow users to cancel the drag operation using the `escape` key for all sensors, not just the Keyboard sensor.\n\nThe keyboard shortcuts of the Keyboard sensor can be [customized](/api-documentation/sensors/keyboard#keyboard-codes), but we discourage you to do so unless you maintain support for the `enter`, `return` and `space` keys to follow the guidelines set by the third rule of ARIA.\n\nBy default, the [Keyboard sensor](/api-documentation/sensors/keyboard) moves in any given direction by `25` pixels when the arrow keys are pressed while dragging.\n\nThis is an arbitrary default that is likely not suited for all use-cases. We encourage you to customize this behaviour and tailor it to the context of your application using the [`getNextCoordinates` option](/api-documentation/sensors/keyboard#coordinates-getter) of the Keyboard sensor.\n\nFor example, the `useSortable` hook ships with an augmented version of the Keyboard sensor that uses the `getNextCoordinates` option behind the scenes to find the coordinates of the next sortable element in any given direction when an arrow key is pressed.\n\nIn order to let users learn how to interact with draggable elements using these keyboard shortcuts, it's important to provide screen reader instructions.\n\n### Screen reader instructions\n\nIn order to users know how to interact with draggable items using only the keyboard, it's important to provide information to the user that their focus is currently on a draggable item, along with clear instruction on how to pick up a a draggable item, how to move it, how to drop it and how to cancel the operation.\n\n#### Role\n\nTo let users know that their focus is currently on a draggable item, the [`useDraggable`](/api-documentation/draggable/usedraggable) hook provides the [`role`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles) and [`aria-roledescription`](https://www.digitala11y.com/aria-roledescriptionproperties/), and [`aria-describedby`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-describedby_attribute) attributes by default:\n\nAttribute\n\nDefault value\n\nDescription\n\n`role`\n\n`\"button\"`\n\nThe ARIA `\"role\"` attribute lets you explicitly define the role for an element, which communicates its purpose to assistive technologies.\n\nIf possible, we recommend you use a semantic `<button>` element for the DOM element you plan on attaching draggable listeners to.\nIn case that's not possible, make sure you include the `role=\"button\"`attribute, which is the default value.\n\n`aria-roledescription`\n\n`\"draggable\"`\n\nDefines a human-readable, localized description for the role of an element that is read by screen readers.\n\nWhile `draggable` is a sensible default, we recommend you customize this value to something that is tailored to your use-case.\n\n`aria-describedby`\n\n`\"DndContext-[uniqueId]\"`\n\nEach draggable item is provided a unique `aria-describedby` ID that points to the voiceover instructions to be read out when a draggable item receives focus\n\nThe `role` and `aria-roledescription` attributes can be customized via the [options passed to the `useDraggable` hook](/api-documentation/draggable/usedraggable#arguments).\n\nTo customize the `aria-describedby` instructions, refer to the section below.\n\n#### Instructions\n\nBy default, each [`<DndContext>`](/api-documentation/context-provider) component renders a unique HTML element that is rendered off-screen to be used to provide these instructions to screen readers.\n\nThe default instructions are:\n\n> To pick up a draggable item, press space or enter.\n> While dragging, use the arrow keys to move the item in any given direction.\n> Press space or enter again to drop the item in its new position, or press escape to cancel.\n\nWe recommend you customize and localize these instructions to your application and use-case using the `screenReaderInstructions` prop of [`<DndContext>`](/api-documentation/context-provider).\n\nFor example, if you were building a sortable grocery shopping list, you may want to tailor the instructions like so:\n\n> To pick up a grocery list item, press space or enter.\n> Use the up and down arrow keys to update the position of the item in the grocery list.\n> Press space or enter again to drop the item in its new position, or press escape to cancel.\n\nIf your application supports multiple languages, make sure you also translate these instructions. The `<DndContext>` component only ships with instructions in English due to bundle size concerns.\n\n### Screen reader announcements using live regions\n\n[Live regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) are used to notify screen readers of content changes.\n\nWhen building accessible drag and drop interfaces, live regions should be used to provide screen reader announcements in real-time of time-sensitive information of what is currently happening with draggable and droppable elements without having to move focus .\n\nBy default, each [`<DndContext>`](/api-documentation/context-provider) component renders a unique HTML element that is rendered off-screen to be used for live screen-reader announcements of events like when a drag operation has started, when a draggable item has been dragged over a droppable container, when a drag operation has ended, and when a drag operation has been cancelled.\n\nThese instructions can be customized using the `announcements` prop of `DndContext`.\n\nThe default announcements are:\n\nWhile these default announcements are sensible defaults that should cover most simple use cases, you know your application best, and we highly recommend that you customize these to provide a screen reader experience that is more tailored to the use case you are building.\n\nWhen authoring screen reader announcements that rely on an element's position (index) in a list, use positions rather than indices to describe the element's current position.\n\nHere's an example of index based announcements and why you should avoid them:\n\n> Item with index 0 was picked up. Item was moved to index 1 of 4.\n\nPosition based announcements are much more intuitive and natural:\n\n> Item at position 1 was picked up. Item was moved to position 2 of 5.\n\nFor example, when building a sortable list, you could write custom announcements that are tailored to that use-case using position based announcements:\n\nThe example above assumes that the [`closestCenter` collision detection strategy](/api-documentation/context-provider/collision-detection-algorithms#closest-center) is used, so the `over` property should always be defined.\n\nIf your application supports multiple languages, make sure you also translate these announcements. The `<DndContext>` component only ships with announcements in English due to bundle size concerns.\n\nLast updated 3 years ago",
  "tags": [
    "dnd-kit",
    "drag-drop",
    "sortable",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:54:25.023039+00:00",
  "content_length": 10500,
  "content_hash": "ea20910e4f28a6d4"
}