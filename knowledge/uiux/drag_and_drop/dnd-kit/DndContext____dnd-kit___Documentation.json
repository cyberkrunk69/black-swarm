{
  "id": "dnd-kit__api-documentation_context-provider",
  "source_id": "dnd-kit",
  "source_name": "dnd kit",
  "category": "drag_and_drop",
  "url": "https://docs.dndkit.com/api-documentation/context-provider",
  "title": "DndContext | @dnd-kit \u2013 Documentation",
  "content": "Application structure\nContext provider\nIn order for your your\nDroppable\nand\nDraggable\ncomponents to interact with each other, you'll need to make sure that the part of your React tree that uses them is nested within  a parent\n<DndContext>\ncomponent. The\n<DndContext>\nprovider makes use of the\nReact Context API\nto share data between draggable and droppable components and hooks.\nReact context provides a way to pass data through the component tree without having to pass props down manually at every level.\nTherefore, components that use\nuseDraggable\n,\nuseDroppable\nor\nDragOverlay\nwill need to be nested within a\nDndContext\nprovider.\nThey don't need to be direct descendants, but, there does need to be a parent\n<DndContext>\nprovider somewhere higher up in the tree.\nCopy\nimport\nReact\nfrom\n'\nreact\n'\n;\nimport\n{\nDndContext\n}\nfrom\n'\n@dnd-kit/core\n'\n;\nfunction\nApp\n()\n{\nreturn\n(\n<\nDndContext\n>\n{\n/*\nComponents that use `useDraggable`, `useDroppable`\n*/\n}\n</\nDndContext\n>\n)\n;\n}\nNesting\nYou may also nest\n<DndContext>\nproviders within other\n<DndContext>\nproviders to achieve nested draggable/droppable interfaces that are independent of one another.\nWhen nesting\nDndContext\nproviders, keep in mind that the\nuseDroppable\nand\nuseDraggable\nhooks will only have access to the other draggable and droppable nodes within that context.\nIf multiple\nDndContext\nproviders are listening for the same event, events will be captured by the first\nDndContext\nthat contains a\nSensor\nthat is activated by that event, similar to how\nevents bubble in the DOM\n.\nProps\nEvent handlers\nAs you can see from the list of props above, there are a number of different events emitted by\n<DndContext>\nthat you can listen to and decide how to handle.\nThe main events you can listen to are:\nonDragStart\nFires when a drag event that meets the\nactivation constraints\nfor that\nsensor\nhappens, along with the unique identifier of the draggable element that was picked up.\nonDragMove\nFires anytime as the\ndraggable\nitem is moved. Depending on the activated\nsensor\n, this could for example be as the\nPointer\nis moved or the\nKeyboard\nmovement keys are pressed.\nonDragOver\nFires when a\ndraggable\nitem is moved over a\ndroppable\ncontainer, along with the unique identifier of that droppable container.\nonDragEnd\nFires after a draggable item is dropped.\nThis event contains information about the active draggable\nid\nalong with information on whether the draggable item was dropped\nover\n.\nIf there are no\ncollisions detected\nwhen the draggable item is dropped, the\nover\nproperty will be\nnull\n. If a collision is detected, the\nover\nproperty will contain the\nid\nof the droppable over which it was dropped.\nIt's important to understand that the\nonDragEnd\nevent\ndoes not move\ndraggable\nitems into\ndroppable\ncontainers.\nRather, it provides\ninformation\nabout which draggable item was dropped and whether it was over a droppable container when it was dropped.\nIt is up to the\nconsumer\nof\nDndContext\nto decide what to do with that information and how to react to it, for example, by updating (or not) its internal state in response to the event so that the items are declaratively rendered in a different parent droppable.\nonDragCancel\nFires if a drag operation is cancelled, for example, if the user presses\nescape\nwhile dragging a draggable item.\nAccessibility\nFor more details and best practices around accessibility of draggable and droppable components, read the accessibility section:\nAccessibility\nAnnouncements\nUse the\nannouncements\nprop to customize the screen reader announcements that are announced in the live region when draggable items are picked up, moved over droppable regions, and dropped.\nThe default announcements are:\nWhile these default announcements are sensible defaults that should cover most simple use cases, you know your application best, and we highly recommend that you customize these to provide a screen reader experience that is more tailored to the use case you are building.\nScreen reader instructions\nUse the\nscreenReaderInstructions\nprop to customize the instructions that are read to screen readers when the focus is moved\nAutoscroll\nUse the optional\nautoScroll\nboolean prop to temporarily or permanently disable auto-scrolling for all sensors used within this\nDndContext\n.\nAuto-scrolling may also be disabled on an individual sensor basis using the static property\nautoScrollEnabled\nof the sensor. For example, the\nKeyboard sensor\nmanages scrolling internally, and therefore has the static property\nautoScrollEnabled\nset to\nfalse\n.\nCollision detection\nUse the\ncollisionDetection\nprop to customize the collision detection algorithm used to detect collisions between draggable nodes and droppable areas within the\nDndContext\nprovider.\nThe default collision detection algorithm is the\nrectangle intersection\nalgorithm.\nThe built-in collision detection algorithms are:\nRectangle intersection\nClosest center\nClosest corners\nYou may also build custom collision detection algorithms or compose existing ones.\nTo learn more, read the collision detection guide:\nCollision detection algorithms\nSensors\nSensors are an abstraction to detect different input methods in order to initiate drag operations, respond to movement and end or cancel the operation.\nThe default sensors used by\nDndContext\nare the\nPointer\nand\nKeyboard\nsensors.\nTo learn how to customize sensors or how to pass different sensors to\nDndContext\n, read the Sensors guide:\nSensors\nModifiers\nModifiers let you dynamically modify the movement coordinates that are detected by sensors. They can be used for a wide range of use cases, for example:\nRestricting motion to a single axis\nRestricting motion to the draggable node container's bounding rectangle\nRestricting motion to the draggable node's scroll container bounding rectangle\nApplying resistance or clamping the motion\nTo learn more about how to use Modifiers, read the Modifiers guide:\nModifiers\nLayout measuring\nYou can configure when and how often\nDndContext\nshould measure its droppable elements by using the\nlayoutMeasuring\nprop.\nThe\nfrequency\nargument controls how frequently layouts should be measured. By default, layout measuring is set to\noptimized\n, which only measures layouts based on the\nstrategy\n.\nSpecify one of the following strategies:\nLayoutMeasuringStrategy.WhileDragging\n: Default behavior, only measure droppable elements right after dragging has begun.\nLayoutMeasuringStrategy.BeforeDragging\n:  Measure droppable elements before dragging begins and right after it ends.\nLayoutMeasuringStrategy.Always\n: Measure droppable elements before dragging begins, right after dragging has begun, and after it ends.\nExample usage:\nLast updated\n4 years ago",
  "content_markdown": "## Application structure\n\n### Context provider\n\nIn order for your your [Droppable](/api-documentation/droppable) and [Draggable](/api-documentation/draggable) components to interact with each other, you'll need to make sure that the part of your React tree that uses them is nested within a parent `<DndContext>` component. The `<DndContext>` provider makes use of the [React Context API](https://reactjs.org/docs/context.html) to share data between draggable and droppable components and hooks.\n\n> React context provides a way to pass data through the component tree without having to pass props down manually at every level.\n\nTherefore, components that use [`useDraggable`](/api-documentation/draggable/usedraggable), [`useDroppable`](/api-documentation/droppable/usedroppable) or [`DragOverlay`](/api-documentation/draggable/drag-overlay) will need to be nested within a `DndContext` provider.\n\nThey don't need to be direct descendants, but, there does need to be a parent `<DndContext>` provider somewhere higher up in the tree.\n\nCopy\n\n```\nimport React from 'react';\nimport {DndContext} from '@dnd-kit/core';\n\nfunction App() {\n  return (\n    <DndContext>\n      {/* Components that use `useDraggable`, `useDroppable` */}\n    </DndContext>\n  );\n}\n```\n\n### Nesting\n\nYou may also nest `<DndContext>` providers within other `<DndContext>` providers to achieve nested draggable/droppable interfaces that are independent of one another.\n\nWhen nesting `DndContext` providers, keep in mind that the `useDroppable` and `useDraggable` hooks will only have access to the other draggable and droppable nodes within that context.\n\nIf multiple `DndContext` providers are listening for the same event, events will be captured by the first `DndContext` that contains a [Sensor](/api-documentation/sensors) that is activated by that event, similar to how [events bubble in the DOM](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n\n## Props\n\n### Event handlers\n\nAs you can see from the list of props above, there are a number of different events emitted by `<DndContext>` that you can listen to and decide how to handle.\n\nThe main events you can listen to are:\n\n#### `onDragStart`\n\nFires when a drag event that meets the [activation constraints](/api-documentation/sensors#concepts) for that [sensor](/api-documentation/sensors) happens, along with the unique identifier of the draggable element that was picked up.\n\n#### `onDragMove`\n\nFires anytime as the [draggable](/api-documentation/draggable) item is moved. Depending on the activated [sensor](/api-documentation/sensors#activators), this could for example be as the [Pointer](/api-documentation/sensors/pointer) is moved or the [Keyboard](/api-documentation/sensors/keyboard) movement keys are pressed.\n\n#### `onDragOver`\n\nFires when a [draggable](/api-documentation/draggable) item is moved over a [droppable](/api-documentation/droppable) container, along with the unique identifier of that droppable container.\n\n#### `onDragEnd`\n\nFires after a draggable item is dropped.\n\nThis event contains information about the active draggable `id` along with information on whether the draggable item was dropped `over`.\n\nIf there are no [collisions detected](/api-documentation/context-provider/collision-detection-algorithms) when the draggable item is dropped, the `over` property will be `null`. If a collision is detected, the `over` property will contain the `id` of the droppable over which it was dropped.\n\nIt's important to understand that the `onDragEnd` event **does not move** [**draggable**](/api-documentation/draggable) **items into** [**droppable**](/api-documentation/droppable) **containers.**\n\nRather, it provides **information** about which draggable item was dropped and whether it was over a droppable container when it was dropped.\n\nIt is up to the **consumer** of `DndContext` to decide what to do with that information and how to react to it, for example, by updating (or not) its internal state in response to the event so that the items are declaratively rendered in a different parent droppable.\n\n#### `onDragCancel`\n\nFires if a drag operation is cancelled, for example, if the user presses `escape` while dragging a draggable item.\n\n### Accessibility\n\nFor more details and best practices around accessibility of draggable and droppable components, read the accessibility section:\n\n[Accessibility](/guides/accessibility)\n\n#### Announcements\n\nUse the `announcements` prop to customize the screen reader announcements that are announced in the live region when draggable items are picked up, moved over droppable regions, and dropped.\n\nThe default announcements are:\n\nWhile these default announcements are sensible defaults that should cover most simple use cases, you know your application best, and we highly recommend that you customize these to provide a screen reader experience that is more tailored to the use case you are building.\n\n#### Screen reader instructions\n\nUse the `screenReaderInstructions` prop to customize the instructions that are read to screen readers when the focus is moved\n\n### Autoscroll\n\nUse the optional `autoScroll` boolean prop to temporarily or permanently disable auto-scrolling for all sensors used within this `DndContext`.\n\nAuto-scrolling may also be disabled on an individual sensor basis using the static property `autoScrollEnabled` of the sensor. For example, the [Keyboard sensor](/api-documentation/sensors/keyboard) manages scrolling internally, and therefore has the static property `autoScrollEnabled` set to `false`.\n\n### Collision detection\n\nUse the `collisionDetection` prop to customize the collision detection algorithm used to detect collisions between draggable nodes and droppable areas within the`DndContext` provider.\n\nThe default collision detection algorithm is the [rectangle intersection](/api-documentation/context-provider/collision-detection-algorithms#rectangle-intersection) algorithm.\n\nThe built-in collision detection algorithms are:\n\n- [Rectangle intersection](/api-documentation/context-provider/collision-detection-algorithms#rectangle-intersection)\n- [Closest center](/api-documentation/context-provider/collision-detection-algorithms#closest-center)\n- [Closest corners](/api-documentation/context-provider/collision-detection-algorithms#closest-corners)\n\nYou may also build custom collision detection algorithms or compose existing ones.\n\nTo learn more, read the collision detection guide:\n\n[Collision detection algorithms](/api-documentation/context-provider/collision-detection-algorithms)\n\n### Sensors\n\nSensors are an abstraction to detect different input methods in order to initiate drag operations, respond to movement and end or cancel the operation.\n\nThe default sensors used by `DndContext` are the [Pointer](/api-documentation/sensors/pointer) and [Keyboard](/api-documentation/sensors/keyboard) sensors.\n\nTo learn how to customize sensors or how to pass different sensors to `DndContext`, read the Sensors guide:\n\n[Sensors](/api-documentation/sensors)\n\n### Modifiers\n\nModifiers let you dynamically modify the movement coordinates that are detected by sensors. They can be used for a wide range of use cases, for example:\n\n- Restricting motion to a single axis\n- Restricting motion to the draggable node container's bounding rectangle\n- Restricting motion to the draggable node's scroll container bounding rectangle\n- Applying resistance or clamping the motion\n\nTo learn more about how to use Modifiers, read the Modifiers guide:\n\n[Modifiers](/api-documentation/modifiers)\n\n### Layout measuring\n\nYou can configure when and how often `DndContext` should measure its droppable elements by using the `layoutMeasuring` prop.\n\nThe `frequency` argument controls how frequently layouts should be measured. By default, layout measuring is set to `optimized`, which only measures layouts based on the `strategy`.\n\nSpecify one of the following strategies:\n\n- `LayoutMeasuringStrategy.WhileDragging`: Default behavior, only measure droppable elements right after dragging has begun.\n\n  `LayoutMeasuringStrategy.BeforeDragging`: Measure droppable elements before dragging begins and right after it ends.\n- `LayoutMeasuringStrategy.Always`: Measure droppable elements before dragging begins, right after dragging has begun, and after it ends.\n\nExample usage:\n\nLast updated 4 years ago",
  "tags": [
    "dnd-kit",
    "drag-drop",
    "sortable",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:54:18.270838+00:00",
  "content_length": 6660,
  "content_hash": "102240f01620d489"
}