{
  "id": "dnd-kit__presets_sortable",
  "source_id": "dnd-kit",
  "source_name": "dnd kit",
  "category": "drag_and_drop",
  "url": "https://docs.dndkit.com/presets/sortable",
  "title": "Sortable | @dnd-kit \u2013 Documentation",
  "content": "Installation\nTo get started, install the sortable preset via\nnpm\nor\nyarn\n:\nCopy\nnpm\ninstall\n@dnd-kit/sortable\nOverview\nIf you're eager to get started right away, here's the code you'll need:\nApp.jsx\nSortableItem.jsx\nCopy\nimport\nReact\n,\n{\nuseState\n}\nfrom\n'\nreact\n'\n;\nimport\n{\nDndContext\n,\nclosestCenter\n,\nKeyboardSensor\n,\nPointerSensor\n,\nuseSensor\n,\nuseSensors\n,\n}\nfrom\n'\n@dnd-kit/core\n'\n;\nimport\n{\narrayMove\n,\nSortableContext\n,\nsortableKeyboardCoordinates\n,\nverticalListSortingStrategy\n,\n}\nfrom\n'\n@dnd-kit/sortable\n'\n;\nimport\n{\nSortableItem\n}\nfrom\n'\n./SortableItem\n'\n;\nfunction\nApp\n()\n{\nconst\n[\nitems\n,\nsetItems\n]\n=\nuseState\n([\n1\n,\n2\n,\n3\n])\n;\nconst\nsensors\n=\nuseSensors\n(\nuseSensor\n(\nPointerSensor\n)\n,\nuseSensor\n(\nKeyboardSensor\n,\n{\ncoordinateGetter\n:\nsortableKeyboardCoordinates\n,\n}\n)\n)\n;\nreturn\n(\n<\nDndContext\nsensors\n=\n{\nsensors\n}\ncollisionDetection\n=\n{\nclosestCenter\n}\nonDragEnd\n=\n{\nhandleDragEnd\n}\n>\n<\nSortableContext\nitems\n=\n{\nitems\n}\nstrategy\n=\n{\nverticalListSortingStrategy\n}\n>\n{items\n.\nmap\n(\nid\n=>\n<\nSortableItem\nkey\n=\n{\nid\n}\nid\n=\n{\nid\n}\n/>)\n}\n</\nSortableContext\n>\n</\nDndContext\n>\n)\n;\nfunction\nhandleDragEnd\n(\nevent\n)\n{\nconst\n{\nactive\n,\nover\n}\n=\nevent\n;\nif\n(\nactive\n.\nid\n!==\nover\n.\nid\n)\n{\nsetItems\n(\n(\nitems\n)\n=>\n{\nconst\noldIndex\n=\nitems\n.\nindexOf\n(\nactive\n.\nid\n)\n;\nconst\nnewIndex\n=\nitems\n.\nindexOf\n(\nover\n.\nid\n)\n;\nreturn\narrayMove\n(\nitems\n,\noldIndex\n,\nnewIndex\n)\n;\n}\n)\n;\n}\n}\n}\nFor most sortable lists, we recommend you use a\nDragOverlay\nif your sortable list is scrollable or if the contents of the scrollable list are taller than the viewport of the window. Check out the\nsortable drag overlay guide\nbelow to learn more.\nArchitecture\nThe sortable preset builds on top of the primitives exposed by\n@dnd-kit/core\nto help building sortable interfaces.\nThe sortable preset exposes two main concepts:\nSortableContext\nand the\nuseSortable\nhook:\nThe\nSortableContext\nprovides information via context that is consumed by the\nuseSortable\nhook.\nThe\nuseSortable\nhook is an abstraction that composes the\nuseDroppable\nand\nuseDraggable\nhooks:\nSingle container\nAt a high level, the application structure to implement a\nsortable list with a single container\nlooks as follows:\nMultiple containers\nTo implement sortable list with items that can be dropped within\nmultiple containers\n, the application structure is the same, but we add as many\nSortableContext\nproviders as we have containers:\nIn this example, we would use the\nonDragOver\ncallback of\nDndContext\nto detect when a draggable element is moved over a different container to insert it in that new container while dragging.\nIf you paid close attention to the illustration above, you may also have noticed that we added a droppable zone around each sortable context. This isn't required, but will likely be the behaviour most people want. If you move all sortable items from one column into the other, you will need a droppable zone for the empty column so that you may drag sortable items back into that empty column:\nConcepts\nSortable Context\nIn addition to the\nDndContext\nprovider\n, the Sortable preset requires its own context provider that contains the\nsorted\narray of the unique identifiers associated to each sortable item:\nThe\nSortableContext\nprovides information via context that is consumed by the\nuseSortable\nhook, which is covered in greater detail in the next section.\nIt's important that the\nitems\nprop passed to\nSortableContext\nbe sorted in the same order in which the items are rendered, otherwise you may see unexpected results.\nIt does not expose any callback props. To know when a sortable (draggable) item is being picked or moved over another sortable (droppable) item, use the callback props of\nDndContext\n:\nIn order for the\nSortableContext\ncomponent to function properly, make sure it is a descendant of a\nDndContext\nprovider. You may nest multiple\nSortableContext\ncomponents within the same parent\nDndContext\n.\nuseSortable\nAs outlined above, the\nuseSortable\nhook combines both the\nuseDraggable\nand\nuseDroppable\nhooks to connect elements as both draggable sources and drop targets:\nIn most cases, the draggable and droppable hooks will be attached to the same node, and therefore be identical in size. They are represented as different nodes for illustration purposes above.\nIf you're already familiar with the\nuseDraggable\nhook, the\nuseSortable\nhook should look very familiar, since, it is an abstraction on top of it.\nIn addition to the\nattributes\n,\nlisteners\n,\ntransform\nand\nsetNodeRef\nproperties, which you should already be familiar with if you've used the\nuseDraggable\nhook before, you'll notice that the\nuseSortable\nhook also provides a\ntransition\nproperty.\nThe\ntransform\nproperty for\nuseSortable\nrepresents the displacement and change of scale transformation that a sortable item needs to apply to transition to its new position without needing to update the DOM order.\nThe\ntransform\nproperty for the\nuseSortable\nhook behaves similarly to the\ntransform\nproperty of the\nuseDraggable\nhook for the active sortable item, when there is no\nDragOverlay\nbeing used.\nSortableItem.jsx\nThe default transition is\n250\nmilliseconds, with an easing function set to\nease\n, but you can customize this and pass any valid\nCSS transition timing function\n, or set the transition argument to\nnull\nto disable transitions entirely:\nFor more details on the\nuseSortable\nhook, read the full\nAPI documentation\n.\nSensors\nSensors are an abstraction to manage and listen to different input methods. If you're unfamiliar with the concept of sensors, we recommend you read the\nintroduction to sensors\nfirst.\nBy default, the\nKeyboard\nsensor moves the active draggable item by\n25\npixels in the direction of the arrow key that was pressed. This is an arbitrary default, and can be customized using the\ncoordinateGetter\noption of the keyboard sensor.\nThe sortable preset ships with a custom coordinate getter function for the keyboard sensor that moves the active draggable to the closest sortable element in a given direction within the same\nDndContext\n.\nTo use it, import the\nsortableKeyboardCoordinates\ncoordinate getter function provided by\n@dnd-kit/sortable\n, and pass it to the\ncoordiniateGetter\noption of the Keyboard sensor.\nIn this example, we'll also be setting up the\nPointer\nsensor, which is the other sensor that is enabled by default on\nDndContext\nif none are defined. We use the\nuseSensor\nand\nuseSensors\nhooks to initialize the sensors:\nIf you'd like to use the\nMouse\nand\nTouch\nsensors instead of the\nPointer\nsensor, simply initialize those sensors instead:\nTo learn more about sensors, read the in-depth documentation on sensors:\nSensors\nSorting strategies\nThe supported use cases of the Sortable preset include vertical lists, horizontal lists, grids, and virtualized lists. Because of the wide variety of use cases supported, it would be difficult to write a single strategy to cover all of these different use cases. Instead, the sortable preset exposes a number of different strategies you can use, that are tailored to these various use cases:\nrectSortingStrategy\n: This is the default value, and is suitable for most use cases. This strategy does not support virtualized lists.\nverticalListSortingStrategy\n: This strategy is optimized for vertical lists, and supports virtualized lists.\nhorizontalListSortingStrategy\n: This strategy is optimized for horizontal lists, and supports virtualized lists.\nrectSwappingStrategy\n: Use this strategy to achieve swappable functionality.\nMake sure to use the sorting strategy that is the most adapted to the use case you are building for.\nCollision detection algorithm\nThe default collision detection algorithm of\nDndContext\nis the\nrectangle intersection\nalgorithm. While the rectangle intersection strategy is well suited for many use cases, it can be unforgiving, since it requires both the draggable and droppable bounding rectangles to come into direct contact and intersect.\nFor sortable lists, we recommend using a more forgiving collision detection strategy such as the\nclosest center\nor\nclosest corners\nalgorithms.\nIn this example, we'll be using the closest center algorithm:\nTo learn more about collision detection algorithms and when to use one over the other, read our guide on collision detection algorithms:\nCollision detection algorithms\nConnecting all the pieces\nFirst, let's go ahead and render all of our sortable items:\nApp.jsx\nSortableItem.jsx\nNext, let's wire up the custom sensors for\nDndContext\nand add a custom collision detection strategy:\nApp.jsx\nSortableItem.jsx\nIn this example, we'll be building a vertical sortable list, so we will be using the\nverticalListSortingStrategy\nsorting strategy:\nFinally, we'll need to set up event handlers on the\nDndContext\nprovider in order to update the order of the items on drag end.\nDrag Overlay\nFor most sortable lists, we recommend you use a\nDragOverlay\nif your sortable list is scrollable or if the contents of the scrollable list are taller than the viewport of the window.\nThe\n<DragOverlay>\ncomponent provides a way to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport. The drag overlay also implements drop animations.\nA\ncommon pitfall\nwhen using the\nDragOverlay\ncomponent is rendering the same component that calls\nuseSortable\ninside the\nDragOverlay\n. This will lead to unexpected results, since there will be an\nid\ncollision between the two components both calling\nuseDraggable\nwith the same\nid\n, since\nuseSortable\nis an abstraction on top of\nuseDraggable\n.\nInstead, create a presentational version of your component that you intend on rendering in the drag overlay, and another version that is sortable and renders the presentational component. There are two recommended patterns for this, either using\nwrapper nodes\nor\nref forwarding\n.\nIn this example, we'll use the\nref forwarding\npattern to avoid introducing wrapper nodes:\nApp.jsx\nSortableItem.jsx\nItem.jsx\nLast updated\n3 years ago",
  "content_markdown": "## Installation\n\nTo get started, install the sortable preset via `npm` or `yarn`:\n\nCopy\n\n```\nnpm install @dnd-kit/sortable\n```\n\n## Overview\n\nIf you're eager to get started right away, here's the code you'll need:\n\nApp.jsx\n\nSortableItem.jsx\n\nCopy\n\n```\nimport React, {useState} from 'react';\nimport {\n  DndContext, \n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\n\nimport {SortableItem} from './SortableItem';\n\nfunction App() {\n  const [items, setItems] = useState([1, 2, 3]);\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  return (\n    <DndContext \n      sensors={sensors}\n      collisionDetection={closestCenter}\n      onDragEnd={handleDragEnd}\n    >\n      <SortableContext \n        items={items}\n        strategy={verticalListSortingStrategy}\n      >\n        {items.map(id => <SortableItem key={id} id={id} />)}\n      </SortableContext>\n    </DndContext>\n  );\n  \n  function handleDragEnd(event) {\n    const {active, over} = event;\n    \n    if (active.id !== over.id) {\n      setItems((items) => {\n        const oldIndex = items.indexOf(active.id);\n        const newIndex = items.indexOf(over.id);\n        \n        return arrayMove(items, oldIndex, newIndex);\n      });\n    }\n  }\n}\n```\n\nFor most sortable lists, we recommend you use a [`DragOverlay`](/api-documentation/draggable/drag-overlay) if your sortable list is scrollable or if the contents of the scrollable list are taller than the viewport of the window. Check out the [sortable drag overlay guide](/presets/sortable#drag-overlay) below to learn more.\n\n## Architecture\n\nThe sortable preset builds on top of the primitives exposed by `@dnd-kit/core` to help building sortable interfaces.\n\nThe sortable preset exposes two main concepts: [`SortableContext`](/presets/sortable#sortable-context) and the [`useSortable`](/presets/sortable#usesortable) hook:\n\n- The `SortableContext` provides information via context that is consumed by the `useSortable` hook.\n- The `useSortable` hook is an abstraction that composes the [`useDroppable`](/api-documentation/droppable) and [`useDraggable`](/api-documentation/draggable) hooks:\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MPAGLQu4q5MwkPGcMwL%252F-MPAJ4EP6hgc_WyBRvU2%252FuseSortable%2520%281%29.png%3Falt%3Dmedia%26token%3D5258bd82-7443-4c7d-8b27-7d092d04ab03&width=768&dpr=3&quality=100&sign=8781210d&sv=2)\n\n### Single container\n\nAt a high level, the application structure to implement a **sortable list with a single container** looks as follows:\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MP7kCLhAw6rXlUxFILQ%252F-MPA8JRM90_d98a9Tvzz%252FSortable%2520%281%29.png%3Falt%3Dmedia%26token%3Dfc6b976d-f97e-4a07-90c5-dee05d3e1498&width=768&dpr=3&quality=100&sign=9fb5e799&sv=2)\n\n### Multiple containers\n\nTo implement sortable list with items that can be dropped within **multiple containers**, the application structure is the same, but we add as many `SortableContext` providers as we have containers:\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MPF80W-heGKUftClbx3%252F-MPF9JDgemy4mwpbni_V%252FSortable%2520Multiple%2520Containers%2520Example.png%3Falt%3Dmedia%26token%3D72170d65-d588-4d93-8da8-26252873c285&width=768&dpr=3&quality=100&sign=77dcea88&sv=2)\n\nIn this example, we would use the `onDragOver` callback of `DndContext` to detect when a draggable element is moved over a different container to insert it in that new container while dragging.\n\nIf you paid close attention to the illustration above, you may also have noticed that we added a droppable zone around each sortable context. This isn't required, but will likely be the behaviour most people want. If you move all sortable items from one column into the other, you will need a droppable zone for the empty column so that you may drag sortable items back into that empty column:\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MPF80W-heGKUftClbx3%252F-MPF9MpK_A0AGiZaGSl7%252FSortable%2520Multiple%2520Containers%2520Empty%2520Column%2520%281%29.png%3Falt%3Dmedia%26token%3D51cd76c1-1c07-49dd-bc80-69128e8b6cbf&width=768&dpr=3&quality=100&sign=43114e8c&sv=2)\n\n## Concepts\n\n### Sortable Context\n\nIn addition to the [`DndContext` provider](/introduction/getting-started#context-provider), the Sortable preset requires its own context provider that contains the **sorted** array of the unique identifiers associated to each sortable item:\n\nThe `SortableContext` provides information via context that is consumed by the `useSortable` hook, which is covered in greater detail in the next section.\n\nIt's important that the `items` prop passed to `SortableContext` be sorted in the same order in which the items are rendered, otherwise you may see unexpected results.\n\nIt does not expose any callback props. To know when a sortable (draggable) item is being picked or moved over another sortable (droppable) item, use the callback props of `DndContext`:\n\nIn order for the `SortableContext` component to function properly, make sure it is a descendant of a `DndContext` provider. You may nest multiple `SortableContext` components within the same parent `DndContext`.\n\n### useSortable\n\nAs outlined above, the `useSortable` hook combines both the [`useDraggable`](/api-documentation/draggable) and [`useDroppable`](/api-documentation/droppable) hooks to connect elements as both draggable sources and drop targets:\n\n![](https://docs.dndkit.com/~gitbook/image?url=https%3A%2F%2F3633755066-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MMujhzqaYbBEEmDxnZO%252F-MPAGLQu4q5MwkPGcMwL%252F-MPALbceK3ZbRNIUEqaN%252FuseSortable%2520%283%29.png%3Falt%3Dmedia%26token%3D85c7c4f9-8f7d-4a28-b9dd-69c50c253d95&width=768&dpr=3&quality=100&sign=76d3d454&sv=2)\n\nIn most cases, the draggable and droppable hooks will be attached to the same node, and therefore be identical in size. They are represented as different nodes for illustration purposes above.\n\nIf you're already familiar with the [`useDraggable`](/api-documentation/draggable) hook, the [`useSortable`](/presets/sortable/usesortable) hook should look very familiar, since, it is an abstraction on top of it.\n\nIn addition to the `attributes`, `listeners`,`transform` and `setNodeRef` properties, which you should already be familiar with if you've used the `useDraggable` hook before, you'll notice that the `useSortable` hook also provides a `transition` property.\n\nThe `transform` property for `useSortable` represents the displacement and change of scale transformation that a sortable item needs to apply to transition to its new position without needing to update the DOM order.\n\nThe `transform` property for the `useSortable` hook behaves similarly to the [`transform`](/api-documentation/draggable#transforms) property of the [`useDraggable`](/api-documentation/draggable) hook for the active sortable item, when there is no [`DragOverlay`](/api-documentation/draggable/drag-overlay) being used.\n\nSortableItem.jsx\n\nThe default transition is `250` milliseconds, with an easing function set to `ease`, but you can customize this and pass any valid [CSS transition timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function), or set the transition argument to `null` to disable transitions entirely:\n\nFor more details on the `useSortable` hook, read the full [API documentation](/presets/sortable/usesortable).\n\n### Sensors\n\nSensors are an abstraction to manage and listen to different input methods. If you're unfamiliar with the concept of sensors, we recommend you read the [introduction to sensors](/api-documentation/sensors) first.\n\nBy default, the [Keyboard](/api-documentation/sensors/keyboard) sensor moves the active draggable item by `25` pixels in the direction of the arrow key that was pressed. This is an arbitrary default, and can be customized using the `coordinateGetter` option of the keyboard sensor.\n\nThe sortable preset ships with a custom coordinate getter function for the keyboard sensor that moves the active draggable to the closest sortable element in a given direction within the same `DndContext`.\n\nTo use it, import the `sortableKeyboardCoordinates` coordinate getter function provided by `@dnd-kit/sortable`, and pass it to the `coordiniateGetter` option of the Keyboard sensor.\n\nIn this example, we'll also be setting up the [Pointer](/api-documentation/sensors/pointer) sensor, which is the other sensor that is enabled by default on `DndContext` if none are defined. We use the `useSensor` and `useSensors` hooks to initialize the sensors:\n\nIf you'd like to use the [Mouse](/api-documentation/sensors/mouse) and [Touch](/api-documentation/sensors/touch) sensors instead of the [Pointer](/api-documentation/sensors/pointer) sensor, simply initialize those sensors instead:\n\nTo learn more about sensors, read the in-depth documentation on sensors:\n\n[Sensors](/api-documentation/sensors)\n\n### Sorting strategies\n\nThe supported use cases of the Sortable preset include vertical lists, horizontal lists, grids, and virtualized lists. Because of the wide variety of use cases supported, it would be difficult to write a single strategy to cover all of these different use cases. Instead, the sortable preset exposes a number of different strategies you can use, that are tailored to these various use cases:\n\n- `rectSortingStrategy`: This is the default value, and is suitable for most use cases. This strategy does not support virtualized lists.\n- `verticalListSortingStrategy`: This strategy is optimized for vertical lists, and supports virtualized lists.\n- `horizontalListSortingStrategy`: This strategy is optimized for horizontal lists, and supports virtualized lists.\n- `rectSwappingStrategy`: Use this strategy to achieve swappable functionality.\n\nMake sure to use the sorting strategy that is the most adapted to the use case you are building for.\n\n### Collision detection algorithm\n\nThe default collision detection algorithm of `DndContext` is the [rectangle intersection](/api-documentation/context-provider/collision-detection-algorithms#rectangle-intersection) algorithm. While the rectangle intersection strategy is well suited for many use cases, it can be unforgiving, since it requires both the draggable and droppable bounding rectangles to come into direct contact and intersect.\n\nFor sortable lists, we recommend using a more forgiving collision detection strategy such as the [closest center](/api-documentation/context-provider/collision-detection-algorithms#closest-center) or [closest corners](/api-documentation/context-provider/collision-detection-algorithms#closest-corners) algorithms.\n\nIn this example, we'll be using the closest center algorithm:\n\nTo learn more about collision detection algorithms and when to use one over the other, read our guide on collision detection algorithms:\n\n[Collision detection algorithms](/api-documentation/context-provider/collision-detection-algorithms)\n\n## Connecting all the pieces\n\nFirst, let's go ahead and render all of our sortable items:\n\nApp.jsx\n\nSortableItem.jsx\n\nNext, let's wire up the custom sensors for `DndContext` and add a custom collision detection strategy:\n\nApp.jsx\n\nSortableItem.jsx\n\nIn this example, we'll be building a vertical sortable list, so we will be using the `verticalListSortingStrategy` sorting strategy:\n\nFinally, we'll need to set up event handlers on the `DndContext` provider in order to update the order of the items on drag end.\n\n### Drag Overlay\n\nFor most sortable lists, we recommend you use a [`DragOverlay`](/api-documentation/draggable/drag-overlay) if your sortable list is scrollable or if the contents of the scrollable list are taller than the viewport of the window.\n\nThe `<DragOverlay>` component provides a way to render a draggable overlay that is removed from the normal document flow and is positioned relative to the viewport. The drag overlay also implements drop animations.\n\nA **common pitfall** when using the `DragOverlay` component is rendering the same component that calls `useSortable` inside the `DragOverlay`. This will lead to unexpected results, since there will be an `id` collision between the two components both calling `useDraggable` with the same `id`, since `useSortable` is an abstraction on top of `useDraggable`.\n\nInstead, create a presentational version of your component that you intend on rendering in the drag overlay, and another version that is sortable and renders the presentational component. There are two recommended patterns for this, either using [wrapper nodes](/api-documentation/draggable/drag-overlay#wrapper-nodes) or [ref forwarding](/api-documentation/draggable/drag-overlay#ref-forwarding).\n\nIn this example, we'll use the [ref forwarding](/api-documentation/draggable/drag-overlay#ref-forwarding) pattern to avoid introducing wrapper nodes:\n\nApp.jsx\n\nSortableItem.jsx\n\nItem.jsx\n\nLast updated 3 years ago",
  "tags": [
    "dnd-kit",
    "drag-drop",
    "sortable",
    "accessibility"
  ],
  "extracted_at": "2026-02-03T12:54:23.358809+00:00",
  "content_length": 9928,
  "content_hash": "25a673b2d6e56b6f"
}