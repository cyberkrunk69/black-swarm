{
  "id": "formik__docs_tutorial",
  "source_id": "formik",
  "source_name": "Formik",
  "category": "forms_patterns",
  "url": "https://formik.org/docs/tutorial",
  "title": "Tutorial",
  "content": "Tutorial\nBefore we start\nWelcome to the Formik tutorial. This will teach you everything you need to know to build simple and complex forms in React.\nIf you\u2019re impatient and just want to start hacking on your machine locally, check out\nthe 60-second quickstart\n.\nWhat are we building?\nIn this tutorial, we\u2019ll build a complex newsletter signup form with React and Formik.\nYou can see what we\u2019ll be building here:\nFinal Result\n. If the code doesn\u2019t make sense to you, don\u2019t worry! The goal of this tutorial is to help you understand Formik.\nPrerequisites\nYou\u2019ll need to have familiarity with HTML, CSS,\nmodern JavaScript\n, and\nReact\n(and\nReact Hooks\n) to fully understand Formik and how it works. In this tutorial, we\u2019re using\narrow functions\n,\nlet\n,\nconst\n,\nspread syntax\n,\ndestructuring\n,\ncomputed property names\n, and\nasync/await\n. You can use the\nBabel REPL\nto check what ES6 code compiles to.\nSetup for the Tutorial\nThere are two ways to complete this tutorial: you can either write the code in your browser, or you can set up a local development environment on your computer.\nSetup Option 1: Write Code in the Browser\nThis is the quickest way to get started!\nFirst, open this\nStarter Code\nin a new tab. The new tab should display an email address input, a submit button, and some React code. We\u2019ll be editing the React code in this tutorial.\nSkip the second setup option, and go to the\nOverview\nsection to get an overview of Formik.\nSetup Option 2: Local Development Environment\nThis is completely optional and not required for this tutorial!\nOptional: Instructions for following along locally using your preferred text editor\nThis setup requires more work, but allows you to complete the tutorial using an editor of your choice. Here are the steps to follow:\nMake sure you have a recent version of\nNode.js\ninstalled.\nFollow the\ninstallation instructions for Create React App\nto make a new project.\nCopy\nnpx create-react-app my-app\nInstall Formik\nCopy\nnpm\ni formik\nOr\nCopy\nyarn\nadd\nformik\nDelete all files in the\nsrc/\nfolder of the new project\nNote:\nDon\u2019t delete the entire\nsrc\nfolder, just the original source files inside it.\nWe\u2019ll replace the default source files with examples for this project in the next step.\nCopy\n1\ncd\nmy-app\n2\ncd\nsrc\n3\n4\n# If you\u2019re using a Mac or Linux:\n5\nrm\n-f *\n6\n7\n# Or, if you\u2019re on Windows:\n8\ndel *\n9\n10\n# Then, switch back to the project folder\n11\ncd\n..\nAdd a file named\nstyles.css\nin the\nsrc/\nfolder with\nthis CSS code\n.\nAdd a file named\nindex.js\nin the\nsrc/\nfolder with\nthis JS code\n.\nNow run\nnpm start\nin the project folder and open\nhttp://localhost:3000\nin the browser. You should see an email input and a submit button.\nWe recommend following\nthese instructions\nto configure syntax highlighting for your editor.\nHelp, I\u2019m Stuck!\nIf you get stuck, check out Formik\u2019s\nGitHub Discussions\n. In addition, the\nFormium Community Discord Server\nis a great way to get help quickly too. If you don\u2019t receive an answer, or if you remain stuck, please file an issue, and we\u2019ll help you out.\nOverview: What is Formik?\nFormik is a small group of React components and hooks for building forms in React and React Native. It helps with the three most annoying parts:\nGetting values in and out of form state\nValidation and error messages\nHandling form submission\nBy colocating all of the above in one place, Formik keeps things\norganized--making testing, refactoring, and reasoning about your forms a breeze.\nThe Basics\nWe\u2019re going to start with the\nmost verbose\nway of using Formik. While this may seem a bit long-winded, it\u2019s important to see how Formik builds on itself so you have a full grasp of what\u2019s possible and a complete mental model of how it works.\nA simple newsletter signup form\nImagine we want to add a newsletter signup form for a blog. To start, our form will have just one field named\nemail\n. With Formik, this is just a few lines of code.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\nconst\nSignupForm\n=\n(\n)\n=>\n{\n5\n// Pass the useFormik() hook initial form values and a submit function that will\n6\n// be called when the form is submitted\n7\nconst\nformik\n=\nuseFormik\n(\n{\n8\ninitialValues\n:\n{\n9\nemail\n:\n''\n,\n10\n}\n,\n11\nonSubmit\n:\nvalues\n=>\n{\n12\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n13\n}\n,\n14\n}\n)\n;\n15\nreturn\n(\n16\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n17\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n18\n<\ninput\n19\nid\n=\n\"\nemail\n\"\n20\nname\n=\n\"\nemail\n\"\n21\ntype\n=\n\"\nemail\n\"\n22\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n23\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n24\n/>\n25\n26\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n27\n</\nform\n>\n28\n)\n;\n29\n}\n;\nWe pass our form\u2019s\ninitialValues\nand a submission function (\nonSubmit\n) to the\nuseFormik()\nhook. The hook then returns to us a goodie bag of form state and helper methods in a variable we call\nformik\n. For now, the only helper methods we care about are as follows:\nhandleSubmit\n: A submission handler\nhandleChange\n: A change handler to pass to each\n<input>\n,\n<select>\n, or\n<textarea>\nvalues\n: Our form\u2019s current values\nAs you can see above, we pass each of these to their respective props...and that\u2019s it! We can now have a working form powered by Formik. Instead of managing our form\u2019s values on our own and writing our own custom event handlers for every single input, we can just use\nuseFormik()\n.\nThis is pretty neat, but with just one single input, the benefits of using\nuseFormik()\nare unclear. So let\u2019s add two more inputs: one for the user\u2019s first and last name, which we\u2019ll store as\nfirstName\nand\nlastName\nin the form.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\nconst\nSignupForm\n=\n(\n)\n=>\n{\n5\n// Note that we have to initialize ALL of fields with values. These\n6\n// could come from props, but since we don\u2019t want to prefill this form,\n7\n// we just use an empty string. If we don\u2019t do this, React will yell\n8\n// at us.\n9\nconst\nformik\n=\nuseFormik\n(\n{\n10\ninitialValues\n:\n{\n11\nfirstName\n:\n''\n,\n12\nlastName\n:\n''\n,\n13\nemail\n:\n''\n,\n14\n}\n,\n15\nonSubmit\n:\nvalues\n=>\n{\n16\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n17\n}\n,\n18\n}\n)\n;\n19\nreturn\n(\n20\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n21\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n22\n<\ninput\n23\nid\n=\n\"\nfirstName\n\"\n24\nname\n=\n\"\nfirstName\n\"\n25\ntype\n=\n\"\ntext\n\"\n26\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n27\nvalue\n=\n{\nformik\n.\nvalues\n.\nfirstName\n}\n28\n/>\n29\n30\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n31\n<\ninput\n32\nid\n=\n\"\nlastName\n\"\n33\nname\n=\n\"\nlastName\n\"\n34\ntype\n=\n\"\ntext\n\"\n35\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n36\nvalue\n=\n{\nformik\n.\nvalues\n.\nlastName\n}\n37\n/>\n38\n39\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n40\n<\ninput\n41\nid\n=\n\"\nemail\n\"\n42\nname\n=\n\"\nemail\n\"\n43\ntype\n=\n\"\nemail\n\"\n44\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n45\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n46\n/>\n47\n48\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n49\n</\nform\n>\n50\n)\n;\n51\n}\n;\nIf you look carefully at our new code, you\u2019ll notice some patterns and symmetry\nforming\n.\nWe reuse the same exact change handler function\nhandleChange\nfor each HTML input\nWe pass an\nid\nand\nname\nHTML attribute that\nmatches\nthe property we defined in\ninitialValues\nWe access the field\u2019s value using the same name (\nemail\n->\nformik.values.email\n)\nIf you\u2019re familiar with building forms with plain React, you can think of Formik\u2019s\nhandleChange\nas working like this:\nCopy\n1\nconst\n[\nvalues\n,\nsetValues\n]\n=\nReact\n.\nuseState\n(\n{\n}\n)\n;\n2\n3\nconst\nhandleChange\n=\nevent\n=>\n{\n4\nsetValues\n(\nprevValues\n=>\n(\n{\n5\n...\nprevValues\n,\n6\n// we use the name to tell Formik which key of `values` to update\n7\n[\nevent\n.\ntarget\n.\nname\n]\n:\nevent\n.\ntarget\n.\nvalue\n8\n}\n)\n;\n9\n}\nValidation\nWhile our contact form works, it\u2019s not quite feature-complete; users can submit it, but it doesn\u2019t tell them which (if any) fields are required.\nIf we\u2019re okay with using the browser\u2019s built-in HTML input validation, we could add a\nrequired\nprop to each of our inputs, specify minimum/maximum lengths (\nmaxlength\nand\nminlength\n), and/or add a\npattern\nprop for regex validation for each of these inputs. These are great if we can get away with them. However, HTML validation has its limitations. First, it only works in the browser! So this clearly is not viable for React Native. Second, it\u2019s hard/impossible to show custom error messages to our user. Third, it\u2019s very janky.\nAs mentioned earlier, Formik keeps track of not only your form\u2019s\nvalues\n, but also its validation and error messages. To add validation with JS, let\u2019s specify a custom validation function and pass it as\nvalidate\nto the\nuseFormik()\nhook. If an error exists, this custom validation function should produce an\nerror\nobject with a matching shape to our\nvalues\n/\ninitialValues\n. Again...\nsymmetry\n...yes...\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\n// A custom validation function. This must return an object\n5\n// which keys are symmetrical to our values/initialValues\n6\nconst\nvalidate\n=\nvalues\n=>\n{\n7\nconst\nerrors\n=\n{\n}\n;\n8\nif\n(\n!\nvalues\n.\nfirstName\n)\n{\n9\nerrors\n.\nfirstName\n=\n'Required'\n;\n10\n}\nelse\nif\n(\nvalues\n.\nfirstName\n.\nlength\n>\n15\n)\n{\n11\nerrors\n.\nfirstName\n=\n'Must be 15 characters or less'\n;\n12\n}\n13\n14\nif\n(\n!\nvalues\n.\nlastName\n)\n{\n15\nerrors\n.\nlastName\n=\n'Required'\n;\n16\n}\nelse\nif\n(\nvalues\n.\nlastName\n.\nlength\n>\n20\n)\n{\n17\nerrors\n.\nlastName\n=\n'Must be 20 characters or less'\n;\n18\n}\n19\n20\nif\n(\n!\nvalues\n.\nemail\n)\n{\n21\nerrors\n.\nemail\n=\n'Required'\n;\n22\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalues\n.\nemail\n)\n)\n{\n23\nerrors\n.\nemail\n=\n'Invalid email address'\n;\n24\n}\n25\n26\nreturn\nerrors\n;\n27\n}\n;\n28\n29\nconst\nSignupForm\n=\n(\n)\n=>\n{\n30\n// Pass the useFormik() hook initial form values, a validate function that will be called when\n31\n// form values change or fields are blurred, and a submit function that will\n32\n// be called when the form is submitted\n33\nconst\nformik\n=\nuseFormik\n(\n{\n34\ninitialValues\n:\n{\n35\nfirstName\n:\n''\n,\n36\nlastName\n:\n''\n,\n37\nemail\n:\n''\n,\n38\n}\n,\n39\nvalidate\n,\n40\nonSubmit\n:\nvalues\n=>\n{\n41\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n42\n}\n,\n43\n}\n)\n;\n44\nreturn\n(\n45\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n46\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n47\n<\ninput\n48\nid\n=\n\"\nfirstName\n\"\n49\nname\n=\n\"\nfirstName\n\"\n50\ntype\n=\n\"\ntext\n\"\n51\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n52\nvalue\n=\n{\nformik\n.\nvalues\n.\nfirstName\n}\n53\n/>\n54\n{\nformik\n.\nerrors\n.\nfirstName\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n:\nnull\n}\n55\n56\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n57\n<\ninput\n58\nid\n=\n\"\nlastName\n\"\n59\nname\n=\n\"\nlastName\n\"\n60\ntype\n=\n\"\ntext\n\"\n61\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n62\nvalue\n=\n{\nformik\n.\nvalues\n.\nlastName\n}\n63\n/>\n64\n{\nformik\n.\nerrors\n.\nlastName\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n:\nnull\n}\n65\n66\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n67\n<\ninput\n68\nid\n=\n\"\nemail\n\"\n69\nname\n=\n\"\nemail\n\"\n70\ntype\n=\n\"\nemail\n\"\n71\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n72\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n73\n/>\n74\n{\nformik\n.\nerrors\n.\nemail\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n:\nnull\n}\n75\n76\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n77\n</\nform\n>\n78\n)\n;\n79\n}\n;\nformik.errors\nis populated via the custom validation function. By default, Formik will validate after each keystroke (change event), each input\u2019s\nblur event\n, as well as prior to submission. The\nonSubmit\nfunction we passed to\nuseFormik()\nwill be executed only if there are no errors (i.e. if our\nvalidate\nfunction returns\n{}\n).\nVisited fields\nWhile our form works, and our users see each error, it\u2019s not a great user experience for them. Since our validation function runs on each keystroke against the\nentire\nform\u2019s\nvalues\n, our\nerrors\nobject contains\nall\nvalidation errors at any given moment. In our component, we\u2019re just checking if an error exists and then immediately showing it to the user. This is awkward since we\u2019re going to show error messages for fields that the user hasn\u2019t even visited yet. Most of the time, we only want to show a field\u2019s error message\nafter\nour user is done typing in that field.\nLike\nerrors\nand\nvalues\n, Formik keeps track of which fields have been visited. It stores this information in an object called\ntouched\nthat also mirrors the shape of\nvalues\n/\ninitialValues\n. The keys of\ntouched\nare the field names, and the values of\ntouched\nare booleans\ntrue\n/\nfalse\n.\nTo take advantage of\ntouched\n, we pass\nformik.handleBlur\nto each input\u2019s\nonBlur\nprop. This function works similarly to\nformik.handleChange\nin that it uses the\nname\nattribute to figure out which field to update.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\nconst\nvalidate\n=\nvalues\n=>\n{\n5\nconst\nerrors\n=\n{\n}\n;\n6\n7\nif\n(\n!\nvalues\n.\nfirstName\n)\n{\n8\nerrors\n.\nfirstName\n=\n'Required'\n;\n9\n}\nelse\nif\n(\nvalues\n.\nfirstName\n.\nlength\n>\n15\n)\n{\n10\nerrors\n.\nfirstName\n=\n'Must be 15 characters or less'\n;\n11\n}\n12\n13\nif\n(\n!\nvalues\n.\nlastName\n)\n{\n14\nerrors\n.\nlastName\n=\n'Required'\n;\n15\n}\nelse\nif\n(\nvalues\n.\nlastName\n.\nlength\n>\n20\n)\n{\n16\nerrors\n.\nlastName\n=\n'Must be 20 characters or less'\n;\n17\n}\n18\n19\nif\n(\n!\nvalues\n.\nemail\n)\n{\n20\nerrors\n.\nemail\n=\n'Required'\n;\n21\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalues\n.\nemail\n)\n)\n{\n22\nerrors\n.\nemail\n=\n'Invalid email address'\n;\n23\n}\n24\n25\nreturn\nerrors\n;\n26\n}\n;\n27\n28\nconst\nSignupForm\n=\n(\n)\n=>\n{\n29\nconst\nformik\n=\nuseFormik\n(\n{\n30\ninitialValues\n:\n{\n31\nfirstName\n:\n''\n,\n32\nlastName\n:\n''\n,\n33\nemail\n:\n''\n,\n34\n}\n,\n35\nvalidate\n,\n36\nonSubmit\n:\nvalues\n=>\n{\n37\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n38\n}\n,\n39\n}\n)\n;\n40\nreturn\n(\n41\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n42\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n43\n<\ninput\n44\nid\n=\n\"\nfirstName\n\"\n45\nname\n=\n\"\nfirstName\n\"\n46\ntype\n=\n\"\ntext\n\"\n47\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n48\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n49\nvalue\n=\n{\nformik\n.\nvalues\n.\nfirstName\n}\n50\n/>\n51\n{\nformik\n.\nerrors\n.\nfirstName\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n:\nnull\n}\n52\n53\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n54\n<\ninput\n55\nid\n=\n\"\nlastName\n\"\n56\nname\n=\n\"\nlastName\n\"\n57\ntype\n=\n\"\ntext\n\"\n58\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n59\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n60\nvalue\n=\n{\nformik\n.\nvalues\n.\nlastName\n}\n61\n/>\n62\n{\nformik\n.\nerrors\n.\nlastName\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n:\nnull\n}\n63\n64\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n65\n<\ninput\n66\nid\n=\n\"\nemail\n\"\n67\nname\n=\n\"\nemail\n\"\n68\ntype\n=\n\"\nemail\n\"\n69\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n70\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n71\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n72\n/>\n73\n{\nformik\n.\nerrors\n.\nemail\n?\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n:\nnull\n}\n74\n75\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n76\n</\nform\n>\n77\n)\n;\n78\n}\n;\nAlmost there! Now that we\u2019re tracking\ntouched\n, we can now change our error message render logic to\nonly\nshow a given field\u2019s error message if it exists\nand\nif our user has visited that field.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\nconst\nvalidate\n=\nvalues\n=>\n{\n5\nconst\nerrors\n=\n{\n}\n;\n6\n7\nif\n(\n!\nvalues\n.\nfirstName\n)\n{\n8\nerrors\n.\nfirstName\n=\n'Required'\n;\n9\n}\nelse\nif\n(\nvalues\n.\nfirstName\n.\nlength\n>\n15\n)\n{\n10\nerrors\n.\nfirstName\n=\n'Must be 15 characters or less'\n;\n11\n}\n12\n13\nif\n(\n!\nvalues\n.\nlastName\n)\n{\n14\nerrors\n.\nlastName\n=\n'Required'\n;\n15\n}\nelse\nif\n(\nvalues\n.\nlastName\n.\nlength\n>\n20\n)\n{\n16\nerrors\n.\nlastName\n=\n'Must be 20 characters or less'\n;\n17\n}\n18\n19\nif\n(\n!\nvalues\n.\nemail\n)\n{\n20\nerrors\n.\nemail\n=\n'Required'\n;\n21\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalues\n.\nemail\n)\n)\n{\n22\nerrors\n.\nemail\n=\n'Invalid email address'\n;\n23\n}\n24\n25\nreturn\nerrors\n;\n26\n}\n;\n27\n28\nconst\nSignupForm\n=\n(\n)\n=>\n{\n29\nconst\nformik\n=\nuseFormik\n(\n{\n30\ninitialValues\n:\n{\n31\nfirstName\n:\n''\n,\n32\nlastName\n:\n''\n,\n33\nemail\n:\n''\n,\n34\n}\n,\n35\nvalidate\n,\n36\nonSubmit\n:\nvalues\n=>\n{\n37\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n38\n}\n,\n39\n}\n)\n;\n40\nreturn\n(\n41\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n42\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n43\n<\ninput\n44\nid\n=\n\"\nfirstName\n\"\n45\nname\n=\n\"\nfirstName\n\"\n46\ntype\n=\n\"\ntext\n\"\n47\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n48\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n49\nvalue\n=\n{\nformik\n.\nvalues\n.\nfirstName\n}\n50\n/>\n51\n{\nformik\n.\ntouched\n.\nfirstName\n&&\nformik\n.\nerrors\n.\nfirstName\n?\n(\n52\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n53\n)\n:\nnull\n}\n54\n55\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n56\n<\ninput\n57\nid\n=\n\"\nlastName\n\"\n58\nname\n=\n\"\nlastName\n\"\n59\ntype\n=\n\"\ntext\n\"\n60\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n61\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n62\nvalue\n=\n{\nformik\n.\nvalues\n.\nlastName\n}\n63\n/>\n64\n{\nformik\n.\ntouched\n.\nlastName\n&&\nformik\n.\nerrors\n.\nlastName\n?\n(\n65\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n66\n)\n:\nnull\n}\n67\n68\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n69\n<\ninput\n70\nid\n=\n\"\nemail\n\"\n71\nname\n=\n\"\nemail\n\"\n72\ntype\n=\n\"\nemail\n\"\n73\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n74\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n75\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n76\n/>\n77\n{\nformik\n.\ntouched\n.\nemail\n&&\nformik\n.\nerrors\n.\nemail\n?\n(\n78\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n79\n)\n:\nnull\n}\n80\n81\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n82\n</\nform\n>\n83\n)\n;\n84\n}\n;\nSchema Validation with Yup\nAs you can see above, validation is left up to you. Feel free to write your own validators or use a 3rd-party helper library. Formik\u2019s authors/a large portion of its users use\nJason Quense\n\u2019s library\nYup\nfor object schema validation. Yup has an API that\u2019s similar to\nJoi\nand\nReact PropTypes\n, but is also small enough for the browser and fast enough for runtime usage. You can try it out here with this\nREPL\n.\nSince Formik authors/users\nlove\nYup so much, Formik has a special configuration prop for Yup called\nvalidationSchema\nwhich will automatically transform Yup\u2019s validation errors messages into a pretty object whose keys match\nvalues\n/\ninitialValues\n/\ntouched\n(just like any custom validation function would have to). Anyways, you can install Yup from NPM/yarn like so...\nCopy\n1\nnpm\ninstall\nyup --save\n2\n3\n# or via yarn\n4\n5\nyarn\nadd\nyup\nTo see how Yup works, let\u2019s get rid of our custom validation function\nvalidate\nand re-write our validation with Yup and\nvalidationSchema\n:\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nSignupForm\n=\n(\n)\n=>\n{\n6\nconst\nformik\n=\nuseFormik\n(\n{\n7\ninitialValues\n:\n{\n8\nfirstName\n:\n''\n,\n9\nlastName\n:\n''\n,\n10\nemail\n:\n''\n,\n11\n}\n,\n12\nvalidationSchema\n:\nYup\n.\nobject\n(\n{\n13\nfirstName\n:\nYup\n.\nstring\n(\n)\n14\n.\nmax\n(\n15\n,\n'Must be 15 characters or less'\n)\n15\n.\nrequired\n(\n'Required'\n)\n,\n16\nlastName\n:\nYup\n.\nstring\n(\n)\n17\n.\nmax\n(\n20\n,\n'Must be 20 characters or less'\n)\n18\n.\nrequired\n(\n'Required'\n)\n,\n19\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email address'\n)\n.\nrequired\n(\n'Required'\n)\n,\n20\n}\n)\n,\n21\nonSubmit\n:\nvalues\n=>\n{\n22\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n23\n}\n,\n24\n}\n)\n;\n25\nreturn\n(\n26\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n27\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n28\n<\ninput\n29\nid\n=\n\"\nfirstName\n\"\n30\nname\n=\n\"\nfirstName\n\"\n31\ntype\n=\n\"\ntext\n\"\n32\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n33\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n34\nvalue\n=\n{\nformik\n.\nvalues\n.\nfirstName\n}\n35\n/>\n36\n{\nformik\n.\ntouched\n.\nfirstName\n&&\nformik\n.\nerrors\n.\nfirstName\n?\n(\n37\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n38\n)\n:\nnull\n}\n39\n40\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n41\n<\ninput\n42\nid\n=\n\"\nlastName\n\"\n43\nname\n=\n\"\nlastName\n\"\n44\ntype\n=\n\"\ntext\n\"\n45\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n46\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n47\nvalue\n=\n{\nformik\n.\nvalues\n.\nlastName\n}\n48\n/>\n49\n{\nformik\n.\ntouched\n.\nlastName\n&&\nformik\n.\nerrors\n.\nlastName\n?\n(\n50\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n51\n)\n:\nnull\n}\n52\n53\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n54\n<\ninput\n55\nid\n=\n\"\nemail\n\"\n56\nname\n=\n\"\nemail\n\"\n57\ntype\n=\n\"\nemail\n\"\n58\nonChange\n=\n{\nformik\n.\nhandleChange\n}\n59\nonBlur\n=\n{\nformik\n.\nhandleBlur\n}\n60\nvalue\n=\n{\nformik\n.\nvalues\n.\nemail\n}\n61\n/>\n62\n{\nformik\n.\ntouched\n.\nemail\n&&\nformik\n.\nerrors\n.\nemail\n?\n(\n63\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n64\n)\n:\nnull\n}\n65\n66\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n67\n</\nform\n>\n68\n)\n;\n69\n}\n;\nAgain, Yup is 100% optional. However, we suggest giving it a try. As you can see above, we expressed the exact same validation function with just 10 lines of code instead of 30. One of Formik\u2019s core design principles is to help you stay organized. Yup definitely helps a lot with this--schemas are extremely expressive, intuitive (since they mirror your values), and reusable. Whether or not you use Yup, we highly recommended you share commonly used validation methods across your application. This will ensure that common fields (e.g. email, street addresses, usernames, phone numbers, etc.) are validated consistently and result in a better user experience.\nReducing Boilerplate\ngetFieldProps()\nThe code above is very explicit about exactly what Formik is doing.\nonChange\n->\nhandleChange\n,\nonBlur\n->\nhandleBlur\n, and so on. However, to save you time,\nuseFormik()\nreturns a helper method called\nformik.getFieldProps()\nto make it faster to wire up inputs. Given some field-level info, it returns to you the exact group of\nonChange\n,\nonBlur\n,\nvalue\n,\nchecked\nfor a given field. You can then spread that on an\ninput\n,\nselect\n, or\ntextarea\n.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nSignupForm\n=\n(\n)\n=>\n{\n6\nconst\nformik\n=\nuseFormik\n(\n{\n7\ninitialValues\n:\n{\n8\nfirstName\n:\n''\n,\n9\nlastName\n:\n''\n,\n10\nemail\n:\n''\n,\n11\n}\n,\n12\nvalidationSchema\n:\nYup\n.\nobject\n(\n{\n13\nfirstName\n:\nYup\n.\nstring\n(\n)\n14\n.\nmax\n(\n15\n,\n'Must be 15 characters or less'\n)\n15\n.\nrequired\n(\n'Required'\n)\n,\n16\nlastName\n:\nYup\n.\nstring\n(\n)\n17\n.\nmax\n(\n20\n,\n'Must be 20 characters or less'\n)\n18\n.\nrequired\n(\n'Required'\n)\n,\n19\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email address'\n)\n.\nrequired\n(\n'Required'\n)\n,\n20\n}\n)\n,\n21\nonSubmit\n:\nvalues\n=>\n{\n22\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n23\n}\n,\n24\n}\n)\n;\n25\nreturn\n(\n26\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n27\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n28\n<\ninput\n29\nid\n=\n\"\nfirstName\n\"\n30\ntype\n=\n\"\ntext\n\"\n31\n{\n...\nformik\n.\ngetFieldProps\n(\n'firstName'\n)\n}\n32\n/>\n33\n{\nformik\n.\ntouched\n.\nfirstName\n&&\nformik\n.\nerrors\n.\nfirstName\n?\n(\n34\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n35\n)\n:\nnull\n}\n36\n37\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n38\n<\ninput\nid\n=\n\"\nlastName\n\"\ntype\n=\n\"\ntext\n\"\n{\n...\nformik\n.\ngetFieldProps\n(\n'lastName'\n)\n}\n/>\n39\n{\nformik\n.\ntouched\n.\nlastName\n&&\nformik\n.\nerrors\n.\nlastName\n?\n(\n40\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n41\n)\n:\nnull\n}\n42\n43\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n44\n<\ninput\nid\n=\n\"\nemail\n\"\ntype\n=\n\"\nemail\n\"\n{\n...\nformik\n.\ngetFieldProps\n(\n'email'\n)\n}\n/>\n45\n{\nformik\n.\ntouched\n.\nemail\n&&\nformik\n.\nerrors\n.\nemail\n?\n(\n46\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n47\n)\n:\nnull\n}\n48\n49\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n50\n</\nform\n>\n51\n)\n;\n52\n}\n;\nLeveraging React Context\nOur code above is again very explicit about exactly what Formik is doing.\nonChange\n->\nhandleChange\n,\nonBlur\n->\nhandleBlur\n, and so on. However, we still have to manually pass each input this \"prop getter\"\ngetFieldProps()\n. To save you even more time, Formik comes with\nReact Context\n-powered API/components to make life easier and code less verbose:\n<Formik />\n,\n<Form />\n,\n<Field />\n, and\n<ErrorMessage />\n. More explicitly, they use React Context implicitly to connect with the parent\n<Formik />\nstate/methods.\nSince these components use React Context, we need to render a\nReact Context Provider\nthat holds our form state and helpers in our tree. If you did this yourself, it would look like:\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nuseFormik\n}\nfrom\n'formik'\n;\n3\n4\n// Create empty context\n5\nconst\nFormikContext\n=\nReact\n.\ncreateContext\n(\n{\n}\n)\n;\n6\n7\n// Place all of what\u2019s returned by useFormik into context\n8\nexport\nconst\nFormik\n=\n(\n{\nchildren\n,\n...\nprops\n}\n)\n=>\n{\n9\nconst\nformikStateAndHelpers\n=\nuseFormik\n(\nprops\n)\n;\n10\nreturn\n(\n11\n<\nFormikContext.Provider\nvalue\n=\n{\nformikStateAndHelpers\n}\n>\n12\n{\ntypeof\nchildren\n===\n'function'\n13\n?\nchildren\n(\nformikStateAndHelpers\n)\n14\n:\nchildren\n}\n15\n</\nFormikContext.Provider\n>\n16\n)\n;\n17\n}\n;\nLuckily, we\u2019ve done this for you in a\n<Formik>\ncomponent that works just like this.\nLet\u2019s now swap out the\nuseFormik()\nhook for Formik\u2019s\n<Formik>\ncomponent/render-prop. Since it\u2019s a component, we\u2019ll convert the object passed to\nuseFormik()\nto JSX, with each key becoming a prop.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nSignupForm\n=\n(\n)\n=>\n{\n6\nreturn\n(\n7\n<\nFormik\n8\ninitialValues\n=\n{\n{\nfirstName\n:\n''\n,\nlastName\n:\n''\n,\nemail\n:\n''\n}\n}\n9\nvalidationSchema\n=\n{\nYup\n.\nobject\n(\n{\n10\nfirstName\n:\nYup\n.\nstring\n(\n)\n11\n.\nmax\n(\n15\n,\n'Must be 15 characters or less'\n)\n12\n.\nrequired\n(\n'Required'\n)\n,\n13\nlastName\n:\nYup\n.\nstring\n(\n)\n14\n.\nmax\n(\n20\n,\n'Must be 20 characters or less'\n)\n15\n.\nrequired\n(\n'Required'\n)\n,\n16\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email address'\n)\n.\nrequired\n(\n'Required'\n)\n,\n17\n}\n)\n}\n18\nonSubmit\n=\n{\n(\nvalues\n,\n{\nsetSubmitting\n}\n)\n=>\n{\n19\nsetTimeout\n(\n(\n)\n=>\n{\n20\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n21\nsetSubmitting\n(\nfalse\n)\n;\n22\n}\n,\n400\n)\n;\n23\n}\n}\n24\n>\n25\n{\nformik\n=>\n(\n26\n<\nform\nonSubmit\n=\n{\nformik\n.\nhandleSubmit\n}\n>\n27\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n28\n<\ninput\n29\nid\n=\n\"\nfirstName\n\"\n30\ntype\n=\n\"\ntext\n\"\n31\n{\n...\nformik\n.\ngetFieldProps\n(\n'firstName'\n)\n}\n32\n/>\n33\n{\nformik\n.\ntouched\n.\nfirstName\n&&\nformik\n.\nerrors\n.\nfirstName\n?\n(\n34\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n35\n)\n:\nnull\n}\n36\n37\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n38\n<\ninput\n39\nid\n=\n\"\nlastName\n\"\n40\ntype\n=\n\"\ntext\n\"\n41\n{\n...\nformik\n.\ngetFieldProps\n(\n'lastName'\n)\n}\n42\n/>\n43\n{\nformik\n.\ntouched\n.\nlastName\n&&\nformik\n.\nerrors\n.\nlastName\n?\n(\n44\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nlastName\n}\n</\ndiv\n>\n45\n)\n:\nnull\n}\n46\n47\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n48\n<\ninput\nid\n=\n\"\nemail\n\"\ntype\n=\n\"\nemail\n\"\n{\n...\nformik\n.\ngetFieldProps\n(\n'email'\n)\n}\n/>\n49\n{\nformik\n.\ntouched\n.\nemail\n&&\nformik\n.\nerrors\n.\nemail\n?\n(\n50\n<\ndiv\n>\n{\nformik\n.\nerrors\n.\nemail\n}\n</\ndiv\n>\n51\n)\n:\nnull\n}\n52\n53\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n54\n</\nform\n>\n55\n)\n}\n56\n</\nFormik\n>\n57\n)\n;\n58\n}\n;\nAs you can see above, we swapped out\nuseFormik()\nhook and replaced it with the\n<Formik>\ncomponent. The\n<Formik>\ncomponent accepts a function as its children (a.k.a. a\nrender prop\n). Its argument is the\nexact\nsame object returned by\nuseFormik()\n(in fact,\n<Formik>\ncalls\nuseFormik()\ninternally!). Thus, our form works the same as before, except now we can use new components to express ourselves in a more concise manner.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n,\nField\n,\nForm\n,\nErrorMessage\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nSignupForm\n=\n(\n)\n=>\n{\n6\nreturn\n(\n7\n<\nFormik\n8\ninitialValues\n=\n{\n{\nfirstName\n:\n''\n,\nlastName\n:\n''\n,\nemail\n:\n''\n}\n}\n9\nvalidationSchema\n=\n{\nYup\n.\nobject\n(\n{\n10\nfirstName\n:\nYup\n.\nstring\n(\n)\n11\n.\nmax\n(\n15\n,\n'Must be 15 characters or less'\n)\n12\n.\nrequired\n(\n'Required'\n)\n,\n13\nlastName\n:\nYup\n.\nstring\n(\n)\n14\n.\nmax\n(\n20\n,\n'Must be 20 characters or less'\n)\n15\n.\nrequired\n(\n'Required'\n)\n,\n16\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email address'\n)\n.\nrequired\n(\n'Required'\n)\n,\n17\n}\n)\n}\n18\nonSubmit\n=\n{\n(\nvalues\n,\n{\nsetSubmitting\n}\n)\n=>\n{\n19\nsetTimeout\n(\n(\n)\n=>\n{\n20\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n21\nsetSubmitting\n(\nfalse\n)\n;\n22\n}\n,\n400\n)\n;\n23\n}\n}\n24\n>\n25\n<\nForm\n>\n26\n<\nlabel\nhtmlFor\n=\n\"\nfirstName\n\"\n>\nFirst Name\n</\nlabel\n>\n27\n<\nField\nname\n=\n\"\nfirstName\n\"\ntype\n=\n\"\ntext\n\"\n/>\n28\n<\nErrorMessage\nname\n=\n\"\nfirstName\n\"\n/>\n29\n30\n<\nlabel\nhtmlFor\n=\n\"\nlastName\n\"\n>\nLast Name\n</\nlabel\n>\n31\n<\nField\nname\n=\n\"\nlastName\n\"\ntype\n=\n\"\ntext\n\"\n/>\n32\n<\nErrorMessage\nname\n=\n\"\nlastName\n\"\n/>\n33\n34\n<\nlabel\nhtmlFor\n=\n\"\nemail\n\"\n>\nEmail Address\n</\nlabel\n>\n35\n<\nField\nname\n=\n\"\nemail\n\"\ntype\n=\n\"\nemail\n\"\n/>\n36\n<\nErrorMessage\nname\n=\n\"\nemail\n\"\n/>\n37\n38\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n39\n</\nForm\n>\n40\n</\nFormik\n>\n41\n)\n;\n42\n}\n;\nThe\n<Field>\ncomponent by default will render an\n<input>\ncomponent that, given a\nname\nprop, will implicitly grab the respective\nonChange\n,\nonBlur\n,\nvalue\nprops and pass them to the element as well as any props you pass to it. However, since not everything is an input,\n<Field>\nalso accepts a few other props to let you render whatever you want. Some examples..\nCopy\n1\n// <input className=\"form-input\" placeHolder=\"Jane\"  />\n2\n<\nField\nname\n=\n\"\nfirstName\n\"\nclassName\n=\n\"\nform-input\n\"\nplaceholder\n=\n\"\nJane\n\"\n/>\n3\n4\n// <textarea className=\"form-textarea\"/></textarea>\n5\n<\nField\nname\n=\n\"\nmessage\n\"\nas\n=\n\"\ntextarea\n\"\nclassName\n=\n\"\nform-textarea\n\"\n/>\n6\n7\n// <select className=\"my-select\"/>\n8\n<\nField\nname\n=\n\"\ncolors\n\"\nas\n=\n\"\nselect\n\"\nclassName\n=\n\"\nmy-select\n\"\n>\n9\n<\noption\nvalue\n=\n\"\nred\n\"\n>\nRed\n</\noption\n>\n10\n<\noption\nvalue\n=\n\"\ngreen\n\"\n>\nGreen\n</\noption\n>\n11\n<\noption\nvalue\n=\n\"\nblue\n\"\n>\nBlue\n</\noption\n>\n12\n</\nField\n>\nReact is all about composition, and while we\u2019ve cut down on a lot of the\nprop-drilling\n, we\u2019re still repeating ourselves with a\nlabel\n,\n<Field>\n, and\n<ErrorMessage>\nfor each of our inputs. We can do better with an abstraction! With Formik, you can and should build reusable input primitive components that you can share around your application. Turns out our\n<Field>\nrender-prop component has a sister and her name is\nuseField\nthat\u2019s going to do the same thing, but via React Hooks! Check this out...\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\nReactDOM\nfrom\n'react-dom'\n;\n3\nimport\n{\nFormik\n,\nForm\n,\nuseField\n}\nfrom\n'formik'\n;\n4\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n5\n6\nconst\nMyTextInput\n=\n(\n{\nlabel\n,\n...\nprops\n}\n)\n=>\n{\n7\n// useField() returns [formik.getFieldProps(), formik.getFieldMeta()]\n8\n// which we can spread on <input>. We can use field meta to show an error\n9\n// message if the field is invalid and it has been touched (i.e. visited)\n10\nconst\n[\nfield\n,\nmeta\n]\n=\nuseField\n(\nprops\n)\n;\n11\nreturn\n(\n12\n<\n>\n13\n<\nlabel\nhtmlFor\n=\n{\nprops\n.\nid\n||\nprops\n.\nname\n}\n>\n{\nlabel\n}\n</\nlabel\n>\n14\n<\ninput\nclassName\n=\n\"\ntext-input\n\"\n{\n...\nfield\n}\n{\n...\nprops\n}\n/>\n15\n{\nmeta\n.\ntouched\n&&\nmeta\n.\nerror\n?\n(\n16\n<\ndiv\nclassName\n=\n\"\nerror\n\"\n>\n{\nmeta\n.\nerror\n}\n</\ndiv\n>\n17\n)\n:\nnull\n}\n18\n</\n>\n19\n)\n;\n20\n}\n;\n21\n22\nconst\nMyCheckbox\n=\n(\n{\nchildren\n,\n...\nprops\n}\n)\n=>\n{\n23\n// React treats radios and checkbox inputs differently from other input types: select and textarea.\n24\n// Formik does this too! When you specify `type` to useField(), it will\n25\n// return the correct bag of props for you -- a `checked` prop will be included\n26\n// in `field` alongside `name`, `value`, `onChange`, and `onBlur`\n27\nconst\n[\nfield\n,\nmeta\n]\n=\nuseField\n(\n{\n...\nprops\n,\ntype\n:\n'checkbox'\n}\n)\n;\n28\nreturn\n(\n29\n<\ndiv\n>\n30\n<\nlabel\nclassName\n=\n\"\ncheckbox-input\n\"\n>\n31\n<\ninput\ntype\n=\n\"\ncheckbox\n\"\n{\n...\nfield\n}\n{\n...\nprops\n}\n/>\n32\n{\nchildren\n}\n33\n</\nlabel\n>\n34\n{\nmeta\n.\ntouched\n&&\nmeta\n.\nerror\n?\n(\n35\n<\ndiv\nclassName\n=\n\"\nerror\n\"\n>\n{\nmeta\n.\nerror\n}\n</\ndiv\n>\n36\n)\n:\nnull\n}\n37\n</\ndiv\n>\n38\n)\n;\n39\n}\n;\n40\n41\nconst\nMySelect\n=\n(\n{\nchildren\n,\nlabel\n,\n...\nprops\n}\n)\n=>\n{\n42\nconst\n[\nfield\n,\nmeta\n]\n=\nuseField\n(\nprops\n)\n;\n43\nreturn\n(\n44\n<\ndiv\n>\n45\n<\nlabel\nhtmlFor\n=\n{\nprops\n.\nid\n||\nprops\n.\nname\n}\n>\n{\nlabel\n}\n</\nlabel\n>\n46\n<\nselect\n{\n...\nfield\n}\n{\n...\nprops\n}\n/>\n47\n{\nchildren\n}\n48\n{\nmeta\n.\ntouched\n&&\nmeta\n.\nerror\n?\n(\n49\n<\ndiv\nclassName\n=\n\"\nerror\n\"\n>\n{\nmeta\n.\nerror\n}\n</\ndiv\n>\n50\n)\n:\nnull\n}\n51\n</\ndiv\n>\n52\n)\n;\n53\n}\n;\n54\n55\n// And now we can use these\n56\nconst\nSignupForm\n=\n(\n)\n=>\n{\n57\nreturn\n(\n58\n<\n>\n59\n<\nh1\n>\nSubscribe!\n</\nh1\n>\n60\n<\nFormik\n61\ninitialValues\n=\n{\n{\n62\nfirstName\n:\n''\n,\n63\nlastName\n:\n''\n,\n64\nemail\n:\n''\n,\n65\nacceptedTerms\n:\nfalse\n,\n// added for our checkbox\n66\njobType\n:\n''\n,\n// added for our select\n67\n}\n}\n68\nvalidationSchema\n=\n{\nYup\n.\nobject\n(\n{\n69\nfirstName\n:\nYup\n.\nstring\n(\n)\n70\n.\nmax\n(\n15\n,\n'Must be 15 characters or less'\n)\n71\n.\nrequired\n(\n'Required'\n)\n,\n72\nlastName\n:\nYup\n.\nstring\n(\n)\n73\n.\nmax\n(\n20\n,\n'Must be 20 characters or less'\n)\n74\n.\nrequired\n(\n'Required'\n)\n,\n75\nemail\n:\nYup\n.\nstring\n(\n)\n76\n.\nemail\n(\n'Invalid email address'\n)\n77\n.\nrequired\n(\n'Required'\n)\n,\n78\nacceptedTerms\n:\nYup\n.\nboolean\n(\n)\n79\n.\nrequired\n(\n'Required'\n)\n80\n.\noneOf\n(\n[\ntrue\n]\n,\n'You must accept the terms and conditions.'\n)\n,\n81\njobType\n:\nYup\n.\nstring\n(\n)\n82\n.\noneOf\n(\n83\n[\n'designer'\n,\n'development'\n,\n'product'\n,\n'other'\n]\n,\n84\n'Invalid Job Type'\n85\n)\n86\n.\nrequired\n(\n'Required'\n)\n,\n87\n}\n)\n}\n88\nonSubmit\n=\n{\n(\nvalues\n,\n{\nsetSubmitting\n}\n)\n=>\n{\n89\nsetTimeout\n(\n(\n)\n=>\n{\n90\nalert\n(\nJSON\n.\nstringify\n(\nvalues\n,\nnull\n,\n2\n)\n)\n;\n91\nsetSubmitting\n(\nfalse\n)\n;\n92\n}\n,\n400\n)\n;\n93\n}\n}\n94\n>\n95\n<\nForm\n>\n96\n<\nMyTextInput\n97\nlabel\n=\n\"\nFirst Name\n\"\n98\nname\n=\n\"\nfirstName\n\"\n99\ntype\n=\n\"\ntext\n\"\n100\nplaceholder\n=\n\"\nJane\n\"\n101\n/>\n102\n103\n<\nMyTextInput\n104\nlabel\n=\n\"\nLast Name\n\"\n105\nname\n=\n\"\nlastName\n\"\n106\ntype\n=\n\"\ntext\n\"\n107\nplaceholder\n=\n\"\nDoe\n\"\n108\n/>\n109\n110\n<\nMyTextInput\n111\nlabel\n=\n\"\nEmail Address\n\"\n112\nname\n=\n\"\nemail\n\"\n113\ntype\n=\n\"\nemail\n\"\n114\nplaceholder\n=\n\"\njane@formik.com\n\"\n115\n/>\n116\n117\n<\nMySelect\nlabel\n=\n\"\nJob Type\n\"\nname\n=\n\"\njobType\n\"\n>\n118\n<\noption\nvalue\n=\n\"\n\"\n>\nSelect a job type\n</\noption\n>\n119\n<\noption\nvalue\n=\n\"\ndesigner\n\"\n>\nDesigner\n</\noption\n>\n120\n<\noption\nvalue\n=\n\"\ndevelopment\n\"\n>\nDeveloper\n</\noption\n>\n121\n<\noption\nvalue\n=\n\"\nproduct\n\"\n>\nProduct Manager\n</\noption\n>\n122\n<\noption\nvalue\n=\n\"\nother\n\"\n>\nOther\n</\noption\n>\n123\n</\nMySelect\n>\n124\n125\n<\nMyCheckbox\nname\n=\n\"\nacceptedTerms\n\"\n>\n126\nI accept the terms and conditions\n127\n</\nMyCheckbox\n>\n128\n129\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n130\n</\nForm\n>\n131\n</\nFormik\n>\n132\n</\n>\n133\n)\n;\n134\n}\n;\nAs you can see above,\nuseField()\ngives us the ability to connect any kind input of React component to Formik as if it were a\n<Field>\n+\n<ErrorMessage>\n. We can use it to build a group of reusable inputs that fit our needs.\nWrapping Up\nCongratulations! You\u2019ve created a signup form with Formik that:\nHas complex validation logic and rich error messages\nProperly displays errors messages to the user at the correct time (after they have blurred a field)\nLeverages your own custom input components you can use on other forms in your app\nNice work! We hope you now feel like you have a decent grasp on how Formik works.\nCheck out the final result here:\nFinal Result\n.\nIf you have extra time or want to practice your new Formik skills, here are some ideas for improvements that you could make to the signup form which are listed in order of increasing difficulty:\nDisable the submit button while the user has attempted to submit (hint:\nformik.isSubmitting\n)\nAdd a reset button with\nformik.handleReset\nor\n<button type=\"reset\">\n.\nPre-populate\ninitialValues\nbased on URL query string or props passed to\n<SignupForm>\n.\nChange the input border color to red when a field has an error and isn\u2019t focused\nAdd a shake animation to each field when it displays an error and has been visited\nPersist form state to the browser\u2019s\nsessionStorage\nso that form progress is kept in between page refreshes\nThroughout this tutorial, we touched on Formik concepts including form state, fields, validation, hooks, render props, and React context. For a more detailed explanation of each of these topics, check out the rest of the\ndocumentation\n. To learn more about defining the components and hooks in the tutorial, check out the\nAPI reference\n.\nPrevious\nGetting Started\nNext\nResources\nWas this page helpful?\nEdit this page on GitHub\nOn this page",
  "content_markdown": "# Tutorial\n\n## Before we start\n\nWelcome to the Formik tutorial. This will teach you everything you need to know to build simple and complex forms in React.\n\nIf you\u2019re impatient and just want to start hacking on your machine locally, check out [the 60-second quickstart](/docs/overview#installation).\n\n### What are we building?\n\nIn this tutorial, we\u2019ll build a complex newsletter signup form with React and Formik.\n\nYou can see what we\u2019ll be building here: [Final Result](https://codesandbox.io/s/formik-v2-tutorial-final-ge1pt). If the code doesn\u2019t make sense to you, don\u2019t worry! The goal of this tutorial is to help you understand Formik.\n\n### Prerequisites\n\nYou\u2019ll need to have familiarity with HTML, CSS, [modern JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript), and [React](https://reactjs.org) (and [React Hooks](https://reactjs.org/docs/hooks-intro.html)) to fully understand Formik and how it works. In this tutorial, we\u2019re using [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), [let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const), [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), [computed property names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names), and [async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) . You can use the [Babel REPL](https://babeljs.io/repl/#?presets=react&code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA) to check what ES6 code compiles to.\n\n## Setup for the Tutorial\n\nThere are two ways to complete this tutorial: you can either write the code in your browser, or you can set up a local development environment on your computer.\n\n### Setup Option 1: Write Code in the Browser\n\nThis is the quickest way to get started!\n\nFirst, open this [Starter Code](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr) in a new tab. The new tab should display an email address input, a submit button, and some React code. We\u2019ll be editing the React code in this tutorial.\n\nSkip the second setup option, and go to the [Overview](/docs/tutorial#overview-what-is-formik) section to get an overview of Formik.\n\n### Setup Option 2: Local Development Environment\n\nThis is completely optional and not required for this tutorial!\n\n**Optional: Instructions for following along locally using your preferred text editor**\n\nThis setup requires more work, but allows you to complete the tutorial using an editor of your choice. Here are the steps to follow:\n\n1. Make sure you have a recent version of [Node.js](https://nodejs.org/en/) installed.\n2. Follow the [installation instructions for Create React App](https://create-react-app.dev) to make a new project.\n\nCopy\n\n```\nnpx create-react-app my-app\n```\n\n1. Install Formik\n\nCopy\n\n```\nnpm i formik\n```\n\nOr\n\nCopy\n\n```\nyarn add formik\n```\n\n1. Delete all files in the `src/` folder of the new project\n\n> Note:\n>\n> **Don\u2019t delete the entire `src` folder, just the original source files inside it.** We\u2019ll replace the default source files with examples for this project in the next step.\n\nCopy\n\n```\n1 cd my-app\n\n2 cd src\n\n3\n\n4 # If you\u2019re using a Mac or Linux:\n\n5 rm -f *\n\n6\n\n7 # Or, if you\u2019re on Windows:\n\n8 del *\n\n9\n\n10 # Then, switch back to the project folder\n\n11 cd ..\n```\n\n5. Add a file named `styles.css` in the `src/` folder with [this CSS code](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr?file=/src/styles.css).\n6. Add a file named `index.js` in the `src/` folder with [this JS code](https://codesandbox.io/s/formik-v2-tutorial-start-s04yr?file=/src/index.js:0-759).\n\nNow run `npm start` in the project folder and open `http://localhost:3000` in the browser. You should see an email input and a submit button.\n\nWe recommend following [these instructions](https://babeljs.io/docs/editors/) to configure syntax highlighting for your editor.\n\n### Help, I\u2019m Stuck!\n\nIf you get stuck, check out Formik\u2019s [GitHub Discussions](https://github.com/formik/formik/discussions). In addition, the [Formium Community Discord Server](https://discord.gg/pJSg287) is a great way to get help quickly too. If you don\u2019t receive an answer, or if you remain stuck, please file an issue, and we\u2019ll help you out.\n\n## Overview: What is Formik?\n\nFormik is a small group of React components and hooks for building forms in React and React Native. It helps with the three most annoying parts:\n\n1. Getting values in and out of form state\n2. Validation and error messages\n3. Handling form submission\n\nBy colocating all of the above in one place, Formik keeps things\norganized--making testing, refactoring, and reasoning about your forms a breeze.\n\n## The Basics\n\nWe\u2019re going to start with the *most verbose* way of using Formik. While this may seem a bit long-winded, it\u2019s important to see how Formik builds on itself so you have a full grasp of what\u2019s possible and a complete mental model of how it works.\n\n### A simple newsletter signup form\n\nImagine we want to add a newsletter signup form for a blog. To start, our form will have just one field named `email`. With Formik, this is just a few lines of code.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 const SignupForm = () => {\n\n5   // Pass the useFormik() hook initial form values and a submit function that will\n\n6   // be called when the form is submitted\n\n7   const formik = useFormik({\n\n8     initialValues: {\n\n9       email: '',\n\n10     },\n\n11     onSubmit: values => {\n\n12       alert(JSON.stringify(values, null, 2));\n\n13     },\n\n14   });\n\n15   return (\n\n16     <form onSubmit={formik.handleSubmit}>\n\n17       <label htmlFor=\"email\">Email Address</label>\n\n18       <input\n\n19         id=\"email\"\n\n20         name=\"email\"\n\n21         type=\"email\"\n\n22         onChange={formik.handleChange}\n\n23         value={formik.values.email}\n\n24       />\n\n25\n\n26       <button type=\"submit\">Submit</button>\n\n27     </form>\n\n28   );\n\n29 };\n```\n\nWe pass our form\u2019s `initialValues` and a submission function (`onSubmit`) to the `useFormik()` hook. The hook then returns to us a goodie bag of form state and helper methods in a variable we call `formik`. For now, the only helper methods we care about are as follows:\n\n- `handleSubmit`: A submission handler\n- `handleChange`: A change handler to pass to each `<input>`, `<select>`, or `<textarea>`\n- `values`: Our form\u2019s current values\n\nAs you can see above, we pass each of these to their respective props...and that\u2019s it! We can now have a working form powered by Formik. Instead of managing our form\u2019s values on our own and writing our own custom event handlers for every single input, we can just use `useFormik()`.\n\nThis is pretty neat, but with just one single input, the benefits of using `useFormik()` are unclear. So let\u2019s add two more inputs: one for the user\u2019s first and last name, which we\u2019ll store as `firstName` and `lastName` in the form.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 const SignupForm = () => {\n\n5   // Note that we have to initialize ALL of fields with values. These\n\n6   // could come from props, but since we don\u2019t want to prefill this form,\n\n7   // we just use an empty string. If we don\u2019t do this, React will yell\n\n8   // at us.\n\n9   const formik = useFormik({\n\n10     initialValues: {\n\n11       firstName: '',\n\n12       lastName: '',\n\n13       email: '',\n\n14     },\n\n15     onSubmit: values => {\n\n16       alert(JSON.stringify(values, null, 2));\n\n17     },\n\n18   });\n\n19   return (\n\n20     <form onSubmit={formik.handleSubmit}>\n\n21       <label htmlFor=\"firstName\">First Name</label>\n\n22       <input\n\n23         id=\"firstName\"\n\n24         name=\"firstName\"\n\n25         type=\"text\"\n\n26         onChange={formik.handleChange}\n\n27         value={formik.values.firstName}\n\n28       />\n\n29\n\n30       <label htmlFor=\"lastName\">Last Name</label>\n\n31       <input\n\n32         id=\"lastName\"\n\n33         name=\"lastName\"\n\n34         type=\"text\"\n\n35         onChange={formik.handleChange}\n\n36         value={formik.values.lastName}\n\n37       />\n\n38\n\n39       <label htmlFor=\"email\">Email Address</label>\n\n40       <input\n\n41         id=\"email\"\n\n42         name=\"email\"\n\n43         type=\"email\"\n\n44         onChange={formik.handleChange}\n\n45         value={formik.values.email}\n\n46       />\n\n47\n\n48       <button type=\"submit\">Submit</button>\n\n49     </form>\n\n50   );\n\n51 };\n```\n\nIf you look carefully at our new code, you\u2019ll notice some patterns and symmetry *forming*.\n\n1. We reuse the same exact change handler function `handleChange` for each HTML input\n2. We pass an `id` and `name` HTML attribute that *matches* the property we defined in `initialValues`\n3. We access the field\u2019s value using the same name (`email` -> `formik.values.email`)\n\nIf you\u2019re familiar with building forms with plain React, you can think of Formik\u2019s `handleChange` as working like this:\n\nCopy\n\n```\n1 const [values, setValues] = React.useState({});\n\n2\n\n3 const handleChange = event => {\n\n4   setValues(prevValues => ({\n\n5     ...prevValues,\n\n6     // we use the name to tell Formik which key of `values` to update\n\n7     [event.target.name]: event.target.value\n\n8   });\n\n9 }\n```\n\n## Validation\n\nWhile our contact form works, it\u2019s not quite feature-complete; users can submit it, but it doesn\u2019t tell them which (if any) fields are required.\n\nIf we\u2019re okay with using the browser\u2019s built-in HTML input validation, we could add a `required` prop to each of our inputs, specify minimum/maximum lengths (`maxlength` and `minlength`), and/or add a `pattern` prop for regex validation for each of these inputs. These are great if we can get away with them. However, HTML validation has its limitations. First, it only works in the browser! So this clearly is not viable for React Native. Second, it\u2019s hard/impossible to show custom error messages to our user. Third, it\u2019s very janky.\n\nAs mentioned earlier, Formik keeps track of not only your form\u2019s `values`, but also its validation and error messages. To add validation with JS, let\u2019s specify a custom validation function and pass it as `validate` to the `useFormik()` hook. If an error exists, this custom validation function should produce an `error` object with a matching shape to our `values`/`initialValues`. Again...*symmetry*...yes...\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 // A custom validation function. This must return an object\n\n5 // which keys are symmetrical to our values/initialValues\n\n6 const validate = values => {\n\n7   const errors = {};\n\n8   if (!values.firstName) {\n\n9     errors.firstName = 'Required';\n\n10   } else if (values.firstName.length > 15) {\n\n11     errors.firstName = 'Must be 15 characters or less';\n\n12   }\n\n13\n\n14   if (!values.lastName) {\n\n15     errors.lastName = 'Required';\n\n16   } else if (values.lastName.length > 20) {\n\n17     errors.lastName = 'Must be 20 characters or less';\n\n18   }\n\n19\n\n20   if (!values.email) {\n\n21     errors.email = 'Required';\n\n22   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(values.email)) {\n\n23     errors.email = 'Invalid email address';\n\n24   }\n\n25\n\n26   return errors;\n\n27 };\n\n28\n\n29 const SignupForm = () => {\n\n30   // Pass the useFormik() hook initial form values, a validate function that will be called when\n\n31   // form values change or fields are blurred, and a submit function that will\n\n32   // be called when the form is submitted\n\n33   const formik = useFormik({\n\n34     initialValues: {\n\n35       firstName: '',\n\n36       lastName: '',\n\n37       email: '',\n\n38     },\n\n39     validate,\n\n40     onSubmit: values => {\n\n41       alert(JSON.stringify(values, null, 2));\n\n42     },\n\n43   });\n\n44   return (\n\n45     <form onSubmit={formik.handleSubmit}>\n\n46       <label htmlFor=\"firstName\">First Name</label>\n\n47       <input\n\n48         id=\"firstName\"\n\n49         name=\"firstName\"\n\n50         type=\"text\"\n\n51         onChange={formik.handleChange}\n\n52         value={formik.values.firstName}\n\n53       />\n\n54       {formik.errors.firstName ? <div>{formik.errors.firstName}</div> : null}\n\n55\n\n56       <label htmlFor=\"lastName\">Last Name</label>\n\n57       <input\n\n58         id=\"lastName\"\n\n59         name=\"lastName\"\n\n60         type=\"text\"\n\n61         onChange={formik.handleChange}\n\n62         value={formik.values.lastName}\n\n63       />\n\n64       {formik.errors.lastName ? <div>{formik.errors.lastName}</div> : null}\n\n65\n\n66       <label htmlFor=\"email\">Email Address</label>\n\n67       <input\n\n68         id=\"email\"\n\n69         name=\"email\"\n\n70         type=\"email\"\n\n71         onChange={formik.handleChange}\n\n72         value={formik.values.email}\n\n73       />\n\n74       {formik.errors.email ? <div>{formik.errors.email}</div> : null}\n\n75\n\n76       <button type=\"submit\">Submit</button>\n\n77     </form>\n\n78   );\n\n79 };\n```\n\n`formik.errors` is populated via the custom validation function. By default, Formik will validate after each keystroke (change event), each input\u2019s [blur event](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event), as well as prior to submission. The `onSubmit` function we passed to `useFormik()` will be executed only if there are no errors (i.e. if our `validate` function returns `{}`).\n\n## Visited fields\n\nWhile our form works, and our users see each error, it\u2019s not a great user experience for them. Since our validation function runs on each keystroke against the *entire* form\u2019s `values`, our `errors` object contains *all* validation errors at any given moment. In our component, we\u2019re just checking if an error exists and then immediately showing it to the user. This is awkward since we\u2019re going to show error messages for fields that the user hasn\u2019t even visited yet. Most of the time, we only want to show a field\u2019s error message *after* our user is done typing in that field.\n\nLike `errors` and `values`, Formik keeps track of which fields have been visited. It stores this information in an object called `touched` that also mirrors the shape of `values`/`initialValues`. The keys of `touched` are the field names, and the values of `touched` are booleans `true`/`false`.\n\nTo take advantage of `touched`, we pass `formik.handleBlur` to each input\u2019s `onBlur` prop. This function works similarly to `formik.handleChange` in that it uses the `name` attribute to figure out which field to update.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 const validate = values => {\n\n5   const errors = {};\n\n6\n\n7   if (!values.firstName) {\n\n8     errors.firstName = 'Required';\n\n9   } else if (values.firstName.length > 15) {\n\n10     errors.firstName = 'Must be 15 characters or less';\n\n11   }\n\n12\n\n13   if (!values.lastName) {\n\n14     errors.lastName = 'Required';\n\n15   } else if (values.lastName.length > 20) {\n\n16     errors.lastName = 'Must be 20 characters or less';\n\n17   }\n\n18\n\n19   if (!values.email) {\n\n20     errors.email = 'Required';\n\n21   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(values.email)) {\n\n22     errors.email = 'Invalid email address';\n\n23   }\n\n24\n\n25   return errors;\n\n26 };\n\n27\n\n28 const SignupForm = () => {\n\n29   const formik = useFormik({\n\n30     initialValues: {\n\n31       firstName: '',\n\n32       lastName: '',\n\n33       email: '',\n\n34     },\n\n35     validate,\n\n36     onSubmit: values => {\n\n37       alert(JSON.stringify(values, null, 2));\n\n38     },\n\n39   });\n\n40   return (\n\n41     <form onSubmit={formik.handleSubmit}>\n\n42       <label htmlFor=\"firstName\">First Name</label>\n\n43       <input\n\n44         id=\"firstName\"\n\n45         name=\"firstName\"\n\n46         type=\"text\"\n\n47         onChange={formik.handleChange}\n\n48         onBlur={formik.handleBlur}\n\n49         value={formik.values.firstName}\n\n50       />\n\n51       {formik.errors.firstName ? <div>{formik.errors.firstName}</div> : null}\n\n52\n\n53       <label htmlFor=\"lastName\">Last Name</label>\n\n54       <input\n\n55         id=\"lastName\"\n\n56         name=\"lastName\"\n\n57         type=\"text\"\n\n58         onChange={formik.handleChange}\n\n59         onBlur={formik.handleBlur}\n\n60         value={formik.values.lastName}\n\n61       />\n\n62       {formik.errors.lastName ? <div>{formik.errors.lastName}</div> : null}\n\n63\n\n64       <label htmlFor=\"email\">Email Address</label>\n\n65       <input\n\n66         id=\"email\"\n\n67         name=\"email\"\n\n68         type=\"email\"\n\n69         onChange={formik.handleChange}\n\n70         onBlur={formik.handleBlur}\n\n71         value={formik.values.email}\n\n72       />\n\n73       {formik.errors.email ? <div>{formik.errors.email}</div> : null}\n\n74\n\n75       <button type=\"submit\">Submit</button>\n\n76     </form>\n\n77   );\n\n78 };\n```\n\nAlmost there! Now that we\u2019re tracking `touched`, we can now change our error message render logic to *only* show a given field\u2019s error message if it exists *and* if our user has visited that field.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 const validate = values => {\n\n5   const errors = {};\n\n6\n\n7   if (!values.firstName) {\n\n8     errors.firstName = 'Required';\n\n9   } else if (values.firstName.length > 15) {\n\n10     errors.firstName = 'Must be 15 characters or less';\n\n11   }\n\n12\n\n13   if (!values.lastName) {\n\n14     errors.lastName = 'Required';\n\n15   } else if (values.lastName.length > 20) {\n\n16     errors.lastName = 'Must be 20 characters or less';\n\n17   }\n\n18\n\n19   if (!values.email) {\n\n20     errors.email = 'Required';\n\n21   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(values.email)) {\n\n22     errors.email = 'Invalid email address';\n\n23   }\n\n24\n\n25   return errors;\n\n26 };\n\n27\n\n28 const SignupForm = () => {\n\n29   const formik = useFormik({\n\n30     initialValues: {\n\n31       firstName: '',\n\n32       lastName: '',\n\n33       email: '',\n\n34     },\n\n35     validate,\n\n36     onSubmit: values => {\n\n37       alert(JSON.stringify(values, null, 2));\n\n38     },\n\n39   });\n\n40   return (\n\n41     <form onSubmit={formik.handleSubmit}>\n\n42       <label htmlFor=\"firstName\">First Name</label>\n\n43       <input\n\n44         id=\"firstName\"\n\n45         name=\"firstName\"\n\n46         type=\"text\"\n\n47         onChange={formik.handleChange}\n\n48         onBlur={formik.handleBlur}\n\n49         value={formik.values.firstName}\n\n50       />\n\n51       {formik.touched.firstName && formik.errors.firstName ? (\n\n52         <div>{formik.errors.firstName}</div>\n\n53       ) : null}\n\n54\n\n55       <label htmlFor=\"lastName\">Last Name</label>\n\n56       <input\n\n57         id=\"lastName\"\n\n58         name=\"lastName\"\n\n59         type=\"text\"\n\n60         onChange={formik.handleChange}\n\n61         onBlur={formik.handleBlur}\n\n62         value={formik.values.lastName}\n\n63       />\n\n64       {formik.touched.lastName && formik.errors.lastName ? (\n\n65         <div>{formik.errors.lastName}</div>\n\n66       ) : null}\n\n67\n\n68       <label htmlFor=\"email\">Email Address</label>\n\n69       <input\n\n70         id=\"email\"\n\n71         name=\"email\"\n\n72         type=\"email\"\n\n73         onChange={formik.handleChange}\n\n74         onBlur={formik.handleBlur}\n\n75         value={formik.values.email}\n\n76       />\n\n77       {formik.touched.email && formik.errors.email ? (\n\n78         <div>{formik.errors.email}</div>\n\n79       ) : null}\n\n80\n\n81       <button type=\"submit\">Submit</button>\n\n82     </form>\n\n83   );\n\n84 };\n```\n\n### Schema Validation with Yup\n\nAs you can see above, validation is left up to you. Feel free to write your own validators or use a 3rd-party helper library. Formik\u2019s authors/a large portion of its users use [Jason Quense](https://github.com/jquense)\u2019s library [Yup](https://github.com/jquense/yup) for object schema validation. Yup has an API that\u2019s similar to [Joi](https://github.com/hapijs/joi) and [React PropTypes](https://github.com/facebook/prop-types), but is also small enough for the browser and fast enough for runtime usage. You can try it out here with this [REPL](https://runkit.com/jquense/yup).\n\nSince Formik authors/users *love* Yup so much, Formik has a special configuration prop for Yup called `validationSchema` which will automatically transform Yup\u2019s validation errors messages into a pretty object whose keys match `values`/`initialValues`/`touched` (just like any custom validation function would have to). Anyways, you can install Yup from NPM/yarn like so...\n\nCopy\n\n```\n1 npm install yup --save\n\n2\n\n3 # or via yarn\n\n4\n\n5 yarn add yup\n```\n\nTo see how Yup works, let\u2019s get rid of our custom validation function `validate` and re-write our validation with Yup and `validationSchema`:\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const SignupForm = () => {\n\n6   const formik = useFormik({\n\n7     initialValues: {\n\n8       firstName: '',\n\n9       lastName: '',\n\n10       email: '',\n\n11     },\n\n12     validationSchema: Yup.object({\n\n13       firstName: Yup.string()\n\n14         .max(15, 'Must be 15 characters or less')\n\n15         .required('Required'),\n\n16       lastName: Yup.string()\n\n17         .max(20, 'Must be 20 characters or less')\n\n18         .required('Required'),\n\n19       email: Yup.string().email('Invalid email address').required('Required'),\n\n20     }),\n\n21     onSubmit: values => {\n\n22       alert(JSON.stringify(values, null, 2));\n\n23     },\n\n24   });\n\n25   return (\n\n26     <form onSubmit={formik.handleSubmit}>\n\n27       <label htmlFor=\"firstName\">First Name</label>\n\n28       <input\n\n29         id=\"firstName\"\n\n30         name=\"firstName\"\n\n31         type=\"text\"\n\n32         onChange={formik.handleChange}\n\n33         onBlur={formik.handleBlur}\n\n34         value={formik.values.firstName}\n\n35       />\n\n36       {formik.touched.firstName && formik.errors.firstName ? (\n\n37         <div>{formik.errors.firstName}</div>\n\n38       ) : null}\n\n39\n\n40       <label htmlFor=\"lastName\">Last Name</label>\n\n41       <input\n\n42         id=\"lastName\"\n\n43         name=\"lastName\"\n\n44         type=\"text\"\n\n45         onChange={formik.handleChange}\n\n46         onBlur={formik.handleBlur}\n\n47         value={formik.values.lastName}\n\n48       />\n\n49       {formik.touched.lastName && formik.errors.lastName ? (\n\n50         <div>{formik.errors.lastName}</div>\n\n51       ) : null}\n\n52\n\n53       <label htmlFor=\"email\">Email Address</label>\n\n54       <input\n\n55         id=\"email\"\n\n56         name=\"email\"\n\n57         type=\"email\"\n\n58         onChange={formik.handleChange}\n\n59         onBlur={formik.handleBlur}\n\n60         value={formik.values.email}\n\n61       />\n\n62       {formik.touched.email && formik.errors.email ? (\n\n63         <div>{formik.errors.email}</div>\n\n64       ) : null}\n\n65\n\n66       <button type=\"submit\">Submit</button>\n\n67     </form>\n\n68   );\n\n69 };\n```\n\nAgain, Yup is 100% optional. However, we suggest giving it a try. As you can see above, we expressed the exact same validation function with just 10 lines of code instead of 30. One of Formik\u2019s core design principles is to help you stay organized. Yup definitely helps a lot with this--schemas are extremely expressive, intuitive (since they mirror your values), and reusable. Whether or not you use Yup, we highly recommended you share commonly used validation methods across your application. This will ensure that common fields (e.g. email, street addresses, usernames, phone numbers, etc.) are validated consistently and result in a better user experience.\n\n## Reducing Boilerplate\n\n### `getFieldProps()`\n\nThe code above is very explicit about exactly what Formik is doing. `onChange` -> `handleChange`, `onBlur` -> `handleBlur`, and so on. However, to save you time, `useFormik()` returns a helper method called `formik.getFieldProps()` to make it faster to wire up inputs. Given some field-level info, it returns to you the exact group of `onChange`, `onBlur`, `value`, `checked` for a given field. You can then spread that on an `input`, `select`, or `textarea`.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const SignupForm = () => {\n\n6   const formik = useFormik({\n\n7     initialValues: {\n\n8       firstName: '',\n\n9       lastName: '',\n\n10       email: '',\n\n11     },\n\n12     validationSchema: Yup.object({\n\n13       firstName: Yup.string()\n\n14         .max(15, 'Must be 15 characters or less')\n\n15         .required('Required'),\n\n16       lastName: Yup.string()\n\n17         .max(20, 'Must be 20 characters or less')\n\n18         .required('Required'),\n\n19       email: Yup.string().email('Invalid email address').required('Required'),\n\n20     }),\n\n21     onSubmit: values => {\n\n22       alert(JSON.stringify(values, null, 2));\n\n23     },\n\n24   });\n\n25   return (\n\n26     <form onSubmit={formik.handleSubmit}>\n\n27       <label htmlFor=\"firstName\">First Name</label>\n\n28       <input\n\n29         id=\"firstName\"\n\n30         type=\"text\"\n\n31         {...formik.getFieldProps('firstName')}\n\n32       />\n\n33       {formik.touched.firstName && formik.errors.firstName ? (\n\n34         <div>{formik.errors.firstName}</div>\n\n35       ) : null}\n\n36\n\n37       <label htmlFor=\"lastName\">Last Name</label>\n\n38       <input id=\"lastName\" type=\"text\" {...formik.getFieldProps('lastName')} />\n\n39       {formik.touched.lastName && formik.errors.lastName ? (\n\n40         <div>{formik.errors.lastName}</div>\n\n41       ) : null}\n\n42\n\n43       <label htmlFor=\"email\">Email Address</label>\n\n44       <input id=\"email\" type=\"email\" {...formik.getFieldProps('email')} />\n\n45       {formik.touched.email && formik.errors.email ? (\n\n46         <div>{formik.errors.email}</div>\n\n47       ) : null}\n\n48\n\n49       <button type=\"submit\">Submit</button>\n\n50     </form>\n\n51   );\n\n52 };\n```\n\n### Leveraging React Context\n\nOur code above is again very explicit about exactly what Formik is doing. `onChange` -> `handleChange`, `onBlur` -> `handleBlur`, and so on. However, we still have to manually pass each input this \"prop getter\" `getFieldProps()`. To save you even more time, Formik comes with [React Context](https://reactjs.org/docs/context.html)-powered API/components to make life easier and code less verbose: `<Formik />`, `<Form />`, `<Field />`, and `<ErrorMessage />`. More explicitly, they use React Context implicitly to connect with the parent `<Formik />` state/methods.\n\nSince these components use React Context, we need to render a [React Context Provider](https://reactjs.org/docs/context.html#contextprovider) that holds our form state and helpers in our tree. If you did this yourself, it would look like:\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { useFormik } from 'formik';\n\n3\n\n4 // Create empty context\n\n5 const FormikContext = React.createContext({});\n\n6\n\n7 // Place all of what\u2019s returned by useFormik into context\n\n8 export const Formik = ({ children, ...props }) => {\n\n9   const formikStateAndHelpers = useFormik(props);\n\n10   return (\n\n11     <FormikContext.Provider value={formikStateAndHelpers}>\n\n12       {typeof children === 'function'\n\n13         ? children(formikStateAndHelpers)\n\n14         : children}\n\n15     </FormikContext.Provider>\n\n16   );\n\n17 };\n```\n\nLuckily, we\u2019ve done this for you in a `<Formik>` component that works just like this.\n\nLet\u2019s now swap out the `useFormik()` hook for Formik\u2019s `<Formik>` component/render-prop. Since it\u2019s a component, we\u2019ll convert the object passed to `useFormik()` to JSX, with each key becoming a prop.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const SignupForm = () => {\n\n6   return (\n\n7     <Formik\n\n8       initialValues={{ firstName: '', lastName: '', email: '' }}\n\n9       validationSchema={Yup.object({\n\n10         firstName: Yup.string()\n\n11           .max(15, 'Must be 15 characters or less')\n\n12           .required('Required'),\n\n13         lastName: Yup.string()\n\n14           .max(20, 'Must be 20 characters or less')\n\n15           .required('Required'),\n\n16         email: Yup.string().email('Invalid email address').required('Required'),\n\n17       })}\n\n18       onSubmit={(values, { setSubmitting }) => {\n\n19         setTimeout(() => {\n\n20           alert(JSON.stringify(values, null, 2));\n\n21           setSubmitting(false);\n\n22         }, 400);\n\n23       }}\n\n24     >\n\n25       {formik => (\n\n26         <form onSubmit={formik.handleSubmit}>\n\n27           <label htmlFor=\"firstName\">First Name</label>\n\n28           <input\n\n29             id=\"firstName\"\n\n30             type=\"text\"\n\n31             {...formik.getFieldProps('firstName')}\n\n32           />\n\n33           {formik.touched.firstName && formik.errors.firstName ? (\n\n34             <div>{formik.errors.firstName}</div>\n\n35           ) : null}\n\n36\n\n37           <label htmlFor=\"lastName\">Last Name</label>\n\n38           <input\n\n39             id=\"lastName\"\n\n40             type=\"text\"\n\n41             {...formik.getFieldProps('lastName')}\n\n42           />\n\n43           {formik.touched.lastName && formik.errors.lastName ? (\n\n44             <div>{formik.errors.lastName}</div>\n\n45           ) : null}\n\n46\n\n47           <label htmlFor=\"email\">Email Address</label>\n\n48           <input id=\"email\" type=\"email\" {...formik.getFieldProps('email')} />\n\n49           {formik.touched.email && formik.errors.email ? (\n\n50             <div>{formik.errors.email}</div>\n\n51           ) : null}\n\n52\n\n53           <button type=\"submit\">Submit</button>\n\n54         </form>\n\n55       )}\n\n56     </Formik>\n\n57   );\n\n58 };\n```\n\nAs you can see above, we swapped out `useFormik()` hook and replaced it with the `<Formik>` component. The `<Formik>` component accepts a function as its children (a.k.a. a [render prop](https://reactjs.org/docs/render-props.html)). Its argument is the *exact* same object returned by `useFormik()` (in fact, `<Formik>` calls `useFormik()` internally!). Thus, our form works the same as before, except now we can use new components to express ourselves in a more concise manner.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik, Field, Form, ErrorMessage } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const SignupForm = () => {\n\n6   return (\n\n7     <Formik\n\n8       initialValues={{ firstName: '', lastName: '', email: '' }}\n\n9       validationSchema={Yup.object({\n\n10         firstName: Yup.string()\n\n11           .max(15, 'Must be 15 characters or less')\n\n12           .required('Required'),\n\n13         lastName: Yup.string()\n\n14           .max(20, 'Must be 20 characters or less')\n\n15           .required('Required'),\n\n16         email: Yup.string().email('Invalid email address').required('Required'),\n\n17       })}\n\n18       onSubmit={(values, { setSubmitting }) => {\n\n19         setTimeout(() => {\n\n20           alert(JSON.stringify(values, null, 2));\n\n21           setSubmitting(false);\n\n22         }, 400);\n\n23       }}\n\n24     >\n\n25       <Form>\n\n26         <label htmlFor=\"firstName\">First Name</label>\n\n27         <Field name=\"firstName\" type=\"text\" />\n\n28         <ErrorMessage name=\"firstName\" />\n\n29\n\n30         <label htmlFor=\"lastName\">Last Name</label>\n\n31         <Field name=\"lastName\" type=\"text\" />\n\n32         <ErrorMessage name=\"lastName\" />\n\n33\n\n34         <label htmlFor=\"email\">Email Address</label>\n\n35         <Field name=\"email\" type=\"email\" />\n\n36         <ErrorMessage name=\"email\" />\n\n37\n\n38         <button type=\"submit\">Submit</button>\n\n39       </Form>\n\n40     </Formik>\n\n41   );\n\n42 };\n```\n\nThe `<Field>` component by default will render an `<input>` component that, given a `name` prop, will implicitly grab the respective `onChange`, `onBlur`, `value` props and pass them to the element as well as any props you pass to it. However, since not everything is an input, `<Field>` also accepts a few other props to let you render whatever you want. Some examples..\n\nCopy\n\n```\n1 // <input className=\"form-input\" placeHolder=\"Jane\"  />\n\n2 <Field name=\"firstName\" className=\"form-input\" placeholder=\"Jane\" />\n\n3\n\n4 // <textarea className=\"form-textarea\"/></textarea>\n\n5 <Field name=\"message\" as=\"textarea\" className=\"form-textarea\" />\n\n6\n\n7 // <select className=\"my-select\"/>\n\n8 <Field name=\"colors\" as=\"select\" className=\"my-select\">\n\n9   <option value=\"red\">Red</option>\n\n10   <option value=\"green\">Green</option>\n\n11   <option value=\"blue\">Blue</option>\n\n12 </Field>\n```\n\nReact is all about composition, and while we\u2019ve cut down on a lot of the [prop-drilling](https://kentcdodds.com/blog/prop-drilling), we\u2019re still repeating ourselves with a `label`, `<Field>`, and `<ErrorMessage>` for each of our inputs. We can do better with an abstraction! With Formik, you can and should build reusable input primitive components that you can share around your application. Turns out our `<Field>` render-prop component has a sister and her name is `useField` that\u2019s going to do the same thing, but via React Hooks! Check this out...\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import ReactDOM from 'react-dom';\n\n3 import { Formik, Form, useField } from 'formik';\n\n4 import * as Yup from 'yup';\n\n5\n\n6 const MyTextInput = ({ label, ...props }) => {\n\n7   // useField() returns [formik.getFieldProps(), formik.getFieldMeta()]\n\n8   // which we can spread on <input>. We can use field meta to show an error\n\n9   // message if the field is invalid and it has been touched (i.e. visited)\n\n10   const [field, meta] = useField(props);\n\n11   return (\n\n12     <>\n\n13       <label htmlFor={props.id || props.name}>{label}</label>\n\n14       <input className=\"text-input\" {...field} {...props} />\n\n15       {meta.touched && meta.error ? (\n\n16         <div className=\"error\">{meta.error}</div>\n\n17       ) : null}\n\n18     </>\n\n19   );\n\n20 };\n\n21\n\n22 const MyCheckbox = ({ children, ...props }) => {\n\n23   // React treats radios and checkbox inputs differently from other input types: select and textarea.\n\n24   // Formik does this too! When you specify `type` to useField(), it will\n\n25   // return the correct bag of props for you -- a `checked` prop will be included\n\n26   // in `field` alongside `name`, `value`, `onChange`, and `onBlur`\n\n27   const [field, meta] = useField({ ...props, type: 'checkbox' });\n\n28   return (\n\n29     <div>\n\n30       <label className=\"checkbox-input\">\n\n31         <input type=\"checkbox\" {...field} {...props} />\n\n32         {children}\n\n33       </label>\n\n34       {meta.touched && meta.error ? (\n\n35         <div className=\"error\">{meta.error}</div>\n\n36       ) : null}\n\n37     </div>\n\n38   );\n\n39 };\n\n40\n\n41 const MySelect = ({children, label, ...props }) => {\n\n42   const [field, meta] = useField(props);\n\n43   return (\n\n44     <div>\n\n45       <label htmlFor={props.id || props.name}>{label}</label>\n\n46       <select {...field} {...props} />\n\n47       {children}\n\n48       {meta.touched && meta.error ? (\n\n49         <div className=\"error\">{meta.error}</div>\n\n50       ) : null}\n\n51     </div>\n\n52   );\n\n53 };\n\n54\n\n55 // And now we can use these\n\n56 const SignupForm = () => {\n\n57   return (\n\n58     <>\n\n59       <h1>Subscribe!</h1>\n\n60       <Formik\n\n61         initialValues={{\n\n62           firstName: '',\n\n63           lastName: '',\n\n64           email: '',\n\n65           acceptedTerms: false, // added for our checkbox\n\n66           jobType: '', // added for our select\n\n67         }}\n\n68         validationSchema={Yup.object({\n\n69           firstName: Yup.string()\n\n70             .max(15, 'Must be 15 characters or less')\n\n71             .required('Required'),\n\n72           lastName: Yup.string()\n\n73             .max(20, 'Must be 20 characters or less')\n\n74             .required('Required'),\n\n75           email: Yup.string()\n\n76             .email('Invalid email address')\n\n77             .required('Required'),\n\n78           acceptedTerms: Yup.boolean()\n\n79             .required('Required')\n\n80             .oneOf([true], 'You must accept the terms and conditions.'),\n\n81           jobType: Yup.string()\n\n82             .oneOf(\n\n83               ['designer', 'development', 'product', 'other'],\n\n84               'Invalid Job Type'\n\n85             )\n\n86             .required('Required'),\n\n87         })}\n\n88         onSubmit={(values, { setSubmitting }) => {\n\n89           setTimeout(() => {\n\n90             alert(JSON.stringify(values, null, 2));\n\n91             setSubmitting(false);\n\n92           }, 400);\n\n93         }}\n\n94       >\n\n95         <Form>\n\n96           <MyTextInput\n\n97             label=\"First Name\"\n\n98             name=\"firstName\"\n\n99             type=\"text\"\n\n100             placeholder=\"Jane\"\n\n101           />\n\n102\n\n103           <MyTextInput\n\n104             label=\"Last Name\"\n\n105             name=\"lastName\"\n\n106             type=\"text\"\n\n107             placeholder=\"Doe\"\n\n108           />\n\n109\n\n110           <MyTextInput\n\n111             label=\"Email Address\"\n\n112             name=\"email\"\n\n113             type=\"email\"\n\n114             placeholder=\"jane@formik.com\"\n\n115           />\n\n116\n\n117           <MySelect label=\"Job Type\" name=\"jobType\">\n\n118             <option value=\"\">Select a job type</option>\n\n119             <option value=\"designer\">Designer</option>\n\n120             <option value=\"development\">Developer</option>\n\n121             <option value=\"product\">Product Manager</option>\n\n122             <option value=\"other\">Other</option>\n\n123           </MySelect>\n\n124\n\n125           <MyCheckbox name=\"acceptedTerms\">\n\n126             I accept the terms and conditions\n\n127           </MyCheckbox>\n\n128\n\n129           <button type=\"submit\">Submit</button>\n\n130         </Form>\n\n131       </Formik>\n\n132     </>\n\n133   );\n\n134 };\n```\n\nAs you can see above, `useField()` gives us the ability to connect any kind input of React component to Formik as if it were a `<Field>` + `<ErrorMessage>`. We can use it to build a group of reusable inputs that fit our needs.\n\n## Wrapping Up\n\nCongratulations! You\u2019ve created a signup form with Formik that:\n\n- Has complex validation logic and rich error messages\n- Properly displays errors messages to the user at the correct time (after they have blurred a field)\n- Leverages your own custom input components you can use on other forms in your app\n\nNice work! We hope you now feel like you have a decent grasp on how Formik works.\n\nCheck out the final result here: [Final Result](https://codesandbox.io/s/formik-v2-tutorial-final-ge1pt).\n\nIf you have extra time or want to practice your new Formik skills, here are some ideas for improvements that you could make to the signup form which are listed in order of increasing difficulty:\n\n- Disable the submit button while the user has attempted to submit (hint: `formik.isSubmitting`)\n- Add a reset button with `formik.handleReset` or `<button type=\"reset\">`.\n- Pre-populate `initialValues` based on URL query string or props passed to `<SignupForm>`.\n- Change the input border color to red when a field has an error and isn\u2019t focused\n- Add a shake animation to each field when it displays an error and has been visited\n- Persist form state to the browser\u2019s [sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) so that form progress is kept in between page refreshes\n\nThroughout this tutorial, we touched on Formik concepts including form state, fields, validation, hooks, render props, and React context. For a more detailed explanation of each of these topics, check out the rest of the [documentation](/docs/overview). To learn more about defining the components and hooks in the tutorial, check out the [API reference](/docs/api/formik).\n\n[PreviousGetting Started](/docs/overview)[NextResources](/docs/resources)\n\nWas this page helpful?\n\n![](/twemoji/1f62d.svg)![](/twemoji/1f615.svg)![](/twemoji/1f600.svg)![](/twemoji/1f929.svg)\n\n[Edit this page on GitHub](https://github.com/formik/formik/edit/main/docs/tutorial.md)\n\n#### On this page",
  "tags": [
    "formik",
    "forms",
    "react"
  ],
  "extracted_at": "2026-02-03T12:50:20.593476+00:00",
  "content_length": 35582,
  "content_hash": "20a19b5851980e6c"
}