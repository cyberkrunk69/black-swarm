{
  "id": "formik__docs_guides_validation",
  "source_id": "formik",
  "source_name": "Formik",
  "category": "forms_patterns",
  "url": "https://formik.org/docs/guides/validation",
  "title": "Validation",
  "content": "Validation\nFormik is designed to manage forms with complex validation with ease. Formik supports synchronous and asynchronous\nform-level and field-level validation. Furthermore, it comes with baked-in support for schema-based form-level validation through Yup. This guide will describe the ins and outs of all of the above.\nFlavors of Validation\nForm-level Validation\nForm-level validation is useful because you have complete access to all of your form's\nvalues\nand props whenever the function runs, so you can validate dependent fields at the same time.\nThere are 2 ways to do form-level validation with Formik:\n<Formik validate>\nand\nwithFormik({ validate: ... })\n<Formik validationSchema>\nand\nwithFormik({ validationSchema: ... })\nvalidate\n<Formik>\nand\nwithFormik()\ntake a prop/option called\nvalidate\nthat accepts either a synchronous or asynchronous function.\nCopy\n1\n// Synchronous validation\n2\nconst\nvalidate\n=\n(\nvalues\n,\nprops\n/* only available when using withFormik */\n)\n=>\n{\n3\nconst\nerrors\n=\n{\n}\n;\n4\n5\nif\n(\n!\nvalues\n.\nemail\n)\n{\n6\nerrors\n.\nemail\n=\n'Required'\n;\n7\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalues\n.\nemail\n)\n)\n{\n8\nerrors\n.\nemail\n=\n'Invalid email address'\n;\n9\n}\n10\n11\n//...\n12\n13\nreturn\nerrors\n;\n14\n}\n;\n15\n16\n// Async Validation\n17\nconst\nsleep\n=\nms\n=>\nnew\nPromise\n(\nresolve\n=>\nsetTimeout\n(\nresolve\n,\nms\n)\n)\n;\n18\n19\nconst\nvalidate\n=\n(\nvalues\n,\nprops\n/* only available when using withFormik */\n)\n=>\n{\n20\nreturn\nsleep\n(\n2000\n)\n.\nthen\n(\n(\n)\n=>\n{\n21\nconst\nerrors\n=\n{\n}\n;\n22\nif\n(\n[\n'admin'\n,\n'null'\n,\n'god'\n]\n.\nincludes\n(\nvalues\n.\nusername\n)\n)\n{\n23\nerrors\n.\nusername\n=\n'Nice try'\n;\n24\n}\n25\n// ...\n26\nreturn\nerrors\n;\n27\n}\n)\n;\n28\n}\n;\nFor more information about\n<Formik validate>\n, see the API reference.\nvalidationSchema\nAs you can see above, validation is left up to you. Feel free to write your own\nvalidators or use a 3rd party library. At The Palmer Group, we use\nYup\nfor object schema validation. It has an\nAPI that's pretty similar to\nJoi\nand\nReact PropTypes\nbut is small enough\nfor the browser and fast enough for runtime usage. Because we \u2764\ufe0f Yup sooo\nmuch, Formik has a special config option / prop for Yup object schemas called\nvalidationSchema\nwhich will automatically transform Yup's validation errors into a pretty object whose keys match\nvalues\nand\ntouched\n. This symmetry makes it easy to manage business logic around error messages.\nTo add Yup to your project, install it from NPM.\nCopy\nnpm install yup --save\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n,\nForm\n,\nField\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nSignupSchema\n=\nYup\n.\nobject\n(\n)\n.\nshape\n(\n{\n6\nfirstName\n:\nYup\n.\nstring\n(\n)\n7\n.\nmin\n(\n2\n,\n'Too Short!'\n)\n8\n.\nmax\n(\n50\n,\n'Too Long!'\n)\n9\n.\nrequired\n(\n'Required'\n)\n,\n10\nlastName\n:\nYup\n.\nstring\n(\n)\n11\n.\nmin\n(\n2\n,\n'Too Short!'\n)\n12\n.\nmax\n(\n50\n,\n'Too Long!'\n)\n13\n.\nrequired\n(\n'Required'\n)\n,\n14\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email'\n)\n.\nrequired\n(\n'Required'\n)\n,\n15\n}\n)\n;\n16\n17\nexport\nconst\nValidationSchemaExample\n=\n(\n)\n=>\n(\n18\n<\ndiv\n>\n19\n<\nh1\n>\nSignup\n</\nh1\n>\n20\n<\nFormik\n21\ninitialValues\n=\n{\n{\n22\nfirstName\n:\n''\n,\n23\nlastName\n:\n''\n,\n24\nemail\n:\n''\n,\n25\n}\n}\n26\nvalidationSchema\n=\n{\nSignupSchema\n}\n27\nonSubmit\n=\n{\nvalues\n=>\n{\n28\n// same shape as initial values\n29\nconsole\n.\nlog\n(\nvalues\n)\n;\n30\n}\n}\n31\n>\n32\n{\n(\n{\nerrors\n,\ntouched\n}\n)\n=>\n(\n33\n<\nForm\n>\n34\n<\nField\nname\n=\n\"\nfirstName\n\"\n/>\n35\n{\nerrors\n.\nfirstName\n&&\ntouched\n.\nfirstName\n?\n(\n36\n<\ndiv\n>\n{\nerrors\n.\nfirstName\n}\n</\ndiv\n>\n37\n)\n:\nnull\n}\n38\n<\nField\nname\n=\n\"\nlastName\n\"\n/>\n39\n{\nerrors\n.\nlastName\n&&\ntouched\n.\nlastName\n?\n(\n40\n<\ndiv\n>\n{\nerrors\n.\nlastName\n}\n</\ndiv\n>\n41\n)\n:\nnull\n}\n42\n<\nField\nname\n=\n\"\nemail\n\"\ntype\n=\n\"\nemail\n\"\n/>\n43\n{\nerrors\n.\nemail\n&&\ntouched\n.\nemail\n?\n<\ndiv\n>\n{\nerrors\n.\nemail\n}\n</\ndiv\n>\n:\nnull\n}\n44\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n45\n</\nForm\n>\n46\n)\n}\n47\n</\nFormik\n>\n48\n</\ndiv\n>\n49\n)\n;\nFor more information about\n<Formik validationSchema>\n, see the API reference.\nField-level Validation\nvalidate\nFormik supports field-level validation via the\nvalidate\nprop of\n<Field>\n/\n<FastField>\ncomponents or\nuseField\nhook. This function can be synchronous or asynchronous (return a Promise). It will run after any\nonChange\nand\nonBlur\nby default. This behavior can be altered at the top level\n<Formik/>\ncomponent using the\nvalidateOnChange\nand\nvalidateOnBlur\nprops respectively. In addition to change/blur, all field-level validations are run at the beginning of a submission attempt and then the results are deeply merged with any top-level validation results.\nNote: The\n<Field>/<FastField>\ncomponents'\nvalidate\nfunction will only be executed on mounted fields. That is to say, if any of your fields unmount during the flow of your form (e.g. Material-UI's\n<Tabs>\nunmounts the previous\n<Tab>\nyour user was on), those fields will not be validated during form validation/submission.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n,\nForm\n,\nField\n}\nfrom\n'formik'\n;\n3\n4\nfunction\nvalidateEmail\n(\nvalue\n)\n{\n5\nlet\nerror\n;\n6\nif\n(\n!\nvalue\n)\n{\n7\nerror\n=\n'Required'\n;\n8\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalue\n)\n)\n{\n9\nerror\n=\n'Invalid email address'\n;\n10\n}\n11\nreturn\nerror\n;\n12\n}\n13\n14\nfunction\nvalidateUsername\n(\nvalue\n)\n{\n15\nlet\nerror\n;\n16\nif\n(\nvalue\n===\n'admin'\n)\n{\n17\nerror\n=\n'Nice try!'\n;\n18\n}\n19\nreturn\nerror\n;\n20\n}\n21\n22\nexport\nconst\nFieldLevelValidationExample\n=\n(\n)\n=>\n(\n23\n<\ndiv\n>\n24\n<\nh1\n>\nSignup\n</\nh1\n>\n25\n<\nFormik\n26\ninitialValues\n=\n{\n{\n27\nusername\n:\n''\n,\n28\nemail\n:\n''\n,\n29\n}\n}\n30\nonSubmit\n=\n{\nvalues\n=>\n{\n31\n// same shape as initial values\n32\nconsole\n.\nlog\n(\nvalues\n)\n;\n33\n}\n}\n34\n>\n35\n{\n(\n{\nerrors\n,\ntouched\n,\nisValidating\n}\n)\n=>\n(\n36\n<\nForm\n>\n37\n<\nField\nname\n=\n\"\nemail\n\"\nvalidate\n=\n{\nvalidateEmail\n}\n/>\n38\n{\nerrors\n.\nemail\n&&\ntouched\n.\nemail\n&&\n<\ndiv\n>\n{\nerrors\n.\nemail\n}\n</\ndiv\n>\n}\n39\n40\n<\nField\nname\n=\n\"\nusername\n\"\nvalidate\n=\n{\nvalidateUsername\n}\n/>\n41\n{\nerrors\n.\nusername\n&&\ntouched\n.\nusername\n&&\n<\ndiv\n>\n{\nerrors\n.\nusername\n}\n</\ndiv\n>\n}\n42\n43\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n44\n</\nForm\n>\n45\n)\n}\n46\n</\nFormik\n>\n47\n</\ndiv\n>\n48\n)\n;\nManually Triggering Validation\nYou can manually trigger both form-level and field-level validation with Formik using the\nvalidateForm\nand\nvalidateField\nmethods respectively.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n,\nForm\n,\nField\n}\nfrom\n'formik'\n;\n3\n4\nfunction\nvalidateEmail\n(\nvalue\n)\n{\n5\nlet\nerror\n;\n6\nif\n(\n!\nvalue\n)\n{\n7\nerror\n=\n'Required'\n;\n8\n}\nelse\nif\n(\n!\n/\n^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$\n/\ni\n.\ntest\n(\nvalue\n)\n)\n{\n9\nerror\n=\n'Invalid email address'\n;\n10\n}\n11\nreturn\nerror\n;\n12\n}\n13\n14\nfunction\nvalidateUsername\n(\nvalue\n)\n{\n15\nlet\nerror\n;\n16\nif\n(\nvalue\n===\n'admin'\n)\n{\n17\nerror\n=\n'Nice try!'\n;\n18\n}\n19\nreturn\nerror\n;\n20\n}\n21\n22\nexport\nconst\nFieldLevelValidationExample\n=\n(\n)\n=>\n(\n23\n<\ndiv\n>\n24\n<\nh1\n>\nSignup\n</\nh1\n>\n25\n<\nFormik\n26\ninitialValues\n=\n{\n{\n27\nusername\n:\n''\n,\n28\nemail\n:\n''\n,\n29\n}\n}\n30\nonSubmit\n=\n{\nvalues\n=>\n{\n31\n// same shape as initial values\n32\nconsole\n.\nlog\n(\nvalues\n)\n;\n33\n}\n}\n34\n>\n35\n{\n(\n{\nerrors\n,\ntouched\n,\nvalidateField\n,\nvalidateForm\n}\n)\n=>\n(\n36\n<\nForm\n>\n37\n<\nField\nname\n=\n\"\nemail\n\"\nvalidate\n=\n{\nvalidateEmail\n}\n/>\n38\n{\nerrors\n.\nemail\n&&\ntouched\n.\nemail\n&&\n<\ndiv\n>\n{\nerrors\n.\nemail\n}\n</\ndiv\n>\n}\n39\n40\n<\nField\nname\n=\n\"\nusername\n\"\nvalidate\n=\n{\nvalidateUsername\n}\n/>\n41\n{\nerrors\n.\nusername\n&&\ntouched\n.\nusername\n&&\n<\ndiv\n>\n{\nerrors\n.\nusername\n}\n</\ndiv\n>\n}\n42\n{\n/** Trigger field-level validation\n43\nimperatively */\n}\n44\n<\nbutton\ntype\n=\n\"\nbutton\n\"\nonClick\n=\n{\n(\n)\n=>\nvalidateField\n(\n'username'\n)\n}\n>\n45\nCheck Username\n46\n</\nbutton\n>\n47\n{\n/** Trigger form-level validation\n48\nimperatively */\n}\n49\n<\nbutton\n50\ntype\n=\n\"\nbutton\n\"\n51\nonClick\n=\n{\n(\n)\n=>\nvalidateForm\n(\n)\n.\nthen\n(\n(\n)\n=>\nconsole\n.\nlog\n(\n'blah'\n)\n)\n}\n52\n>\n53\nValidate All\n54\n</\nbutton\n>\n55\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nSubmit\n</\nbutton\n>\n56\n</\nForm\n>\n57\n)\n}\n58\n</\nFormik\n>\n59\n</\ndiv\n>\n60\n)\n;\nWhen Does Validation Run?\nYou can control when Formik runs validation by changing the values of\n<Formik validateOnChange>\nand/or\n<Formik validateOnBlur>\nprops depending on your needs. By default, Formik will run validation methods as follows:\nAfter \"change\" events/methods\n(things that update\nvalues\n)\nhandleChange\nsetFieldValue\nsetValues\nAfter \"blur\" events/methods\n(things that update\ntouched\n)\nhandleBlur\nsetTouched\nsetFieldTouched\nWhenever submission is attempted\nhandleSubmit\nsubmitForm\nThere are also imperative helper methods provided to you via Formik's render/injected props which you can use to imperatively call validation.\nvalidateForm\nvalidateField\nDisplaying Error Messages\nError messages are dependent on the form's validation. If an error exists, and the validation function produces an error object (as it should) with a matching shape to our values/initialValues, dependent field errors can be accessed from the errors object.\nCopy\n1\nimport\nReact\nfrom\n'react'\n;\n2\nimport\n{\nFormik\n,\nForm\n,\nField\n}\nfrom\n'formik'\n;\n3\nimport\n*\nas\nYup\nfrom\n'yup'\n;\n4\n5\nconst\nDisplayingErrorMessagesSchema\n=\nYup\n.\nobject\n(\n)\n.\nshape\n(\n{\n6\nusername\n:\nYup\n.\nstring\n(\n)\n7\n.\nmin\n(\n2\n,\n'Too Short!'\n)\n8\n.\nmax\n(\n50\n,\n'Too Long!'\n)\n9\n.\nrequired\n(\n'Required'\n)\n,\n10\nemail\n:\nYup\n.\nstring\n(\n)\n.\nemail\n(\n'Invalid email'\n)\n.\nrequired\n(\n'Required'\n)\n,\n11\n}\n)\n;\n12\n13\nexport\nconst\nDisplayingErrorMessagesExample\n=\n(\n)\n=>\n(\n14\n<\ndiv\n>\n15\n<\nh1\n>\nDisplaying\nError\nMessages\n<\n/\nh1\n>\n16\n<\nFormik\n17\ninitialValues\n=\n{\n{\n18\nusername\n:\n''\n,\n19\nemail\n:\n''\n,\n20\n}\n}\n21\nvalidationSchema\n=\n{\nDisplayingErrorMessagesSchema\n}\n22\nonSubmit\n=\n{\nvalues\n=>\n{\n23\n// same shape as initial values\n24\nconsole\n.\nlog\n(\nvalues\n)\n;\n25\n}\n}\n26\n>\n27\n{\n(\n{\nerrors\n,\ntouched\n}\n)\n=>\n(\n28\n<\nForm\n>\n29\n<\nField\nname\n=\n\"username\"\n/\n>\n30\n{\n/* If this field has been touched, and it contains an error, display it\n31\n*/\n}\n32\n{\ntouched\n.\nusername\n&&\nerrors\n.\nusername\n&&\n<\ndiv\n>\n{\nerrors\n.\nusername\n}\n<\n/\ndiv\n>\n}\n33\n<\nField\nname\n=\n\"email\"\n/\n>\n34\n{\n/* If this field has been touched, and it contains an error, display\n35\nit */\n}\n36\n{\ntouched\n.\nemail\n&&\nerrors\n.\nemail\n&&\n<\ndiv\n>\n{\nerrors\n.\nemail\n}\n<\n/\ndiv\n>\n}\n37\n<\nbutton type\n=\n\"submit\"\n>\nSubmit\n<\n/\nbutton\n>\n38\n<\n/\nForm\n>\n39\n)\n}\n40\n<\n/\nFormik\n>\n41\n<\n/\ndiv\n>\n42\n)\n;\nThe\nErrorMessage\ncomponent can also be used to display error messages.\nFrequently Asked Questions\nHow do I determine if my form is validating?\nIf\nisValidating\nprop is\ntrue\nCan I return `null` as an error message?\nNo. Use\nundefined\ninstead. Formik uses\nundefined\nto represent empty states. If you use\nnull\n, several parts of Formik's computed props (e.g.\nisValid\nfor example), will not work as expected.\nHow do I test validation?\nFormik has extensive unit tests for Yup validation so you do not need to test that. However, if you are rolling your own validation functions, you should simply unit test those. If you do need to test Formik's execution you should use the imperative\nvalidateForm\nand\nvalidateField\nmethods respectively.\nPrevious\nMigrating from v1.x to v2.x\nNext\nArrays\nWas this page helpful?\nEdit this page on GitHub\nOn this page",
  "content_markdown": "# Validation\n\nFormik is designed to manage forms with complex validation with ease. Formik supports synchronous and asynchronous\nform-level and field-level validation. Furthermore, it comes with baked-in support for schema-based form-level validation through Yup. This guide will describe the ins and outs of all of the above.\n\n## Flavors of Validation\n\n### Form-level Validation\n\nForm-level validation is useful because you have complete access to all of your form's `values` and props whenever the function runs, so you can validate dependent fields at the same time.\n\nThere are 2 ways to do form-level validation with Formik:\n\n- `<Formik validate>` and `withFormik({ validate: ... })`\n- `<Formik validationSchema>` and `withFormik({ validationSchema: ... })`\n\n#### `validate`\n\n`<Formik>` and `withFormik()` take a prop/option called `validate` that accepts either a synchronous or asynchronous function.\n\nCopy\n\n```\n1 // Synchronous validation\n\n2 const validate = (values, props /* only available when using withFormik */) => {\n\n3   const errors = {};\n\n4\n\n5   if (!values.email) {\n\n6     errors.email = 'Required';\n\n7   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(values.email)) {\n\n8     errors.email = 'Invalid email address';\n\n9   }\n\n10\n\n11   //...\n\n12\n\n13   return errors;\n\n14 };\n\n15\n\n16 // Async Validation\n\n17 const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n18\n\n19 const validate = (values, props /* only available when using withFormik */) => {\n\n20   return sleep(2000).then(() => {\n\n21     const errors = {};\n\n22     if (['admin', 'null', 'god'].includes(values.username)) {\n\n23       errors.username = 'Nice try';\n\n24     }\n\n25     // ...\n\n26     return errors;\n\n27   });\n\n28 };\n```\n\nFor more information about `<Formik validate>`, see the API reference.\n\n#### `validationSchema`\n\nAs you can see above, validation is left up to you. Feel free to write your own\nvalidators or use a 3rd party library. At The Palmer Group, we use\n[Yup](https://github.com/jquense/yup) for object schema validation. It has an\nAPI that's pretty similar to [Joi](https://github.com/hapijs/joi) and\n[React PropTypes](https://github.com/facebook/prop-types) but is small enough\nfor the browser and fast enough for runtime usage. Because we \u2764\ufe0f Yup sooo\nmuch, Formik has a special config option / prop for Yup object schemas called `validationSchema` which will automatically transform Yup's validation errors into a pretty object whose keys match `values` and `touched`. This symmetry makes it easy to manage business logic around error messages.\n\nTo add Yup to your project, install it from NPM.\n\nCopy\n\n```\nnpm install yup --save\n```\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik, Form, Field } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const SignupSchema = Yup.object().shape({\n\n6   firstName: Yup.string()\n\n7     .min(2, 'Too Short!')\n\n8     .max(50, 'Too Long!')\n\n9     .required('Required'),\n\n10   lastName: Yup.string()\n\n11     .min(2, 'Too Short!')\n\n12     .max(50, 'Too Long!')\n\n13     .required('Required'),\n\n14   email: Yup.string().email('Invalid email').required('Required'),\n\n15 });\n\n16\n\n17 export const ValidationSchemaExample = () => (\n\n18   <div>\n\n19     <h1>Signup</h1>\n\n20     <Formik\n\n21       initialValues={{\n\n22         firstName: '',\n\n23         lastName: '',\n\n24         email: '',\n\n25       }}\n\n26       validationSchema={SignupSchema}\n\n27       onSubmit={values => {\n\n28         // same shape as initial values\n\n29         console.log(values);\n\n30       }}\n\n31     >\n\n32       {({ errors, touched }) => (\n\n33         <Form>\n\n34           <Field name=\"firstName\" />\n\n35           {errors.firstName && touched.firstName ? (\n\n36             <div>{errors.firstName}</div>\n\n37           ) : null}\n\n38           <Field name=\"lastName\" />\n\n39           {errors.lastName && touched.lastName ? (\n\n40             <div>{errors.lastName}</div>\n\n41           ) : null}\n\n42           <Field name=\"email\" type=\"email\" />\n\n43           {errors.email && touched.email ? <div>{errors.email}</div> : null}\n\n44           <button type=\"submit\">Submit</button>\n\n45         </Form>\n\n46       )}\n\n47     </Formik>\n\n48   </div>\n\n49 );\n```\n\nFor more information about `<Formik validationSchema>`, see the API reference.\n\n### Field-level Validation\n\n#### `validate`\n\nFormik supports field-level validation via the `validate` prop of `<Field>`/`<FastField>` components or `useField` hook. This function can be synchronous or asynchronous (return a Promise). It will run after any `onChange` and `onBlur` by default. This behavior can be altered at the top level `<Formik/>` component using the `validateOnChange` and `validateOnBlur` props respectively. In addition to change/blur, all field-level validations are run at the beginning of a submission attempt and then the results are deeply merged with any top-level validation results.\n\n> Note: The `<Field>/<FastField>` components' `validate` function will only be executed on mounted fields. That is to say, if any of your fields unmount during the flow of your form (e.g. Material-UI's `<Tabs>` unmounts the previous `<Tab>` your user was on), those fields will not be validated during form validation/submission.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik, Form, Field } from 'formik';\n\n3\n\n4 function validateEmail(value) {\n\n5   let error;\n\n6   if (!value) {\n\n7     error = 'Required';\n\n8   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value)) {\n\n9     error = 'Invalid email address';\n\n10   }\n\n11   return error;\n\n12 }\n\n13\n\n14 function validateUsername(value) {\n\n15   let error;\n\n16   if (value === 'admin') {\n\n17     error = 'Nice try!';\n\n18   }\n\n19   return error;\n\n20 }\n\n21\n\n22 export const FieldLevelValidationExample = () => (\n\n23   <div>\n\n24     <h1>Signup</h1>\n\n25     <Formik\n\n26       initialValues={{\n\n27         username: '',\n\n28         email: '',\n\n29       }}\n\n30       onSubmit={values => {\n\n31         // same shape as initial values\n\n32         console.log(values);\n\n33       }}\n\n34     >\n\n35       {({ errors, touched, isValidating }) => (\n\n36         <Form>\n\n37           <Field name=\"email\" validate={validateEmail} />\n\n38           {errors.email && touched.email && <div>{errors.email}</div>}\n\n39\n\n40           <Field name=\"username\" validate={validateUsername} />\n\n41           {errors.username && touched.username && <div>{errors.username}</div>}\n\n42\n\n43           <button type=\"submit\">Submit</button>\n\n44         </Form>\n\n45       )}\n\n46     </Formik>\n\n47   </div>\n\n48 );\n```\n\n### Manually Triggering Validation\n\nYou can manually trigger both form-level and field-level validation with Formik using the `validateForm` and `validateField` methods respectively.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik, Form, Field } from 'formik';\n\n3\n\n4 function validateEmail(value) {\n\n5   let error;\n\n6   if (!value) {\n\n7     error = 'Required';\n\n8   } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i.test(value)) {\n\n9     error = 'Invalid email address';\n\n10   }\n\n11   return error;\n\n12 }\n\n13\n\n14 function validateUsername(value) {\n\n15   let error;\n\n16   if (value === 'admin') {\n\n17     error = 'Nice try!';\n\n18   }\n\n19   return error;\n\n20 }\n\n21\n\n22 export const FieldLevelValidationExample = () => (\n\n23   <div>\n\n24     <h1>Signup</h1>\n\n25     <Formik\n\n26       initialValues={{\n\n27         username: '',\n\n28         email: '',\n\n29       }}\n\n30       onSubmit={values => {\n\n31         // same shape as initial values\n\n32         console.log(values);\n\n33       }}\n\n34     >\n\n35       {({ errors, touched, validateField, validateForm }) => (\n\n36         <Form>\n\n37           <Field name=\"email\" validate={validateEmail} />\n\n38           {errors.email && touched.email && <div>{errors.email}</div>}\n\n39\n\n40           <Field name=\"username\" validate={validateUsername} />\n\n41           {errors.username && touched.username && <div>{errors.username}</div>}\n\n42           {/** Trigger field-level validation\n\n43            imperatively */}\n\n44           <button type=\"button\" onClick={() => validateField('username')}>\n\n45             Check Username\n\n46           </button>\n\n47           {/** Trigger form-level validation\n\n48            imperatively */}\n\n49           <button\n\n50             type=\"button\"\n\n51             onClick={() => validateForm().then(() => console.log('blah'))}\n\n52           >\n\n53             Validate All\n\n54           </button>\n\n55           <button type=\"submit\">Submit</button>\n\n56         </Form>\n\n57       )}\n\n58     </Formik>\n\n59   </div>\n\n60 );\n```\n\n## When Does Validation Run?\n\nYou can control when Formik runs validation by changing the values of `<Formik validateOnChange>` and/or `<Formik validateOnBlur>` props depending on your needs. By default, Formik will run validation methods as follows:\n\n**After \"change\" events/methods** (things that update`values`)\n\n- `handleChange`\n- `setFieldValue`\n- `setValues`\n\n**After \"blur\" events/methods** (things that update `touched`)\n\n- `handleBlur`\n- `setTouched`\n- `setFieldTouched`\n\n**Whenever submission is attempted**\n\n- `handleSubmit`\n- `submitForm`\n\nThere are also imperative helper methods provided to you via Formik's render/injected props which you can use to imperatively call validation.\n\n- `validateForm`\n- `validateField`\n\n## Displaying Error Messages\n\nError messages are dependent on the form's validation. If an error exists, and the validation function produces an error object (as it should) with a matching shape to our values/initialValues, dependent field errors can be accessed from the errors object.\n\nCopy\n\n```\n1 import React from 'react';\n\n2 import { Formik, Form, Field } from 'formik';\n\n3 import * as Yup from 'yup';\n\n4\n\n5 const DisplayingErrorMessagesSchema = Yup.object().shape({\n\n6   username: Yup.string()\n\n7     .min(2, 'Too Short!')\n\n8     .max(50, 'Too Long!')\n\n9     .required('Required'),\n\n10   email: Yup.string().email('Invalid email').required('Required'),\n\n11 });\n\n12\n\n13 export const DisplayingErrorMessagesExample = () => (\n\n14   <div>\n\n15     <h1>Displaying Error Messages</h1>\n\n16     <Formik\n\n17       initialValues={{\n\n18         username: '',\n\n19         email: '',\n\n20       }}\n\n21       validationSchema={DisplayingErrorMessagesSchema}\n\n22       onSubmit={values => {\n\n23         // same shape as initial values\n\n24         console.log(values);\n\n25       }}\n\n26     >\n\n27       {({ errors, touched }) => (\n\n28         <Form>\n\n29           <Field name=\"username\" />\n\n30           {/* If this field has been touched, and it contains an error, display it\n\n31            */}\n\n32           {touched.username && errors.username && <div>{errors.username}</div>}\n\n33           <Field name=\"email\" />\n\n34           {/* If this field has been touched, and it contains an error, display\n\n35           it */}\n\n36           {touched.email && errors.email && <div>{errors.email}</div>}\n\n37           <button type=\"submit\">Submit</button>\n\n38         </Form>\n\n39       )}\n\n40     </Formik>\n\n41   </div>\n\n42 );\n```\n\n> The [ErrorMessage](/docs/api/errormessage) component can also be used to display error messages.\n\n## Frequently Asked Questions\n\nHow do I determine if my form is validating?\n\nIf `isValidating` prop is `true`\n\nCan I return `null` as an error message?\n\nNo. Use `undefined` instead. Formik uses `undefined` to represent empty states. If you use `null`, several parts of Formik's computed props (e.g. `isValid` for example), will not work as expected.\n\nHow do I test validation?\n\nFormik has extensive unit tests for Yup validation so you do not need to test that. However, if you are rolling your own validation functions, you should simply unit test those. If you do need to test Formik's execution you should use the imperative `validateForm` and `validateField` methods respectively.\n\n[PreviousMigrating from v1.x to v2.x](/docs/migrating-v2)[NextArrays](/docs/guides/arrays)\n\nWas this page helpful?\n\n![](/twemoji/1f62d.svg)![](/twemoji/1f615.svg)![](/twemoji/1f600.svg)![](/twemoji/1f929.svg)\n\n[Edit this page on GitHub](https://github.com/formik/formik/edit/main/docs/guides/validation.md)\n\n#### On this page",
  "tags": [
    "formik",
    "forms",
    "react"
  ],
  "extracted_at": "2026-02-03T12:50:22.463232+00:00",
  "content_length": 10955,
  "content_hash": "d4be045fc1131c3b"
}