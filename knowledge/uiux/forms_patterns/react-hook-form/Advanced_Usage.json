{
  "id": "react-hook-form__advanced-usage",
  "source_id": "react-hook-form",
  "source_name": "React Hook Form",
  "category": "forms_patterns",
  "url": "https://react-hook-form.com/advanced-usage",
  "title": "Advanced Usage",
  "content": "Accessibility (A11y)\nReact Hook Form has support for native form validation, which lets you validate inputs with your own rules. Since most of us have to build forms with custom designs and layouts, it is our responsibility to make sure those are accessible (A11y).\nThe following code example works as intended for validation; however, it can be improved for accessibility.\nCopy\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\n}\n=\nuseForm\n(\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nlabel htmlFor\n=\n\"name\"\n>\nName\n<\n/\nlabel\n>\n<\ninput\nid\n=\n\"name\"\n{\n...\nregister\n(\n\"name\"\n,\n{\nrequired\n:\ntrue\n,\nmaxLength\n:\n30\n}\n)\n}\n/\n>\n{\nerrors\n.\nname\n&&\nerrors\n.\nname\n.\ntype\n===\n\"required\"\n&&\n(\n<\nspan\n>\nThis\nis required\n<\n/\nspan\n>\n)\n}\n{\nerrors\n.\nname\n&&\nerrors\n.\nname\n.\ntype\n===\n\"maxLength\"\n&&\n(\n<\nspan\n>\nMax\nlength exceeded\n<\n/\nspan\n>\n)\n}\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nThe following code example is an improved version by leveraging\nARIA\n.\nCopy\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\n}\n=\nuseForm\n(\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nlabel htmlFor\n=\n\"name\"\n>\nName\n<\n/\nlabel\n>\n{\n/* use aria-invalid to indicate field contain error */\n}\n<\ninput\nid\n=\n\"name\"\naria\n-\ninvalid\n=\n{\nerrors\n.\nname\n?\n\"true\"\n:\n\"false\"\n}\n{\n...\nregister\n(\n\"name\"\n,\n{\nrequired\n:\ntrue\n,\nmaxLength\n:\n30\n}\n)\n}\n/\n>\n{\n/* use role=\"alert\" to announce the error message */\n}\n{\nerrors\n.\nname\n&&\nerrors\n.\nname\n.\ntype\n===\n\"required\"\n&&\n(\n<\nspan role\n=\n\"alert\"\n>\nThis\nis required\n<\n/\nspan\n>\n)\n}\n{\nerrors\n.\nname\n&&\nerrors\n.\nname\n.\ntype\n===\n\"maxLength\"\n&&\n(\n<\nspan role\n=\n\"alert\"\n>\nMax\nlength exceeded\n<\n/\nspan\n>\n)\n}\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nAfter this improvement, the screen reader will say:\n\u201cName, edit, invalid entry, This is required.\u201d\nWizard Form / Funnel\nIt's pretty common to collect user information through different pages and sections. We recommend using a state management library to store user input through different pages or sections. In this example, we are going to use\nlittle state machine\nas our state management library (you can replace it with\nredux\nif you are more familiar with it).\nStep 1:\nSet up your routes and store.\nCopy\nCodeSandbox\nJS\nimport\n{\nBrowserRouter\nas\nRouter\n,\nRoute\n}\nfrom\n\"react-router-dom\"\nimport\n{\nStateMachineProvider\n,\ncreateStore\n}\nfrom\n\"little-state-machine\"\nimport\nStep1\nfrom\n\"./Step1\"\nimport\nStep2\nfrom\n\"./Step2\"\nimport\nResult\nfrom\n\"./Result\"\ncreateStore\n(\n{\ndata\n:\n{\nfirstName\n:\n\"\"\n,\nlastName\n:\n\"\"\n,\n}\n,\n}\n)\nexport\ndefault\nfunction\nApp\n(\n)\n{\nreturn\n(\n<\nStateMachineProvider\n>\n<\nRouter\n>\n<\nRoute\nexact path\n=\n\"/\"\ncomponent\n=\n{\nStep1\n}\n/\n>\n<\nRoute\npath\n=\n\"/step2\"\ncomponent\n=\n{\nStep2\n}\n/\n>\n<\nRoute\npath\n=\n\"/result\"\ncomponent\n=\n{\nResult\n}\n/\n>\n<\n/\nRouter\n>\n<\n/\nStateMachineProvider\n>\n)\n}\nStep 2:\nCreate your pages, collect and submit the data to the store and push to the next form/page.\nCopy\nCodeSandbox\nJS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\nwithRouter\n}\nfrom\n\"react-router-dom\"\nimport\n{\nuseStateMachine\n}\nfrom\n\"little-state-machine\"\nimport\nupdateAction\nfrom\n\"./updateAction\"\nconst\nStep1\n=\n(\nprops\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n)\nconst\n{\nactions\n}\n=\nuseStateMachine\n(\n{\nupdateAction\n}\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\n{\nactions\n.\nupdateAction\n(\ndata\n)\nprops\n.\nhistory\n.\npush\n(\n\"./step2\"\n)\n}\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"firstName\"\n)\n}\n/\n>\n<\ninput\n{\n...\nregister\n(\n\"lastName\"\n)\n}\n/\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nexport\ndefault\nwithRouter\n(\nStep1\n)\nStep 3:\nMake your final submission with all the data in the store or display the resulting data.\nCopy\nCodeSandbox\nJS\nimport\n{\nuseStateMachine\n}\nfrom\n\"little-state-machine\"\nimport\nupdateAction\nfrom\n\"./updateAction\"\nconst\nResult\n=\n(\nprops\n)\n=>\n{\nconst\n{\nstate\n}\n=\nuseStateMachine\n(\nupdateAction\n)\nreturn\n<\npre\n>\n{\nJSON\n.\nstringify\n(\nstate\n,\nnull\n,\n2\n)\n}\n<\n/\npre\n>\n}\nFollowing the above pattern, you should be able to build a wizard form/funnel to collect user input data from multiple pages.\nSmart Form Component\nThis idea here is that you can easily compose your form with inputs. We are going to create a\nForm\ncomponent to automatically collect form data.\nCopy\nCodeSandbox\nJS\nimport\n{\nForm\n,\nInput\n,\nSelect\n}\nfrom\n\"./Components\"\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nreturn\n(\n<\nForm\nonSubmit\n=\n{\nonSubmit\n}\n>\n<\nInput\nname\n=\n\"firstName\"\n/\n>\n<\nInput\nname\n=\n\"lastName\"\n/\n>\n<\nSelect\nname\n=\n\"gender\"\noptions\n=\n{\n[\n\"female\"\n,\n\"male\"\n,\n\"other\"\n]\n}\n/\n>\n<\nInput\ntype\n=\n\"submit\"\nvalue\n=\n\"Submit\"\n/\n>\n<\n/\nForm\n>\n)\n}\nLet's have a look what's in each of these components.\n</> Form\nThe\nForm\ncomponent's responsibility is to inject all\nreact-hook-form\nmethods into the child component.\nCopy\nCodeSandbox\nJS\nimport\n{\nChildren\n,\ncreateElement\n}\nfrom\n\"react\"\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nForm\n(\n{\ndefaultValues\n,\nchildren\n,\nonSubmit\n}\n)\n{\nconst\nmethods\n=\nuseForm\n(\n{\ndefaultValues\n}\n)\nconst\n{\nhandleSubmit\n}\n=\nmethods\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n{\nChildren\n.\nmap\n(\nchildren\n,\n(\nchild\n)\n=>\n{\nreturn\nchild\n.\nprops\n.\nname\n?\ncreateElement\n(\nchild\n.\ntype\n,\n{\n...\n{\n...\nchild\n.\nprops\n,\nregister\n:\nmethods\n.\nregister\n,\nkey\n:\nchild\n.\nprops\n.\nname\n,\n}\n,\n}\n)\n:\nchild\n}\n)\n}\n<\n/\nform\n>\n)\n}\n</> Input / Select\nThose input components' responsibility is to register them into\nreact-hook-form\n.\nCopy\nCodeSandbox\nJS\nexport\nfunction\nInput\n(\n{\nregister\n,\nname\n,\n...\nrest\n}\n)\n{\nreturn\n<\ninput\n{\n...\nregister\n(\nname\n)\n}\n{\n...\nrest\n}\n/\n>\n}\nexport\nfunction\nSelect\n(\n{\nregister\n,\noptions\n,\nname\n,\n...\nrest\n}\n)\n{\nreturn\n(\n<\nselect\n{\n...\nregister\n(\nname\n)\n}\n{\n...\nrest\n}\n>\n{\noptions\n.\nmap\n(\n(\nvalue\n)\n=>\n(\n<\noption key\n=\n{\nvalue\n}\nvalue\n=\n{\nvalue\n}\n>\n{\nvalue\n}\n<\n/\noption\n>\n)\n)\n}\n<\n/\nselect\n>\n)\n}\nWith the\nForm\ncomponent injecting\nreact-hook-form\n's\nprops\ninto the child component, you can easily create and compose complex forms in your app.\nError Messages\nError messages are visual feedback to our users when there are issues with their inputs. React Hook Form provides an\nerrors\nobject to let you retrieve errors easily. There are several different ways to improve error presentation on the screen.\nRegister\nYou can simply pass the error message to\nregister\n, via the\nmessage\nattribute of the validation rule object, like this:\n<input {...register('test', { maxLength: { value: 2, message: \"error message\" } })} />\nOptional Chaining\nThe\n?.\noptional chaining\noperator permits reading the\nerrors\nobject without worrying about causing another error due to\nnull\nor\nundefined\n.\nerrors?.firstName?.message\nLodash\nget\nIf your project is using\nlodash\n, then you can leverage the lodash\nget\nfunction. Eg:\nget(errors, 'firstName.message')\nConnect Form\nWhen we are building forms, there are times when our input lives inside of deeply nested component trees, and that's when\nFormContext\ncomes in handy. However, we can further improve the Developer Experience by creating a\nConnectForm\ncomponent and leveraging React's\nrenderProps\n. The benefit is you can connect your input with React Hook Form much easier.\nCopy\nimport\n{\nFormProvider\n,\nuseForm\n,\nuseFormContext\n}\nfrom\n\"react-hook-form\"\nexport\nconst\nConnectForm\n=\n(\n{\nchildren\n}\n)\n=>\n{\nconst\nmethods\n=\nuseFormContext\n(\n)\nreturn\nchildren\n(\nmethods\n)\n}\nexport\nconst\nDeepNest\n=\n(\n)\n=>\n(\n<\nConnectForm\n>\n{\n(\n{\nregister\n}\n)\n=>\n<\ninput\n{\n...\nregister\n(\n\"deepNestedInput\"\n)\n}\n/\n>\n}\n<\n/\nConnectForm\n>\n)\nexport\nconst\nApp\n=\n(\n)\n=>\n{\nconst\nmethods\n=\nuseForm\n(\n)\nreturn\n(\n<\nFormProvider\n{\n...\nmethods\n}\n>\n<\nform\n>\n<\nDeepNest\n/\n>\n<\n/\nform\n>\n<\n/\nFormProvider\n>\n)\n}\nFormProvider Performance\nReact Hook Form's\nFormProvider\nis built upon\nReact's Context\nAPI. It solves the problem where data is passed through the component tree without having to pass props down manually at every level. This also causes the component tree to trigger a re-render when React Hook Form triggers a state update, but we can still optimise our App if required via the example below.\nNote:\nUsing React Hook Form's\nDevtools\nalongside\nFormProvider\ncan cause performance issues in some situations. Before diving deep in performance optimizations, consider this bottleneck first.\nCopy\nCodeSandbox\nJS\nimport\n{\nmemo\n}\nfrom\n\"react\"\nimport\n{\nuseForm\n,\nFormProvider\n,\nuseFormContext\n}\nfrom\n\"react-hook-form\"\n// we can use React.memo to prevent re-render except isDirty state changed\nconst\nNestedInput\n=\nmemo\n(\n(\n{\nregister\n,\nformState\n:\n{\nisDirty\n}\n}\n)\n=>\n(\n<\ndiv\n>\n<\ninput\n{\n...\nregister\n(\n\"test\"\n)\n}\n/\n>\n{\nisDirty\n&&\n<\np\n>\nThis\nfield is dirty\n<\n/\np\n>\n}\n<\n/\ndiv\n>\n)\n,\n(\nprevProps\n,\nnextProps\n)\n=>\nprevProps\n.\nformState\n.\nisDirty\n===\nnextProps\n.\nformState\n.\nisDirty\n)\nexport\nconst\nNestedInputContainer\n=\n(\n{\nchildren\n}\n)\n=>\n{\nconst\nmethods\n=\nuseFormContext\n(\n)\nreturn\n<\nNestedInput\n{\n...\nmethods\n}\n/\n>\n}\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\nmethods\n=\nuseForm\n(\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nconsole\n.\nlog\n(\nmethods\n.\nformState\n.\nisDirty\n)\n// make sure formState is read before render to enable the Proxy\nreturn\n(\n<\nFormProvider\n{\n...\nmethods\n}\n>\n<\nform onSubmit\n=\n{\nmethods\n.\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nNestedInputContainer\n/\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n<\n/\nFormProvider\n>\n)\n}\nControlled mixed with Uncontrolled Components\nReact Hook Form embraces uncontrolled components but is also compatible with controlled components. Most UI libraries are built to support only controlled components, such as\nMUI\nand\nAntd\n. But with React Hook Form, the re-rendering of controlled components are also optimized. Here is an example that combines them both with validation.\nController\nCustom Register\nCopy\nimport\n{\nInput\n,\nSelect\n,\nMenuItem\n}\nfrom\n\"@material-ui/core\"\nimport\n{\nuseForm\n,\nController\n}\nfrom\n\"react-hook-form\"\nconst\ndefaultValues\n=\n{\nselect\n:\n\"\"\n,\ninput\n:\n\"\"\n,\n}\nfunction\nApp\n(\n)\n{\nconst\n{\nhandleSubmit\n,\nreset\n,\ncontrol\n,\nregister\n}\n=\nuseForm\n(\n{\ndefaultValues\n,\n}\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nController\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\n(\n<\nSelect\n{\n...\nfield\n}\n>\n<\nMenuItem\nvalue\n=\n{\n10\n}\n>\nTen\n<\n/\nMenuItem\n>\n<\nMenuItem\nvalue\n=\n{\n20\n}\n>\nTwenty\n<\n/\nMenuItem\n>\n<\n/\nSelect\n>\n)\n}\ncontrol\n=\n{\ncontrol\n}\nname\n=\n\"select\"\ndefaultValue\n=\n{\n10\n}\n/\n>\n<\nInput\n{\n...\nregister\n(\n\"input\"\n)\n}\n/\n>\n<\nbutton type\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nreset\n(\n{\n...\ndefaultValues\n}\n)\n}\n>\nReset\n<\n/\nbutton\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nCopy\nCodeSandbox\nJS\nimport\n{\nuseEffect\n}\nfrom\n\"react\"\nimport\n{\nInput\n,\nSelect\n,\nMenuItem\n}\nfrom\n\"@material-ui/core\"\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nconst\ndefaultValues\n=\n{\nselect\n:\n\"\"\n,\ninput\n:\n\"\"\n,\n}\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nsetValue\n,\nreset\n,\nwatch\n}\n=\nuseForm\n(\n{\ndefaultValues\n,\n}\n)\nconst\nselectValue\n=\nwatch\n(\n\"select\"\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nuseEffect\n(\n(\n)\n=>\n{\nregister\n(\n\"select\"\n)\n}\n,\n[\nregister\n]\n)\nconst\nhandleChange\n=\n(\ne\n)\n=>\nsetValue\n(\n\"select\"\n,\ne\n.\ntarget\n.\nvalue\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nSelect\nvalue\n=\n{\nselectValue\n}\nonChange\n=\n{\nhandleChange\n}\n>\n<\nMenuItem\nvalue\n=\n{\n10\n}\n>\nTen\n<\n/\nMenuItem\n>\n<\nMenuItem\nvalue\n=\n{\n20\n}\n>\nTwenty\n<\n/\nMenuItem\n>\n<\n/\nSelect\n>\n<\nInput\n{\n...\nregister\n(\n\"input\"\n)\n}\n/\n>\n<\nbutton type\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nreset\n(\n{\n...\ndefaultValues\n}\n)\n}\n>\nReset\n<\n/\nbutton\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nCustom Hook with Resolver\nYou can build a custom hook as a resolver. A custom hook can easily integrate with yup/Joi/Superstruct as a validation method, and to be used inside validation resolver.\nDefine a memorized validation schema (or define it outside your component if you don't have any dependencies)\nUse the custom hook, by passing the validation schema\nPass the validation resolver to the useForm hook\nCopy\nCodeSandbox\nJS\nimport\n{\nuseCallback\n}\nfrom\n\"react\"\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n*\nas\nyup\nfrom\n\"yup\"\nconst\nuseYupValidationResolver\n=\n(\nvalidationSchema\n)\n=>\nuseCallback\n(\nasync\n(\ndata\n)\n=>\n{\ntry\n{\nconst\nvalues\n=\nawait\nvalidationSchema\n.\nvalidate\n(\ndata\n,\n{\nabortEarly\n:\nfalse\n,\n}\n)\nreturn\n{\nvalues\n,\nerrors\n:\n{\n}\n,\n}\n}\ncatch\n(\nerrors\n)\n{\nreturn\n{\nvalues\n:\n{\n}\n,\nerrors\n:\nerrors\n.\ninner\n.\nreduce\n(\n(\nallErrors\n,\ncurrentError\n)\n=>\n(\n{\n...\nallErrors\n,\n[\ncurrentError\n.\npath\n]\n:\n{\ntype\n:\ncurrentError\n.\ntype\n??\n\"validation\"\n,\nmessage\n:\ncurrentError\n.\nmessage\n,\n}\n,\n}\n)\n,\n{\n}\n)\n,\n}\n}\n}\n,\n[\nvalidationSchema\n]\n)\nconst\nvalidationSchema\n=\nyup\n.\nobject\n(\n{\nfirstName\n:\nyup\n.\nstring\n(\n)\n.\nrequired\n(\n\"Required\"\n)\n,\nlastName\n:\nyup\n.\nstring\n(\n)\n.\nrequired\n(\n\"Required\"\n)\n,\n}\n)\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\nresolver\n=\nuseYupValidationResolver\n(\nvalidationSchema\n)\nconst\n{\nhandleSubmit\n,\nregister\n}\n=\nuseForm\n(\n{\nresolver\n}\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"firstName\"\n)\n}\n/\n>\n<\ninput\n{\n...\nregister\n(\n\"lastName\"\n)\n}\n/\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\nWorking with virtualized lists\nImagine a scenario where you have a table of data. This table might contain hundreds or thousands of rows, and each row will have inputs. A common practice is to only render the items that are in the viewport, however this will cause issues as the items are removed from the DOM when they are out of view and re-added. This will cause items to reset to their default values when they re-enter the viewport.\nAn example is shown below using\nreact-window\n.\nForm\nField Array\nCopy\nCodeSandbox\nJS\nimport\n{\nmemo\n}\nfrom\n\"react\"\nimport\n{\nFormProvider\n,\nuseForm\n,\nuseFormContext\n}\nfrom\n\"react-hook-form\"\nimport\n{\nVariableSizeList\nas\nList\n}\nfrom\n\"react-window\"\nimport\nAutoSizer\nfrom\n\"react-virtualized-auto-sizer\"\nconst\nitems\n=\nArray\n.\nfrom\n(\nArray\n(\n1000\n)\n.\nkeys\n(\n)\n)\n.\nmap\n(\n(\ni\n)\n=>\n(\n{\ntitle\n:\n`\nList\n${\ni\n}\n`\n,\nquantity\n:\nMath\n.\nfloor\n(\nMath\n.\nrandom\n(\n)\n*\n10\n)\n,\n}\n)\n)\nconst\nWindowedRow\n=\nmemo\n(\n(\n{\nindex\n,\nstyle\n,\ndata\n}\n)\n=>\n{\nconst\n{\nregister\n}\n=\nuseFormContext\n(\n)\nreturn\n(\n<\ndiv style\n=\n{\nstyle\n}\n>\n<\nlabel\n>\n{\ndata\n[\nindex\n]\n.\ntitle\n}\n<\n/\nlabel\n>\n<\ninput\n{\n...\nregister\n(\n`\n${\nindex\n}\n.quantity\n`\n)\n}\n/\n>\n<\n/\ndiv\n>\n)\n}\n)\nexport\nconst\nApp\n=\n(\n)\n=>\n{\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nconst\nmethods\n=\nuseForm\n(\n{\ndefaultValues\n:\nitems\n}\n)\nreturn\n(\n<\nform onSubmit\n=\n{\nmethods\n.\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nFormProvider\n{\n...\nmethods\n}\n>\n<\nAutoSizer\n>\n{\n(\n{\nheight\n,\nwidth\n}\n)\n=>\n(\n<\nList\nheight\n=\n{\nheight\n}\nitemCount\n=\n{\nitems\n.\nlength\n}\nitemSize\n=\n{\n(\n)\n=>\n100\n}\nwidth\n=\n{\nwidth\n}\nitemData\n=\n{\nitems\n}\n>\n{\nWindowedRow\n}\n<\n/\nList\n>\n)\n}\n<\n/\nAutoSizer\n>\n<\n/\nFormProvider\n>\n<\nbutton type\n=\n\"submit\"\n>\nSubmit\n<\n/\nbutton\n>\n<\n/\nform\n>\n)\n}\nCopy\nCodeSandbox\nJS\nimport\n{\nFixedSizeList\n}\nfrom\n\"react-window\"\nimport\n{\nController\n,\nuseFieldArray\n,\nuseForm\n}\nfrom\n\"react-hook-form\"\nconst\nitems\n=\nArray\n.\nfrom\n(\nArray\n(\n1000\n)\n.\nkeys\n(\n)\n)\n.\nmap\n(\n(\ni\n)\n=>\n(\n{\ntitle\n:\n`\nList\n${\ni\n}\n`\n,\nquantity\n:\nMath\n.\nfloor\n(\nMath\n.\nrandom\n(\n)\n*\n10\n)\n,\n}\n)\n)\nfunction\nApp\n(\n)\n{\nconst\n{\ncontrol\n,\ngetValues\n}\n=\nuseForm\n(\n{\ndefaultValues\n:\n{\ntest\n:\nitems\n,\n}\n,\n}\n)\nconst\n{\nfields\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n\"test\"\n}\n)\nreturn\n(\n<\nFixedSizeList\nwidth\n=\n{\n400\n}\nheight\n=\n{\n500\n}\nitemSize\n=\n{\n40\n}\nitemCount\n=\n{\nfields\n.\nlength\n}\nitemData\n=\n{\nfields\n}\nitemKey\n=\n{\n(\ni\n)\n=>\nfields\n[\ni\n]\n.\nid\n}\n>\n{\n(\n{\nstyle\n,\nindex\n,\ndata\n}\n)\n=>\n{\nconst\ndefaultValue\n=\ngetValues\n(\n)\n[\n\"test\"\n]\n[\nindex\n]\n.\nquantity\n??\ndata\n[\nindex\n]\n.\nquantity\nreturn\n(\n<\nform style\n=\n{\nstyle\n}\n>\n<\nController\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\n<\ninput\n{\n...\nfield\n}\n/\n>\n}\nname\n=\n{\n`\ntest[\n${\nindex\n}\n].quantity\n`\n}\ndefaultValue\n=\n{\ndefaultValue\n}\ncontrol\n=\n{\ncontrol\n}\n/\n>\n<\n/\nform\n>\n)\n}\n}\n<\n/\nFixedSizeList\n>\n)\n}\nTesting Form\nTesting is very important because it prevents your code from having bugs or mistakes. It also guarantees code safety when refactoring the codebase.\nWe recommend using\ntesting-library\n, because it is simple and tests are more focused on user behavior.\nStep 1:\nSet up your testing environment.\nPlease install\n@testing-library/jest-dom\nwith the latest version of\njest\n, because react-hook-form uses\nMutationObserver\nto detect inputs, and to get unmounted from the DOM.\nNote:\nIf you are using React Native, you don't need to install\n@testing-library/jest-dom\n.\nCopy\nnpm install -D @testing-library/jest-dom\nCreate\nsetup.js\nto import\n@testing-library/jest-dom\n.\nCopy\nCodeSandbox\nJS\nimport\n\"@testing-library/jest-dom\"\nNote:\nIf you are using React Native, you need to create setup.js, define\nwindow\nobject, and include the following lines in the setup file:\nCopy\nglobal\n.\nwindow\n=\n{\n}\nglobal\n.\nwindow\n=\nglobal\nFinally, you have to update\nsetup.js\nin\njest.config.js\nto include the file.\nCopy\nCodeSandbox\nJS\nmodule\n.\nexports\n=\n{\nsetupFilesAfterEnv\n:\n[\n\"<rootDir>/setup.js\"\n]\n,\n// or .ts for TypeScript App\n// ...other settings\n}\nAdditionally, you can set up\neslint-plugin-testing-library\nand\neslint-plugin-jest-dom\nto follow best practices and anticipate common mistakes when writing your tests.\nStep 2:\nCreate login form.\nWe have set the role attribute accordingly. These attributes are helpful for when you write tests, and they improve accessibility. For more information, you can refer to the\ntesting-library\ndocumentation.\nCopy\nCodeSandbox\nJS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nApp\n(\n{\nlogin\n}\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\nreset\n,\n}\n=\nuseForm\n(\n)\nconst\nonSubmit\n=\nasync\n(\ndata\n)\n=>\n{\nawait\nlogin\n(\ndata\n.\nemail\n,\ndata\n.\npassword\n)\nreset\n(\n)\n}\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nlabel htmlFor\n=\n\"email\"\n>\nemail\n<\n/\nlabel\n>\n<\ninput\nid\n=\n\"email\"\n{\n...\nregister\n(\n\"email\"\n,\n{\nrequired\n:\n\"required\"\n,\npattern\n:\n{\nvalue\n:\n/\n\\S\n+\n@\n\\S\n+\n\\.\n\\S\n+\n/\n,\nmessage\n:\n\"Entered value does not match email format\"\n,\n}\n,\n}\n)\n}\ntype\n=\n\"email\"\n/\n>\n{\nerrors\n.\nemail\n&&\n<\nspan role\n=\n\"alert\"\n>\n{\nerrors\n.\nemail\n.\nmessage\n}\n<\n/\nspan\n>\n}\n<\nlabel htmlFor\n=\n\"password\"\n>\npassword\n<\n/\nlabel\n>\n<\ninput\nid\n=\n\"password\"\n{\n...\nregister\n(\n\"password\"\n,\n{\nrequired\n:\n\"required\"\n,\nminLength\n:\n{\nvalue\n:\n5\n,\nmessage\n:\n\"min length is 5\"\n,\n}\n,\n}\n)\n}\ntype\n=\n\"password\"\n/\n>\n{\nerrors\n.\npassword\n&&\n<\nspan role\n=\n\"alert\"\n>\n{\nerrors\n.\npassword\n.\nmessage\n}\n<\n/\nspan\n>\n}\n<\nbutton type\n=\n\"submit\"\n>\nSUBMIT\n<\n/\nbutton\n>\n<\n/\nform\n>\n)\n}\nStep 3:\nWrite tests.\nThe following criteria are what we try to cover with the tests:\nTest submission failure.\nWe are using\nwaitFor\nutil and\nfind*\nqueries to detect submission feedback, because the\nhandleSubmit\nmethod is executed asynchronously.\nTest validation associated with each inputs.\nWe are using the\n*ByRole\nmethod when querying different elements because that's how users recognize your UI component.\nTest successful submission.\nCopy\nCodeSandbox\nJS\nimport\n{\nrender\n,\nscreen\n,\nfireEvent\n,\nwaitFor\n}\nfrom\n\"@testing-library/react\"\nimport\nApp\nfrom\n\"./App\"\nconst\nmockLogin\n=\njest\n.\nfn\n(\n(\nemail\n,\npassword\n)\n=>\n{\nreturn\nPromise\n.\nresolve\n(\n{\nemail\n,\npassword\n}\n)\n}\n)\nit\n(\n\"should display required error when value is invalid\"\n,\nasync\n(\n)\n=>\n{\nrender\n(\n<\nApp\nlogin\n=\n{\nmockLogin\n}\n/\n>\n)\nfireEvent\n.\nsubmit\n(\nscreen\n.\ngetByRole\n(\n\"button\"\n)\n)\nexpect\n(\nawait\nscreen\n.\nfindAllByRole\n(\n\"alert\"\n)\n)\n.\ntoHaveLength\n(\n2\n)\nexpect\n(\nmockLogin\n)\n.\nnot\n.\ntoBeCalled\n(\n)\n}\n)\nit\n(\n\"should display matching error when email is invalid\"\n,\nasync\n(\n)\n=>\n{\nrender\n(\n<\nApp\nlogin\n=\n{\nmockLogin\n}\n/\n>\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"test\"\n,\n}\n,\n}\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"password\"\n,\n}\n,\n}\n)\nfireEvent\n.\nsubmit\n(\nscreen\n.\ngetByRole\n(\n\"button\"\n)\n)\nexpect\n(\nawait\nscreen\n.\nfindAllByRole\n(\n\"alert\"\n)\n)\n.\ntoHaveLength\n(\n1\n)\nexpect\n(\nmockLogin\n)\n.\nnot\n.\ntoBeCalled\n(\n)\nexpect\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n)\n.\ntoHaveValue\n(\n\"test\"\n)\nexpect\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n)\n.\ntoHaveValue\n(\n\"password\"\n)\n}\n)\nit\n(\n\"should display min length error when password is invalid\"\n,\nasync\n(\n)\n=>\n{\nrender\n(\n<\nApp\nlogin\n=\n{\nmockLogin\n}\n/\n>\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"test@mail.com\"\n,\n}\n,\n}\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"pass\"\n,\n}\n,\n}\n)\nfireEvent\n.\nsubmit\n(\nscreen\n.\ngetByRole\n(\n\"button\"\n)\n)\nexpect\n(\nawait\nscreen\n.\nfindAllByRole\n(\n\"alert\"\n)\n)\n.\ntoHaveLength\n(\n1\n)\nexpect\n(\nmockLogin\n)\n.\nnot\n.\ntoBeCalled\n(\n)\nexpect\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n)\n.\ntoHaveValue\n(\n\"test@mail.com\"\n)\nexpect\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n)\n.\ntoHaveValue\n(\n\"pass\"\n)\n}\n)\nit\n(\n\"should not display error when value is valid\"\n,\nasync\n(\n)\n=>\n{\nrender\n(\n<\nApp\nlogin\n=\n{\nmockLogin\n}\n/\n>\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"test@mail.com\"\n,\n}\n,\n}\n)\nfireEvent\n.\ninput\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n,\n{\ntarget\n:\n{\nvalue\n:\n\"password\"\n,\n}\n,\n}\n)\nfireEvent\n.\nsubmit\n(\nscreen\n.\ngetByRole\n(\n\"button\"\n)\n)\nawait\nwaitFor\n(\n(\n)\n=>\nexpect\n(\nscreen\n.\nqueryAllByRole\n(\n\"alert\"\n)\n)\n.\ntoHaveLength\n(\n0\n)\n)\nexpect\n(\nmockLogin\n)\n.\ntoBeCalledWith\n(\n\"test@mail.com\"\n,\n\"password\"\n)\nexpect\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n,\n{\nname\n:\n/\nemail\n/\ni\n}\n)\n)\n.\ntoHaveValue\n(\n\"\"\n)\nexpect\n(\nscreen\n.\ngetByLabelText\n(\n\"password\"\n)\n)\n.\ntoHaveValue\n(\n\"\"\n)\n}\n)\nResolving act warning during test\nIf you test a component that uses react-hook-form, you might run into a warning like this, even if you didn't write any asynchronous code for that component:\nWarning: An update to MyComponent inside a test was not wrapped in act(...)\nCopy\nCodeSandbox\nJS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\nmode\n:\n\"onChange\"\n,\n}\n)\nconst\nonSubmit\n=\n(\ndata\n)\n=>\n{\n}\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"answer\"\n,\n{\nrequired\n:\ntrue\n,\n}\n)\n}\n/\n>\n<\nbutton type\n=\n\"submit\"\n>\nSUBMIT\n<\n/\nbutton\n>\n<\n/\nform\n>\n)\n}\nCopy\nCodeSandbox\nJS\nimport\n{\nrender\n,\nscreen\n}\nfrom\n\"@testing-library/react\"\nimport\nApp\nfrom\n\"./App\"\nit\n(\n\"should have a submit button\"\n,\n(\n)\n=>\n{\nrender\n(\n<\nApp\n/\n>\n)\nexpect\n(\nscreen\n.\ngetByText\n(\n\"SUBMIT\"\n)\n)\n.\ntoBeInTheDocument\n(\n)\n}\n)\nIn this example, there is a simple form without any apparent async code, and the test merely renders the component and tests for the presence of a button. However, it still logs the warning about updates not being wrapped in\nact()\n.\nThis is because react-hook-form internally uses asynchronous validation handlers. In order to compute the formState, it has to initially validate the form, which is done asynchronously, resulting in another render. That update happens after the test function returns, which triggers the warning.\nTo solve this, wait until some element from your UI appears with\nfind*\nqueries. Note that you\nmust not\nwrap your\nrender()\ncalls in\nact()\n.\nYou can read more about wrapping things in\nact\nunnecessarily here\n.\nCopy\nCodeSandbox\nJS\nimport\n{\nrender\n,\nscreen\n}\nfrom\n\"@testing-library/react\"\nimport\nApp\nfrom\n\"./App\"\nit\n(\n\"should have a submit button\"\n,\nasync\n(\n)\n=>\n{\nrender\n(\n<\nApp\n/\n>\n)\nexpect\n(\nawait\nscreen\n.\nfindByText\n(\n\"SUBMIT\"\n)\n)\n.\ntoBeInTheDocument\n(\n)\n// Now that the UI was awaited until the async behavior was completed,\n// you can keep asserting with `get*` queries.\nexpect\n(\nscreen\n.\ngetByRole\n(\n\"textbox\"\n)\n)\n.\ntoBeInTheDocument\n(\n)\n}\n)\nTransform and Parse\nThe native input returns the value in\nstring\nformat unless invoked with\nvalueAsNumber\nor\nvalueAsDate\n, you can read more under\nthis section\n. However, it's not perfect. We still have to deal with\nisNaN\nor\nnull\nvalues. So it's better to leave the transform at the custom hook level. In the following example, we are using the\nController\nto include the functionality of the transform value's input and output. You can also achieve a similar result with a custom\nregister\n.\nCopy\nCodeSandbox\nJS\nimport\n{\nController\n}\nfrom\n\"react-hook-form\"\nconst\nControllerPlus\n=\n(\n{\ncontrol\n,\ntransform\n,\nname\n,\ndefaultValue\n}\n)\n=>\n(\n<\nController\ndefaultValue\n=\n{\ndefaultValue\n}\ncontrol\n=\n{\ncontrol\n}\nname\n=\n{\nname\n}\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\n(\n<\ninput\nonChange\n=\n{\n(\ne\n)\n=>\nfield\n.\nonChange\n(\ntransform\n.\noutput\n(\ne\n)\n)\n}\nvalue\n=\n{\ntransform\n.\ninput\n(\nfield\n.\nvalue\n)\n}\n/\n>\n)\n}\n/\n>\n)\n// usage below:\n<\nControllerPlus\ntransform\n=\n{\n{\ninput\n:\n(\nvalue\n)\n=>\n(\nisNaN\n(\nvalue\n)\n||\nvalue\n===\n0\n?\n\"\"\n:\nvalue\n.\ntoString\n(\n)\n)\n,\noutput\n:\n(\ne\n)\n=>\n{\nconst\noutput\n=\nparseInt\n(\ne\n.\ntarget\n.\nvalue\n,\n10\n)\nreturn\nisNaN\n(\noutput\n)\n?\n0\n:\noutput\n}\n,\n}\n}\ncontrol\n=\n{\ncontrol\n}\nname\n=\n\"number\"\ndefaultValue\n=\n\"\"\n/\n>\nThank you for your support\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\nStar us on GitHub",
  "content_markdown": "## Accessibility (A11y)\n\nReact Hook Form has support for native form validation, which lets you validate inputs with your own rules. Since most of us have to build forms with custom designs and layouts, it is our responsibility to make sure those are accessible (A11y).\n\nThe following code example works as intended for validation; however, it can be improved for accessibility.\n\nCopy\n\n```\nimport { useForm } from \"react-hook-form\"\n\nexport default function App() {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\n} = useForm()\n\nconst onSubmit = (data) => console.log(data)\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<label htmlFor=\"name\">Name</label>\n\n<input\n\nid=\"name\"\n\n{...register(\"name\", { required: true, maxLength: 30 })}\n\n/>\n\n{errors.name && errors.name.type === \"required\" && (\n\n<span>This is required</span>\n\n)}\n\n{errors.name && errors.name.type === \"maxLength\" && (\n\n<span>Max length exceeded</span>\n\n)}\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nThe following code example is an improved version by leveraging [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA).\n\nCopy\n\n```\nimport { useForm } from \"react-hook-form\"\n\nexport default function App() {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\n} = useForm()\n\nconst onSubmit = (data) => console.log(data)\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<label htmlFor=\"name\">Name</label>\n\n{/* use aria-invalid to indicate field contain error */}\n\n<input\n\nid=\"name\"\n\naria-invalid={errors.name ? \"true\" : \"false\"}\n\n{...register(\"name\", { required: true, maxLength: 30 })}\n\n/>\n\n{/* use role=\"alert\" to announce the error message */}\n\n{errors.name && errors.name.type === \"required\" && (\n\n<span role=\"alert\">This is required</span>\n\n)}\n\n{errors.name && errors.name.type === \"maxLength\" && (\n\n<span role=\"alert\">Max length exceeded</span>\n\n)}\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nAfter this improvement, the screen reader will say: *\u201cName, edit, invalid entry, This is required.\u201d*\n\n---\n\n## Wizard Form / Funnel\n\nIt's pretty common to collect user information through different pages and sections. We recommend using a state management library to store user input through different pages or sections. In this example, we are going to use [little state machine](https://github.com/bluebill1049/little-state-machine) as our state management library (you can replace it with [redux](https://github.com/reduxjs/redux) if you are more familiar with it).\n\n**Step 1:** Set up your routes and store.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-wizard-form-9pg6j)\n\n```\nimport { BrowserRouter as Router, Route } from \"react-router-dom\"\n\nimport { StateMachineProvider, createStore } from \"little-state-machine\"\n\nimport Step1 from \"./Step1\"\n\nimport Step2 from \"./Step2\"\n\nimport Result from \"./Result\"\n\ncreateStore({\n\ndata: {\n\nfirstName: \"\",\n\nlastName: \"\",\n\n},\n\n})\n\nexport default function App() {\n\nreturn (\n\n<StateMachineProvider>\n\n<Router>\n\n<Route exact path=\"/\" component={Step1} />\n\n<Route path=\"/step2\" component={Step2} />\n\n<Route path=\"/result\" component={Result} />\n\n</Router>\n\n</StateMachineProvider>\n\n)\n\n}\n```\n\n**Step 2:** Create your pages, collect and submit the data to the store and push to the next form/page.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-wizard-form-9pg6j)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nimport { withRouter } from \"react-router-dom\"\n\nimport { useStateMachine } from \"little-state-machine\"\n\nimport updateAction from \"./updateAction\"\n\nconst Step1 = (props) => {\n\nconst { register, handleSubmit } = useForm()\n\nconst { actions } = useStateMachine({ updateAction })\n\nconst onSubmit = (data) => {\n\nactions.updateAction(data)\n\nprops.history.push(\"./step2\")\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<input {...register(\"firstName\")} />\n\n<input {...register(\"lastName\")} />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n\nexport default withRouter(Step1)\n```\n\n**Step 3:** Make your final submission with all the data in the store or display the resulting data.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-wizard-form-9pg6j)\n\n```\nimport { useStateMachine } from \"little-state-machine\"\n\nimport updateAction from \"./updateAction\"\n\nconst Result = (props) => {\n\nconst { state } = useStateMachine(updateAction)\n\nreturn <pre>{JSON.stringify(state, null, 2)}</pre>\n\n}\n```\n\nFollowing the above pattern, you should be able to build a wizard form/funnel to collect user input data from multiple pages.\n\n---\n\n## Smart Form Component\n\nThis idea here is that you can easily compose your form with inputs. We are going to create a `Form` component to automatically collect form data.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-smart-form-component-forked-iq89z)\n\n```\nimport { Form, Input, Select } from \"./Components\"\n\nexport default function App() {\n\nconst onSubmit = (data) => console.log(data)\n\nreturn (\n\n<Form onSubmit={onSubmit}>\n\n<Input name=\"firstName\" />\n\n<Input name=\"lastName\" />\n\n<Select name=\"gender\" options={[\"female\", \"male\", \"other\"]} />\n\n<Input type=\"submit\" value=\"Submit\" />\n\n</Form>\n\n)\n\n}\n```\n\nLet's have a look what's in each of these components.\n\n`</> Form`\n\nThe `Form` component's responsibility is to inject all `react-hook-form` methods into the child component.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-smart-form-component-forked-iq89z)\n\n```\nimport { Children, createElement } from \"react\"\n\nimport { useForm } from \"react-hook-form\"\n\nexport default function Form({ defaultValues, children, onSubmit }) {\n\nconst methods = useForm({ defaultValues })\n\nconst { handleSubmit } = methods\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n{Children.map(children, (child) => {\n\nreturn child.props.name\n\n? createElement(child.type, {\n\n...{\n\n...child.props,\n\nregister: methods.register,\n\nkey: child.props.name,\n\n},\n\n})\n\n: child\n\n})}\n\n</form>\n\n)\n\n}\n```\n\n`</> Input / Select`\n\nThose input components' responsibility is to register them into `react-hook-form`.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-smart-form-component-forked-iq89z)\n\n```\nexport function Input({ register, name, ...rest }) {\n\nreturn <input {...register(name)} {...rest} />\n\n}\n\nexport function Select({ register, options, name, ...rest }) {\n\nreturn (\n\n<select {...register(name)} {...rest}>\n\n{options.map((value) => (\n\n<option key={value} value={value}>\n\n{value}\n\n</option>\n\n))}\n\n</select>\n\n)\n\n}\n```\n\nWith the `Form` component injecting `react-hook-form`'s `props` into the child component, you can easily create and compose complex forms in your app.\n\n---\n\n## Error Messages\n\nError messages are visual feedback to our users when there are issues with their inputs. React Hook Form provides an `errors` object to let you retrieve errors easily. There are several different ways to improve error presentation on the screen.\n\n- #### Register\n\n  You can simply pass the error message to `register`, via the `message` attribute of the validation rule object, like this:\n\n  `<input {...register('test', { maxLength: { value: 2, message: \"error message\" } })} />`\n- #### Optional Chaining\n\n  The `?.` [optional chaining](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) operator permits reading the `errors` object without worrying about causing another error due to `null` or `undefined`.\n\n  `errors?.firstName?.message`\n- #### Lodash `get`\n\n  If your project is using [lodash](https://lodash.com), then you can leverage the lodash [get](https://lodash.com/docs/4.17.15#get) function. Eg:\n\n  `get(errors, 'firstName.message')`\n\n---\n\n## Connect Form\n\nWhen we are building forms, there are times when our input lives inside of deeply nested component trees, and that's when [FormContext](/docs/useformcontext) comes in handy. However, we can further improve the Developer Experience by creating a `ConnectForm` component and leveraging React's [renderProps](https://reactjs.org/docs/render-props.html). The benefit is you can connect your input with React Hook Form much easier.\n\nCopy\n\n```\nimport { FormProvider, useForm, useFormContext } from \"react-hook-form\"\n\nexport const ConnectForm = ({ children }) => {\n\nconst methods = useFormContext()\n\nreturn children(methods)\n\n}\n\nexport const DeepNest = () => (\n\n<ConnectForm>\n\n{({ register }) => <input {...register(\"deepNestedInput\")} />}\n\n</ConnectForm>\n\n)\n\nexport const App = () => {\n\nconst methods = useForm()\n\nreturn (\n\n<FormProvider {...methods}>\n\n<form>\n\n<DeepNest />\n\n</form>\n\n</FormProvider>\n\n)\n\n}\n```\n\n---\n\n## FormProvider Performance\n\nReact Hook Form's [FormProvider](/docs/formprovider) is built upon [React's Context](https://react.dev/learn/passing-data-deeply-with-context) API. It solves the problem where data is passed through the component tree without having to pass props down manually at every level. This also causes the component tree to trigger a re-render when React Hook Form triggers a state update, but we can still optimise our App if required via the example below.\n\n**Note:** Using React Hook Form's [Devtools](/dev-tools) alongside [FormProvider](/docs/formprovider) can cause performance issues in some situations. Before diving deep in performance optimizations, consider this bottleneck first.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/provider-perf-forked-r24ho)\n\n```\nimport { memo } from \"react\"\n\nimport { useForm, FormProvider, useFormContext } from \"react-hook-form\"\n\n// we can use React.memo to prevent re-render except isDirty state changed\n\nconst NestedInput = memo(\n\n({ register, formState: { isDirty } }) => (\n\n<div>\n\n<input {...register(\"test\")} />\n\n{isDirty && <p>This field is dirty</p>}\n\n</div>\n\n),\n\n(prevProps, nextProps) =>\n\nprevProps.formState.isDirty === nextProps.formState.isDirty\n\n)\n\nexport const NestedInputContainer = ({ children }) => {\n\nconst methods = useFormContext()\n\nreturn <NestedInput {...methods} />\n\n}\n\nexport default function App() {\n\nconst methods = useForm()\n\nconst onSubmit = (data) => console.log(data)\n\nconsole.log(methods.formState.isDirty) // make sure formState is read before render to enable the Proxy\n\nreturn (\n\n<FormProvider {...methods}>\n\n<form onSubmit={methods.handleSubmit(onSubmit)}>\n\n<NestedInputContainer />\n\n<input type=\"submit\" />\n\n</form>\n\n</FormProvider>\n\n)\n\n}\n```\n\n---\n\n## Controlled mixed with Uncontrolled Components\n\nReact Hook Form embraces uncontrolled components but is also compatible with controlled components. Most UI libraries are built to support only controlled components, such as [MUI](https://github.com/mui/material-ui) and [Antd](https://github.com/ant-design/ant-design). But with React Hook Form, the re-rendering of controlled components are also optimized. Here is an example that combines them both with validation.\n\nControllerCustom Register\n\nCopy\n\n```\nimport { Input, Select, MenuItem } from \"@material-ui/core\"\n\nimport { useForm, Controller } from \"react-hook-form\"\n\nconst defaultValues = {\n\nselect: \"\",\n\ninput: \"\",\n\n}\n\nfunction App() {\n\nconst { handleSubmit, reset, control, register } = useForm({\n\ndefaultValues,\n\n})\n\nconst onSubmit = (data) => console.log(data)\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<Controller\n\nrender={({ field }) => (\n\n<Select {...field}>\n\n<MenuItem value={10}>Ten</MenuItem>\n\n<MenuItem value={20}>Twenty</MenuItem>\n\n</Select>\n\n)}\n\ncontrol={control}\n\nname=\"select\"\n\ndefaultValue={10}\n\n/>\n\n<Input {...register(\"input\")} />\n\n<button type=\"button\" onClick={() => reset({ ...defaultValues })}>\n\nReset\n\n</button>\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-controlled-mixed-with-uncontrolled-forked-c323j)\n\n```\nimport { useEffect } from \"react\"\n\nimport { Input, Select, MenuItem } from \"@material-ui/core\"\n\nimport { useForm } from \"react-hook-form\"\n\nconst defaultValues = {\n\nselect: \"\",\n\ninput: \"\",\n\n}\n\nfunction App() {\n\nconst { register, handleSubmit, setValue, reset, watch } = useForm({\n\ndefaultValues,\n\n})\n\nconst selectValue = watch(\"select\")\n\nconst onSubmit = (data) => console.log(data)\n\nuseEffect(() => {\n\nregister(\"select\")\n\n}, [register])\n\nconst handleChange = (e) => setValue(\"select\", e.target.value)\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<Select value={selectValue} onChange={handleChange}>\n\n<MenuItem value={10}>Ten</MenuItem>\n\n<MenuItem value={20}>Twenty</MenuItem>\n\n</Select>\n\n<Input {...register(\"input\")} />\n\n<button type=\"button\" onClick={() => reset({ ...defaultValues })}>\n\nReset\n\n</button>\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\n---\n\n## Custom Hook with Resolver\n\nYou can build a custom hook as a resolver. A custom hook can easily integrate with yup/Joi/Superstruct as a validation method, and to be used inside validation resolver.\n\n- Define a memorized validation schema (or define it outside your component if you don't have any dependencies)\n- Use the custom hook, by passing the validation schema\n- Pass the validation resolver to the useForm hook\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/custom-hook-with-resolver-v7-cwczk)\n\n```\nimport { useCallback } from \"react\"\n\nimport { useForm } from \"react-hook-form\"\n\nimport * as yup from \"yup\"\n\nconst useYupValidationResolver = (validationSchema) =>\n\nuseCallback(\n\nasync (data) => {\n\ntry {\n\nconst values = await validationSchema.validate(data, {\n\nabortEarly: false,\n\n})\n\nreturn {\n\nvalues,\n\nerrors: {},\n\n}\n\n} catch (errors) {\n\nreturn {\n\nvalues: {},\n\nerrors: errors.inner.reduce(\n\n(allErrors, currentError) => ({\n\n...allErrors,\n\n[currentError.path]: {\n\ntype: currentError.type ?? \"validation\",\n\nmessage: currentError.message,\n\n},\n\n}),\n\n{}\n\n),\n\n}\n\n}\n\n},\n\n[validationSchema]\n\n)\n\nconst validationSchema = yup.object({\n\nfirstName: yup.string().required(\"Required\"),\n\nlastName: yup.string().required(\"Required\"),\n\n})\n\nexport default function App() {\n\nconst resolver = useYupValidationResolver(validationSchema)\n\nconst { handleSubmit, register } = useForm({ resolver })\n\nreturn (\n\n<form onSubmit={handleSubmit((data) => console.log(data))}>\n\n<input {...register(\"firstName\")} />\n\n<input {...register(\"lastName\")} />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\n---\n\n## Working with virtualized lists\n\nImagine a scenario where you have a table of data. This table might contain hundreds or thousands of rows, and each row will have inputs. A common practice is to only render the items that are in the viewport, however this will cause issues as the items are removed from the DOM when they are out of view and re-added. This will cause items to reset to their default values when they re-enter the viewport.\n\nAn example is shown below using [react-window](https://github.com/bvaughn/react-window).\n\nFormField Array\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-with-react-window-forked-3j3mq)\n\n```\nimport { memo } from \"react\"\n\nimport { FormProvider, useForm, useFormContext } from \"react-hook-form\"\n\nimport { VariableSizeList as List } from \"react-window\"\n\nimport AutoSizer from \"react-virtualized-auto-sizer\"\n\nconst items = Array.from(Array(1000).keys()).map((i) => ({\n\ntitle: `List ${i}`,\n\nquantity: Math.floor(Math.random() * 10),\n\n}))\n\nconst WindowedRow = memo(({ index, style, data }) => {\n\nconst { register } = useFormContext()\n\nreturn (\n\n<div style={style}>\n\n<label>{data[index].title}</label>\n\n<input {...register(`${index}.quantity`)} />\n\n</div>\n\n)\n\n})\n\nexport const App = () => {\n\nconst onSubmit = (data) => console.log(data)\n\nconst methods = useForm({ defaultValues: items })\n\nreturn (\n\n<form onSubmit={methods.handleSubmit(onSubmit)}>\n\n<FormProvider {...methods}>\n\n<AutoSizer>\n\n{({ height, width }) => (\n\n<List\n\nheight={height}\n\nitemCount={items.length}\n\nitemSize={() => 100}\n\nwidth={width}\n\nitemData={items}\n\n>\n\n{WindowedRow}\n\n</List>\n\n)}\n\n</AutoSizer>\n\n</FormProvider>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-usefieldarray-virtual-inputs-ghrey)\n\n```\nimport { FixedSizeList } from \"react-window\"\n\nimport { Controller, useFieldArray, useForm } from \"react-hook-form\"\n\nconst items = Array.from(Array(1000).keys()).map((i) => ({\n\ntitle: `List ${i}`,\n\nquantity: Math.floor(Math.random() * 10),\n\n}))\n\nfunction App() {\n\nconst { control, getValues } = useForm({\n\ndefaultValues: {\n\ntest: items,\n\n},\n\n})\n\nconst { fields } = useFieldArray({ control, name: \"test\" })\n\nreturn (\n\n<FixedSizeList\n\nwidth={400}\n\nheight={500}\n\nitemSize={40}\n\nitemCount={fields.length}\n\nitemData={fields}\n\nitemKey={(i) => fields[i].id}\n\n>\n\n{({ style, index, data }) => {\n\nconst defaultValue =\n\ngetValues()[\"test\"][index].quantity ?? data[index].quantity\n\nreturn (\n\n<form style={style}>\n\n<Controller\n\nrender={({ field }) => <input {...field} />}\n\nname={`test[${index}].quantity`}\n\ndefaultValue={defaultValue}\n\ncontrol={control}\n\n/>\n\n</form>\n\n)\n\n}}\n\n</FixedSizeList>\n\n)\n\n}\n```\n\n---\n\n## Testing Form\n\nTesting is very important because it prevents your code from having bugs or mistakes. It also guarantees code safety when refactoring the codebase.\n\nWe recommend using [testing-library](https://testing-library.com/), because it is simple and tests are more focused on user behavior.\n\n**Step 1:** Set up your testing environment.\n\nPlease install [@testing-library/jest-dom](https://github.com/testing-library/jest-dom) with the latest version of `jest`, because react-hook-form uses `MutationObserver` to detect inputs, and to get unmounted from the DOM.\n\n**Note:** If you are using React Native, you don't need to install [@testing-library/jest-dom](https://github.com/testing-library/jest-dom).\n\nCopy\n\n```\nnpm install -D @testing-library/jest-dom\n```\n\nCreate `setup.js` to import [@testing-library/jest-dom](https://github.com/testing-library/jest-dom).\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-docs-066zk?file=/src/setupTests.js)\n\n```\nimport \"@testing-library/jest-dom\"\n```\n\n**Note:** If you are using React Native, you need to create setup.js, define `window` object, and include the following lines in the setup file:\n\nCopy\n\n```\nglobal.window = {}\n\nglobal.window = global\n```\n\nFinally, you have to update `setup.js` in `jest.config.js` to include the file.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-docs-066zk)\n\n```\nmodule.exports = {\n\nsetupFilesAfterEnv: [\"<rootDir>/setup.js\"], // or .ts for TypeScript App\n\n// ...other settings\n\n}\n```\n\nAdditionally, you can set up [eslint-plugin-testing-library](https://github.com/testing-library/eslint-plugin-testing-library) and [eslint-plugin-jest-dom](https://github.com/testing-library/eslint-plugin-jest-dom) to follow best practices and anticipate common mistakes when writing your tests.\n\n**Step 2:** Create login form.\n\nWe have set the role attribute accordingly. These attributes are helpful for when you write tests, and they improve accessibility. For more information, you can refer to the [testing-library](https://testing-library.com/) documentation.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-docs-066zk?file=/src/App.js)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nexport default function App({ login }) {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\nreset,\n\n} = useForm()\n\nconst onSubmit = async (data) => {\n\nawait login(data.email, data.password)\n\nreset()\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<label htmlFor=\"email\">email</label>\n\n<input\n\nid=\"email\"\n\n{...register(\"email\", {\n\nrequired: \"required\",\n\npattern: {\n\nvalue: /\\S+@\\S+\\.\\S+/,\n\nmessage: \"Entered value does not match email format\",\n\n},\n\n})}\n\ntype=\"email\"\n\n/>\n\n{errors.email && <span role=\"alert\">{errors.email.message}</span>}\n\n<label htmlFor=\"password\">password</label>\n\n<input\n\nid=\"password\"\n\n{...register(\"password\", {\n\nrequired: \"required\",\n\nminLength: {\n\nvalue: 5,\n\nmessage: \"min length is 5\",\n\n},\n\n})}\n\ntype=\"password\"\n\n/>\n\n{errors.password && <span role=\"alert\">{errors.password.message}</span>}\n\n<button type=\"submit\">SUBMIT</button>\n\n</form>\n\n)\n\n}\n```\n\n**Step 3:** Write tests.\n\nThe following criteria are what we try to cover with the tests:\n\n- Test submission failure.\n\n  We are using `waitFor` util and `find*` queries to detect submission feedback, because the `handleSubmit` method is executed asynchronously.\n- Test validation associated with each inputs.\n\n  We are using the `*ByRole` method when querying different elements because that's how users recognize your UI component.\n- Test successful submission.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-docs-066zk?file=/src/App.test.js)\n\n```\nimport { render, screen, fireEvent, waitFor } from \"@testing-library/react\"\n\nimport App from \"./App\"\n\nconst mockLogin = jest.fn((email, password) => {\n\nreturn Promise.resolve({ email, password })\n\n})\n\nit(\"should display required error when value is invalid\", async () => {\n\nrender(<App login={mockLogin} />)\n\nfireEvent.submit(screen.getByRole(\"button\"))\n\nexpect(await screen.findAllByRole(\"alert\")).toHaveLength(2)\n\nexpect(mockLogin).not.toBeCalled()\n\n})\n\nit(\"should display matching error when email is invalid\", async () => {\n\nrender(<App login={mockLogin} />)\n\nfireEvent.input(screen.getByRole(\"textbox\", { name: /email/i }), {\n\ntarget: {\n\nvalue: \"test\",\n\n},\n\n})\n\nfireEvent.input(screen.getByLabelText(\"password\"), {\n\ntarget: {\n\nvalue: \"password\",\n\n},\n\n})\n\nfireEvent.submit(screen.getByRole(\"button\"))\n\nexpect(await screen.findAllByRole(\"alert\")).toHaveLength(1)\n\nexpect(mockLogin).not.toBeCalled()\n\nexpect(screen.getByRole(\"textbox\", { name: /email/i })).toHaveValue(\"test\")\n\nexpect(screen.getByLabelText(\"password\")).toHaveValue(\"password\")\n\n})\n\nit(\"should display min length error when password is invalid\", async () => {\n\nrender(<App login={mockLogin} />)\n\nfireEvent.input(screen.getByRole(\"textbox\", { name: /email/i }), {\n\ntarget: {\n\nvalue: \"test@mail.com\",\n\n},\n\n})\n\nfireEvent.input(screen.getByLabelText(\"password\"), {\n\ntarget: {\n\nvalue: \"pass\",\n\n},\n\n})\n\nfireEvent.submit(screen.getByRole(\"button\"))\n\nexpect(await screen.findAllByRole(\"alert\")).toHaveLength(1)\n\nexpect(mockLogin).not.toBeCalled()\n\nexpect(screen.getByRole(\"textbox\", { name: /email/i })).toHaveValue(\n\n\"test@mail.com\"\n\n)\n\nexpect(screen.getByLabelText(\"password\")).toHaveValue(\"pass\")\n\n})\n\nit(\"should not display error when value is valid\", async () => {\n\nrender(<App login={mockLogin} />)\n\nfireEvent.input(screen.getByRole(\"textbox\", { name: /email/i }), {\n\ntarget: {\n\nvalue: \"test@mail.com\",\n\n},\n\n})\n\nfireEvent.input(screen.getByLabelText(\"password\"), {\n\ntarget: {\n\nvalue: \"password\",\n\n},\n\n})\n\nfireEvent.submit(screen.getByRole(\"button\"))\n\nawait waitFor(() => expect(screen.queryAllByRole(\"alert\")).toHaveLength(0))\n\nexpect(mockLogin).toBeCalledWith(\"test@mail.com\", \"password\")\n\nexpect(screen.getByRole(\"textbox\", { name: /email/i })).toHaveValue(\"\")\n\nexpect(screen.getByLabelText(\"password\")).toHaveValue(\"\")\n\n})\n```\n\n#### Resolving act warning during test\n\nIf you test a component that uses react-hook-form, you might run into a warning like this, even if you didn't write any asynchronous code for that component:\n\n> Warning: An update to MyComponent inside a test was not wrapped in act(...)\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-act-warning-docs-yq7uj?file=/src/App.js)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nexport default function App() {\n\nconst { register, handleSubmit } = useForm({\n\nmode: \"onChange\",\n\n})\n\nconst onSubmit = (data) => {}\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<input\n\n{...register(\"answer\", {\n\nrequired: true,\n\n})}\n\n/>\n\n<button type=\"submit\">SUBMIT</button>\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-act-warning-docs-yq7uj?file=/src/App.test.js)\n\n```\nimport { render, screen } from \"@testing-library/react\"\n\nimport App from \"./App\"\n\nit(\"should have a submit button\", () => {\n\nrender(<App />)\n\nexpect(screen.getByText(\"SUBMIT\")).toBeInTheDocument()\n\n})\n```\n\nIn this example, there is a simple form without any apparent async code, and the test merely renders the component and tests for the presence of a button. However, it still logs the warning about updates not being wrapped in `act()`.\n\nThis is because react-hook-form internally uses asynchronous validation handlers. In order to compute the formState, it has to initially validate the form, which is done asynchronously, resulting in another render. That update happens after the test function returns, which triggers the warning.\n\nTo solve this, wait until some element from your UI appears with `find*` queries. Note that you **must not** wrap your `render()` calls in `act()`. [You can read more about wrapping things in `act` unnecessarily here](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library#wrapping-things-in-act-unnecessarily).\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-unit-test-act-warning-docs-tcb7y?file=/src/App.test.js)\n\n```\nimport { render, screen } from \"@testing-library/react\"\n\nimport App from \"./App\"\n\nit(\"should have a submit button\", async () => {\n\nrender(<App />)\n\nexpect(await screen.findByText(\"SUBMIT\")).toBeInTheDocument()\n\n// Now that the UI was awaited until the async behavior was completed,\n\n// you can keep asserting with `get*` queries.\n\nexpect(screen.getByRole(\"textbox\")).toBeInTheDocument()\n\n})\n```\n\n---\n\n## Transform and Parse\n\nThe native input returns the value in `string` format unless invoked with `valueAsNumber` or `valueAsDate`, you can read more under [this section](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement). However, it's not perfect. We still have to deal with `isNaN` or `null` values. So it's better to leave the transform at the custom hook level. In the following example, we are using the `Controller` to include the functionality of the transform value's input and output. You can also achieve a similar result with a custom `register`.\n\nCopy [CodeSandbox JS](https://codesandbox.io/s/transform-vt3tm)\n\n```\nimport { Controller } from \"react-hook-form\"\n\nconst ControllerPlus = ({ control, transform, name, defaultValue }) => (\n\n<Controller\n\ndefaultValue={defaultValue}\n\ncontrol={control}\n\nname={name}\n\nrender={({ field }) => (\n\n<input\n\nonChange={(e) => field.onChange(transform.output(e))}\n\nvalue={transform.input(field.value)}\n\n/>\n\n)}\n\n/>\n\n)\n\n// usage below:\n\n<ControllerPlus\n\ntransform={{\n\ninput: (value) => (isNaN(value) || value === 0 ? \"\" : value.toString()),\n\noutput: (e) => {\n\nconst output = parseInt(e.target.value, 10)\n\nreturn isNaN(output) ? 0 : output\n\n},\n\n}}\n\ncontrol={control}\n\nname=\"number\"\n\ndefaultValue=\"\"\n\n/>\n```\n\n# Thank you for your support\n\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\n\nStar us on GitHub",
  "tags": [
    "react",
    "forms",
    "validation",
    "hooks"
  ],
  "extracted_at": "2026-02-03T12:50:10.174651+00:00",
  "content_length": 25055,
  "content_hash": "7132fb9909353da4"
}