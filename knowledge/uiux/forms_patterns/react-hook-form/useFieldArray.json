{
  "id": "react-hook-form__docs_usefieldarray",
  "source_id": "react-hook-form",
  "source_name": "React Hook Form",
  "category": "forms_patterns",
  "url": "https://react-hook-form.com/docs/usefieldarray",
  "title": "useFieldArray",
  "content": "useFieldArray:\nUseFieldArrayProps\nCustom hook for working with Field Arrays (dynamic form). The motivation is to provide better user experience and performance. You can watch\nthis short video\nto visualize the performance enhancement.\nProps\nName\nType\nRequired\nDescription\nname\nstring\n\u2713\nName of the field array.\nNote:\nDo not support dynamic name.\ncontrol\nObject\ncontrol\nobject provided by\nuseForm\n. It's optional if you are using FormProvider.\nshouldUnregister\nboolean\nWhether Field Array will be unregistered after unmount.\nkeyName\nstring = id\nName of the attribute with autogenerated identifier to use as the\nkey\nprop. This prop is no longer required and will be removed in the next major version.\nrules\nObject\nThe same validation\nrules\nAPI as for\nregister\n, which includes:\nrequired, minLength, maxLength, validate\nCodeSandbox\nTS\nuseFieldArray\n(\n{\nrules\n:\n{\nminLength\n:\n4\n}\n}\n)\nIn case of validation error, the\nroot\nproperty is appended to\nformState.errors?.fieldArray?.root\nof type\nFieldError\nImportant:\nThis is only applicable to\nbuilt-in\nvalidation.\nExamples\nCopy\nfunction\nFieldArray\n(\n)\n{\nconst\n{\ncontrol\n,\nregister\n}\n=\nuseForm\n(\n)\n;\nconst\n{\nfields\n,\nappend\n,\nprepend\n,\nremove\n,\nswap\n,\nmove\n,\ninsert\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\n// control props comes from useForm (optional: if you are using FormProvider)\nname\n:\n\"test\"\n,\n// unique name for your Field Array\n}\n)\n;\nreturn\n(\n{\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n(\n<\ninput\nkey\n=\n{\nfield\n.\nid\n}\n// important to include key with field's id\n{\n...\nregister\n(\n`\ntest.\n${\nindex\n}\n.value\n`\n)\n}\n/\n>\n)\n)\n}\n)\n;\n}\nReturn\nName\nType\nDescription\nfields\nobject &\n{ id: string }\nThis\nobject\ncontains the\ndefaultValue\nand\nkey\nfor your component.\nappend\n(obj: object | object[], focusOptions) => void\nAppend input/inputs to the end of your fields and focus. The input value will be registered during this action.\nImportant:\nappend data is required and not partial.\nprepend\n(obj: object | object[], focusOptions) => void\nPrepend input/inputs to the start of your fields and focus. The input value will be registered during this action.\nImportant:\nprepend data is required and not partial.\ninsert\n(index: number, value: object | object[], focusOptions) => void\nInsert input/inputs at particular position and focus.\nImportant:\ninsert data is required and not partial.\nswap\n(from: number, to: number) => void\nSwap input/inputs position.\nmove\n(from: number, to: number) => void\nMove input/inputs to another position.\nupdate\n(index: number, obj: object) => void\nUpdate input/inputs at a particular position, updated fields will get unmounted and remounted. If this is not desired behavior, please use\nsetValue\nAPI instead.\nImportant:\nupdate data is required and not partial.\nreplace\n(obj: object[]) => void\nReplace the entire field array values.\nremove\n(index?: number | number[]) => void\nRemove input/inputs at particular position, or remove all when no index provided.\nRules\nuseFieldArray\nautomatically generates a unique identifier named\nid\nwhich is used for\nkey\nprop. For more information why this is required:\nhttps://react.dev/learn/rendering-lists\nThe\nfield.id\n(and not\nindex\n) must be added as the component key to prevent re-renders breaking the fields:\n// \u2705 correct:\n{\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n<\ninput key\n=\n{\nfield\n.\nid\n}\n...\n/\n>\n)\n}\n// \u274c incorrect:\n{\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n<\ninput key\n=\n{\nindex\n}\n...\n/\n>\n)\n}\nIt's recommended to not stack actions one after another.\nonClick\n=\n{\n(\n)\n=>\n{\nappend\n(\n{\ntest\n:\n'test'\n}\n)\n;\nremove\n(\n0\n)\n;\n}\n}\n// \u2705 Better solution: the remove action is happened after the second render\nReact\n.\nuseEffect\n(\n(\n)\n=>\n{\nremove\n(\n0\n)\n;\n}\n,\n[\nremove\n]\n)\nonClick\n=\n{\n(\n)\n=>\n{\nappend\n(\n{\ntest\n:\n'test'\n}\n)\n;\n}\n}\nEach\nuseFieldArray\nis unique and has its own state update, which means you should not have multiple useFieldArray with the same\nname\n.\nEach input name needs to be unique, if you need to build checkbox or radio with the same name then use it with\nuseController\nor\nController\n.\nDoes not support flat field array.\nWhen you append, prepend, insert and update the field array, the obj can't be empty object\nrather need to supply all your input's defaultValues.\nappend\n(\n)\n;\n\u274c\nappend\n(\n{\n}\n)\n;\n\u274c\nappend\n(\n{\nfirstName\n:\n'bill'\n,\nlastName\n:\n'luo'\n}\n)\n;\n\u2705\nTypeScript\nwhen register input\nname\n, you will have to cast them as\nconst\n<\ninput key\n=\n{\nfield\n.\nid\n}\n{\n...\nregister\n(\n`\ntest.\n${\nindex\n}\n.test\n`\nas\nconst\n)\n}\n/\n>\nwe do not support circular reference. Refer to this\nGithub issue\nfor more detail.\nfor nested field array, you will have to cast the field array by its name.\nconst\n{\nfields\n}\n=\nuseFieldArray\n(\n{\nname\n:\n`\ntest.\n${\nindex\n}\n.keyValue\n`\nas\n'test.0.keyValue'\n}\n)\n;\nExamples\nuseFieldArray\nNested Form\nconditional Field Array\nFocus Name/index\nJS\nTS\nCopy\nCodeSandbox\nJS\nimport\n{\nuseForm\n,\nuseFieldArray\n}\nfrom\n\"react-hook-form\"\n;\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\ncontrol\n,\nhandleSubmit\n,\nreset\n,\ntrigger\n,\nsetError\n}\n=\nuseForm\n(\n{\n// defaultValues: {}; you can populate the fields by this attribute\n}\n)\n;\nconst\n{\nfields\n,\nappend\n,\nremove\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n\"test\"\n}\n)\n;\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\ndata\n=>\nconsole\n.\nlog\n(\ndata\n)\n)\n}\n>\n<\nul\n>\n{\nfields\n.\nmap\n(\n(\nitem\n,\nindex\n)\n=>\n(\n<\nli key\n=\n{\nitem\n.\nid\n}\n>\n<\ninput\n{\n...\nregister\n(\n`\ntest.\n${\nindex\n}\n.firstName\n`\n)\n}\n/\n>\n<\nController\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\n<\ninput\n{\n...\nfield\n}\n/\n>\n}\nname\n=\n{\n`\ntest.\n${\nindex\n}\n.lastName\n`\n}\ncontrol\n=\n{\ncontrol\n}\n/\n>\n<\nbutton type\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nremove\n(\nindex\n)\n}\n>\nDelete\n<\n/\nbutton\n>\n<\n/\nli\n>\n)\n)\n}\n<\n/\nul\n>\n<\nbutton\ntype\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nappend\n(\n{\nfirstName\n:\n\"bill\"\n,\nlastName\n:\n\"luo\"\n}\n)\n}\n>\nappend\n<\n/\nbutton\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n;\n}\nCopy\nCodeSandbox\nTS\nimport\n*\nas\nReact\nfrom\n\"react\"\n;\nimport\n{\nuseForm\n,\nuseFieldArray\n,\nuseWatch\n}\nfrom\n\"react-hook-form\"\n;\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\ncontrol\n,\nhandleSubmit\n}\n=\nuseForm\n(\n)\n;\nconst\n{\nfields\n,\nappend\n,\nupdate\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n'array'\n}\n)\n;\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n)\n}\n>\n{\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n(\n<\nEdit\nkey\n=\n{\nfield\n.\nid\n}\ncontrol\n=\n{\ncontrol\n}\nupdate\n=\n{\nupdate\n}\nindex\n=\n{\nindex\n}\nvalue\n=\n{\nfield\n}\n/\n>\n)\n)\n}\n<\nbutton\ntype\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\n{\nappend\n(\n{\nfirstName\n:\n\"\"\n}\n)\n;\n}\n}\n>\nappend\n<\n/\nbutton\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n;\n}\nconst\nDisplay\n=\n(\n{\ncontrol\n,\nindex\n}\n)\n=>\n{\nconst\ndata\n=\nuseWatch\n(\n{\ncontrol\n,\nname\n:\n`\narray.\n${\nindex\n}\n`\n}\n)\n;\nreturn\n<\np\n>\n{\ndata\n?.\nfirstName\n}\n<\n/\np\n>\n;\n}\n;\nconst\nEdit\n=\n(\n{\nupdate\n,\nindex\n,\nvalue\n,\ncontrol\n}\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\ndefaultValues\n:\nvalue\n}\n)\n;\nreturn\n(\n<\ndiv\n>\n<\nDisplay\ncontrol\n=\n{\ncontrol\n}\nindex\n=\n{\nindex\n}\n/\n>\n<\ninput\nplaceholder\n=\n\"first name\"\n{\n...\nregister\n(\n`\nfirstName\n`\n,\n{\nrequired\n:\ntrue\n}\n)\n}\n/\n>\n<\nbutton\ntype\n=\n\"button\"\nonClick\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\nupdate\n(\nindex\n,\ndata\n)\n)\n}\n>\nSubmit\n<\n/\nbutton\n>\n<\n/\ndiv\n>\n)\n;\n}\n;\nCopy\nCodeSandbox\nTS\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseForm\n,\nuseWatch\n,\nuseFieldArray\n,\nControl\n}\nfrom\n'react-hook-form'\n;\ntype\nFormValues\n=\n{\ndata\n:\n{\nname\n:\nstring\n}\n[\n]\n;\n}\n;\nconst\nConditionField\n=\n(\n{\ncontrol\n,\nindex\n,\nregister\n,\n}\n:\n{\ncontrol\n:\nControl\n<\nFormValues\n>\n;\nindex\n:\nnumber\n;\n}\n)\n=>\n{\nconst\noutput\n=\nuseWatch\n(\n{\nname\n:\n'data'\n,\ncontrol\n,\ndefaultValue\n:\n'yay! I am watching you :)'\n,\n}\n)\n;\nreturn\n(\n<\n>\n{\noutput\n[\nindex\n]\n?.\nname\n===\n\"bill\"\n&&\n(\n<\ninput\n{\n...\nregister\n(\n`\ndata[\n${\nindex\n}\n].conditional\n`\n)\n}\n/\n>\n)\n}\n<\ninput\n{\n...\nregister\n(\n`\ndata[\n${\nindex\n}\n].easyConditional\n`\n)\n}\nstyle\n=\n{\n{\ndisplay\n:\noutput\n[\nindex\n]\n?.\nname\n===\n\"bill\"\n?\n\"block\"\n:\n\"none\"\n}\n}\n/\n>\n<\n/\n>\n)\n;\n}\n;\nconst\nUseFieldArrayUnregister\n:\nReact\n.\nFC\n=\n(\n)\n=>\n{\nconst\n{\ncontrol\n,\nhandleSubmit\n,\nregister\n}\n=\nuseForm\n<\nFormValues\n>\n(\n{\ndefaultValues\n:\n{\ndata\n:\n[\n{\nname\n:\n'test'\n}\n,\n{\nname\n:\n'test1'\n}\n,\n{\nname\n:\n'test2'\n}\n]\n,\n}\n,\nmode\n:\n'onSubmit'\n,\nshouldUnregister\n:\nfalse\n,\n}\n)\n;\nconst\n{\nfields\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n'data'\n,\n}\n)\n;\nconst\nonSubmit\n=\n(\ndata\n:\nFormValues\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n;\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n{\nfields\n.\nmap\n(\n(\ndata\n,\nindex\n)\n=>\n(\n<\n>\n<\ninput\n{\n...\nregister\n(\n`\ndata[\n${\nindex\n}\n].name\n`\n)\n}\n/\n>\n<\nConditionField\ncontrol\n=\n{\ncontrol\n}\nregister\n=\n{\nregister\n}\nindex\n=\n{\nindex\n}\n/\n>\n<\n/\n>\n)\n)\n}\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n;\n}\n;\nCopy\nimport\nReact\nfrom\n'react'\n;\nimport\n{\nuseForm\n,\nuseFieldArray\n}\nfrom\n'react-hook-form'\n;\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\ncontrol\n}\n=\nuseForm\n<\n{\ntest\n:\n{\nvalue\n:\nstring\n}\n[\n]\n;\n}\n>\n(\n{\ndefaultValues\n:\n{\ntest\n:\n[\n{\nvalue\n:\n'1'\n}\n,\n{\nvalue\n:\n'2'\n}\n]\n,\n}\n,\n}\n)\n;\nconst\n{\nfields\n,\nprepend\n,\nappend\n}\n=\nuseFieldArray\n(\n{\nname\n:\n'test'\n,\ncontrol\n,\n}\n)\n;\nreturn\n(\n<\nform\n>\n{\nfields\n.\nmap\n(\n(\nfield\n,\ni\n)\n=>\n(\n<\ninput key\n=\n{\nfield\n.\nid\n}\n{\n...\nregister\n(\n`\ntest.\n${\ni\n}\n.value\n`\nas\nconst\n)\n}\n/\n>\n)\n)\n}\n<\nbutton\ntype\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nprepend\n(\n{\nvalue\n:\n''\n}\n,\n{\nfocusIndex\n:\n1\n}\n)\n}\n>\nprepend\n<\n/\nbutton\n>\n<\nbutton\ntype\n=\n\"button\"\nonClick\n=\n{\n(\n)\n=>\nappend\n(\n{\nvalue\n:\n''\n}\n,\n{\nfocusName\n:\n'test.0.value'\n}\n)\n}\n>\nappend\n<\n/\nbutton\n>\n<\n/\nform\n>\n)\n;\n}\n;\nVideo\nThe following video explains the basic usage of\nuseFieldArray\n.\nTips\nCustom Register\nYou can also\nregister\ninputs at\nController\nwithout the actual input. This makes\nuseFieldArray\nquick and flexible to use with complex data structure or the actual data is not stored inside an input.\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n,\nuseFieldArray\n,\nController\n,\nuseWatch\n}\nfrom\n\"react-hook-form\"\n;\nconst\nConditionalInput\n=\n(\n{\ncontrol\n,\nindex\n,\nfield\n}\n)\n=>\n{\nconst\nvalue\n=\nuseWatch\n(\n{\nname\n:\n\"test\"\n,\ncontrol\n}\n)\n;\nreturn\n(\n<\nController\ncontrol\n=\n{\ncontrol\n}\nname\n=\n{\n`\ntest.\n${\nindex\n}\n.firstName\n`\n}\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\nvalue\n?.\n[\nindex\n]\n?.\ncheckbox\n===\n\"on\"\n?\n<\ninput\n{\n...\nfield\n}\n/\n>\n:\nnull\n}\n/\n>\n)\n;\n}\n;\nfunction\nApp\n(\n)\n{\nconst\n{\ncontrol\n,\nregister\n}\n=\nuseForm\n(\n)\n;\nconst\n{\nfields\n,\nappend\n,\nprepend\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n\"test\"\n}\n)\n;\nreturn\n(\n<\nform\n>\n{\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n(\n<\nConditionalInput\nkey\n=\n{\nfield\n.\nid\n}\n{\n...\n{\ncontrol\n,\nindex\n,\nfield\n}\n}\n/\n>\n)\n)\n}\n<\n/\nform\n>\n)\n;\n}\nControlled Field Array\nThere will be cases where you want to control the entire field array, which means each onChange reflects on the\nfields\nobject.\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n,\nuseFieldArray\n}\nfrom\n\"react-hook-form\"\n;\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\ncontrol\n,\nwatch\n}\n=\nuseForm\n<\nFormValues\n>\n(\n)\n;\nconst\n{\nfields\n,\nappend\n}\n=\nuseFieldArray\n(\n{\ncontrol\n,\nname\n:\n\"fieldArray\"\n}\n)\n;\nconst\nwatchFieldArray\n=\nwatch\n(\n\"fieldArray\"\n)\n;\nconst\ncontrolledFields\n=\nfields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n{\nreturn\n{\n...\nfield\n,\n...\nwatchFieldArray\n[\nindex\n]\n}\n;\n}\n)\n;\nreturn\n(\n<\nform\n>\n{\ncontrolledFields\n.\nmap\n(\n(\nfield\n,\nindex\n)\n=>\n{\nreturn\n<\ninput\n{\n...\nregister\n(\n`\nfieldArray.\n${\nindex\n}\n.name\n`\nas\nconst\n)\n}\n/\n>\n;\n}\n)\n}\n<\n/\nform\n>\n)\n;\n}\nThank you for your support\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\nStar us on GitHub",
  "content_markdown": "`## useFieldArray: UseFieldArrayProps`\n\nCustom hook for working with Field Arrays (dynamic form). The motivation is to provide better user experience and performance. You can watch [this short video](https://www.youtube.com/watch?v=Q7lrHuUfgIs) to visualize the performance enhancement.\n\n## Props\n\n| Name | Type | Required | Description |\n| --- | --- | --- | --- |\n| `name` | `string` | \u2713 | Name of the field array. **Note:** Do not support dynamic name. |\n| `control` | `Object` |  | [`control`](/docs/useform/control) object provided by `useForm`. It's optional if you are using FormProvider. |\n| `shouldUnregister` | `boolean` |  | Whether Field Array will be unregistered after unmount. |\n| `keyName` | `string = id` |  | Name of the attribute with autogenerated identifier to use as the `key` prop. This prop is no longer required and will be removed in the next major version. |\n| `rules` | `Object` |  | The same validation `rules` API as for [register](/docs/useform/register), which includes:  required, minLength, maxLength, validate  [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-usefieldarray-rules-iyejbp?file=/src/index.js)  ```  useFieldArray({  rules: { minLength: 4 }  }) ```  In case of validation error, the `root` property is appended to `formState.errors?.fieldArray?.root` of type [`FieldError`](/ts#FieldError) **Important:** This is only applicable to **built-in** validation. |\n\n### Examples\n\nCopy\n\n```\nfunction FieldArray() {\n\nconst { control, register } = useForm();\n\nconst { fields, append, prepend, remove, swap, move, insert } = useFieldArray({\n\ncontrol, // control props comes from useForm (optional: if you are using FormProvider)\n\nname: \"test\", // unique name for your Field Array\n\n});\n\nreturn (\n\n{fields.map((field, index) => (\n\n<input\n\nkey={field.id} // important to include key with field's id\n\n{...register(`test.${index}.value`)}\n\n/>\n\n))}\n\n);\n\n}\n```\n\n## Return\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `fields` | `object & { id: string }` | This `object` contains the `defaultValue` and `key` for your component. |\n| `append` | `(obj: object | object[], focusOptions) => void` | Append input/inputs to the end of your fields and focus. The input value will be registered during this action.  **Important:** append data is required and not partial. |\n| `prepend` | `(obj: object | object[], focusOptions) => void` | Prepend input/inputs to the start of your fields and focus. The input value will be registered during this action.  **Important:** prepend data is required and not partial. |\n| `insert` | `(index: number, value: object | object[], focusOptions) => void` | Insert input/inputs at particular position and focus.  **Important:** insert data is required and not partial. |\n| `swap` | `(from: number, to: number) => void` | Swap input/inputs position. |\n| `move` | `(from: number, to: number) => void` | Move input/inputs to another position. |\n| `update` | `(index: number, obj: object) => void` | Update input/inputs at a particular position, updated fields will get unmounted and remounted. If this is not desired behavior, please use [`setValue`](/docs/useform/setvalue) API instead.  **Important:** update data is required and not partial. |\n| `replace` | `(obj: object[]) => void` | Replace the entire field array values. |\n| `remove` | `(index?: number | number[]) => void` | Remove input/inputs at particular position, or remove all when no index provided. |\n\n## Rules\n\n- `useFieldArray` automatically generates a unique identifier named `id` which is used for `key` prop. For more information why this is required: [https://react.dev/learn/rendering-lists](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)\n\n  The `field.id` (and not `index`) must be added as the component key to prevent re-renders breaking the fields:\n\n  ```\n  // \u2705 correct:\n\n  {fields.map((field, index) => <input key={field.id} ... />)}\n\n  // \u274c incorrect:\n\n  {fields.map((field, index) => <input key={index} ... />)}\n  ```\n- It's recommended to not stack actions one after another.\n\n  ```\n  onClick={() => {\n\n  append({ test: 'test' });\n\n  remove(0);\n\n  }}\n\n  // \u2705 Better solution: the remove action is happened after the second render\n\n  React.useEffect(() => {\n\n  remove(0);\n\n  }, [remove])\n\n  onClick={() => {\n\n  append({ test: 'test' });\n\n  }}\n  ```\n- Each `useFieldArray` is unique and has its own state update, which means you should not have multiple useFieldArray with the same `name`.\n- Each input name needs to be unique, if you need to build checkbox or radio with the same name then use it with `useController` or `Controller`.\n- Does not support flat field array.\n- When you append, prepend, insert and update the field array, the obj can't be empty object  rather need to supply all your input's defaultValues.\n\n  ```\n  append(); \u274c\n\n  append({}); \u274c\n\n  append({ firstName: 'bill', lastName: 'luo' }); \u2705\n  ```\n\n## TypeScript\n\n- when register input `name`, you will have to cast them as `const`\n\n  ```\n  <input key={field.id} {...register(`test.${index}.test` as const)} />\n  ```\n- we do not support circular reference. Refer to this [Github issue](https://github.com/react-hook-form/react-hook-form/issues/4055) for more detail.\n- for nested field array, you will have to cast the field array by its name.\n\n  ```\n  const { fields } = useFieldArray({ name: `test.${index}.keyValue` as 'test.0.keyValue' });\n  ```\n\n## Examples\n\nuseFieldArrayNested Formconditional Field ArrayFocus Name/index\n\nJSTSCopy [CodeSandbox JS](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n\n```\nimport { useForm, useFieldArray } from \"react-hook-form\";\n\nfunction App() {\n\nconst { register, control, handleSubmit, reset, trigger, setError } = useForm({\n\n// defaultValues: {}; you can populate the fields by this attribute\n\n});\n\nconst { fields, append, remove } = useFieldArray({\n\ncontrol,\n\nname: \"test\"\n\n});\n\nreturn (\n\n<form onSubmit={handleSubmit(data => console.log(data))}>\n\n<ul>\n\n{fields.map((item, index) => (\n\n<li key={item.id}>\n\n<input {...register(`test.${index}.firstName`)} />\n\n<Controller\n\nrender={({ field }) => <input {...field} />}\n\nname={`test.${index}.lastName`}\n\ncontrol={control}\n\n/>\n\n<button type=\"button\" onClick={() => remove(index)}>Delete</button>\n\n</li>\n\n))}\n\n</ul>\n\n<button\n\ntype=\"button\"\n\nonClick={() => append({ firstName: \"bill\", lastName: \"luo\" })}\n\n>\n\nappend\n\n</button>\n\n<input type=\"submit\" />\n\n</form>\n\n);\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/usefieldarray-with-preview-odmtx5)\n\n```\nimport * as React from \"react\";\n\nimport { useForm, useFieldArray, useWatch } from \"react-hook-form\";\n\nexport default function App() {\n\nconst { control, handleSubmit } = useForm();\n\nconst { fields, append, update } = useFieldArray({\n\ncontrol,\n\nname: 'array'\n\n});\n\nreturn (\n\n<form onSubmit={handleSubmit((data) => console.log(data))}>\n\n{fields.map((field, index) => (\n\n<Edit\n\nkey={field.id}\n\ncontrol={control}\n\nupdate={update}\n\nindex={index}\n\nvalue={field}\n\n/>\n\n))}\n\n<button\n\ntype=\"button\"\n\nonClick={() => {\n\nappend({ firstName: \"\" });\n\n}}\n\n>\n\nappend\n\n</button>\n\n<input type=\"submit\" />\n\n</form>\n\n);\n\n}\n\nconst Display = ({ control, index }) => {\n\nconst data = useWatch({\n\ncontrol,\n\nname: `array.${index}`\n\n});\n\nreturn <p>{data?.firstName}</p>;\n\n};\n\nconst Edit = ({ update, index, value, control }) => {\n\nconst { register, handleSubmit } = useForm({\n\ndefaultValues: value\n\n});\n\nreturn (\n\n<div>\n\n<Display control={control} index={index} />\n\n<input\n\nplaceholder=\"first name\"\n\n{...register(`firstName`, { required: true })}\n\n/>\n\n<button\n\ntype=\"button\"\n\nonClick={handleSubmit((data) => update(index, data))}\n\n>\n\nSubmit\n\n</button>\n\n</div>\n\n);\n\n};\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/usefieldarray-conditional-2wi6f)\n\n```\nimport React from 'react';\n\nimport { useForm, useWatch, useFieldArray, Control } from 'react-hook-form';\n\ntype FormValues = {\n\ndata: { name: string }[];\n\n};\n\nconst ConditionField = ({\n\ncontrol,\n\nindex,\n\nregister,\n\n}: {\n\ncontrol: Control<FormValues>;\n\nindex: number;\n\n}) => {\n\nconst output = useWatch({\n\nname: 'data',\n\ncontrol,\n\ndefaultValue: 'yay! I am watching you :)',\n\n});\n\nreturn (\n\n<>\n\n{output[index]?.name === \"bill\" && (\n\n<input {...register(`data[${index}].conditional`)} />\n\n)}\n\n<input\n\n{...register(`data[${index}].easyConditional`)}\n\nstyle={{ display: output[index]?.name === \"bill\" ? \"block\" : \"none\" }}\n\n/>\n\n</>\n\n);\n\n};\n\nconst UseFieldArrayUnregister: React.FC = () => {\n\nconst { control, handleSubmit, register } = useForm<FormValues>({\n\ndefaultValues: {\n\ndata: [{ name: 'test' }, { name: 'test1' }, { name: 'test2' }],\n\n},\n\nmode: 'onSubmit',\n\nshouldUnregister: false,\n\n});\n\nconst { fields } = useFieldArray({\n\ncontrol,\n\nname: 'data',\n\n});\n\nconst onSubmit = (data: FormValues) => console.log(data);\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n{fields.map((data, index) => (\n\n<>\n\n<input {...register(`data[${index}].name`)} />\n\n<ConditionField control={control} register={register} index={index} />\n\n</>\n\n))}\n\n<input type=\"submit\" />\n\n</form>\n\n);\n\n};\n```\n\nCopy\n\n```\nimport React from 'react';\n\nimport { useForm, useFieldArray } from 'react-hook-form';\n\nconst App = () => {\n\nconst { register, control } = useForm<{\n\ntest: { value: string }[];\n\n}>({\n\ndefaultValues: {\n\ntest: [{ value: '1' }, { value: '2' }],\n\n},\n\n});\n\nconst { fields, prepend, append } = useFieldArray({\n\nname: 'test',\n\ncontrol,\n\n});\n\nreturn (\n\n<form>\n\n{fields.map((field, i) => (\n\n<input key={field.id} {...register(`test.${i}.value` as const)} />\n\n))}\n\n<button\n\ntype=\"button\"\n\nonClick={() => prepend({ value: '' }, { focusIndex: 1 })}\n\n>\n\nprepend\n\n</button>\n\n<button\n\ntype=\"button\"\n\nonClick={() => append({ value: '' }, { focusName: 'test.0.value' })}\n\n>\n\nappend\n\n</button>\n\n</form>\n\n);\n\n};\n```\n\n## Video\n\nThe following video explains the basic usage of `useFieldArray`.\n\n## Tips\n\n#### Custom Register\n\nYou can also `register` inputs at `Controller` without the actual input. This makes `useFieldArray` quick and flexible to use with complex data structure or the actual data is not stored inside an input.\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/usefieldarray-virtual-input-v9wyw)\n\n```\nimport { useForm, useFieldArray, Controller, useWatch } from \"react-hook-form\";\n\nconst ConditionalInput = ({ control, index, field }) => {\n\nconst value = useWatch({\n\nname: \"test\",\n\ncontrol\n\n});\n\nreturn (\n\n<Controller\n\ncontrol={control}\n\nname={`test.${index}.firstName`}\n\nrender={({ field }) =>\n\nvalue?.[index]?.checkbox === \"on\" ? <input {...field} /> : null\n\n}\n\n/>\n\n);\n\n};\n\nfunction App() {\n\nconst { control, register } = useForm();\n\nconst { fields, append, prepend } = useFieldArray({\n\ncontrol,\n\nname: \"test\"\n\n});\n\nreturn (\n\n<form>\n\n{fields.map((field, index) => (\n\n<ConditionalInput key={field.id} {...{ control, index, field }} />\n\n))}\n\n</form>\n\n);\n\n}\n```\n\n#### Controlled Field Array\n\nThere will be cases where you want to control the entire field array, which means each onChange reflects on the `fields` object.\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/infallible-bush-c92l0?file=/src/App.tsx)\n\n```\nimport { useForm, useFieldArray } from \"react-hook-form\";\n\nexport default function App() {\n\nconst { register, handleSubmit, control, watch } = useForm<FormValues>();\n\nconst { fields, append } = useFieldArray({\n\ncontrol,\n\nname: \"fieldArray\"\n\n});\n\nconst watchFieldArray = watch(\"fieldArray\");\n\nconst controlledFields = fields.map((field, index) => {\n\nreturn {\n\n...field,\n\n...watchFieldArray[index]\n\n};\n\n});\n\nreturn (\n\n<form>\n\n{controlledFields.map((field, index) => {\n\nreturn <input {...register(`fieldArray.${index}.name` as const)} />;\n\n})}\n\n</form>\n\n);\n\n}\n```\n\n# Thank you for your support\n\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\n\nStar us on GitHub",
  "tags": [
    "react",
    "forms",
    "validation",
    "hooks"
  ],
  "extracted_at": "2026-02-03T12:50:06.703634+00:00",
  "content_length": 11151,
  "content_hash": "c033b6740e7ed462"
}