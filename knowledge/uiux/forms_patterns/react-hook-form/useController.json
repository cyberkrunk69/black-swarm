{
  "id": "react-hook-form__docs_usecontroller",
  "source_id": "react-hook-form",
  "source_name": "React Hook Form",
  "category": "forms_patterns",
  "url": "https://react-hook-form.com/docs/usecontroller",
  "title": "useController",
  "content": "Select page...\ncontroller\nuseController:\n(props?: UseControllerProps) => { field: object, fieldState: object, formState: object }\nThis custom hook powers\nController\n. Additionally, it shares the same props and methods as\nController\n. It's useful for creating reusable Controlled input.\nProps\nThe following table contains information about the arguments for\nuseController\n.\nName\nType\nRequired\nDescription\nname\nFieldPath\n\u2713\nUnique name of your input.\ncontrol\nControl\ncontrol\nobject provided by invoking\nuseForm\n. Optional when using\nFormProvider\n.\nrules\nObject\nValidation rules in the same format for\nregister\n, which includes:\nrequired, min, max, minLength, maxLength, pattern, validate\nCodeSandbox\nTS\nrules\n=\n{\n{\nrequired\n:\ntrue\n}\n}\nshouldUnregister\nboolean = false\nInput will be unregistered after unmount and defaultValues will be removed as well.\nNote:\nthis prop should be avoided when using with\nuseFieldArray\nas\nunregister\nfunction gets called after input unmount/remount and reorder.\ndisabled\nboolean = false\ndisabled\nprop will be returned from `field` prop. Controlled input will be disabled and its value will be omitted from the submission data.\ndefaultValue\nunknown\nImportant:\nCan not apply\nundefined\nto\ndefaultValue\nor\ndefaultValues\nat\nuseForm\n.\nYou need to either set\ndefaultValue\nat the field-level or\nuseForm\n's\ndefaultValues\n.\nundefined\nis not a valid value. If you used\ndefaultValues\nat\nuseForm\n, skip using this prop.\nIf your form will invoke\nreset\nwith default values, you will need to provide\nuseForm\nwith\ndefaultValues\n.\nexact\nboolean = false\nThis prop will enable an exact match for input name subscriptions, default to true.\nReturn\nThe following table contains information about properties which\nuseController\nproduces.\nObject Name\nName\nType\nDescription\nfield\nonChange\n(value: any) => void\nA function which sends the input's value to the library.\nIt should be assigned to the\nonChange\nprop of the input and value should\nnot be\nundefined\n.\nThis prop update\nformState\nand you should avoid manually invoke\nsetValue\nor other API related to field update.\nfield\nonBlur\n() => void\nA function which sends the input's onBlur event to the library. It should be assigned to the input's\nonBlur\nprop.\nfield\nvalue\nunknown\nThe current value of the controlled component.\nfield\ndisabled\nboolean\nThe disabled state of the input.\nfield\nname\nstring\nInput's name being registered.\nfield\nref\nReact.Ref\nA ref used to connect hook form to the input. Assign\nref\nto component's input ref to allow hook form to focus the error input.\nfieldState\ninvalid\nboolean\nInvalid state for current input.\nfieldState\nisTouched\nboolean\nTouched state for current controlled input.\nfieldState\nisDirty\nboolean\nDirty state for current controlled input.\nfieldState\nerror\nobject\nerror for this specific input.\nformState\nisDirty\nboolean\nSet to\ntrue\nafter the user modifies any of the inputs.\nImportant:\nMake sure to provide all inputs' defaultValues at the useForm, so hook form can have a single source of truth to compare whether the form is dirty.\nCopy\nconst\n{\nformState\n:\n{\nisDirty\n,\ndirtyFields\n}\n,\nsetValue\n,\n}\n=\nuseForm\n(\n{\ndefaultValues\n:\n{\ntest\n:\n\"\"\n}\n}\n)\n;\n// isDirty: true\nsetValue\n(\n'test'\n,\n'change'\n)\n// isDirty: false because there getValues() === defaultValues\nsetValue\n(\n'test'\n,\n''\n)\nFile typed input will need to be managed at the app level due to the ability to cancel file selection and\nFileList\nobject.\nDo not support custom object, Class or File object.\nformState\ndirtyFields\nobject\nAn object with the user-modified fields. Make sure to provide all inputs' defaultValues via useForm, so the library can compare against the\ndefaultValues\n.\nImportant:\nMake sure to provide defaultValues at the useForm, so hook form can have a single source of truth to compare each field's dirtiness.\nDirty fields will\nnot\nrepresent as\nisDirty\nformState, because dirty fields are marked field dirty at field level rather the entire form. If you want to determine the entire form state use\nisDirty\ninstead.\nformState\ntouchedFields\nobject\nAn object containing all the inputs the user has interacted with.\nformState\ndefaultValues\nobject\nThe value which has been set at\nuseForm\n's defaultValues or updated defaultValues via\nreset\nAPI.\nformState\nisSubmitted\nboolean\nSet to\ntrue\nafter the form is submitted. Will remain\ntrue\nuntil the\nreset\nmethod is invoked.\nformState\nisSubmitSuccessful\nboolean\nIndicate the form was successfully submitted without any runtime error.\nformState\nisSubmitting\nboolean\ntrue\nif the form is currently being submitted.\nfalse\notherwise.\nformState\nisLoading\nboolean\ntrue\nif the form is currently loading async default values.\nImportant:\nthis prop is only applicable to async\ndefaultValues\nCopy\nconst\n{\nformState\n:\n{\nisLoading\n}\n}\n=\nuseForm\n(\n{\ndefaultValues\n:\nasync\n(\n)\n=>\nawait\nfetch\n(\n'/api'\n)\n}\n)\n;\nformState\nsubmitCount\nnumber\nNumber of times the form was submitted.\nformState\nisValid\nboolean\nSet to\ntrue\nif the form doesn't have any errors.\nsetError\nhas no effect on\nisValid\nformState,\nisValid\nwill always derived via the entire form validation result.\nformState\nisValidating\nboolean\nSet to\ntrue\nduring validation.\nformState\nvalidatingFields\nobject\nCapture fields which are getting async validation.\nformState\nerrors\nobject\nAn object with field errors. There is also an\nErrorMessage\ncomponent to retrieve error message easily.\nformState\ndisabled\nboolean\nSet to\ntrue\nif the form is disabled via the\ndisabled\nprop in\nuseForm\n.\nExamples\nTextField\nCheckboxes\nJS\nTS\nCopy\nCodeSandbox\nJS\nimport\n{\nTextField\n}\nfrom\n\"@material-ui/core\"\n;\nimport\n{\nuseController\n,\nuseForm\n}\nfrom\n\"react-hook-form\"\n;\nfunction\nInput\n(\n{\ncontrol\n,\nname\n}\n)\n{\nconst\n{\nfield\n,\nfieldState\n:\n{\ninvalid\n,\nisTouched\n,\nisDirty\n}\n,\nformState\n:\n{\ntouchedFields\n,\ndirtyFields\n}\n}\n=\nuseController\n(\n{\nname\n,\ncontrol\n,\nrules\n:\n{\nrequired\n:\ntrue\n}\n,\n}\n)\n;\nreturn\n(\n<\nTextField\nonChange\n=\n{\nfield\n.\nonChange\n}\n// send value to hook form\nonBlur\n=\n{\nfield\n.\nonBlur\n}\n// notify when input is touched/blur\nvalue\n=\n{\nfield\n.\nvalue\n}\n// input value\nname\n=\n{\nfield\n.\nname\n}\n// send down the input name\ninputRef\n=\n{\nfield\n.\nref\n}\n// send input ref, so we can focus on input when error appear\n/\n>\n)\n;\n}\nCopy\nCodeSandbox\nTS\nimport\n*\nas\nReact\nfrom\n\"react\"\n;\nimport\n{\nuseController\n,\nuseForm\n}\nfrom\n\"react-hook-form\"\n;\nconst\nCheckboxes\n=\n(\n{\noptions\n,\ncontrol\n,\nname\n}\n)\n=>\n{\nconst\n{\nfield\n}\n=\nuseController\n(\n{\ncontrol\n,\nname\n}\n)\n;\nconst\n[\nvalue\n,\nsetValue\n]\n=\nReact\n.\nuseState\n(\nfield\n.\nvalue\n||\n[\n]\n)\n;\nreturn\n(\n<\n>\n{\noptions\n.\nmap\n(\n(\noption\n,\nindex\n)\n=>\n(\n<\ninput\nonChange\n=\n{\n(\ne\n)\n=>\n{\nconst\nvalueCopy\n=\n[\n...\nvalue\n]\n;\n// update checkbox value\nvalueCopy\n[\nindex\n]\n=\ne\n.\ntarget\n.\nchecked\n?\ne\n.\ntarget\n.\nvalue\n:\nnull\n;\n// send data to react hook form\nfield\n.\nonChange\n(\nvalueCopy\n)\n;\n// update local state\nsetValue\n(\nvalueCopy\n)\n;\n}\n}\nkey\n=\n{\noption\n}\nchecked\n=\n{\nvalue\n.\nincludes\n(\noption\n)\n}\ntype\n=\n\"checkbox\"\nvalue\n=\n{\noption\n}\n/\n>\n)\n)\n}\n<\n/\n>\n)\n;\n}\n;\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\ncontrol\n}\n=\nuseForm\n(\n{\ndefaultValues\n:\n{\ncontrolled\n:\n[\n]\n,\nuncontrolled\n:\n[\n]\n}\n}\n)\n;\nconst\nonSubmit\n=\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n;\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nsection\n>\n<\nh2\n>\nuncontrolled\n<\n/\nh2\n>\n<\ninput\n{\n...\nregister\n(\n\"uncontrolled\"\n)\n}\ntype\n=\n\"checkbox\"\nvalue\n=\n\"A\"\n/\n>\n<\ninput\n{\n...\nregister\n(\n\"uncontrolled\"\n)\n}\ntype\n=\n\"checkbox\"\nvalue\n=\n\"B\"\n/\n>\n<\ninput\n{\n...\nregister\n(\n\"uncontrolled\"\n)\n}\ntype\n=\n\"checkbox\"\nvalue\n=\n\"C\"\n/\n>\n<\n/\nsection\n>\n<\nsection\n>\n<\nh2\n>\ncontrolled\n<\n/\nh2\n>\n<\nCheckboxes\noptions\n=\n{\n[\n\"a\"\n,\n\"b\"\n,\n\"c\"\n]\n}\ncontrol\n=\n{\ncontrol\n}\nname\n=\n\"controlled\"\n/\n>\n<\n/\nsection\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n;\n}\nTips\nIt's important to be aware of each prop's responsibility when working with external controlled components, such as MUI, AntD, Chakra UI. Its job is to spy on the input, report, and set its value.\nonChange\n: send data back to hook form\nonBlur\n: report input has been interacted (focus and blur)\nvalue\n: set up input initial and updated value\nref\n: allow input to be focused with error\nname\n: give input an unique name\nIt's fine to host your state and combined with\nuseController\n.\nCopy\nCodeSandbox\nTS\nconst\n{\nfield\n}\n=\nuseController\n(\n)\n;\nconst\n[\nvalue\n,\nsetValue\n]\n=\nuseState\n(\nfield\n.\nvalue\n)\n;\nonChange\n=\n{\n(\nevent\n)\n=>\n{\nfield\n.\nonChange\n(\nparseInt\n(\nevent\n.\ntarget\n.\nvalue\n)\n)\n// data send back to hook form\nsetValue\n(\nevent\n.\ntarget\n.\nvalue\n)\n// UI state\n}\n}\nDo not\nregister\ninput again. This custom hook is designed to take care of the registration process.\nCopy\nconst\n{\nfield\n}\n=\nuseController\n(\n{\nname\n:\n'test'\n}\n)\n<\ninput\n{\n...\nfield\n}\n/\n>\n// \u2705\n<\ninput\n{\n...\nfield\n}\n{\n...\nregister\n(\n'test'\n)\n}\n/\n>\n// \u274c double up the registration\nIt's ideal to use a single\nuseController\nper component. If you need to use more than one, make sure you rename the prop. May want to consider using\nController\ninstead.\nCopy\nconst\n{\nfield\n:\ninput\n}\n=\nuseController\n(\n{\nname\n:\n'test'\n}\n)\nconst\n{\nfield\n:\ncheckbox\n}\n=\nuseController\n(\n{\nname\n:\n'test1'\n}\n)\n<\ninput\n{\n...\ninput\n}\n/\n>\n<\ninput\n{\n...\ncheckbox\n}\n/\n>\nThank you for your support\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\nStar us on GitHub",
  "content_markdown": "Select page...controller`## useController: (props?: UseControllerProps) => { field: object, fieldState: object, formState: object }`\n\nThis custom hook powers [`Controller`](/docs/usecontroller/controller). Additionally, it shares the same props and methods as `Controller`. It's useful for creating reusable Controlled input.\n\n## Props\n\nThe following table contains information about the arguments for `useController`.\n\n| Name | Type | Required | Description |\n| --- | --- | --- | --- |\n| `name` | [`FieldPath`](/ts#FieldPath \"FieldPath type\") | \u2713 | Unique name of your input. |\n| `control` | [`Control`](/ts#Control \"Control type\") |  | [`control`](/docs/useform/control) object provided by invoking `useForm`. Optional when using `FormProvider`. |\n| `rules` | `Object` |  | Validation rules in the same format for `register`, which includes:  required, min, max, minLength, maxLength, pattern, validate  [CodeSandbox TS](https://codesandbox.io/s/controller-rules-8pd7z?file=/src/App.tsx)  ```  rules={{ required: true }} ``` |\n| `shouldUnregister` | `boolean = false` |  | Input will be unregistered after unmount and defaultValues will be removed as well.  **Note:** this prop should be avoided when using with `useFieldArray` as `unregister` function gets called after input unmount/remount and reorder. |\n| `disabled` | `boolean = false` |  | `disabled` prop will be returned from `field` prop. Controlled input will be disabled and its value will be omitted from the submission data. |\n| `defaultValue` | `unknown` |  | **Important:** Can not apply `undefined` to `defaultValue` or `defaultValues` at `useForm`.   - You need to either set `defaultValue` at the field-level or `useForm`'s `defaultValues`. `undefined` is not a valid value. If you used `defaultValues` at `useForm`, skip using this prop. - If your form will invoke `reset` with default values, you will need to provide `useForm` with `defaultValues`. |\n| `exact` | `boolean = false` |  | This prop will enable an exact match for input name subscriptions, default to true. |\n\n## Return\n\nThe following table contains information about properties which `useController` produces.\n\n| Object Name | Name | Type | Description |\n| --- | --- | --- | --- |\n| `field` | `onChange` | `(value: any) => void` | A function which sends the input's value to the library.   - It should be assigned to the `onChange` prop of the input and value should **not be `undefined`**. - This prop update [formState](/docs/useform/formstate) and you should avoid manually invoke [setValue](/docs/useform/setvalue) or other API related to field update. |\n| `field` | `onBlur` | `() => void` | A function which sends the input's onBlur event to the library. It should be assigned to the input's `onBlur` prop. |\n| `field` | `value` | `unknown` | The current value of the controlled component. |\n| `field` | `disabled` | `boolean` | The disabled state of the input. |\n| `field` | `name` | `string` | Input's name being registered. |\n| `field` | `ref` | `React.Ref` | A ref used to connect hook form to the input. Assign `ref` to component's input ref to allow hook form to focus the error input. |\n| `fieldState` | `invalid` | `boolean` | Invalid state for current input. |\n| `fieldState` | `isTouched` | `boolean` | Touched state for current controlled input. |\n| `fieldState` | `isDirty` | `boolean` | Dirty state for current controlled input. |\n| `fieldState` | `error` | `object` | error for this specific input. |\n| [`formState`](/docs/useform/formstate) | `isDirty` | `boolean` | Set to `true` after the user modifies any of the inputs.   - **Important:** Make sure to provide all inputs' defaultValues at the useForm, so hook form can have a single source of truth to compare whether the form is dirty.  Copy  ```    const {  formState: { isDirty, dirtyFields },  setValue,  } = useForm({ defaultValues: { test: \"\" } });    // isDirty: true  setValue('test', 'change')    // isDirty: false because there getValues() === defaultValues  setValue('test', '')   ``` - File typed input will need to be managed at the app level due to the ability to cancel file selection and [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList) object. - Do not support custom object, Class or File object. |\n| `formState` | `dirtyFields` | `object` | An object with the user-modified fields. Make sure to provide all inputs' defaultValues via useForm, so the library can compare against the `defaultValues`.   - **Important:** Make sure to provide defaultValues at the useForm, so hook form can have a single source of truth to compare each field's dirtiness. - Dirty fields will **not** represent as `isDirty` formState, because dirty fields are marked field dirty at field level rather the entire form. If you want to determine the entire form state use `isDirty` instead. |\n| `formState` | `touchedFields` | `object` | An object containing all the inputs the user has interacted with. |\n| `formState` | `defaultValues` | `object` | The value which has been set at [useForm](/docs/useform)'s defaultValues or updated defaultValues via [reset](/docs/useform/reset) API. |\n| `formState` | `isSubmitted` | `boolean` | Set to `true` after the form is submitted. Will remain `true` until the `reset` method is invoked. |\n| `formState` | `isSubmitSuccessful` | `boolean` | Indicate the form was successfully submitted without any runtime error. |\n| `formState` | `isSubmitting` | `boolean` | `true` if the form is currently being submitted. `false` otherwise. |\n| `formState` | `isLoading` | `boolean` | `true` if the form is currently loading async default values.  **Important:** this prop is only applicable to async `defaultValues`  Copy  ```  const {  formState: { isLoading }  } = useForm({  defaultValues: async () => await fetch('/api')  }); ``` |\n| `formState` | `submitCount` | `number` | Number of times the form was submitted. |\n| `formState` | `isValid` | `boolean` | Set to `true` if the form doesn't have any errors.  `setError` has no effect on `isValid` formState, `isValid` will always derived via the entire form validation result. |\n| `formState` | `isValidating` | `boolean` | Set to `true` during validation. |\n| `formState` | `validatingFields` | `object` | Capture fields which are getting async validation. |\n| `formState` | `errors` | `object` | An object with field errors. There is also an [ErrorMessage](/docs/useformstate/errormessage) component to retrieve error message easily. |\n| `formState` | `disabled` | `boolean` | Set to `true` if the form is disabled via the `disabled` prop in [useForm](/docs/useform#disabled). |\n\n## Examples\n\nTextFieldCheckboxes\n\nJSTSCopy [CodeSandbox JS](https://codesandbox.io/s/usecontroller-i0ywh)\n\n```\nimport { TextField } from \"@material-ui/core\";\n\nimport { useController, useForm } from \"react-hook-form\";\n\nfunction Input({ control, name }) {\n\nconst {\n\nfield,\n\nfieldState: { invalid, isTouched, isDirty },\n\nformState: { touchedFields, dirtyFields }\n\n} = useController({\n\nname,\n\ncontrol,\n\nrules: { required: true },\n\n});\n\nreturn (\n\n<TextField\n\nonChange={field.onChange} // send value to hook form\n\nonBlur={field.onBlur} // notify when input is touched/blur\n\nvalue={field.value} // input value\n\nname={field.name} // send down the input name\n\ninputRef={field.ref} // send input ref, so we can focus on input when error appear\n\n/>\n\n);\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/usecontroller-checkboxes-99ld4)\n\n```\nimport * as React from \"react\";\n\nimport { useController, useForm } from \"react-hook-form\";\n\nconst Checkboxes = ({ options, control, name }) => {\n\nconst { field } = useController({\n\ncontrol,\n\nname\n\n});\n\nconst [value, setValue] = React.useState(field.value || []);\n\nreturn (\n\n<>\n\n{options.map((option, index) => (\n\n<input\n\nonChange={(e) => {\n\nconst valueCopy = [...value];\n\n// update checkbox value\n\nvalueCopy[index] = e.target.checked ? e.target.value : null;\n\n// send data to react hook form\n\nfield.onChange(valueCopy);\n\n// update local state\n\nsetValue(valueCopy);\n\n}}\n\nkey={option}\n\nchecked={value.includes(option)}\n\ntype=\"checkbox\"\n\nvalue={option}\n\n/>\n\n))}\n\n</>\n\n);\n\n};\n\nexport default function App() {\n\nconst { register, handleSubmit, control } = useForm({\n\ndefaultValues: {\n\ncontrolled: [],\n\nuncontrolled: []\n\n}\n\n});\n\nconst onSubmit = (data) => console.log(data);\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<section>\n\n<h2>uncontrolled</h2>\n\n<input {...register(\"uncontrolled\")} type=\"checkbox\" value=\"A\" />\n\n<input {...register(\"uncontrolled\")} type=\"checkbox\" value=\"B\" />\n\n<input {...register(\"uncontrolled\")} type=\"checkbox\" value=\"C\" />\n\n</section>\n\n<section>\n\n<h2>controlled</h2>\n\n<Checkboxes\n\noptions={[\"a\", \"b\", \"c\"]}\n\ncontrol={control}\n\nname=\"controlled\"\n\n/>\n\n</section>\n\n<input type=\"submit\" />\n\n</form>\n\n);\n\n}\n```\n\n## Tips\n\n- It's important to be aware of each prop's responsibility when working with external controlled components, such as MUI, AntD, Chakra UI. Its job is to spy on the input, report, and set its value.\n\n  - **onChange**: send data back to hook form\n  - **onBlur**: report input has been interacted (focus and blur)\n  - **value**: set up input initial and updated value\n  - **ref**: allow input to be focused with error\n  - **name**: give input an unique name\n\n  It's fine to host your state and combined with `useController`.\n\n  Copy [CodeSandbox TS](https://codesandbox.io/s/usecontroller-own-state-wncet2?file=/src/App.tsx)\n\n  ```\n  const { field } = useController();\n\n  const [value, setValue] = useState(field.value);\n\n  onChange={(event) => {\n\n  field.onChange(parseInt(event.target.value)) // data send back to hook form\n\n  setValue(event.target.value) // UI state\n\n  }}\n  ```\n- Do not `register` input again. This custom hook is designed to take care of the registration process.\n\n  Copy\n\n  ```\n  const { field } = useController({ name: 'test' })\n\n  <input {...field} /> // \u2705\n\n  <input {...field} {...register('test')} /> // \u274c double up the registration\n  ```\n- It's ideal to use a single `useController` per component. If you need to use more than one, make sure you rename the prop. May want to consider using `Controller` instead.\n\n  Copy\n\n  ```\n  const { field: input } = useController({ name: 'test' })\n\n  const { field: checkbox } = useController({ name: 'test1' })\n\n  <input {...input} />\n\n  <input {...checkbox} />\n  ```\n\n# Thank you for your support\n\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\n\nStar us on GitHub",
  "tags": [
    "react",
    "forms",
    "validation",
    "hooks"
  ],
  "extracted_at": "2026-02-03T12:50:04.812027+00:00",
  "content_length": 9201,
  "content_hash": "37d28b4ad979f4e2"
}