{
  "id": "react-hook-form__docs_useform",
  "source_id": "react-hook-form",
  "source_name": "React Hook Form",
  "category": "forms_patterns",
  "url": "https://react-hook-form.com/docs/useform",
  "title": "useForm",
  "content": "Select page...\nregister\nunregister\nformstate\nwatch\nsubscribe\nhandlesubmit\nreset\nresetField\nsetError\nclearErrors\nsetValue\nsetFocus\ngetValues\ngetFieldState\ntrigger\ncontrol\nForm\n</>\nuseForm:\nUseFormProps\nuseForm\nis a custom hook for managing forms with ease. It takes one object as\noptional\nargument. The following example demonstrates all of its properties along with their default values.\nGeneric props:\nOption\nDescription\nmode\nValidation strategy\nbefore\nsubmitting behaviour.\nreValidateMode\nValidation strategy\nafter\nsubmitting behaviour.\ndefaultValues\nDefault values for the form, this value will be cached.\nvalues\nReactive values to update the form values.\nerrors\nServer returns errors to update form.\n\u26a0 Important:\nKeep the errors object reference-stable to avoid infinite re-renders.\nresetOptions\nOption to reset form state update while updating new form values.\ncriteriaMode\nDisplay all validation errors or one at a time.\nshouldFocusError\nEnable or disable built-in focus management.\ndelayError\nDelay error from appearing instantly.\nshouldUseNativeValidation\nUse browser built-in form constraint API.\nshouldUnregister\nEnable and disable input unregister after unmount.\ndisabled\nDisable the entire form with all associated inputs.\nSchema validation props:\nOption\nDescription\nresolver\nIntegrates with your preferred schema validation library.\ncontext\nA context object to supply for your schema validation.\nProps\nmode:\nonChange | onBlur | onSubmit | onTouched | all = 'onSubmit'\n!\nReact Native: compatible with Controller\nThis option allows you to configure the validation strategy before a user submits the form. The validation occurs during the\nonSubmit\nevent, which is triggered by invoking the\nhandleSubmit\nfunction.\nName\nType\nDescription\nonSubmit\nstring\nValidation is triggered on the\nsubmit\nevent, and inputs attach\nonChange\nevent listeners to re-validate themselves.\nonBlur\nstring\nValidation is triggered on the\nblur\nevent.\nonChange\nstring\nValidation is triggered on the\nchange\nevent for each input, leading to multiple re-renders. Warning: this often comes with a significant impact on performance.\nonTouched\nstring\nValidation is initially triggered on the first\nblur\nevent. After that, it is triggered on every\nchange\nevent.\nNote:\nwhen using with\nController\n, make sure to wire up\nonBlur\nwith the\nrender\nprop.\nall\nstring\nValidation is triggered on both\nblur\nand\nchange\nevents.\nreValidateMode:\nonChange | onBlur | onSubmit = 'onChange'\n!\nReact Native: Custom register or using Controller\nThis option allows you to configure validation strategy when inputs with errors get re-validated\nafter\na user submits the form (\nonSubmit\nevent and\nhandleSubmit\nfunction executed). By default, re-validation occurs during the input change event.\ndefaultValues:\nFieldValues | () => Promise<FieldValues>\nThe\ndefaultValues\nprop populates the entire form with default values. It supports both synchronous and asynchronous assignment of default values. While you can set an input's default value using\ndefaultValue\nor\ndefaultChecked\n(as detailed in the official React documentation)\n, it is\nrecommended\nto use\ndefaultValues\nfor the entire form.\nCopy\nuseForm\n(\n{\ndefaultValues\n:\n{\nfirstName\n:\n''\n,\nlastName\n:\n''\n}\n}\n)\n// set default value async\nuseForm\n(\n{\ndefaultValues\n:\nasync\n(\n)\n=>\nfetch\n(\n'/api-endpoint'\n)\n;\n}\n)\nRULES\nYou\nshould avoid\nproviding\nundefined\nas a default value, as it conflicts with the default state of a controlled component.\ndefaultValues\nare cached. To reset them, use the\nreset\nAPI.\ndefaultValues\nwill be included in the submission result by default.\nIt's recommended to avoid using custom objects containing prototype methods, such as\nMoment\nor\nLuxon\n, as\ndefaultValues\n.\nThere are other options for including form data:\n// adding a hidden input\n<\ninput\n{\n...\nregister\n(\n\"hidden\"\n,\n{\nvalue\n:\n\"data\"\n}\n)\n}\ntype\n=\n\"hidden\"\n/\n>\n// include data onSubmit\nconst\nonSubmit\n=\n(\ndata\n)\n=>\n{\nconst\noutput\n=\n{\n...\ndata\n,\nothers\n:\n\"others\"\n,\n}\n}\nvalues:\nFieldValues\nThe\nvalues\nprop will react to changes and update the form values, which is useful when your form needs to be updated by external state or server data. The\nvalues\nprop will overwrite the\ndefaultValues\nprop, unless\nresetOptions: { keepDefaultValues: true }\nis also set for\nuseForm\n.\nCopy\n// set default value sync\nfunction\nApp\n(\n{\nvalues\n}\n)\n{\nuseForm\n(\n{\nvalues\n,\n// will get updated when values props updates\n}\n)\n}\nfunction\nApp\n(\n)\n{\nconst\nvalues\n=\nuseFetch\n(\n\"/api\"\n)\nuseForm\n(\n{\ndefaultValues\n:\n{\nfirstName\n:\n\"\"\n,\nlastName\n:\n\"\"\n,\n}\n,\nvalues\n,\n// will get updated once values returns\n}\n)\n}\nerrors:\nFieldErrors\nThe\nerrors\nprops will react to changes and update the server errors state, which is useful when your form needs to be updated by external server returned errors.\nCopy\nfunction\nApp\n(\n)\n{\nconst\n{\nerrors\n,\ndata\n}\n=\nuseFetch\n(\n\"/api\"\n)\nuseForm\n(\n{\nerrors\n,\n// will get updated once errors returns\n}\n)\n}\nresetOptions:\nKeepStateOptions\nThis property is related to value update behaviors. When\nvalues\nor\ndefaultValues\nare updated, the\nreset\nAPI is invoked internally. It's important to specify the desired behavior after\nvalues\nor\ndefaultValues\nare asynchronously updated. The configuration option itself is a reference to the\nreset\nmethod's options.\nCopy\n// by default asynchronously value or defaultValues update will reset the form values\nuseForm\n(\n{\nvalues\n}\n)\nuseForm\n(\n{\ndefaultValues\n:\nasync\n(\n)\n=>\nawait\nfetch\n(\n)\n}\n)\n// options to config the behaviour\n// eg: I want to keep user interacted/dirty value and not remove any user errors\nuseForm\n(\n{\nvalues\n,\nresetOptions\n:\n{\nkeepDirtyValues\n:\ntrue\n,\n// user-interacted input will be retained\nkeepErrors\n:\ntrue\n,\n// input errors will be retained with value update\n}\n,\n}\n)\ncontext:\nobject\nThis context\nobject\nis mutable and will be injected into the\nresolver\n's second argument or\nYup\nvalidation's context object.\nCodeSandbox\ncriteriaMode:\nfirstError | all\nWhen set to\nfirstError\n(default), only the first error from each field will be gathered.\nWhen set to\nall\n, all errors from each field will be gathered.\nCodeSandbox\nshouldFocusError:\nboolean = true\nWhen set to\ntrue\n(default), and the user submits a form that fails validation, focus is set on the first field with an error.\nNOTE\nOnly registered fields with a\nref\nwill work. Custom registered inputs do not\napply. For example:\nregister('test') // doesn't work\nThe focus order is based on the\nregister\norder.\ndelayError:\nnumber\nThis configuration delays the display of error states to the end-user by a specified number of milliseconds. If the user corrects the error input, the error is removed instantly, and the delay is not applied.\nCodeSandbox\nshouldUnregister:\nboolean = false\nBy default, an input value will be retained when input is removed. However, you can set\nshouldUnregister\nto\ntrue\nto\nunregister\ninput during unmount.\nThis is a global configuration that overrides child-level configurations. To have individual behavior, set the configuration at the component or hook level, not at\nuseForm\n.\nBy default,\nshouldUnregister: false\nmeans unmounted fields are\nnot validated\nby built-in validation.\nBy setting\nshouldUnregister\nto true at\nuseForm\nlevel,\ndefaultValues\nwill\nnot\nbe merged against submission result.\nSetting\nshouldUnregister: true\nmakes your form behave more closely to native forms.\nForm values are stored within the inputs themselves.\nUnmounting an input removes its value.\nHidden inputs should use the\nhidden\nattribute for storing hidden data.\nOnly registered inputs are included as submission data.\nUnmounted inputs must be notified at either\nuseForm\nor\nuseWatch\n's\nuseEffect\nfor the hook form to verify that the input is unmounted from the DOM.\nconst\nNotWork\n=\n(\n)\n=>\n{\nconst\n[\nshow\n,\nsetShow\n]\n=\nReact\n.\nuseState\n(\nfalse\n)\n// \u274c won't get notified, need to invoke unregister\nreturn\nshow\n&&\n<\ninput\n{\n...\nregister\n(\n\"test\"\n)\n}\n/\n>\n}\nconst\nWork\n=\n(\n{\ncontrol\n}\n)\n=>\n{\nconst\n{\nshow\n}\n=\nuseWatch\n(\n{\ncontrol\n}\n)\n// \u2705 get notified at useEffect\nreturn\nshow\n&&\n<\ninput\n{\n...\nregister\n(\n\"test1\"\n)\n}\n/\n>\n}\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n[\nshow\n,\nsetShow\n]\n=\nReact\n.\nuseState\n(\nfalse\n)\nconst\n{\ncontrol\n}\n=\nuseForm\n(\n{\nshouldUnregister\n:\ntrue\n}\n)\nreturn\n(\n<\ndiv\n>\n// \u2705 get notified at useForm's useEffect\n{\nshow\n&&\n<\ninput\n{\n...\nregister\n(\n\"test2\"\n)\n}\n/\n>\n}\n<\nNotWork\n/\n>\n<\nWork\ncontrol\n=\n{\ncontrol\n}\n/\n>\n<\n/\ndiv\n>\n)\n}\nshouldUseNativeValidation:\nboolean = false\nThis config will enable\nbrowser native validation\n. It will also enable CSS selectors\n:valid\nand\n:invalid\nmaking styling inputs easier. You can still use these selectors even when client-side validation is disabled.\nOnly works with\nonSubmit\nand\nonChange\nmodes, as the\nreportValidity\nexecution will focus the error input.\nEach registered field's validation message is required to be string to display them natively.\nThis feature only works with the\nregister\nAPI and\nuseController/Controller\nthat are connected with actual DOM references.\nExamples:\nCopy\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nexport\ndefault\nfunction\nApp\n(\n)\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\nshouldUseNativeValidation\n:\ntrue\n,\n}\n)\nconst\nonSubmit\n=\nasync\n(\ndata\n)\n=>\n{\nconsole\n.\nlog\n(\ndata\n)\n}\nreturn\n(\n<\nform onSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"firstName\"\n,\n{\nrequired\n:\n\"Please enter your first name.\"\n,\n}\n)\n}\n// custom message\n/\n>\n<\ninput type\n=\n\"submit\"\n/\n>\n<\n/\nform\n>\n)\n}\ndisabled:\nboolean = false\nThis config allows you to disable the entire form and all associated inputs when set to\ntrue\n.\nThis can be useful for preventing user interaction during asynchronous tasks or other\nsituations where inputs should be temporarily unresponsive.\nExamples:\nCopy\nimport\n{\nuseForm\n,\nController\n}\nfrom\n\"react-hook-form\"\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n[\ndisabled\n,\nsetDisabled\n]\n=\nuseState\n(\nfalse\n)\nconst\n{\nregister\n,\nhandleSubmit\n,\ncontrol\n}\n=\nuseForm\n(\n{\ndisabled\n,\n}\n)\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\nasync\n(\n)\n=>\n{\nsetDisabled\n(\ntrue\n)\nawait\nsleep\n(\n100\n)\nsetDisabled\n(\nfalse\n)\n}\n)\n}\n>\n<\ninput\ntype\n=\n{\n\"checkbox\"\n}\n{\n...\nregister\n(\n\"checkbox\"\n)\n}\ndata\n-\ntestid\n=\n{\n\"checkbox\"\n}\n/\n>\n<\nselect\n{\n...\nregister\n(\n\"select\"\n)\n}\ndata\n-\ntestid\n=\n{\n\"select\"\n}\n/\n>\n<\nController\ncontrol\n=\n{\ncontrol\n}\nrender\n=\n{\n(\n{\nfield\n}\n)\n=>\n<\ninput disabled\n=\n{\nfield\n.\ndisabled\n}\n/\n>\n}\nname\n=\n\"test\"\n/\n>\n<\nbutton type\n=\n\"submit\"\n>\nSubmit\n<\n/\nbutton\n>\n<\n/\nform\n>\n)\n}\nresolver:\nResolver\nThis function allows you to use any external validation library such as\nYup\n,\nZod\n,\nJoi\n,\nVest\n,\nAjv\nand many others. The goal is to make sure you can seamlessly integrate whichever validation library you prefer. If you're not using a library, you can always write your own logic to validate your forms.\nCopy\nnpm install @hookform/resolvers\nProps\nName\nType\nDescription\nvalues\nobject\nThis object contains the entire form values.\ncontext\nobject\nThis is the\ncontext\nobject which you can provide to the\nuseForm\nconfig. It is a mutable\nobject\nthat can be changed on each re-render.\noptions\n{\n  \"criteriaMode\": \"string\",\n  \"fields\": \"object\",\n  \"names\": \"string[]\"\n}\nThis is the option object containing information about the validated fields, names and\ncriteriaMode\nfrom\nuseForm\n.\nRULES\nSchema validation focuses on field-level error reporting. Parent-level error checking is limited to the direct parent level, which is applicable for components such as group checkboxes.\nThis function will be cached.\nRe-validation of an input will only occur one field at time during a user\u2019s interaction. The lib itself will evaluate the\nerror\nobject to trigger a re-render accordingly.\nA resolver can not be used with the built-in validators (e.g.: required, min, etc.)\nWhen building a custom resolver:\nMake sure that you return an object with both\nvalues\nand\nerrors\nproperties. Their default values should be an empty object. For example:\n{}\n.\nThe keys of the\nerrors\nobject should match the\nname\nvalues of your fields, but they\nmust\nbe hierarchical rather than a single key for deep errors:\n\u274c { \"participants.1.name\": someErr }\nwill not set or clear properly - instead, use\n\u2705 { participants: [null, { name: someErr } ] }\nas this is reachable\nas\nerrors.participants[1].name\n- you can still prepare your errors using flat keys, and then use a function like this one from the zod resolver:\ntoNestErrors(flatErrs, resolverOptions)\nExamples:\nYup\nZod\nJoi\nAjv\nVest\nCustom\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\nyupResolver\n}\nfrom\n\"@hookform/resolvers/yup\"\nimport\n*\nas\nyup\nfrom\n\"yup\"\nconst\nschema\n=\nyup\n.\nobject\n(\n)\n.\nshape\n(\n{\nname\n:\nyup\n.\nstring\n(\n)\n.\nrequired\n(\n)\n,\nage\n:\nyup\n.\nnumber\n(\n)\n.\nrequired\n(\n)\n,\n}\n)\n.\nrequired\n(\n)\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\nresolver\n:\nyupResolver\n(\nschema\n)\n,\n// yup, joi and even your own.\n}\n)\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\n(\nd\n)\n=>\nconsole\n.\nlog\n(\nd\n)\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"name\"\n)\n}\n/>\n<\ninput\ntype\n=\n\"\nnumber\n\"\n{\n...\nregister\n(\n\"age\"\n)\n}\n/>\n<\ninput\ntype\n=\n\"\nsubmit\n\"\n/>\n</\nform\n>\n)\n}\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\nzodResolver\n}\nfrom\n\"@hookform/resolvers/zod\"\nimport\n*\nas\nz\nfrom\n\"zod\"\nconst\nschema\n=\nz\n.\nobject\n(\n{\nname\n:\nz\n.\nstring\n(\n)\n,\nage\n:\nz\n.\nnumber\n(\n)\n,\n}\n)\ntype\nSchema\n=\nz\n.\ninfer\n<\ntypeof\nschema\n>\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\nresolver\n:\nzodResolver\n(\nschema\n)\n,\n}\n)\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\n{\n// handle inputs\nconsole\n.\nlog\n(\ndata\n)\n}\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"name\"\n)\n}\n/>\n<\ninput\n{\n...\nregister\n(\n\"age\"\n,\n{\nvalueAsNumber\n:\ntrue\n}\n)\n}\ntype\n=\n\"\nnumber\n\"\n/>\n<\ninput\ntype\n=\n\"\nsubmit\n\"\n/>\n</\nform\n>\n)\n}\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\njoiResolver\n}\nfrom\n\"@hookform/resolvers/joi\"\nimport\nJoi\nfrom\n\"joi\"\ninterface\nIFormInput\n{\nname\n:\nstring\nage\n:\nnumber\n}\nconst\nschema\n=\nJoi\n.\nobject\n(\n{\nname\n:\nJoi\n.\nstring\n(\n)\n.\nrequired\n(\n)\n,\nage\n:\nJoi\n.\nnumber\n(\n)\n.\nrequired\n(\n)\n,\n}\n)\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\n}\n=\nuseForm\n<\nIFormInput\n>\n(\n{\nresolver\n:\njoiResolver\n(\nschema\n)\n,\n}\n)\nconst\nonSubmit\n=\n(\ndata\n:\nIFormInput\n)\n=>\n{\nconsole\n.\nlog\n(\ndata\n)\n}\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"name\"\n)\n}\n/>\n<\ninput\ntype\n=\n\"\nnumber\n\"\n{\n...\nregister\n(\n\"age\"\n)\n}\n/>\n<\ninput\ntype\n=\n\"\nsubmit\n\"\n/>\n</\nform\n>\n)\n}\nCopy\nCodeSandbox\nTS\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\najvResolver\n}\nfrom\n\"@hookform/resolvers/ajv\"\n// must use `minLength: 1` to implement required field\nconst\nschema\n=\n{\ntype\n:\n\"object\"\n,\nproperties\n:\n{\nusername\n:\n{\ntype\n:\n\"string\"\n,\nminLength\n:\n1\n,\nerrorMessage\n:\n{\nminLength\n:\n\"username field is required\"\n}\n,\n}\n,\npassword\n:\n{\ntype\n:\n\"string\"\n,\nminLength\n:\n1\n,\nerrorMessage\n:\n{\nminLength\n:\n\"password field is required\"\n}\n,\n}\n,\n}\n,\nrequired\n:\n[\n\"username\"\n,\n\"password\"\n]\n,\nadditionalProperties\n:\nfalse\n,\n}\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\n}\n=\nuseForm\n(\n{\nresolver\n:\najvResolver\n(\nschema\n)\n,\n}\n)\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"username\"\n)\n}\n/>\n{\nerrors\n.\nusername\n&&\n<\np\n>\n{\nerrors\n.\nusername\n.\nmessage\n}\n</\np\n>\n}\n<\ninput\n{\n...\nregister\n(\n\"password\"\n)\n}\n/>\n{\nerrors\n.\npassword\n&&\n<\np\n>\n{\nerrors\n.\npassword\n.\nmessage\n}\n</\np\n>\n}\n<\nbutton\ntype\n=\n\"\nsubmit\n\"\n>\nsubmit\n</\nbutton\n>\n</\nform\n>\n)\n}\nCopy\nCodeSandbox\nTS\nimport\n*\nas\nReact\nfrom\n\"react\"\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n{\nvestResolver\n}\nfrom\n\"@hookform/resolvers/vest\"\nimport\nvest\n,\n{\ntest\n,\nenforce\n}\nfrom\n\"vest\"\nconst\nvalidationSuite\n=\nvest\n.\ncreate\n(\n(\ndata\n=\n{\n}\n)\n=>\n{\ntest\n(\n\"username\"\n,\n\"Username is required\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\nusername\n)\n.\nisNotEmpty\n(\n)\n}\n)\ntest\n(\n\"username\"\n,\n\"Must be longer than 3 chars\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\nusername\n)\n.\nlongerThan\n(\n3\n)\n}\n)\ntest\n(\n\"password\"\n,\n\"Password is required\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\npassword\n)\n.\nisNotEmpty\n(\n)\n}\n)\ntest\n(\n\"password\"\n,\n\"Password must be at least 5 chars\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\npassword\n)\n.\nlongerThanOrEquals\n(\n5\n)\n}\n)\ntest\n(\n\"password\"\n,\n\"Password must contain a digit\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\npassword\n)\n.\nmatches\n(\n/\n[\n0\n-\n9\n]\n/\n)\n}\n)\ntest\n(\n\"password\"\n,\n\"Password must contain a symbol\"\n,\n(\n)\n=>\n{\nenforce\n(\ndata\n.\npassword\n)\n.\nmatches\n(\n/\n[\n^\nA\n-\nZ\na\n-\nz\n0\n-\n9\n]\n/\n)\n}\n)\n}\n)\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n}\n=\nuseForm\n(\n{\nresolver\n:\nvestResolver\n(\nvalidationSuite\n)\n,\n}\n)\nreturn\n(\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\n(\ndata\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\n)\n}\n>\n<\ninput\n{\n...\nregister\n(\n\"username\"\n)\n}\n/>\n<\ninput\n{\n...\nregister\n(\n\"password\"\n)\n}\n/>\n<\ninput\ntype\n=\n\"\nsubmit\n\"\n/>\n</\nform\n>\n)\n}\nCopy\nCodeSandbox\nTS\nimport\n*\nas\nReact\nfrom\n\"react\"\nimport\n{\nuseForm\n}\nfrom\n\"react-hook-form\"\nimport\n*\nas\nJoi\nfrom\n\"joi\"\ninterface\nIFormInputs\n{\nusername\n:\nstring\n}\nconst\nvalidationSchema\n=\nJoi\n.\nobject\n(\n{\nusername\n:\nJoi\n.\nstring\n(\n)\n.\nalphanum\n(\n)\n.\nmin\n(\n3\n)\n.\nmax\n(\n30\n)\n.\nrequired\n(\n)\n,\n}\n)\nconst\nApp\n=\n(\n)\n=>\n{\nconst\n{\nregister\n,\nhandleSubmit\n,\nformState\n:\n{\nerrors\n}\n,\n}\n=\nuseForm\n<\nIFormInputs\n>\n(\n{\nresolver\n:\nasync\n(\ndata\n)\n=>\n{\nconst\n{\nerror\n,\nvalue\n:\nvalues\n}\n=\nvalidationSchema\n.\nvalidate\n(\ndata\n,\n{\nabortEarly\n:\nfalse\n,\n}\n)\nreturn\n{\nvalues\n:\nerror\n?\n{\n}\n:\nvalues\n,\nerrors\n:\nerror\n?\nerror\n.\ndetails\n.\nreduce\n(\n(\nprevious\n,\ncurrentError\n)\n=>\n{\nreturn\n{\n...\nprevious\n,\n[\ncurrentError\n.\npath\n[\n0\n]\n]\n:\ncurrentError\n,\n}\n}\n,\n{\n}\n)\n:\n{\n}\n,\n}\n}\n,\n}\n)\nconst\nonSubmit\n=\n(\ndata\n:\nIFormInputs\n)\n=>\nconsole\n.\nlog\n(\ndata\n)\nreturn\n(\n<\ndiv\nclassName\n=\n\"\nApp\n\"\n>\n<\nh1\n>\nresolver\n</\nh1\n>\n<\nform\nonSubmit\n=\n{\nhandleSubmit\n(\nonSubmit\n)\n}\n>\n<\nlabel\n>\nUsername\n</\nlabel\n>\n<\ninput\n{\n...\nregister\n(\n\"username\"\n)\n}\n/>\n{\nerrors\n.\nusername\n&&\n<\np\n>\nerrors.username.message\n</\np\n>\n}\n<\ninput\ntype\n=\n\"\nsubmit\n\"\n/>\n</\nform\n>\n</\ndiv\n>\n)\n}\nNeed more? See\nResolver Documentation\nTIP\nYou can debug your schema via the following code snippet:\nCopy\nresolver\n:\nasync\n(\ndata\n,\ncontext\n,\noptions\n)\n=>\n{\n// you can debug your validation schema here\nconsole\n.\nlog\n(\n\"formData\"\n,\ndata\n)\nconsole\n.\nlog\n(\n\"validation result\"\n,\nawait\nanyResolver\n(\nschema\n)\n(\ndata\n,\ncontext\n,\noptions\n)\n)\nreturn\nanyResolver\n(\nschema\n)\n(\ndata\n,\ncontext\n,\noptions\n)\n}\nuseForm\nreturn and\nuseEffect\ndependencies\nIn a future major release,\nuseForm\nreturn will be memoized to optimize performance and reflect changes in\nformState\n.\nAs a result, adding the entire return value of\nuseForm\nto a\nuseEffect\ndependency list may lead to infinite loops.\nWARNING\nThe following code is likely to create this situation:\nconst\nmethods\n=\nuseForm\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nmethods\n.\nreset\n(\n{\n...\n}\n)\n}\n,\n[\nmethods\n]\n)\nPassing only the relevant methods, as showed below, should avoid this kind of issue:\nconst\nmethods\n=\nuseForm\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nmethods\n.\nreset\n(\n{\n...\n}\n)\n}\n,\n[\nmethods\n.\nreset\n]\n)\nTIP\nThe recommended way is to pass destructured methods to the dependencies of an\nuseEffect\nconst\n{\nreset\n}\n=\nuseForm\n(\n)\nuseEffect\n(\n(\n)\n=>\n{\nreset\n(\n{\n...\n}\n)\n}\n,\n[\nreset\n]\n)\nMore info can be found on this issue\nReturn\nThe following list contains reference to\nuseForm\nreturn props.\nregister\nunregister\nformState\nwatch\nhandleSubmit\nreset\nresetField\nsetError\nclearErrors\nsetValue\nsetFocus\ngetValues\ngetFieldState\ntrigger\ncontrol\nForm\nThank you for your support\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\nStar us on GitHub",
  "content_markdown": "Select page...registerunregisterformstatewatchsubscribehandlesubmitresetresetFieldsetErrorclearErrorssetValuesetFocusgetValuesgetFieldStatetriggercontrolForm\n\n## </> `useForm:` [`UseFormProps`](/ts#UseFormProps)\n\n`useForm` is a custom hook for managing forms with ease. It takes one object as **optional** argument. The following example demonstrates all of its properties along with their default values.\n\n**Generic props:**\n\n| Option | Description |\n| --- | --- |\n| [mode](#mode) | Validation strategy **before** submitting behaviour. |\n| [reValidateMode](#reValidateMode) | Validation strategy **after** submitting behaviour. |\n| [defaultValues](#defaultValues) | Default values for the form, this value will be cached. |\n| [values](#values) | Reactive values to update the form values. |\n| [errors](#errors) | Server returns errors to update form. **\u26a0 Important:** Keep the errors object reference-stable to avoid infinite re-renders. |\n| [resetOptions](#resetOptions) | Option to reset form state update while updating new form values. |\n| [criteriaMode](#criteriaMode) | Display all validation errors or one at a time. |\n| [shouldFocusError](#shouldFocusError) | Enable or disable built-in focus management. |\n| [delayError](#delayError) | Delay error from appearing instantly. |\n| [shouldUseNativeValidation](#shouldUseNativeValidation) | Use browser built-in form constraint API. |\n| [shouldUnregister](#shouldUnregister) | Enable and disable input unregister after unmount. |\n| [disabled](#disabled) | Disable the entire form with all associated inputs. |\n\n**Schema validation props:**\n\n| Option | Description |\n| --- | --- |\n| [resolver](#resolver) | Integrates with your preferred schema validation library. |\n| [context](#context) | A context object to supply for your schema validation. |\n\n### Props\n\n---\n\n#### mode: onChange | onBlur | onSubmit | onTouched | all = 'onSubmit' !React Native: compatible with Controller\n\n---\n\nThis option allows you to configure the validation strategy before a user submits the form. The validation occurs during the `onSubmit` event, which is triggered by invoking the [`handleSubmit`](/docs/useform/handlesubmit) function.\n\n| Name | Type | Description |\n| --- | --- | --- |\n| onSubmit | string | Validation is triggered on the `submit` event, and inputs attach `onChange` event listeners to re-validate themselves. |\n| onBlur | string | Validation is triggered on the `blur` event. |\n| onChange | string | Validation is triggered on the `change`event for each input, leading to multiple re-renders. Warning: this often comes with a significant impact on performance. |\n| onTouched | string | Validation is initially triggered on the first `blur` event. After that, it is triggered on every `change` event.  **Note:** when using with `Controller`, make sure to wire up `onBlur` with the `render` prop. |\n| all | string | Validation is triggered on both `blur` and `change` events. |\n\n#### reValidateMode: onChange | onBlur | onSubmit = 'onChange' !React Native: Custom register or using Controller\n\n---\n\nThis option allows you to configure validation strategy when inputs with errors get re-validated **after** a user submits the form (`onSubmit` event and [`handleSubmit`](/docs/useform/handlesubmit) function executed). By default, re-validation occurs during the input change event.\n\n#### defaultValues: `FieldValues | () => Promise<FieldValues>`\n\n---\n\nThe `defaultValues` prop populates the entire form with default values. It supports both synchronous and asynchronous assignment of default values. While you can set an input's default value using `defaultValue` or `defaultChecked` [(as detailed in the official React documentation)](https://react.dev/reference/react-dom/components/input), it is **recommended** to use `defaultValues` for the entire form.\n\nCopy\n\n```\nuseForm({\n\ndefaultValues: {\n\nfirstName: '',\n\nlastName: ''\n\n}\n\n})\n\n// set default value async\n\nuseForm({\n\ndefaultValues: async () => fetch('/api-endpoint');\n\n})\n```\n\n**RULES**\n\n- You **should avoid** providing `undefined` as a default value, as it conflicts with the default state of a controlled component.\n- `defaultValues` are cached. To reset them, use the [reset](/docs/useform/reset) API.\n- `defaultValues` will be included in the submission result by default.\n- It's recommended to avoid using custom objects containing prototype methods, such as `Moment` or `Luxon`, as `defaultValues`.\n- There are other options for including form data:\n\n  ```\n  // adding a hidden input\n\n  <input {...register(\"hidden\", { value: \"data\" })} type=\"hidden\" />\n  ```\n\n  ```\n  // include data onSubmit\n\n  const onSubmit = (data) => {\n\n  const output = {\n\n  ...data,\n\n  others: \"others\",\n\n  }\n\n  }\n  ```\n\n#### values: FieldValues\n\n---\n\nThe `values` prop will react to changes and update the form values, which is useful when your form needs to be updated by external state or server data. The `values` prop will overwrite the `defaultValues` prop, unless `resetOptions: { keepDefaultValues: true }` is also set for `useForm`.\n\nCopy\n\n```\n// set default value sync\n\nfunction App({ values }) {\n\nuseForm({\n\nvalues, // will get updated when values props updates\n\n})\n\n}\n\nfunction App() {\n\nconst values = useFetch(\"/api\")\n\nuseForm({\n\ndefaultValues: {\n\nfirstName: \"\",\n\nlastName: \"\",\n\n},\n\nvalues, // will get updated once values returns\n\n})\n\n}\n```\n\n#### errors: FieldErrors\n\n---\n\nThe `errors` props will react to changes and update the server errors state, which is useful when your form needs to be updated by external server returned errors.\n\nCopy\n\n```\nfunction App() {\n\nconst { errors, data } = useFetch(\"/api\")\n\nuseForm({\n\nerrors, // will get updated once errors returns\n\n})\n\n}\n```\n\n#### resetOptions: KeepStateOptions\n\n---\n\nThis property is related to value update behaviors. When `values` or `defaultValues` are updated, the `reset` API is invoked internally. It's important to specify the desired behavior after `values` or `defaultValues` are asynchronously updated. The configuration option itself is a reference to the [reset](/docs/useform/reset) method's options.\n\nCopy\n\n```\n// by default asynchronously value or defaultValues update will reset the form values\n\nuseForm({ values })\n\nuseForm({ defaultValues: async () => await fetch() })\n\n// options to config the behaviour\n\n// eg: I want to keep user interacted/dirty value and not remove any user errors\n\nuseForm({\n\nvalues,\n\nresetOptions: {\n\nkeepDirtyValues: true, // user-interacted input will be retained\n\nkeepErrors: true, // input errors will be retained with value update\n\n},\n\n})\n```\n\n#### context: object\n\n---\n\n|  |  |\n| --- | --- |\n| This context `object` is mutable and will be injected into the `resolver`'s second argument or [Yup](https://github.com/jquense/yup) validation's context object. | [CodeSandbox](https://codesandbox.io/s/resolver-context-d9jqy) |\n\n#### criteriaMode: firstError | all\n\n---\n\n|  |  |\n| --- | --- |\n| - When set to `firstError` (default), only the first error from each field will be gathered. - When set to `all`, all errors from each field will be gathered. | [CodeSandbox](https://codesandbox.io/s/react-hook-form-v6-errors-validatecriteriamode-all-p9xm6) |\n\n#### shouldFocusError: boolean = true\n\n---\n\nWhen set to `true` (default), and the user submits a form that fails validation, focus is set on the first field with an error.\n\n**NOTE**\n\n- Only registered fields with a `ref` will work. Custom registered inputs do not\n  apply. For example: `register('test') // doesn't work`\n- The focus order is based on the `register` order.\n\n#### delayError: number\n\n---\n\n|  |  |\n| --- | --- |\n| This configuration delays the display of error states to the end-user by a specified number of milliseconds. If the user corrects the error input, the error is removed instantly, and the delay is not applied. | [CodeSandbox](https://codesandbox.io/s/useform-delayerror-q6c2d) |\n\n#### shouldUnregister: boolean = false\n\n---\n\nBy default, an input value will be retained when input is removed. However, you can set `shouldUnregister` to `true` to `unregister` input during unmount.\n\n- This is a global configuration that overrides child-level configurations. To have individual behavior, set the configuration at the component or hook level, not at `useForm`.\n- By default, `shouldUnregister: false` means unmounted fields are **not validated** by built-in validation.\n- By setting `shouldUnregister` to true at `useForm` level, `defaultValues` will **not** be merged against submission result.\n- Setting `shouldUnregister: true` makes your form behave more closely to native forms.\n  - Form values are stored within the inputs themselves.\n  - Unmounting an input removes its value.\n  - Hidden inputs should use the `hidden` attribute for storing hidden data.\n  - Only registered inputs are included as submission data.\n  - Unmounted inputs must be notified at either `useForm` or `useWatch`'s `useEffect` for the hook form to verify that the input is unmounted from the DOM.\n\n    ```\n    const NotWork = () => {\n\n    const [show, setShow] = React.useState(false)\n\n    // \u274c won't get notified, need to invoke unregister\n\n    return show && <input {...register(\"test\")} />\n\n    }\n\n    const Work = ({ control }) => {\n\n    const { show } = useWatch({ control })\n\n    // \u2705 get notified at useEffect\n\n    return show && <input {...register(\"test1\")} />\n\n    }\n\n    const App = () => {\n\n    const [show, setShow] = React.useState(false)\n\n    const { control } = useForm({ shouldUnregister: true })\n\n    return (\n\n    <div>\n\n    // \u2705 get notified at useForm's useEffect\n\n    {show && <input {...register(\"test2\")} />}\n\n    <NotWork />\n\n    <Work control={control} />\n\n    </div>\n\n    )\n\n    }\n    ```\n\n#### shouldUseNativeValidation: boolean = false\n\n---\n\nThis config will enable [browser native validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation). It will also enable CSS selectors `:valid` and`:invalid` making styling inputs easier. You can still use these selectors even when client-side validation is disabled.\n\n- Only works with `onSubmit` and `onChange` modes, as the `reportValidity` execution will focus the error input.\n- Each registered field's validation message is required to be string to display them natively.\n- This feature only works with the `register` API and\u00a0 `useController/Controller` that are connected with actual DOM references.\n\n**Examples:**\n\n---\n\nCopy\n\n```\nimport { useForm } from \"react-hook-form\"\n\nexport default function App() {\n\nconst { register, handleSubmit } = useForm({\n\nshouldUseNativeValidation: true,\n\n})\n\nconst onSubmit = async (data) => {\n\nconsole.log(data)\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<input\n\n{...register(\"firstName\", {\n\nrequired: \"Please enter your first name.\",\n\n})} // custom message\n\n/>\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\n#### disabled: boolean = false\n\n---\n\nThis config allows you to disable the entire form and all associated inputs when set to `true`.  \nThis can be useful for preventing user interaction during asynchronous tasks or other\nsituations where inputs should be temporarily unresponsive.\n\n**Examples:**\n\n---\n\nCopy\n\n```\nimport { useForm, Controller } from \"react-hook-form\"\n\nconst App = () => {\n\nconst [disabled, setDisabled] = useState(false)\n\nconst { register, handleSubmit, control } = useForm({\n\ndisabled,\n\n})\n\nreturn (\n\n<form\n\nonSubmit={handleSubmit(async () => {\n\nsetDisabled(true)\n\nawait sleep(100)\n\nsetDisabled(false)\n\n})}\n\n>\n\n<input\n\ntype={\"checkbox\"}\n\n{...register(\"checkbox\")}\n\ndata-testid={\"checkbox\"}\n\n/>\n\n<select {...register(\"select\")} data-testid={\"select\"} />\n\n<Controller\n\ncontrol={control}\n\nrender={({ field }) => <input disabled={field.disabled} />}\n\nname=\"test\"\n\n/>\n\n<button type=\"submit\">Submit</button>\n\n</form>\n\n)\n\n}\n```\n\n#### resolver: [Resolver](/ts#Resolver)\n\n---\n\nThis function allows you to use any external validation library such as [Yup](https://github.com/jquense/yup), [Zod](https://github.com/vriad/zod), [Joi](https://github.com/hapijs/joi), [Vest](https://github.com/ealush/vest), [Ajv](https://github.com/ajv-validator/ajv) and many others. The goal is to make sure you can seamlessly integrate whichever validation library you prefer. If you're not using a library, you can always write your own logic to validate your forms.\n\nCopy\n\n```\nnpm install @hookform/resolvers\n```\n\n##### Props\n\n---\n\n| Name | Type | Description |\n| --- | --- | --- |\n| `values` | object | This object contains the entire form values. |\n| `context` | object | This is the `context` object which you can provide to the `useForm` config. It is a mutable `object` that can be changed on each re-render. |\n| `options` | ``` {   \"criteriaMode\": \"string\",   \"fields\": \"object\",   \"names\": \"string[]\" } ``` | This is the option object containing information about the validated fields, names and `criteriaMode` from `useForm`. |\n\n**RULES**\n\n- Schema validation focuses on field-level error reporting. Parent-level error checking is limited to the direct parent level, which is applicable for components such as group checkboxes.\n- This function will be cached.\n- Re-validation of an input will only occur one field at time during a user\u2019s interaction. The lib itself will evaluate the `error` object to trigger a re-render accordingly.\n- A resolver can not be used with the built-in validators (e.g.: required, min, etc.)\n- When building a custom resolver:\n  - Make sure that you return an object with both `values` and `errors` properties. Their default values should be an empty object. For example: `{}`.\n  - The keys of the `errors` object should match the `name` values of your fields, but they *must* be hierarchical rather than a single key for deep errors:\n    `\u274c { \"participants.1.name\": someErr }` will not set or clear properly - instead, use `\u2705 { participants: [null, { name: someErr } ] }` as this is reachable\n    as `errors.participants[1].name` - you can still prepare your errors using flat keys, and then use a function like this one from the zod resolver:\n    [toNestErrors(flatErrs, resolverOptions)](https://github.com/react-hook-form/resolvers/blob/master/src/toNestErrors.ts)\n\n**Examples:**\n\n---\n\nYupZodJoiAjvVestCustom\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-apply-validation-ts-forked-nmbyh)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nimport { yupResolver } from \"@hookform/resolvers/yup\"\n\nimport * as yup from \"yup\"\n\nconst schema = yup\n\n.object()\n\n.shape({\n\nname: yup.string().required(),\n\nage: yup.number().required(),\n\n})\n\n.required()\n\nconst App = () => {\n\nconst { register, handleSubmit } = useForm({\n\nresolver: yupResolver(schema), // yup, joi and even your own.\n\n})\n\nreturn (\n\n<form onSubmit={handleSubmit((d) => console.log(d))}>\n\n<input {...register(\"name\")} />\n\n<input type=\"number\" {...register(\"age\")} />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-zod-resolver-ts-example-forked-w72vp)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nimport { zodResolver } from \"@hookform/resolvers/zod\"\n\nimport * as z from \"zod\"\n\nconst schema = z.object({\n\nname: z.string(),\n\nage: z.number(),\n\n})\n\ntype Schema = z.infer<typeof schema>\n\nconst App = () => {\n\nconst { register, handleSubmit } = useForm({\n\nresolver: zodResolver(schema),\n\n})\n\nreturn (\n\n<form\n\nonSubmit={handleSubmit((data) => {\n\n// handle inputs\n\nconsole.log(data)\n\n})}\n\n>\n\n<input {...register(\"name\")} />\n\n<input {...register(\"age\", { valueAsNumber: true })} type=\"number\" />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-joiresolver-v6-ts-forked-5pseh)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nimport { joiResolver } from \"@hookform/resolvers/joi\"\n\nimport Joi from \"joi\"\n\ninterface IFormInput {\n\nname: string\n\nage: number\n\n}\n\nconst schema = Joi.object({\n\nname: Joi.string().required(),\n\nage: Joi.number().required(),\n\n})\n\nconst App = () => {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\n} = useForm<IFormInput>({\n\nresolver: joiResolver(schema),\n\n})\n\nconst onSubmit = (data: IFormInput) => {\n\nconsole.log(data)\n\n}\n\nreturn (\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<input {...register(\"name\")} />\n\n<input type=\"number\" {...register(\"age\")} />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-ajvresolver-vr3imc)\n\n```\nimport { useForm } from \"react-hook-form\"\n\nimport { ajvResolver } from \"@hookform/resolvers/ajv\"\n\n// must use `minLength: 1` to implement required field\n\nconst schema = {\n\ntype: \"object\",\n\nproperties: {\n\nusername: {\n\ntype: \"string\",\n\nminLength: 1,\n\nerrorMessage: { minLength: \"username field is required\" },\n\n},\n\npassword: {\n\ntype: \"string\",\n\nminLength: 1,\n\nerrorMessage: { minLength: \"password field is required\" },\n\n},\n\n},\n\nrequired: [\"username\", \"password\"],\n\nadditionalProperties: false,\n\n}\n\nconst App = () => {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\n} = useForm({\n\nresolver: ajvResolver(schema),\n\n})\n\nreturn (\n\n<form onSubmit={handleSubmit((data) => console.log(data))}>\n\n<input {...register(\"username\")} />\n\n{errors.username && <p>{errors.username.message}</p>}\n\n<input {...register(\"password\")} />\n\n{errors.password && <p>{errors.password.message}</p>}\n\n<button type=\"submit\">submit</button>\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/vest-8q874)\n\n```\nimport * as React from \"react\"\n\nimport { useForm } from \"react-hook-form\"\n\nimport { vestResolver } from \"@hookform/resolvers/vest\"\n\nimport vest, { test, enforce } from \"vest\"\n\nconst validationSuite = vest.create((data = {}) => {\n\ntest(\"username\", \"Username is required\", () => {\n\nenforce(data.username).isNotEmpty()\n\n})\n\ntest(\"username\", \"Must be longer than 3 chars\", () => {\n\nenforce(data.username).longerThan(3)\n\n})\n\ntest(\"password\", \"Password is required\", () => {\n\nenforce(data.password).isNotEmpty()\n\n})\n\ntest(\"password\", \"Password must be at least 5 chars\", () => {\n\nenforce(data.password).longerThanOrEquals(5)\n\n})\n\ntest(\"password\", \"Password must contain a digit\", () => {\n\nenforce(data.password).matches(/[0-9]/)\n\n})\n\ntest(\"password\", \"Password must contain a symbol\", () => {\n\nenforce(data.password).matches(/[^A-Za-z0-9]/)\n\n})\n\n})\n\nconst App = () => {\n\nconst { register, handleSubmit } = useForm({\n\nresolver: vestResolver(validationSuite),\n\n})\n\nreturn (\n\n<form onSubmit={handleSubmit((data) => console.log(data))}>\n\n<input {...register(\"username\")} />\n\n<input {...register(\"password\")} />\n\n<input type=\"submit\" />\n\n</form>\n\n)\n\n}\n```\n\nCopy [CodeSandbox TS](https://codesandbox.io/s/react-hook-form-customresoliver-ts-v7-juc63)\n\n```\nimport * as React from \"react\"\n\nimport { useForm } from \"react-hook-form\"\n\nimport * as Joi from \"joi\"\n\ninterface IFormInputs {\n\nusername: string\n\n}\n\nconst validationSchema = Joi.object({\n\nusername: Joi.string().alphanum().min(3).max(30).required(),\n\n})\n\nconst App = () => {\n\nconst {\n\nregister,\n\nhandleSubmit,\n\nformState: { errors },\n\n} = useForm<IFormInputs>({\n\nresolver: async (data) => {\n\nconst { error, value: values } = validationSchema.validate(data, {\n\nabortEarly: false,\n\n})\n\nreturn {\n\nvalues: error ? {} : values,\n\nerrors: error\n\n? error.details.reduce((previous, currentError) => {\n\nreturn {\n\n...previous,\n\n[currentError.path[0]]: currentError,\n\n}\n\n}, {})\n\n: {},\n\n}\n\n},\n\n})\n\nconst onSubmit = (data: IFormInputs) => console.log(data)\n\nreturn (\n\n<div className=\"App\">\n\n<h1>resolver</h1>\n\n<form onSubmit={handleSubmit(onSubmit)}>\n\n<label>Username</label>\n\n<input {...register(\"username\")} />\n\n{errors.username && <p>errors.username.message</p>}\n\n<input type=\"submit\" />\n\n</form>\n\n</div>\n\n)\n\n}\n```\n\nNeed more? See [Resolver Documentation](https://github.com/react-hook-form/resolvers#quickstart)\n\n**TIP**\n\nYou can debug your schema via the following code snippet:\n\nCopy\n\n```\nresolver: async (data, context, options) => {\n\n// you can debug your validation schema here\n\nconsole.log(\"formData\", data)\n\nconsole.log(\n\n\"validation result\",\n\nawait anyResolver(schema)(data, context, options)\n\n)\n\nreturn anyResolver(schema)(data, context, options)\n\n}\n```\n\n#### `useForm` return and `useEffect` dependencies\n\nIn a future major release, `useForm` return will be memoized to optimize performance and reflect changes in `formState`.\nAs a result, adding the entire return value of `useForm` to a `useEffect` dependency list may lead to infinite loops.\n\n**WARNING**\n\nThe following code is likely to create this situation:\n\n```\nconst methods = useForm()\n\nuseEffect(() => {\n\nmethods.reset({ ... })\n\n}, [methods])\n```\n\nPassing only the relevant methods, as showed below, should avoid this kind of issue:\n\n```\nconst methods = useForm()\n\nuseEffect(() => {\n\nmethods.reset({ ... })\n\n}, [methods.reset])\n```\n\n**TIP**\n\nThe recommended way is to pass destructured methods to the dependencies of an `useEffect`\n\n```\nconst { reset } = useForm()\n\nuseEffect(() => {\n\nreset({ ... })\n\n}, [reset])\n```\n\n[More info can be found on this issue](https://github.com/react-hook-form/react-hook-form/issues/12463)\n\n#### Return\n\n---\n\nThe following list contains reference to `useForm` return props.\n\n- [register](/docs/useform/register)\n- [unregister](/docs/useform/unregister)\n- [formState](/docs/useform/formstate)\n- [watch](/docs/useform/watch)\n- [handleSubmit](/docs/useform/handlesubmit)\n- [reset](/docs/useform/reset)\n- [resetField](/docs/useform/resetfield)\n- [setError](/docs/useform/seterror)\n- [clearErrors](/docs/useform/clearerrors)\n- [setValue](/docs/useform/setvalue)\n- [setFocus](/docs/useform/setfocus)\n- [getValues](/docs/useform/getvalues)\n- [getFieldState](/docs/useform/getfieldstate)\n- [trigger](/docs/useform/trigger)\n- [control](/docs/useform/control)\n- [Form](/docs/useform/form)\n\n# Thank you for your support\n\nIf you find React Hook Form to be useful in your project, please consider to star and support it.\n\nStar us on GitHub",
  "tags": [
    "react",
    "forms",
    "validation",
    "hooks"
  ],
  "extracted_at": "2026-02-03T12:49:51.843648+00:00",
  "content_length": 19341,
  "content_hash": "608c637524ad1747"
}