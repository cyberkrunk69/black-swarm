<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Task Dependency Graph</title>
  <style>
    body { font-family: Arial, sans-serif; margin:0; padding:0; }
    svg { width: 100vw; height: 100vh; }
    .node circle { stroke: #333; stroke-width: 1.5px; }
    .node text { pointer-events: none; font-size: 12px; }
    .link { fill: none; stroke: #999; stroke-opacity: 0.6; stroke-width: 1.5px; }
    .status-completed circle { fill: #4caf50; }        /* green */
    .status-inprogress circle { 
      fill: #fff; 
      stroke: url(#rainbow-gradient); 
      stroke-width: 4px; 
    }
    .status-blocked circle { fill: #9e9e9e; }        /* gray */
    /* Rainbow gradient for in‑progress border */
    #rainbow-gradient stop:nth-child(1) { stop-color:#ff0000; }
    #rainbow-gradient stop:nth-child(2) { stop-color:#ff7f00; }
    #rainbow-gradient stop:nth-child(3) { stop-color:#ffff00; }
    #rainbow-gradient stop:nth-child(4) { stop-color:#00ff00; }
    #rainbow-gradient stop:nth-child(5) { stop-color:#0000ff; }
    #rainbow-gradient stop:nth-child(6) { stop-color:#4b0082; }
    #rainbow-gradient stop:nth-child(7) { stop-color:#9400d3; }
  </style>
</head>
<body>
<svg></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function() {
  // -----------------------------------------------------------------
  // Helper: load all grind_tasks_*.json files in the workspace root.
  // -----------------------------------------------------------------
  async function loadTaskFiles() {
    // The list of files is not known a‑priori. In a real environment you
    // would generate this list server‑side or via a build step.
    // For the purpose of this static demo we assume the files are placed
    // next to this HTML file in a folder called "data".
    const response = await fetch('data/task_file_index.json');
    const index = await response.json(); // e.g. ["grind_tasks_a.json","grind_tasks_b.json"]
    const promises = index.map(fname => fetch(`data/${fname}`).then(r=>r.json()));
    return Promise.all(promises);
  }

  // -----------------------------------------------------------------
  // Parse tasks -> nodes & edges
  // -----------------------------------------------------------------
  function buildGraph(taskLists) {
    const nodes = new Map(); // id -> node object
    const links = [];

    taskLists.forEach(tasks => {
      tasks.forEach(t => {
        const id = t.id || t.name; // assume each task has a unique id or name
        if (!nodes.has(id)) {
          nodes.set(id, {
            id,
            label: t.label || t.name || id,
            phase: t.phase || 'unknown',
            status: t.status || 'blocked' // expected: "completed","in-progress","blocked"
          });
        }
        // dependencies array (ids of tasks that must finish before this one)
        (t.dependencies || []).forEach(dep => {
          links.push({ source: dep, target: id });
        });
      });
    });

    return { nodes: Array.from(nodes.values()), links };
  }

  // -----------------------------------------------------------------
  // Render using D3 force‑directed layout (acyclic, but works for DAG)
  // -----------------------------------------------------------------
  function render({nodes, links}) {
    const svg = d3.select('svg');
    const width = +svg.attr('width') || window.innerWidth;
    const height = +svg.attr('height') || window.innerHeight;

    // Define rainbow gradient for in‑progress border
    const defs = svg.append('defs');
    const gradient = defs.append('linearGradient')
        .attr('id','rainbow-gradient')
        .attr('gradientUnits','userSpaceOnUse')
        .attr('x1','0%')
        .attr('x2','100%')
        .attr('y1','0%')
        .attr('y2','0%');
    const colors = ['#ff0000','#ff7f00','#ffff00','#00ff00','#0000ff','#4b0082','#9400d3'];
    colors.forEach((c,i) => {
      gradient.append('stop')
        .attr('offset', `${i/(colors.length-1)*100}%`)
        .attr('stop-color', c);
    });

    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(150))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width/2, height/2));

    const link = svg.append('g')
        .attr('class','links')
        .selectAll('path')
        .data(links)
        .enter()
        .append('path')
        .attr('class','link')
        .attr('marker-end','url(#arrow)');

    // Arrowhead definition
    defs.append('marker')
        .attr('id','arrow')
        .attr('viewBox','0 -5 10 10')
        .attr('refX',15)
        .attr('refY',0)
        .attr('markerWidth',6)
        .attr('markerHeight',6)
        .attr('orient','auto')
        .append('path')
        .attr('d','M0,-5L10,0L0,5')
        .attr('fill','#999');

    const node = svg.append('g')
        .attr('class','nodes')
        .selectAll('g')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', d => `node status-${d.status.replace('_','')}`);

    node.append('circle')
        .attr('r',20);

    node.append('text')
        .attr('dx',0)
        .attr('dy',4)
        .attr('text-anchor','middle')
        .text(d=>d.label);

    simulation.on('tick', () => {
      link.attr('d', d => {
        const src = d.source;
        const tgt = d.target;
        const dx = tgt.x - src.x,
              dy = tgt.y - src.y,
              dr = 0;
        return `M${src.x},${src.y}L${tgt.x},${tgt.y}`;
      });

      node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Drag behaviour
    const drag = d3.drag()
        .on('start', (event,d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x;
          d.fy = d.y;
        })
        .on('drag', (event,d) => {
          d.fx = event.x;
          d.fy = event.y;
        })
        .on('end', (event,d) => {
          if (!event.active) simulation.alphaTarget(0);
          d.fx = null;
          d.fy = null;
        });

    node.call(drag);
  }

  // -----------------------------------------------------------------
  // Main execution
  // -----------------------------------------------------------------
  try {
    const taskLists = await loadTaskFiles(); // array of arrays
    const graph = buildGraph(taskLists);
    render(graph);
  } catch (e) {
    console.error('Failed to load or render task graph:', e);
    d3.select('body').append('pre').text(e.stack);
  }
})();
</script>
</body>
</html>