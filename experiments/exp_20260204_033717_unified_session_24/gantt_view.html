<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Parallel Execution Timeline (Gantt)</title>
  <style>
    body { font-family: Arial, sans-serif; margin:0; overflow:hidden; }
    .axis path,
    .axis line { fill: none; stroke: #000; shape-rendering: crispEdges; }
    .task { stroke: #000; stroke-width: 1px; }
    .tooltip {
      position: absolute;
      padding: 4px 8px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 3px;
      pointer-events: none;
      font-size: 12px;
    }
  </style>
</head>
<body>
<div id="chart"></div>
<div class="tooltip" style="display:none;"></div>

<!-- D3 v7 -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
/**
 * Expected data format (JSON):
 * [
 *   {
 *     "task": "Task A",
 *     "worker": 0,
 *     "start": "2026-02-04T10:00:00Z",
 *     "end":   "2026-02-04T10:05:30Z",
 *     "origin": "module_a.py"
 *   },
 *   ...
 * ]
 *
 * The file can be loaded via `data.json` placed in the same folder.
 */

const margin = {top: 20, right: 20, bottom: 30, left: 80};
const slotHeight = 30;
const slotPadding = 5;
const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

const svg = d3.select("#chart")
  .append("svg")
  .attr("width", window.innerWidth)
  .attr("height", window.innerHeight)
  .call(d3.zoom().scaleExtent([0.5, 10]).on("zoom", zoomed));

const g = svg.append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`);

let xScale = d3.scaleTime();
let yScale = d3.scaleBand().paddingInner(0.1).paddingOuter(0.2);
let xAxis = g.append("g").attr("class", "x axis");
let yAxis = g.append("g").attr("class", "y axis");

const tooltip = d3.select(".tooltip");

// Load data
d3.json("data.json").then(render);

function render(data) {
  // Parse dates
  data.forEach(d => {
    d.start = new Date(d.start);
    d.end   = new Date(d.end);
  });

  const workers = Array.from(new Set(data.map(d => d.worker))).sort((a,b)=>a-b);
  const timeExtent = d3.extent([...data.map(d=>d.start), ...data.map(d=>d.end)]);

  xScale.domain(timeExtent).range([0, window.innerWidth - margin.left - margin.right]);
  yScale.domain(workers).range([0, workers.length * slotHeight]);

  // Axes
  xAxis.attr("transform", `translate(0,${yScale.range()[1]})`)
       .call(d3.axisBottom(xScale).ticks(10).tickFormat(d3.timeFormat("%H:%M:%S")));
  yAxis.call(d3.axisLeft(yScale).tickFormat(d => `Worker ${d}`));

  // Tasks
  const tasks = g.selectAll(".task")
    .data(data)
    .enter()
    .append("rect")
    .attr("class", "task")
    .attr("x", d => xScale(d.start))
    .attr("y", d => yScale(d.worker) + slotPadding/2)
    .attr("height", yScale.bandwidth() - slotPadding)
    .attr("width", d => Math.max(1, xScale(d.end) - xScale(d.start)))
    .attr("fill", d => colorScale(d.origin))
    .on("mouseover", (event,d) => {
      tooltip.style("display","block")
        .html(`<strong>${d.task}</strong><br/>
               Origin: ${d.origin}<br/>
               Start: ${d3.timeFormat("%Y-%m-%d %H:%M:%S")(d.start)}<br/>
               End:   ${d3.timeFormat("%Y-%m-%d %H:%M:%S")(d.end)}`)
        .style("left", (event.pageX+10)+"px")
        .style("top", (event.pageY-28)+"px");
    })
    .on("mouseout", () => tooltip.style("display","none"));
}

// Zoom & pan handling
function zoomed(event) {
  const transform = event.transform;
  const newXScale = transform.rescaleX(xScale);
  xAxis.call(d3.axisBottom(newXScale).ticks(10).tickFormat(d3.timeFormat("%H:%M:%S")));

  g.selectAll(".task")
    .attr("x", d => newXScale(d.start))
    .attr("width", d => Math.max(1, newXScale(d.end) - newXScale(d.start)));
}

// Resize handling
window.addEventListener("resize", () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  svg.attr("width", w).attr("height", h);
  xScale.range([0, w - margin.left - margin.right]);
  yScale.range([0, yScale.domain().length * slotHeight]);
  xAxis.attr("transform", `translate(0,${yScale.range()[1]})`);
  render(d3.selectAll(".task").data()); // reâ€‘render with updated scales
});
</script>
</body>
</html>