<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Task Dependency Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node text {
            pointer-events: none;
            font-size: 10px;
        }
        .completed circle {
            fill: #4caf50; /* green */
        }
        .blocked circle {
            fill: #9e9e9e; /* gray */
        }
        .in-progress circle {
            fill: #fff;
        }
        .rainbow {
            stroke: url(#rainbow-gradient);
            stroke-width: 3px;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            marker-end: url(#arrow);
        }
    </style>
</head>
<body>
    <h2>Task Dependency Graph</h2>
    <svg id="svgCanvas" width="1200" height="800"></svg>

    <script>
        // ------------------------------------------------------------------
        // Configuration
        // ------------------------------------------------------------------
        // Add the names of all grind_tasks_*.json files you want to visualise.
        const jsonFiles = [
            "grind_tasks_phase1.json",
            "grind_tasks_phase2.json",
            "grind_tasks_phase3.json"
            // extend this list as needed
        ];

        // ------------------------------------------------------------------
        // Helper: Load all JSON files and merge their content
        // ------------------------------------------------------------------
        async function loadAllData(files) {
            const allTasks = [];
            for (const f of files) {
                const resp = await fetch(f);
                if (!resp.ok) {
                    console.warn(`Could not fetch ${f}: ${resp.statusText}`);
                    continue;
                }
                const data = await resp.json();
                // Expect each file to contain an array of task objects
                // Example task object:
                // {
                //   "id": "task_42",
                //   "phase": "phase1",
                //   "deps": ["task_10", "task_11"],
                //   "status": "completed"   // or "in-progress" or "blocked"
                // }
                allTasks.push(...data);
            }
            return allTasks;
        }

        // ------------------------------------------------------------------
        // Build nodes & links from raw task objects
        // ------------------------------------------------------------------
        function buildGraph(tasks) {
            const nodeMap = new Map();
            const nodes = [];
            const links = [];

            tasks.forEach(t => {
                const node = {
                    id: t.id,
                    phase: t.phase,
                    status: t.status
                };
                nodeMap.set(t.id, node);
                nodes.push(node);
            });

            tasks.forEach(t => {
                if (Array.isArray(t.deps)) {
                    t.deps.forEach(depId => {
                        if (nodeMap.has(depId)) {
                            links.push({
                                source: depId,
                                target: t.id
                            });
                        } else {
                            console.warn(`Dependency ${depId} not found for task ${t.id}`);
                        }
                    });
                }
            });

            return {nodes, links};
        }

        // ------------------------------------------------------------------
        // Render the graph using D3
        // ------------------------------------------------------------------
        function renderGraph({nodes, links}) {
            const svg = d3.select("#svgCanvas");
            const width = +svg.attr("width");
            const height = +svg.attr("height");

            // Define arrow marker
            svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 15)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");

            // Rainbow gradient for inâ€‘progress border
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "rainbow-gradient")
                .attr("gradientUnits", "userSpaceOnUse")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "100%")
                .attr("y2", "0%");

            const colors = ["red","orange","yellow","green","blue","indigo","violet"];
            colors.forEach((c,i) => {
                gradient.append("stop")
                    .attr("offset", `${i/(colors.length-1)*100}%`)
                    .attr("stop-color", c);
            });

            const link = svg.append("g")
                .attr("class", "links")
                .selectAll("path")
                .data(links)
                .enter()
                .append("path")
                .attr("class", "link");

            const node = svg.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter()
                .append("g")
                .attr("class", d => `node ${statusClass(d.status)}`);

            node.append("circle")
                .attr("r", 12)
                .attr("class", d => d.status === "in-progress" ? "rainbow" : null);

            node.append("text")
                .attr("dx", 15)
                .attr("dy", 4)
                .text(d => d.id);

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(80))
                .force("charge", d3.forceManyBody().strength(-300))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked);

            function ticked() {
                link.attr("d", d => {
                    const srcX = d.source.x,
                          srcY = d.source.y,
                          tgtX = d.target.x,
                          tgtY = d.target.y;
                    return `M${srcX},${srcY} L${tgtX},${tgtY}`;
                });

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            }

            function statusClass(status) {
                switch (status) {
                    case "completed": return "completed";
                    case "in-progress": return "in-progress";
                    case "blocked": return "blocked";
                    default: return "";
                }
            }
        }

        // ------------------------------------------------------------------
        // Main
        // ------------------------------------------------------------------
        (async () => {
            const tasks = await loadAllData(jsonFiles);
            const graph = buildGraph(tasks);
            renderGraph(graph);
        })();
    </script>
</body>
</html>