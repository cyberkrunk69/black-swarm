<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Task Dependency Graph</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
        .node { cursor: pointer; }
        .node.completed circle { fill: #4caf50; }          /* green */
        .node.in_progress circle { stroke: url(#rainbow); stroke-width: 4; fill: #fff; }
        .node.blocked circle { fill: #9e9e9e; }            /* gray */
        .node text { font-size: 12px; pointer-events: none; }
        .link { fill: none; stroke: #555; stroke-width: 1.5px; }
        #rainbow {
            stop-color: red;
            stop-opacity: 1;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<svg width="100%" height="100%" id="graph"></svg>

<script>
// Utility: fetch all grind_tasks_*.json files in the same directory
async function fetchTaskFiles() {
    // This simple approach assumes a manifest file named "manifest.json"
    // containing an array of filenames. If not present, you can manually
    // list the files here.
    try {
        const resp = await fetch('manifest.json');
        const list = await resp.json(); // e.g., ["grind_tasks_a.json","grind_tasks_b.json"]
        const promises = list.map(f => fetch(f).then(r => r.json()));
        return Promise.all(promises);
    } catch (_) {
        // Fallback: hard‑code an example list (adjust as needed)
        const files = ['grind_tasks_1.json', 'grind_tasks_2.json'];
        const promises = files.map(f => fetch(f).then(r => r.json()));
        return Promise.all(promises);
    }
}

// Build nodes & links from raw JSON
function buildGraph(dataArrays) {
    const nodes = new Map(); // id -> node data
    const links = [];

    dataArrays.forEach(arr => {
        arr.forEach(task => {
            const id = task.id || task.task_id || task.name;
            if (!id) return;
            const phase = task.phase || 'unknown';
            const status = task.status || 'blocked'; // expected: completed, in_progress, blocked
            // Store node
            if (!nodes.has(id)) {
                nodes.set(id, { id, phase, status });
            }

            // Dependencies (array of ids)
            const deps = task.dependencies || task.depends_on || [];
            deps.forEach(dep => {
                links.push({ source: dep, target: id });
            });
        });
    });

    return { nodes: Array.from(nodes.values()), links };
}

// Render using D3
function renderGraph({nodes, links}) {
    const svg = d3.select('#graph');
    const width = window.innerWidth;
    const height = window.innerHeight;
    svg.attr('viewBox', [0, 0, width, height]);

    // Define rainbow gradient for in‑progress border
    const defs = svg.append('defs');
    const gradient = defs.append('linearGradient')
        .attr('id', 'rainbow')
        .attr('gradientUnits', 'userSpaceOnUse')
        .attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', 1);
    const colors = ['red','orange','yellow','green','blue','indigo','violet'];
    colors.forEach((c,i)=> {
        gradient.append('stop')
            .attr('offset', `${(i/(colors.length-1))*100}%`)
            .attr('stop-color', c);
    });

    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d=>d.id).distance(120))
        .force('charge', d3.forceManyBody().strength(-400))
        .force('center', d3.forceCenter(width/2, height/2));

    const link = svg.append('g')
        .attr('stroke', '#999')
        .attr('stroke-opacity', 0.6)
      .selectAll('path')
      .data(links)
      .join('path')
        .attr('class', 'link')
        .attr('marker-end','url(#arrow)');

    // Arrowhead marker
    defs.append('marker')
        .attr('id','arrow')
        .attr('viewBox','0 -5 10 10')
        .attr('refX',15)
        .attr('refY',0)
        .attr('markerWidth',6)
        .attr('markerHeight',6)
        .attr('orient','auto')
      .append('path')
        .attr('d','M0,-5L10,0L0,5')
        .attr('fill','#999');

    const node = svg.append('g')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5)
      .selectAll('g')
      .data(nodes)
      .join('g')
        .attr('class', d => `node ${statusClass(d.status)}`)
        .call(drag(simulation));

    node.append('circle')
        .attr('r', 20)
        .attr('fill', d => statusColor(d.status));

    node.append('text')
        .attr('x', 0)
        .attr('y', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id);

    simulation.on('tick', () => {
        link.attr('d', d => {
            const dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = 0;
            return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
        });

        node.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Helper functions
    function statusClass(status) {
        if (status === 'completed') return 'completed';
        if (status === 'in_progress') return 'in_progress';
        return 'blocked';
    }
    function statusColor(status) {
        if (status === 'completed') return '#4caf50';
        if (status === 'blocked') return '#9e9e9e';
        return '#fff'; // in_progress will have transparent fill + rainbow border
    }
    function drag(sim) {
        function dragstarted(event) {
            if (!event.active) sim.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) sim.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended);
    }
}

// Main
(async () => {
    const raw = await fetchTaskFiles(); // array of arrays
    const graph = buildGraph(raw);
    renderGraph(graph);
})();
</script>
</body>
</html>