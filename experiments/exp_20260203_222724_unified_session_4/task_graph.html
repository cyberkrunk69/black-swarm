<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Task Dependency Graph</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>
<style>
  .node rect {
    stroke-width: 2px;
    fill: #fff;
  }
  .node.completed rect {
    fill: #8f8;
  }
  .node.blocked rect {
    fill: #bbb;
  }
  .node.in-progress rect {
    fill: #fff;
    stroke: url(#rainbow);
    stroke-width: 4px;
    animation: rainbowBorder 3s linear infinite;
  }
  @keyframes rainbowBorder {
    0%   {stroke: red;}
    20%  {stroke: orange;}
    40%  {stroke: yellow;}
    60%  {stroke: green;}
    80%  {stroke: blue;}
    100% {stroke: violet;}
  }
  svg {
    border: 1px solid #ccc;
  }
</style>
</head>
<body>
<h2>Task Dependency Graph</h2>
<svg id="svg-canvas" width="1200" height="800"></svg>

<script>
// Helper to load all grind_tasks_*.json files in the current directory.
// This works when the page is served by a simple static server that also
// provides an index file `tasks_index.json` listing the filenames.
// Example `tasks_index.json`:
// ["grind_tasks_1.json","grind_tasks_2.json", ...]
async function loadAllTasks() {
  const indexResp = await fetch('tasks_index.json');
  const fileList = await indexResp.json(); // array of filenames
  const allTasks = [];
  for (const fname of fileList) {
    const resp = await fetch(fname);
    const data = await resp.json(); // assume array of task objects
    allTasks.push(...data);
  }
  return allTasks;
}

// Build DAG using dagre-d3
function renderGraph(tasks) {
  const g = new dagreD3.graphlib.Graph({ compound: true })
    .setGraph({})
    .setDefaultEdgeLabel(() => ({}));

  // Add nodes
  tasks.forEach(task => {
    const label = `${task.id}\\n${task.phase}`;
    const cssClass = task.status === 'completed' ? 'completed' :
                     task.status === 'in-progress' ? 'in-progress' :
                     task.status === 'blocked' ? 'blocked' : '';
    g.setNode(task.id, {
      label: label,
      class: `node ${cssClass}`,
      shape: 'rect',
      style: 'stroke: #333; stroke-width: 1.5px;'
    });
  });

  // Add edges (dependencies)
  tasks.forEach(task => {
    if (Array.isArray(task.dependencies)) {
      task.dependencies.forEach(dep => {
        // Ensure both nodes exist
        if (g.hasNode(dep) && g.hasNode(task.id)) {
          g.setEdge(dep, task.id);
        }
      });
    }
  });

  // Render
  const render = new dagreD3.render();
  const svg = d3.select('#svg-canvas');
  const inner = svg.append('g');

  render(inner, g);

  // Center the graph
  const zoom = d3.zoom().on('zoom', (event) => inner.attr('transform', event.transform));
  svg.call(zoom);
}

// Main
loadAllTasks()
  .then(tasks => {
    renderGraph(tasks);
  })
  .catch(err => {
    console.error('Failed to load tasks:', err);
    const container = document.getElementById('svg-canvas');
    container.innerHTML = '<text x="20" y="40" fill="red">Error loading task data.</text>';
  });
</script>
</body>
</html>