<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Task Dependency Graph</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        .node circle {
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node.completed circle {
            fill: #4caf50; /* green */
        }
        .node.inprogress circle {
            fill: #fff;
            stroke: url(#rainbow);
            stroke-width: 4px;
        }
        .node.blocked circle {
            fill: #9e9e9e; /* gray */
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
        }
        /* Rainbow border definition */
        svg defs {
            overflow: visible;
        }
        #rainbow stop:nth-child(1) { stop-color:#ff0000; }
        #rainbow stop:nth-child(2) { stop-color:#ff7f00; }
        #rainbow stop:nth-child(3) { stop-color:#ffff00; }
        #rainbow stop:nth-child(4) { stop-color:#00ff00; }
        #rainbow stop:nth-child(5) { stop-color:#0000ff; }
        #rainbow stop:nth-child(6) { stop-color:#4b0082; }
        #rainbow stop:nth-child(7) { stop-color:#9400d3; }
        @keyframes rainbowBorder {
            0% {stroke-dashoffset: 0;}
            100% {stroke-dashoffset: -200;}
        }
        .node.inprogress circle {
            stroke-dasharray: 10,5;
            animation: rainbowBorder 3s linear infinite;
        }
    </style>
</head>
<body>
<svg width="100%" height="100%"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
(async function() {
    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = window.innerHeight;

    // Define rainbow gradient for inâ€‘progress border
    const defs = svg.append("defs");
    const rainbow = defs.append("linearGradient")
        .attr("id", "rainbow")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "100%")
        .attr("y2", "0%");
    const colors = ["#ff0000","#ff7f00","#ffff00","#00ff00","#0000ff","#4b0082","#9400d3"];
    colors.forEach((c,i)=> {
        rainbow.append("stop")
            .attr("offset", `${i/(colors.length-1)*100}%`)
            .attr("stop-color", c);
    });

    // Load all grind_tasks_*.json files in the current directory
    // NOTE: This works only when served by a server that allows directory listing or an endpoint that returns the list.
    // For a static environment, manually list the files below.
    const taskFiles = await fetch("task_file_manifest.json")
        .then(r=> r.ok ? r.json() : [])
        .catch(()=>[]); // fallback to empty list

    const tasks = [];
    const links = [];

    for (const file of taskFiles) {
        const data = await fetch(file).then(r=>r.json());
        // Expected schema:
        // { "id": "...", "phase": "completed|inprogress|blocked", "deps": ["id1","id2"] }
        data.forEach(t => {
            tasks.push({id: t.id, phase: t.phase});
            if (Array.isArray(t.deps)) {
                t.deps.forEach(d => links.push({source: d, target: t.id}));
            }
        });
    }

    // If no manifest, try a simple glob fallback (requires server side support)
    // This block can be removed when manifest is provided.
    if (tasks.length===0) {
        console.warn("No task data loaded. Ensure task_file_manifest.json lists all grind_tasks_*.json files.");
    }

    const simulation = d3.forceSimulation(tasks)
        .force("link", d3.forceLink(links).id(d=>d.id).distance(120))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(width/2, height/2));

    const link = svg.append("g")
        .attr("class", "links")
        .selectAll("path")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "link");

    const node = svg.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(tasks)
        .enter()
        .append("g")
        .attr("class", d => `node ${d.phase}`);

    node.append("circle")
        .attr("r", 20);

    node.append("text")
        .attr("dy", 4)
        .attr("x", 0)
        .attr("text-anchor", "middle")
        .text(d=>d.id);

    simulation.on("tick", () => {
        link.attr("d", d => {
            const dx = d.target.x - d.source.x,
                  dy = d.target.y - d.source.y,
                  dr = 0;
            return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
        });

        node.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    // Drag behavior
    node.call(d3.drag()
        .on("start", (event,d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        })
        .on("drag", (event,d) => {
            d.fx = event.x;
            d.fy = event.y;
        })
        .on("end", (event,d) => {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }));
})();
</script>
</body>
</html>