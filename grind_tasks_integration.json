{
  "meta": {
    "name": "Self-Integration Pipeline",
    "priority": "critical",
    "description": "The swarm currently writes to experiments/ directories but nothing merges back to mainline. Fix this."
  },
  "tasks": [
    {
      "id": "int-1",
      "phase": 1,
      "component": "Integration Problem",
      "description": "PROBLEM: You (the swarm) write code to experiments/ folders but it never gets integrated into the actual codebase. The main files (dashboard_vision.js, etc.) remain unchanged. Your work is orphaned. SOLVE THIS. Design and implement a self-integration pipeline. Consider: How do you validate your work before merging? How do you handle conflicts? How do you use git branching? What testing do you need? You have full autonomy to design the solution. The only requirement is that good code you produce actually ends up in the mainline codebase, versioned properly."
    },
    {
      "id": "int-2",
      "phase": 1,
      "component": "Git Workflow",
      "description": "Implement intelligent git workflow for the swarm. You should: 1) Create feature branches for experiments, 2) Run validation before commits, 3) Write meaningful commit messages, 4) Only merge to main when tests pass. Look at the existing .bumpversion.cfg and Makefile for versioning conventions. Design git_automation.py or similar to handle this."
    },
    {
      "id": "int-3",
      "phase": 1,
      "component": "Self-Testing",
      "description": "Implement self-testing for swarm output. Before any code is merged, it must be validated. Consider: syntax checking, import validation, running existing pytest tests, basic smoke tests. Create a test_runner.py or validation_pipeline.py that the swarm uses to verify its own work. If tests fail, the code stays in experiments/ and gets flagged for retry or human review."
    },
    {
      "id": "int-4",
      "phase": 2,
      "component": "Experiment Promotion",
      "description": "Build the experiment promotion system. When an experiment passes all tests, automatically: 1) Extract the relevant file changes, 2) Apply them to the correct locations in the main codebase, 3) Create a proper git commit with attribution, 4) Optionally bump version if significant. Handle the case where multiple experiments modify the same file - you need conflict resolution."
    },
    {
      "id": "int-5",
      "phase": 2,
      "component": "Quality Gate",
      "description": "Implement a quality gate that all swarm output must pass. This is the Observer pattern from OBSERVER_PATTERN_DESIGN.md applied to integration. A secondary check reviews the diff, validates it makes sense, checks for regressions, and issues APPROVE/REJECT. Only APPROVED changes get merged."
    },
    {
      "id": "int-6",
      "phase": 3,
      "component": "Cleanup",
      "description": "After successful integration, clean up the experiments/ directory. Archive or delete experiments that have been merged. Keep failed experiments for analysis. Maintain a manifest of what was integrated and when. Prevent experiments/ from growing unbounded."
    }
  ]
}
